[
  {
    "name": "IsEven_0",
    "sat": "def sat(b: bool, n: int=10):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=10):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_1",
    "sat": "def sat(b: bool, n: int=0):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=0):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_2",
    "sat": "def sat(b: bool, n: int=1):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=1):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_3",
    "sat": "def sat(b: bool, n: int=2):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=2):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_4",
    "sat": "def sat(b: bool, n: int=3):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=3):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_5",
    "sat": "def sat(b: bool, n: int=4):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=4):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_6",
    "sat": "def sat(b: bool, n: int=5):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=5):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_7",
    "sat": "def sat(b: bool, n: int=6):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=6):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_8",
    "sat": "def sat(b: bool, n: int=7):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=7):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_9",
    "sat": "def sat(b: bool, n: int=8):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=8):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_10",
    "sat": "def sat(b: bool, n: int=9):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=9):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_11",
    "sat": "def sat(b: bool, n: int=11):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=11):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_12",
    "sat": "def sat(b: bool, n: int=12):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=12):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_13",
    "sat": "def sat(b: bool, n: int=13):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=13):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_14",
    "sat": "def sat(b: bool, n: int=14):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=14):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_15",
    "sat": "def sat(b: bool, n: int=15):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=15):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_16",
    "sat": "def sat(b: bool, n: int=16):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=16):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_17",
    "sat": "def sat(b: bool, n: int=17):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=17):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_18",
    "sat": "def sat(b: bool, n: int=18):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=18):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_19",
    "sat": "def sat(b: bool, n: int=19):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=19):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_20",
    "sat": "def sat(b: bool, n: int=20):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=20):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_21",
    "sat": "def sat(b: bool, n: int=21):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=21):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_22",
    "sat": "def sat(b: bool, n: int=22):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=22):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_23",
    "sat": "def sat(b: bool, n: int=23):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=23):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_24",
    "sat": "def sat(b: bool, n: int=24):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=24):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_25",
    "sat": "def sat(b: bool, n: int=25):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=25):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_26",
    "sat": "def sat(b: bool, n: int=26):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=26):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_27",
    "sat": "def sat(b: bool, n: int=27):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=27):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_28",
    "sat": "def sat(b: bool, n: int=28):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=28):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_29",
    "sat": "def sat(b: bool, n: int=29):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=29):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_30",
    "sat": "def sat(b: bool, n: int=30):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=30):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_31",
    "sat": "def sat(b: bool, n: int=31):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=31):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_32",
    "sat": "def sat(b: bool, n: int=32):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=32):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_33",
    "sat": "def sat(b: bool, n: int=33):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=33):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_34",
    "sat": "def sat(b: bool, n: int=34):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=34):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_35",
    "sat": "def sat(b: bool, n: int=35):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=35):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_36",
    "sat": "def sat(b: bool, n: int=36):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=36):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_37",
    "sat": "def sat(b: bool, n: int=37):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=37):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_38",
    "sat": "def sat(b: bool, n: int=38):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=38):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_39",
    "sat": "def sat(b: bool, n: int=39):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=39):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_40",
    "sat": "def sat(b: bool, n: int=40):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=40):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_41",
    "sat": "def sat(b: bool, n: int=41):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=41):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_42",
    "sat": "def sat(b: bool, n: int=42):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=42):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_43",
    "sat": "def sat(b: bool, n: int=43):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=43):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_44",
    "sat": "def sat(b: bool, n: int=44):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=44):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_45",
    "sat": "def sat(b: bool, n: int=45):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=45):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_46",
    "sat": "def sat(b: bool, n: int=46):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=46):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_47",
    "sat": "def sat(b: bool, n: int=47):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=47):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_48",
    "sat": "def sat(b: bool, n: int=48):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=48):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_49",
    "sat": "def sat(b: bool, n: int=49):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=49):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_50",
    "sat": "def sat(b: bool, n: int=50):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=50):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_51",
    "sat": "def sat(b: bool, n: int=51):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=51):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_52",
    "sat": "def sat(b: bool, n: int=52):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=52):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_53",
    "sat": "def sat(b: bool, n: int=53):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=53):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_54",
    "sat": "def sat(b: bool, n: int=54):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=54):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_55",
    "sat": "def sat(b: bool, n: int=55):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=55):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_56",
    "sat": "def sat(b: bool, n: int=56):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=56):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_57",
    "sat": "def sat(b: bool, n: int=57):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=57):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_58",
    "sat": "def sat(b: bool, n: int=58):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=58):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_59",
    "sat": "def sat(b: bool, n: int=59):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=59):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_60",
    "sat": "def sat(b: bool, n: int=60):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=60):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_61",
    "sat": "def sat(b: bool, n: int=61):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=61):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_62",
    "sat": "def sat(b: bool, n: int=62):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=62):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_63",
    "sat": "def sat(b: bool, n: int=63):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=63):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_64",
    "sat": "def sat(b: bool, n: int=64):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=64):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_65",
    "sat": "def sat(b: bool, n: int=65):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=65):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_66",
    "sat": "def sat(b: bool, n: int=66):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=66):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_67",
    "sat": "def sat(b: bool, n: int=67):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=67):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_68",
    "sat": "def sat(b: bool, n: int=68):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=68):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_69",
    "sat": "def sat(b: bool, n: int=69):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=69):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_70",
    "sat": "def sat(b: bool, n: int=70):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=70):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_71",
    "sat": "def sat(b: bool, n: int=71):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=71):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_72",
    "sat": "def sat(b: bool, n: int=72):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=72):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_73",
    "sat": "def sat(b: bool, n: int=73):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=73):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_74",
    "sat": "def sat(b: bool, n: int=74):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=74):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_75",
    "sat": "def sat(b: bool, n: int=75):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=75):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_76",
    "sat": "def sat(b: bool, n: int=76):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=76):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_77",
    "sat": "def sat(b: bool, n: int=77):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=77):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_78",
    "sat": "def sat(b: bool, n: int=78):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=78):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_79",
    "sat": "def sat(b: bool, n: int=79):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=79):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_80",
    "sat": "def sat(b: bool, n: int=80):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=80):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_81",
    "sat": "def sat(b: bool, n: int=81):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=81):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_82",
    "sat": "def sat(b: bool, n: int=82):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=82):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_83",
    "sat": "def sat(b: bool, n: int=83):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=83):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_84",
    "sat": "def sat(b: bool, n: int=84):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=84):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_85",
    "sat": "def sat(b: bool, n: int=85):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=85):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_86",
    "sat": "def sat(b: bool, n: int=86):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=86):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_87",
    "sat": "def sat(b: bool, n: int=87):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=87):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_88",
    "sat": "def sat(b: bool, n: int=88):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=88):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_89",
    "sat": "def sat(b: bool, n: int=89):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=89):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_90",
    "sat": "def sat(b: bool, n: int=90):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=90):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_91",
    "sat": "def sat(b: bool, n: int=91):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=91):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_92",
    "sat": "def sat(b: bool, n: int=92):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=92):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_93",
    "sat": "def sat(b: bool, n: int=93):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=93):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_94",
    "sat": "def sat(b: bool, n: int=94):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=94):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_95",
    "sat": "def sat(b: bool, n: int=95):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=95):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_96",
    "sat": "def sat(b: bool, n: int=96):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=96):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_97",
    "sat": "def sat(b: bool, n: int=97):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=97):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_98",
    "sat": "def sat(b: bool, n: int=98):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=98):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "Abbreviate_0",
    "sat": "def sat(s: str, word: str=\"antidisestablishmentarianism\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"antidisestablishmentarianism\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_1",
    "sat": "def sat(s: str, word: str=\"tuzesecirozuzyv\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tuzesecirozuzyv\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_2",
    "sat": "def sat(s: str, word: str=\"vyvyvoboquolivucycyny\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vyvyvoboquolivucycyny\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_3",
    "sat": "def sat(s: str, word: str=\"dafochexuceth\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"dafochexuceth\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_4",
    "sat": "def sat(s: str, word: str=\"non\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"non\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_5",
    "sat": "def sat(s: str, word: str=\"fabykuzorifura\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fabykuzorifura\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_6",
    "sat": "def sat(s: str, word: str=\"ravysequiquequefoh\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"ravysequiquequefoh\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_7",
    "sat": "def sat(s: str, word: str=\"dawelyfyjaruvelidocosesutextub\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"dawelyfyjaruvelidocosesutextub\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_8",
    "sat": "def sat(s: str, word: str=\"rechuthibubes\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"rechuthibubes\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_9",
    "sat": "def sat(s: str, word: str=\"zedoze\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zedoze\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_10",
    "sat": "def sat(s: str, word: str=\"sac\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"sac\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_11",
    "sat": "def sat(s: str, word: str=\"pyxuvaquinijewicexitextafifipi\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pyxuvaquinijewicexitextafifipi\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_12",
    "sat": "def sat(s: str, word: str=\"refomujeragyp\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"refomujeragyp\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_13",
    "sat": "def sat(s: str, word: str=\"juzazu\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"juzazu\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_14",
    "sat": "def sat(s: str, word: str=\"fyxolycurydi\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fyxolycurydi\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_15",
    "sat": "def sat(s: str, word: str=\"fakivyxywehikiribycywemexem\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fakivyxywehikiribycywemexem\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_16",
    "sat": "def sat(s: str, word: str=\"novocomu\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"novocomu\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_17",
    "sat": "def sat(s: str, word: str=\"modigitigy\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"modigitigy\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_18",
    "sat": "def sat(s: str, word: str=\"kuti\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kuti\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_19",
    "sat": "def sat(s: str, word: str=\"gitextobege\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gitextobege\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_20",
    "sat": "def sat(s: str, word: str=\"nogetygyquachuhovacaranath\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"nogetygyquachuhovacaranath\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_21",
    "sat": "def sat(s: str, word: str=\"textabichisachiw\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textabichisachiw\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_22",
    "sat": "def sat(s: str, word: str=\"xowynesupanebothi\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xowynesupanebothi\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_23",
    "sat": "def sat(s: str, word: str=\"cococharerihyxydawapekib\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cococharerihyxydawapekib\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_24",
    "sat": "def sat(s: str, word: str=\"quewufakoquejovesabebado\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quewufakoquejovesabebado\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_25",
    "sat": "def sat(s: str, word: str=\"gejozysikutha\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gejozysikutha\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_26",
    "sat": "def sat(s: str, word: str=\"kykygoketexte\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kykygoketexte\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_27",
    "sat": "def sat(s: str, word: str=\"lethoryzycubyxonyxo\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lethoryzycubyxonyxo\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_28",
    "sat": "def sat(s: str, word: str=\"textaquamuvyrepu\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textaquamuvyrepu\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_29",
    "sat": "def sat(s: str, word: str=\"fovasel\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fovasel\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_30",
    "sat": "def sat(s: str, word: str=\"gasilozitextinisanucaquachinur\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gasilozitextinisanucaquachinur\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_31",
    "sat": "def sat(s: str, word: str=\"civotextohyvulyhicefatavaluhy\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"civotextohyvulyhicefatavaluhy\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_32",
    "sat": "def sat(s: str, word: str=\"vybutex\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vybutex\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_33",
    "sat": "def sat(s: str, word: str=\"lovuthotufyrututony\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lovuthotufyrututony\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_34",
    "sat": "def sat(s: str, word: str=\"quudekaquytyfatextegahite\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quudekaquytyfatextegahite\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_35",
    "sat": "def sat(s: str, word: str=\"pevidecychukipudixopyguj\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pevidecychukipudixopyguj\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_36",
    "sat": "def sat(s: str, word: str=\"kotexta\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kotexta\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_37",
    "sat": "def sat(s: str, word: str=\"xehytherucuhafagizysosezovaq\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xehytherucuhafagizysosezovaq\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_38",
    "sat": "def sat(s: str, word: str=\"tharequupycyhitextobevokuq\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tharequupycyhitextobevokuq\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_39",
    "sat": "def sat(s: str, word: str=\"tubimelecocequ\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tubimelecocequ\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_40",
    "sat": "def sat(s: str, word: str=\"xothy\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xothy\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_41",
    "sat": "def sat(s: str, word: str=\"textitextov\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textitextov\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_42",
    "sat": "def sat(s: str, word: str=\"luthoxychybulaquakonypem\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"luthoxychybulaquakonypem\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_43",
    "sat": "def sat(s: str, word: str=\"tifozupuwulupodabowohoda\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tifozupuwulupodabowohoda\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_44",
    "sat": "def sat(s: str, word: str=\"bethihitextychuty\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"bethihitextychuty\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_45",
    "sat": "def sat(s: str, word: str=\"zybykuthebiquyxothelihixysugoj\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zybykuthebiquyxothelihixysugoj\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_46",
    "sat": "def sat(s: str, word: str=\"paxedymozosycufychujub\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"paxedymozosycufychujub\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_47",
    "sat": "def sat(s: str, word: str=\"wacotivychilepiluchubogapequac\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"wacotivychilepiluchubogapequac\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_48",
    "sat": "def sat(s: str, word: str=\"textabixikym\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textabixikym\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_49",
    "sat": "def sat(s: str, word: str=\"kowopaquityquacataxizedilopu\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kowopaquityquacataxizedilopu\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_50",
    "sat": "def sat(s: str, word: str=\"cefovothyjitholokutex\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cefovothyjitholokutex\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_51",
    "sat": "def sat(s: str, word: str=\"pymicabyryzida\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pymicabyryzida\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_52",
    "sat": "def sat(s: str, word: str=\"tapulamuzochamanejojec\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tapulamuzochamanejojec\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_53",
    "sat": "def sat(s: str, word: str=\"lychuchar\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lychuchar\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_54",
    "sat": "def sat(s: str, word: str=\"jothidelygobosubi\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"jothidelygobosubi\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_55",
    "sat": "def sat(s: str, word: str=\"juqu\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"juqu\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_56",
    "sat": "def sat(s: str, word: str=\"xitatextolevytextaj\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xitatextolevytextaj\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_57",
    "sat": "def sat(s: str, word: str=\"kegygubevepufasubiziquu\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kegygubevepufasubiziquu\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_58",
    "sat": "def sat(s: str, word: str=\"favic\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"favic\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_59",
    "sat": "def sat(s: str, word: str=\"fozinixyquehifyvinejatume\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fozinixyquehifyvinejatume\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_60",
    "sat": "def sat(s: str, word: str=\"rythobukity\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"rythobukity\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_61",
    "sat": "def sat(s: str, word: str=\"quejithicichuzaneque\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quejithicichuzaneque\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_62",
    "sat": "def sat(s: str, word: str=\"pugyhyzyxofyh\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pugyhyzyxofyh\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_63",
    "sat": "def sat(s: str, word: str=\"kodanathirizodasisus\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kodanathirizodasisus\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_64",
    "sat": "def sat(s: str, word: str=\"pavydyzyxatextinochu\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pavydyzyxatextinochu\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_65",
    "sat": "def sat(s: str, word: str=\"vyrudychatext\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vyrudychatext\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_66",
    "sat": "def sat(s: str, word: str=\"zefuxuquowojo\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zefuxuquowojo\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_67",
    "sat": "def sat(s: str, word: str=\"cylysegecuwosonezoveruxefopoc\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cylysegecuwosonezoveruxefopoc\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_68",
    "sat": "def sat(s: str, word: str=\"guwixudichisilys\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"guwixudichisilys\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_69",
    "sat": "def sat(s: str, word: str=\"sunibisalufusanotextydy\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"sunibisalufusanotextydy\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_70",
    "sat": "def sat(s: str, word: str=\"lyxisugasabyvafyzuvuvecigu\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lyxisugasabyvafyzuvuvecigu\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_71",
    "sat": "def sat(s: str, word: str=\"bani\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"bani\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_72",
    "sat": "def sat(s: str, word: str=\"chyjyfuvochiquucymyfik\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"chyjyfuvochiquucymyfik\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_73",
    "sat": "def sat(s: str, word: str=\"xyfifuthef\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xyfifuthef\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_74",
    "sat": "def sat(s: str, word: str=\"queth\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"queth\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_75",
    "sat": "def sat(s: str, word: str=\"xunujavojukoviquyqu\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xunujavojukoviquyqu\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_76",
    "sat": "def sat(s: str, word: str=\"norymyjexylygyjoduza\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"norymyjexylygyjoduza\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_77",
    "sat": "def sat(s: str, word: str=\"kowiwymekithigequyzukod\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kowiwymekithigequyzukod\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_78",
    "sat": "def sat(s: str, word: str=\"kutext\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kutext\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_79",
    "sat": "def sat(s: str, word: str=\"jurewubozynakiquathetage\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"jurewubozynakiquathetage\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_80",
    "sat": "def sat(s: str, word: str=\"vohelekeket\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vohelekeket\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_81",
    "sat": "def sat(s: str, word: str=\"chysodarequaquixoqu\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"chysodarequaquixoqu\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_82",
    "sat": "def sat(s: str, word: str=\"hutypipesojikerizuquyjuwyro\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"hutypipesojikerizuquyjuwyro\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_83",
    "sat": "def sat(s: str, word: str=\"myt\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"myt\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_84",
    "sat": "def sat(s: str, word: str=\"migiwoxo\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"migiwoxo\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_85",
    "sat": "def sat(s: str, word: str=\"fupegyquurinusurewosagotext\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fupegyquurinusurewosagotext\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_86",
    "sat": "def sat(s: str, word: str=\"thyxiwucazusotigulote\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"thyxiwucazusotigulote\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_87",
    "sat": "def sat(s: str, word: str=\"pihisoxytextisa\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pihisoxytextisa\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_88",
    "sat": "def sat(s: str, word: str=\"datheruxisuteruroby\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"datheruxisuteruroby\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_89",
    "sat": "def sat(s: str, word: str=\"girumidisixixufetholivejequat\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"girumidisixixufetholivejequat\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_90",
    "sat": "def sat(s: str, word: str=\"dehojelo\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"dehojelo\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_91",
    "sat": "def sat(s: str, word: str=\"liwomylukekitut\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"liwomylukekitut\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_92",
    "sat": "def sat(s: str, word: str=\"quifuke\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quifuke\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_93",
    "sat": "def sat(s: str, word: str=\"nodylowagidolorirerygechoduvev\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"nodylowagidolorirerygechoduvev\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_94",
    "sat": "def sat(s: str, word: str=\"zixuwunesyraxozudajojutekivat\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zixuwunesyraxozudajojutekivat\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_95",
    "sat": "def sat(s: str, word: str=\"gahuxoquicociwethukodecibixet\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gahuxoquicociwethukodecibixet\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_96",
    "sat": "def sat(s: str, word: str=\"narilytextygapi\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"narilytextygapi\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_97",
    "sat": "def sat(s: str, word: str=\"cykumagyxigachykihuchac\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cykumagyxigachykihuchac\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_98",
    "sat": "def sat(s: str, word: str=\"chixonet\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"chixonet\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_99",
    "sat": "def sat(s: str, word: str=\"quuxafozerebujityzem\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quuxafozerebujityzem\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "SquareTiles_0",
    "sat": "def sat(corners: List[List[int]], m: int=10, n: int=9, a: int=5, target: int=4):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=10, n=9, a=5, target=4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_1",
    "sat": "def sat(corners: List[List[int]], m: int=3, n: int=826, a: int=2, target: int=830):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=826, a=2, target=830):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_2",
    "sat": "def sat(corners: List[List[int]], m: int=81, n: int=9, a: int=4, target: int=63):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=81, n=9, a=4, target=63):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_3",
    "sat": "def sat(corners: List[List[int]], m: int=49, n: int=517, a: int=3, target: int=2944):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=49, n=517, a=3, target=2944):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_4",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=8, a: int=10, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=8, a=10, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_5",
    "sat": "def sat(corners: List[List[int]], m: int=75, n: int=178, a: int=1, target: int=13352):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=75, n=178, a=1, target=13352):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_6",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=184, a: int=3, target: int=65):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=184, a=3, target=65):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_7",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=998, a: int=1, target: int=5989):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=998, a=1, target=5989):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_8",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=347, a: int=7, target: int=53):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=347, a=7, target=53):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_9",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=78, a: int=3, target: int=54):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=78, a=3, target=54):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_10",
    "sat": "def sat(corners: List[List[int]], m: int=969, n: int=22, a: int=5, target: int=972):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=969, n=22, a=5, target=972):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_11",
    "sat": "def sat(corners: List[List[int]], m: int=699, n: int=44, a: int=9, target: int=392):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=699, n=44, a=9, target=392):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_12",
    "sat": "def sat(corners: List[List[int]], m: int=50, n: int=50, a: int=9, target: int=40):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=50, n=50, a=9, target=40):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_13",
    "sat": "def sat(corners: List[List[int]], m: int=652, n: int=534, a: int=10, target: int=3567):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=652, n=534, a=10, target=3567):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_14",
    "sat": "def sat(corners: List[List[int]], m: int=627, n: int=69, a: int=9, target: int=560):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=627, n=69, a=9, target=560):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_15",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=576, a: int=3, target: int=192):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=576, a=3, target=192):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_16",
    "sat": "def sat(corners: List[List[int]], m: int=45, n: int=456, a: int=3, target: int=2281):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=45, n=456, a=3, target=2281):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_17",
    "sat": "def sat(corners: List[List[int]], m: int=3, n: int=31, a: int=9, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=31, a=9, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_18",
    "sat": "def sat(corners: List[List[int]], m: int=22, n: int=763, a: int=3, target: int=2043):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=22, n=763, a=3, target=2043):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_19",
    "sat": "def sat(corners: List[List[int]], m: int=49, n: int=44, a: int=3, target: int=259):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=49, n=44, a=3, target=259):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_20",
    "sat": "def sat(corners: List[List[int]], m: int=68, n: int=15, a: int=9, target: int=20):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=68, n=15, a=9, target=20):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_21",
    "sat": "def sat(corners: List[List[int]], m: int=54, n: int=85, a: int=4, target: int=312):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=54, n=85, a=4, target=312):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_22",
    "sat": "def sat(corners: List[List[int]], m: int=3, n: int=3, a: int=7, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=3, a=7, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_23",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=67, a: int=4, target: int=17):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=67, a=4, target=17):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_24",
    "sat": "def sat(corners: List[List[int]], m: int=148, n: int=15, a: int=9, target: int=37):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=148, n=15, a=9, target=37):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_25",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=570, a: int=8, target: int=74):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=570, a=8, target=74):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_26",
    "sat": "def sat(corners: List[List[int]], m: int=50, n: int=240, a: int=4, target: int=780):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=50, n=240, a=4, target=780):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_27",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=26, a: int=8, target: int=8):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=26, a=8, target=8):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_28",
    "sat": "def sat(corners: List[List[int]], m: int=638, n: int=6, a: int=3, target: int=427):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=638, n=6, a=3, target=427):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_29",
    "sat": "def sat(corners: List[List[int]], m: int=91, n: int=8, a: int=10, target: int=12):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=91, n=8, a=10, target=12):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_30",
    "sat": "def sat(corners: List[List[int]], m: int=73, n: int=6, a: int=6, target: int=15):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=73, n=6, a=6, target=15):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_31",
    "sat": "def sat(corners: List[List[int]], m: int=17, n: int=551, a: int=5, target: int=446):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=17, n=551, a=5, target=446):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_32",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=380, a: int=2, target: int=380):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=380, a=2, target=380):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_33",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=8, a: int=2, target: int=13):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=8, a=2, target=13):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_34",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=8, a: int=5, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=8, a=5, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_35",
    "sat": "def sat(corners: List[List[int]], m: int=55, n: int=42, a: int=7, target: int=49):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=55, n=42, a=7, target=49):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_36",
    "sat": "def sat(corners: List[List[int]], m: int=88, n: int=9, a: int=9, target: int=11):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=88, n=9, a=9, target=11):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_37",
    "sat": "def sat(corners: List[List[int]], m: int=69, n: int=136, a: int=3, target: int=1058):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=69, n=136, a=3, target=1058):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_38",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=59, a: int=2, target: int=154):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=59, a=2, target=154):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_39",
    "sat": "def sat(corners: List[List[int]], m: int=53, n: int=18, a: int=3, target: int=111):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=53, n=18, a=3, target=111):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_40",
    "sat": "def sat(corners: List[List[int]], m: int=14, n: int=671, a: int=5, target: int=407):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=14, n=671, a=5, target=407):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_41",
    "sat": "def sat(corners: List[List[int]], m: int=28, n: int=77, a: int=7, target: int=47):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=28, n=77, a=7, target=47):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_42",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=350, a: int=6, target: int=119):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=350, a=6, target=119):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_43",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=69, a: int=3, target: int=73):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=69, a=3, target=73):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_44",
    "sat": "def sat(corners: List[List[int]], m: int=54, n: int=7, a: int=5, target: int=25):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=54, n=7, a=5, target=25):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_45",
    "sat": "def sat(corners: List[List[int]], m: int=967, n: int=2, a: int=4, target: int=243):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=967, n=2, a=4, target=243):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_46",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=21, a: int=9, target: int=6):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=21, a=9, target=6):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_47",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=302, a: int=7, target: int=46):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=302, a=7, target=46):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_48",
    "sat": "def sat(corners: List[List[int]], m: int=12, n: int=44, a: int=5, target: int=28):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=12, n=44, a=5, target=28):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_49",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=381, a: int=6, target: int=132):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=381, a=6, target=132):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_50",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=1, a: int=4, target: int=6):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=1, a=4, target=6):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_51",
    "sat": "def sat(corners: List[List[int]], m: int=781, n: int=81, a: int=4, target: int=4119):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=781, n=81, a=4, target=4119):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_52",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=557, a: int=7, target: int=80):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=557, a=7, target=80):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_53",
    "sat": "def sat(corners: List[List[int]], m: int=3, n: int=231, a: int=4, target: int=60):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=231, a=4, target=60):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_54",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=30, a: int=1, target: int=123):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=30, a=1, target=123):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_55",
    "sat": "def sat(corners: List[List[int]], m: int=490, n: int=9, a: int=9, target: int=59):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=490, n=9, a=9, target=59):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_56",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=2, a: int=2, target: int=1):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=2, a=2, target=1):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_57",
    "sat": "def sat(corners: List[List[int]], m: int=80, n: int=1, a: int=4, target: int=20):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=80, n=1, a=4, target=20):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_58",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=890, a: int=1, target: int=890):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=890, a=1, target=890):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_59",
    "sat": "def sat(corners: List[List[int]], m: int=20, n: int=88, a: int=5, target: int=72):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=20, n=88, a=5, target=72):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_60",
    "sat": "def sat(corners: List[List[int]], m: int=924, n: int=4, a: int=2, target: int=926):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=924, n=4, a=2, target=926):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_61",
    "sat": "def sat(corners: List[List[int]], m: int=597, n: int=9, a: int=6, target: int=200):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=597, n=9, a=6, target=200):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_62",
    "sat": "def sat(corners: List[List[int]], m: int=13, n: int=532, a: int=7, target: int=155):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=13, n=532, a=7, target=155):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_63",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=399, a: int=6, target: int=71):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=399, a=6, target=71):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_64",
    "sat": "def sat(corners: List[List[int]], m: int=50, n: int=195, a: int=4, target: int=638):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=50, n=195, a=4, target=638):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_65",
    "sat": "def sat(corners: List[List[int]], m: int=303, n: int=2, a: int=10, target: int=32):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=303, n=2, a=10, target=32):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_66",
    "sat": "def sat(corners: List[List[int]], m: int=23, n: int=726, a: int=8, target: int=275):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=23, n=726, a=8, target=275):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_67",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=4, a: int=6, target: int=4):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=4, a=6, target=4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_68",
    "sat": "def sat(corners: List[List[int]], m: int=46, n: int=48, a: int=6, target: int=68):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=46, n=48, a=6, target=68):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_69",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=47, a: int=8, target: int=9):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=47, a=8, target=9):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_70",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=53, a: int=1, target: int=477):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=53, a=1, target=477):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_71",
    "sat": "def sat(corners: List[List[int]], m: int=22, n: int=2, a: int=10, target: int=3):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=22, n=2, a=10, target=3):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_72",
    "sat": "def sat(corners: List[List[int]], m: int=61, n: int=700, a: int=10, target: int=493):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=61, n=700, a=10, target=493):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_73",
    "sat": "def sat(corners: List[List[int]], m: int=673, n: int=6, a: int=3, target: int=454):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=673, n=6, a=3, target=454):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_74",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=68, a: int=1, target: int=275):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=68, a=1, target=275):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_75",
    "sat": "def sat(corners: List[List[int]], m: int=15, n: int=6, a: int=8, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=15, n=6, a=8, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_76",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=751, a: int=8, target: int=95):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=751, a=8, target=95):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_77",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=65, a: int=8, target: int=11):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=65, a=8, target=11):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_78",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=29, a: int=1, target: int=60):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=29, a=1, target=60):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_79",
    "sat": "def sat(corners: List[List[int]], m: int=321, n: int=30, a: int=9, target: int=145):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=321, n=30, a=9, target=145):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_80",
    "sat": "def sat(corners: List[List[int]], m: int=71, n: int=640, a: int=3, target: int=5140):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=71, n=640, a=3, target=5140):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_81",
    "sat": "def sat(corners: List[List[int]], m: int=261, n: int=7, a: int=1, target: int=1831):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=261, n=7, a=1, target=1831):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_82",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=855, a: int=3, target: int=573):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=855, a=3, target=573):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_83",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=45, a: int=8, target: int=6):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=45, a=8, target=6):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_84",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=5, a: int=9, target: int=1):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=5, a=9, target=1):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_85",
    "sat": "def sat(corners: List[List[int]], m: int=20, n: int=59, a: int=7, target: int=29):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=20, n=59, a=7, target=29):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_86",
    "sat": "def sat(corners: List[List[int]], m: int=76, n: int=207, a: int=7, target: int=331):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=76, n=207, a=7, target=331):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_87",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=40, a: int=4, target: int=24):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=40, a=4, target=24):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_88",
    "sat": "def sat(corners: List[List[int]], m: int=94, n: int=90, a: int=2, target: int=2115):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=94, n=90, a=2, target=2115):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_89",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=58, a: int=2, target: int=119):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=58, a=2, target=119):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_90",
    "sat": "def sat(corners: List[List[int]], m: int=93, n: int=91, a: int=7, target: int=184):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=93, n=91, a=7, target=184):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_91",
    "sat": "def sat(corners: List[List[int]], m: int=995, n: int=2, a: int=3, target: int=332):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=995, n=2, a=3, target=332):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_92",
    "sat": "def sat(corners: List[List[int]], m: int=585, n: int=9, a: int=8, target: int=148):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=585, n=9, a=8, target=148):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_93",
    "sat": "def sat(corners: List[List[int]], m: int=12, n: int=20, a: int=3, target: int=28):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=12, n=20, a=3, target=28):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_94",
    "sat": "def sat(corners: List[List[int]], m: int=496, n: int=3, a: int=1, target: int=1492):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=496, n=3, a=1, target=1492):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_95",
    "sat": "def sat(corners: List[List[int]], m: int=671, n: int=4, a: int=10, target: int=68):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=671, n=4, a=10, target=68):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_96",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=8, a: int=2, target: int=20):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=8, a=2, target=20):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_97",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=8, a: int=1, target: int=19):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=8, a=1, target=19):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_98",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=1, a: int=1, target: int=8):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=1, a=1, target=8):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_99",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=913, a: int=10, target: int=93):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=913, a=10, target=93):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "EasyTwos_0",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_1",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 0], [0, 1, 1], [1, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 0], [0, 1, 1], [1, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_2",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_3",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_4",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_5",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_6",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_7",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_8",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_9",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_10",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_11",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_12",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_13",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_14",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_15",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_16",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_17",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_18",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_19",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_20",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_21",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_22",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_23",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_24",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_25",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 0], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 0], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_26",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_27",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_28",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_29",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [1, 0, 0], [1, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 0, 0], [1, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_30",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 1], [0, 1, 1], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 0], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 1], [0, 1, 1], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 0], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_31",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_32",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_33",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 0, 0], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 0, 0], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_34",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_35",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_36",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_37",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_38",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [0, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [1, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [0, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [1, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_39",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_40",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_41",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_42",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 0], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 0], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_43",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_44",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_45",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_46",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 0], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 0], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_47",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 0, 1], [0, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 0, 1], [0, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_48",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0], [1, 1, 0], [1, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0], [1, 1, 0], [1, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_49",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_50",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_51",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_52",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 0, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 0, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_53",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_54",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_55",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_56",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 1, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 1, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_57",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_58",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_59",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_60",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 1], [1, 1, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 1], [1, 1, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_61",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_62",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_63",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_64",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 1, 0], [1, 0, 1], [1, 1, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0], [0, 1, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 1, 0], [1, 0, 1], [1, 1, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0], [0, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_65",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_66",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_67",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_68",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_69",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_70",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_71",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_72",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_73",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_74",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_75",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_76",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 0], [1, 0, 0], [1, 1, 1], [0, 0, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 0], [1, 0, 0], [1, 1, 1], [0, 0, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_77",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [1, 1, 0], [1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [1, 1, 0], [1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_78",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [0, 0, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [0, 0, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_79",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_80",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 1, 0], [1, 1, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 1, 0], [1, 1, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_81",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_82",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_83",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_84",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_85",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_86",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_87",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_88",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_89",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_90",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_91",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_92",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 1], [1, 1, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 1], [1, 1, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_93",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_94",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_95",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_96",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_97",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_98",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_99",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [0, 0, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 0, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "DecreasingCountComparison_0",
    "sat": "def sat(n: int, scores: List[int]=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_1",
    "sat": "def sat(n: int, scores: List[int]=[6, 3], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[6, 3], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_2",
    "sat": "def sat(n: int, scores: List[int]=[15, 12, 7], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 12, 7], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_3",
    "sat": "def sat(n: int, scores: List[int]=[36, 13, 12, 3], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[36, 13, 12, 3], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_4",
    "sat": "def sat(n: int, scores: List[int]=[32, 32, 16, 16, 11], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 32, 16, 16, 11], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_5",
    "sat": "def sat(n: int, scores: List[int]=[22, 17, 10, 4, 3, 1], k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 17, 10, 4, 3, 1], k=3):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_6",
    "sat": "def sat(n: int, scores: List[int]=[4, 4, 4, 4, 4, 0, 0], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[4, 4, 4, 4, 4, 0, 0], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_7",
    "sat": "def sat(n: int, scores: List[int]=[0, 0, 0, 0, 0, 0, 0, 0], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0, 0, 0, 0, 0, 0, 0], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_8",
    "sat": "def sat(n: int, scores: List[int]=[34, 28, 20, 19, 19, 16, 13, 11, 9], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 28, 20, 19, 19, 16, 13, 11, 9], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_9",
    "sat": "def sat(n: int, scores: List[int]=[7, 7, 5, 4, 4, 3, 3, 3, 2, 0], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[7, 7, 5, 4, 4, 3, 3, 3, 2, 0], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_10",
    "sat": "def sat(n: int, scores: List[int]=[20, 20, 19, 19, 18, 18, 18, 13, 12, 12, 2], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[20, 20, 19, 19, 18, 18, 18, 13, 12, 12, 2], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_11",
    "sat": "def sat(n: int, scores: List[int]=[41, 32, 30, 28, 28, 24, 18, 13, 11, 8, 5, 1], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[41, 32, 30, 28, 28, 24, 18, 13, 11, 8, 5, 1], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_12",
    "sat": "def sat(n: int, scores: List[int]=[46, 41, 39, 39, 35, 33, 32, 29, 28, 20, 9, 3, 2], k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[46, 41, 39, 39, 35, 33, 32, 29, 28, 20, 9, 3, 2], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_13",
    "sat": "def sat(n: int, scores: List[int]=[38, 35, 33, 31, 31, 20, 20, 20, 13, 13, 10, 6, 6, 2], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[38, 35, 33, 31, 31, 20, 20, 20, 13, 13, 10, 6, 6, 2], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_14",
    "sat": "def sat(n: int, scores: List[int]=[48, 47, 46, 37, 35, 31, 27, 22, 16, 14, 6, 6, 5, 3, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[48, 47, 46, 37, 35, 31, 27, 22, 16, 14, 6, 6, 5, 3, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_15",
    "sat": "def sat(n: int, scores: List[int]=[32, 29, 26, 23, 19, 17, 16, 14, 12, 10, 9, 8, 7, 7, 1, 0], k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 29, 26, 23, 19, 17, 16, 14, 12, 10, 9, 8, 7, 7, 1, 0], k=1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_16",
    "sat": "def sat(n: int, scores: List[int]=[36, 35, 35, 34, 27, 24, 21, 19, 17, 17, 12, 11, 7, 5, 5, 3, 0], k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[36, 35, 35, 34, 27, 24, 21, 19, 17, 17, 12, 11, 7, 5, 5, 3, 0], k=10):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_17",
    "sat": "def sat(n: int, scores: List[int]=[20, 19, 19, 18, 17, 15, 11, 11, 10, 9, 9, 8, 8, 4, 3, 3, 2, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[20, 19, 19, 18, 17, 15, 11, 11, 10, 9, 9, 8, 8, 4, 3, 3, 2, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_18",
    "sat": "def sat(n: int, scores: List[int]=[28, 26, 25, 25, 24, 24, 22, 21, 21, 20, 20, 16, 13, 12, 8, 8, 8, 7, 1], k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[28, 26, 25, 25, 24, 24, 22, 21, 21, 20, 20, 16, 13, 12, 8, 8, 8, 7, 1], k=10):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_19",
    "sat": "def sat(n: int, scores: List[int]=[47, 43, 40, 38, 38, 35, 29, 25, 24, 24, 21, 14, 12, 12, 12, 11, 9, 8, 6, 5], k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 43, 40, 38, 38, 35, 29, 25, 24, 24, 21, 14, 12, 12, 12, 11, 9, 8, 6, 5], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_20",
    "sat": "def sat(n: int, scores: List[int]=[26, 23, 22, 21, 21, 20, 20, 20, 19, 18, 16, 15, 15, 12, 11, 8, 8, 7, 3, 3, 0], k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[26, 23, 22, 21, 21, 20, 20, 20, 19, 18, 16, 15, 15, 12, 11, 8, 8, 7, 3, 3, 0], k=14):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_21",
    "sat": "def sat(n: int, scores: List[int]=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_22",
    "sat": "def sat(n: int, scores: List[int]=[29, 28, 23, 23, 20, 19, 18, 18, 17, 17, 16, 16, 14, 11, 9, 5, 5, 4, 3, 3, 2, 0, 0], k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[29, 28, 23, 23, 20, 19, 18, 18, 17, 17, 16, 16, 14, 11, 9, 5, 5, 4, 3, 3, 2, 0, 0], k=8):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_23",
    "sat": "def sat(n: int, scores: List[int]=[44, 42, 37, 37, 37, 36, 36, 31, 29, 24, 23, 21, 17, 17, 12, 11, 9, 9, 7, 6, 6, 4, 2, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[44, 42, 37, 37, 37, 36, 36, 31, 29, 24, 23, 21, 17, 17, 12, 11, 9, 9, 7, 6, 6, 4, 2, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_24",
    "sat": "def sat(n: int, scores: List[int]=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_25",
    "sat": "def sat(n: int, scores: List[int]=[39, 36, 36, 36, 36, 34, 26, 22, 21, 19, 19, 18, 18, 17, 14, 12, 11, 7, 7, 7, 7, 7, 6, 6, 3, 0], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[39, 36, 36, 36, 36, 34, 26, 22, 21, 19, 19, 18, 18, 17, 14, 12, 11, 7, 7, 7, 7, 7, 6, 6, 3, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_26",
    "sat": "def sat(n: int, scores: List[int]=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=16):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_27",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 21, 21, 21, 21, 20, 19, 19, 18, 18, 17, 16, 16, 13, 12, 12, 11, 10, 7, 7, 5, 5, 3, 1, 1, 0, 0], k: int=24):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 21, 21, 21, 21, 20, 19, 19, 18, 18, 17, 16, 16, 13, 12, 12, 11, 10, 7, 7, 5, 5, 3, 1, 1, 0, 0], k=24):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_28",
    "sat": "def sat(n: int, scores: List[int]=[31, 29, 28, 28, 27, 27, 27, 26, 25, 21, 21, 21, 20, 20, 18, 18, 17, 15, 14, 13, 12, 11, 11, 10, 6, 4, 3, 2, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[31, 29, 28, 28, 27, 27, 27, 26, 25, 21, 21, 21, 20, 20, 18, 18, 17, 15, 14, 13, 12, 11, 11, 10, 6, 4, 3, 2, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_29",
    "sat": "def sat(n: int, scores: List[int]=[32, 31, 30, 30, 27, 27, 26, 25, 24, 22, 22, 22, 22, 19, 19, 17, 16, 15, 13, 12, 11, 11, 7, 6, 6, 5, 3, 3, 2, 1], k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 31, 30, 30, 27, 27, 26, 25, 24, 22, 22, 22, 22, 19, 19, 17, 16, 15, 13, 12, 11, 11, 7, 6, 6, 5, 3, 3, 2, 1], k=19):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_30",
    "sat": "def sat(n: int, scores: List[int]=[32, 32, 31, 28, 27, 27, 27, 25, 24, 23, 22, 21, 20, 18, 18, 16, 15, 13, 12, 9, 8, 6, 6, 5, 4, 4, 3, 2, 1, 1, 0], k: int=22):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 32, 31, 28, 27, 27, 27, 25, 24, 23, 22, 21, 20, 18, 18, 16, 15, 13, 12, 9, 8, 6, 6, 5, 4, 4, 3, 2, 1, 1, 0], k=22):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_31",
    "sat": "def sat(n: int, scores: List[int]=[36, 34, 33, 31, 31, 31, 30, 29, 29, 28, 28, 25, 25, 25, 24, 22, 21, 20, 19, 18, 15, 15, 12, 11, 11, 11, 9, 9, 6, 6, 4, 4], k: int=31):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[36, 34, 33, 31, 31, 31, 30, 29, 29, 28, 28, 25, 25, 25, 24, 22, 21, 20, 19, 18, 15, 15, 12, 11, 11, 11, 9, 9, 6, 6, 4, 4], k=31):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_32",
    "sat": "def sat(n: int, scores: List[int]=[18, 18, 17, 16, 16, 16, 15, 15, 15, 14, 13, 13, 12, 11, 11, 10, 10, 10, 10, 8, 7, 7, 6, 6, 5, 3, 3, 3, 1, 1, 0, 0, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[18, 18, 17, 16, 16, 16, 15, 15, 15, 14, 13, 13, 12, 11, 11, 10, 10, 10, 10, 8, 7, 7, 6, 6, 5, 3, 3, 3, 1, 1, 0, 0, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_33",
    "sat": "def sat(n: int, scores: List[int]=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_34",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=25):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=25):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_35",
    "sat": "def sat(n: int, scores: List[int]=[22, 22, 21, 20, 20, 20, 19, 18, 16, 15, 14, 14, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 8, 8, 6, 6, 4, 4, 3, 2, 2, 1, 1, 1, 1], k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 22, 21, 20, 20, 20, 19, 18, 16, 15, 14, 14, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 8, 8, 6, 6, 4, 4, 3, 2, 2, 1, 1, 1, 1], k=3):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_36",
    "sat": "def sat(n: int, scores: List[int]=[38, 37, 35, 33, 32, 31, 31, 30, 28, 28, 28, 27, 26, 25, 24, 24, 22, 21, 17, 16, 16, 14, 14, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 6, 5, 5, 5], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[38, 37, 35, 33, 32, 31, 31, 30, 28, 28, 28, 27, 26, 25, 24, 24, 22, 21, 17, 16, 16, 14, 14, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 6, 5, 5, 5], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_37",
    "sat": "def sat(n: int, scores: List[int]=[16, 15, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 7, 7, 7, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2, 1, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[16, 15, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 7, 7, 7, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2, 1, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_38",
    "sat": "def sat(n: int, scores: List[int]=[33, 32, 32, 32, 31, 31, 30, 30, 29, 29, 28, 24, 22, 22, 21, 20, 20, 20, 19, 17, 16, 15, 15, 14, 12, 12, 12, 9, 7, 7, 6, 5, 4, 4, 1, 1, 1, 1, 0], k: int=28):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[33, 32, 32, 32, 31, 31, 30, 30, 29, 29, 28, 24, 22, 22, 21, 20, 20, 20, 19, 17, 16, 15, 15, 14, 12, 12, 12, 9, 7, 7, 6, 5, 4, 4, 1, 1, 1, 1, 0], k=28):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_39",
    "sat": "def sat(n: int, scores: List[int]=[48, 47, 46, 45, 43, 42, 42, 41, 40, 38, 38, 37, 35, 35, 33, 32, 31, 29, 28, 26, 24, 24, 22, 22, 20, 19, 19, 16, 16, 15, 14, 9, 9, 9, 8, 6, 6, 6, 5, 0], k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[48, 47, 46, 45, 43, 42, 42, 41, 40, 38, 38, 37, 35, 35, 33, 32, 31, 29, 28, 26, 24, 24, 22, 22, 20, 19, 19, 16, 16, 15, 14, 9, 9, 9, 8, 6, 6, 6, 5, 0], k=7):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_40",
    "sat": "def sat(n: int, scores: List[int]=[46, 43, 42, 39, 37, 37, 36, 36, 35, 35, 32, 32, 30, 29, 28, 26, 26, 26, 25, 24, 23, 23, 22, 22, 21, 21, 21, 21, 20, 20, 19, 17, 16, 13, 11, 10, 9, 8, 2, 1, 0], k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[46, 43, 42, 39, 37, 37, 36, 36, 35, 35, 32, 32, 30, 29, 28, 26, 26, 26, 25, 24, 23, 23, 22, 22, 21, 21, 21, 21, 20, 20, 19, 17, 16, 13, 11, 10, 9, 8, 2, 1, 0], k=18):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_41",
    "sat": "def sat(n: int, scores: List[int]=[24, 23, 23, 22, 22, 21, 20, 18, 18, 18, 17, 16, 16, 15, 13, 12, 12, 12, 11, 11, 10, 10, 10, 9, 8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 4, 4, 2, 2, 2, 1, 1, 1], k: int=36):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[24, 23, 23, 22, 22, 21, 20, 18, 18, 18, 17, 16, 16, 15, 13, 12, 12, 12, 11, 11, 10, 10, 10, 9, 8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 4, 4, 2, 2, 2, 1, 1, 1], k=36):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_42",
    "sat": "def sat(n: int, scores: List[int]=[16, 16, 16, 15, 15, 15, 14, 14, 14, 13, 11, 11, 11, 10, 9, 9, 8, 8, 7, 6, 6, 6, 4, 4, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k: int=40):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[16, 16, 16, 15, 15, 15, 14, 14, 14, 13, 11, 11, 11, 10, 9, 9, 8, 8, 7, 6, 6, 6, 4, 4, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k=40):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_43",
    "sat": "def sat(n: int, scores: List[int]=[22, 22, 22, 21, 20, 20, 19, 19, 19, 19, 17, 15, 14, 14, 14, 13, 12, 11, 10, 10, 9, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 22, 22, 21, 20, 20, 19, 19, 19, 19, 17, 15, 14, 14, 14, 13, 12, 11, 10, 10, 9, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_44",
    "sat": "def sat(n: int, scores: List[int]=[15, 15, 15, 15, 15, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 6, 6, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 15, 15, 15, 15, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 6, 6, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=7):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_45",
    "sat": "def sat(n: int, scores: List[int]=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_46",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 18, 17, 17, 17, 17, 16, 15, 15, 14, 14, 14, 12, 12, 11, 11, 11, 11, 10, 9, 8, 7, 7, 6, 6, 4, 4, 4, 4, 4, 2, 2, 1, 1, 1, 0], k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 18, 17, 17, 17, 17, 16, 15, 15, 14, 14, 14, 12, 12, 11, 11, 11, 11, 10, 9, 8, 7, 7, 6, 6, 4, 4, 4, 4, 4, 2, 2, 1, 1, 1, 0], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_47",
    "sat": "def sat(n: int, scores: List[int]=[24, 22, 21, 20, 20, 20, 20, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 13, 13, 13, 13, 11, 8, 8, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k: int=29):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[24, 22, 21, 20, 20, 20, 20, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 13, 13, 13, 13, 11, 8, 8, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k=29):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_48",
    "sat": "def sat(n: int, scores: List[int]=[34, 34, 32, 31, 31, 31, 31, 30, 30, 30, 28, 27, 27, 27, 25, 24, 23, 21, 21, 20, 20, 20, 19, 16, 16, 16, 15, 14, 13, 13, 12, 12, 11, 11, 10, 10, 10, 9, 9, 9, 9, 7, 6, 6, 6, 5, 3, 2, 0], k: int=45):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 34, 32, 31, 31, 31, 31, 30, 30, 30, 28, 27, 27, 27, 25, 24, 23, 21, 21, 20, 20, 20, 19, 16, 16, 16, 15, 14, 13, 13, 12, 12, 11, 11, 10, 10, 10, 9, 9, 9, 9, 7, 6, 6, 6, 5, 3, 2, 0], k=45):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_49",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 20, 20, 19, 19, 19, 19, 17, 17, 17, 16, 16, 16, 16, 15, 14, 14, 14, 13, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 5, 5, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0], k: int=27):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 20, 20, 19, 19, 19, 19, 17, 17, 17, 16, 16, 16, 16, 15, 14, 14, 14, 13, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 5, 5, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0], k=27):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_50",
    "sat": "def sat(n: int, scores: List[int]=[13, 13, 13, 13, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k: int=41):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[13, 13, 13, 13, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k=41):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_51",
    "sat": "def sat(n: int, scores: List[int]=[29, 29, 29, 28, 28, 28, 28, 27, 26, 25, 25, 24, 22, 22, 20, 20, 19, 19, 18, 18, 18, 18, 17, 16, 16, 14, 14, 14, 14, 13, 13, 10, 10, 9, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 3, 2, 2, 2, 1, 1, 0, 0], k: int=21):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[29, 29, 29, 28, 28, 28, 28, 27, 26, 25, 25, 24, 22, 22, 20, 20, 19, 19, 18, 18, 18, 18, 17, 16, 16, 14, 14, 14, 14, 13, 13, 10, 10, 9, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 3, 2, 2, 2, 1, 1, 0, 0], k=21):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_52",
    "sat": "def sat(n: int, scores: List[int]=[25, 24, 24, 23, 23, 22, 22, 21, 21, 21, 20, 20, 18, 18, 18, 18, 15, 15, 15, 14, 14, 14, 14, 12, 12, 12, 12, 11, 10, 10, 9, 8, 8, 7, 7, 7, 7, 7, 7, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 0], k: int=26):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[25, 24, 24, 23, 23, 22, 22, 21, 21, 21, 20, 20, 18, 18, 18, 18, 15, 15, 15, 14, 14, 14, 14, 12, 12, 12, 12, 11, 10, 10, 9, 8, 8, 7, 7, 7, 7, 7, 7, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 0], k=26):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_53",
    "sat": "def sat(n: int, scores: List[int]=[26, 26, 26, 25, 24, 24, 24, 23, 23, 23, 22, 21, 21, 21, 20, 20, 20, 19, 18, 18, 17, 17, 17, 16, 16, 15, 14, 13, 12, 12, 10, 10, 10, 10, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 3, 2, 2, 1, 1, 0], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[26, 26, 26, 25, 24, 24, 24, 23, 23, 23, 22, 21, 21, 21, 20, 20, 20, 19, 18, 18, 17, 17, 17, 16, 16, 15, 14, 13, 12, 12, 10, 10, 10, 10, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 3, 2, 2, 1, 1, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_54",
    "sat": "def sat(n: int, scores: List[int]=[15, 15, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 15, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k=14):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_55",
    "sat": "def sat(n: int, scores: List[int]=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=34):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=34):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_56",
    "sat": "def sat(n: int, scores: List[int]=[37, 37, 35, 34, 34, 34, 33, 33, 32, 31, 31, 31, 30, 30, 29, 28, 28, 27, 26, 26, 25, 24, 23, 21, 21, 20, 20, 19, 18, 17, 16, 15, 15, 13, 12, 11, 10, 10, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 5, 3, 3, 2, 2, 1, 0], k: int=46):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[37, 37, 35, 34, 34, 34, 33, 33, 32, 31, 31, 31, 30, 30, 29, 28, 28, 27, 26, 26, 25, 24, 23, 21, 21, 20, 20, 19, 18, 17, 16, 15, 15, 13, 12, 11, 10, 10, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 5, 3, 3, 2, 2, 1, 0], k=46):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_57",
    "sat": "def sat(n: int, scores: List[int]=[15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 13, 13, 13, 13, 13, 12, 12, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 13, 13, 13, 13, 13, 12, 12, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=13):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_58",
    "sat": "def sat(n: int, scores: List[int]=[42, 41, 40, 40, 38, 38, 37, 37, 37, 36, 36, 36, 36, 36, 34, 33, 32, 32, 32, 32, 30, 29, 28, 27, 27, 26, 26, 24, 24, 23, 23, 22, 22, 21, 20, 19, 17, 17, 14, 14, 13, 13, 11, 10, 9, 9, 8, 8, 8, 7, 5, 4, 4, 3, 3, 2, 1, 1, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[42, 41, 40, 40, 38, 38, 37, 37, 37, 36, 36, 36, 36, 36, 34, 33, 32, 32, 32, 32, 30, 29, 28, 27, 27, 26, 26, 24, 24, 23, 23, 22, 22, 21, 20, 19, 17, 17, 14, 14, 13, 13, 11, 10, 9, 9, 8, 8, 8, 7, 5, 4, 4, 3, 3, 2, 1, 1, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_59",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=46):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=46):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_60",
    "sat": "def sat(n: int, scores: List[int]=[39, 38, 38, 37, 37, 36, 35, 35, 34, 33, 32, 32, 31, 28, 26, 25, 25, 24, 24, 24, 22, 21, 19, 19, 19, 19, 18, 18, 17, 16, 15, 15, 14, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 8, 7, 7, 7, 7, 6, 5, 5, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[39, 38, 38, 37, 37, 36, 35, 35, 34, 33, 32, 32, 31, 28, 26, 25, 25, 24, 24, 24, 22, 21, 19, 19, 19, 19, 18, 18, 17, 16, 15, 15, 14, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 8, 7, 7, 7, 7, 6, 5, 5, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k=10):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_61",
    "sat": "def sat(n: int, scores: List[int]=[9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=61):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=61):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_62",
    "sat": "def sat(n: int, scores: List[int]=[41, 40, 39, 38, 36, 34, 34, 34, 34, 33, 32, 29, 29, 27, 26, 25, 25, 23, 23, 22, 22, 20, 20, 19, 18, 17, 17, 17, 15, 15, 15, 14, 14, 12, 12, 12, 12, 11, 11, 10, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 7, 5, 5, 4, 4, 4, 4, 2, 2, 1, 1, 0, 0], k: int=57):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[41, 40, 39, 38, 36, 34, 34, 34, 34, 33, 32, 29, 29, 27, 26, 25, 25, 23, 23, 22, 22, 20, 20, 19, 18, 17, 17, 17, 15, 15, 15, 14, 14, 12, 12, 12, 12, 11, 11, 10, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 7, 5, 5, 4, 4, 4, 4, 2, 2, 1, 1, 0, 0], k=57):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_63",
    "sat": "def sat(n: int, scores: List[int]=[34, 33, 33, 33, 33, 32, 32, 31, 31, 31, 30, 30, 30, 30, 30, 30, 29, 29, 29, 28, 28, 28, 28, 25, 25, 25, 24, 24, 24, 22, 19, 18, 18, 18, 17, 17, 16, 15, 15, 14, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 9, 9, 8, 6, 6, 5, 5, 3, 3, 2, 2, 1, 1, 0], k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 33, 33, 33, 33, 32, 32, 31, 31, 31, 30, 30, 30, 30, 30, 30, 29, 29, 29, 28, 28, 28, 28, 25, 25, 25, 24, 24, 24, 22, 19, 18, 18, 18, 17, 17, 16, 15, 15, 14, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 9, 9, 8, 6, 6, 5, 5, 3, 3, 2, 2, 1, 1, 0], k=15):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_64",
    "sat": "def sat(n: int, scores: List[int]=[10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=28):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=28):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_65",
    "sat": "def sat(n: int, scores: List[int]=[13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=55):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=55):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_66",
    "sat": "def sat(n: int, scores: List[int]=[47, 47, 46, 44, 43, 42, 42, 42, 41, 39, 39, 39, 38, 38, 38, 38, 37, 36, 36, 35, 34, 32, 30, 30, 30, 29, 28, 28, 27, 25, 25, 25, 25, 25, 25, 24, 23, 22, 22, 20, 19, 19, 18, 17, 17, 16, 16, 15, 15, 14, 13, 12, 11, 11, 11, 10, 10, 8, 7, 6, 5, 5, 4, 4, 3, 3, 2], k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 47, 46, 44, 43, 42, 42, 42, 41, 39, 39, 39, 38, 38, 38, 38, 37, 36, 36, 35, 34, 32, 30, 30, 30, 29, 28, 28, 27, 25, 25, 25, 25, 25, 25, 24, 23, 22, 22, 20, 19, 19, 18, 17, 17, 16, 16, 15, 15, 14, 13, 12, 11, 11, 11, 10, 10, 8, 7, 6, 5, 5, 4, 4, 3, 3, 2], k=12):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_67",
    "sat": "def sat(n: int, scores: List[int]=[12, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[12, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_68",
    "sat": "def sat(n: int, scores: List[int]=[11, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=29):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[11, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=29):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_69",
    "sat": "def sat(n: int, scores: List[int]=[20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1], k: int=47):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1], k=47):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_70",
    "sat": "def sat(n: int, scores: List[int]=[30, 30, 30, 29, 29, 29, 29, 27, 27, 26, 26, 26, 25, 24, 24, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 13, 12, 12, 12, 12, 11, 10, 9, 8, 8, 8, 8, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 4, 3, 3, 1, 1, 0], k: int=25):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[30, 30, 30, 29, 29, 29, 29, 27, 27, 26, 26, 26, 25, 24, 24, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 13, 12, 12, 12, 12, 11, 10, 9, 8, 8, 8, 8, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 4, 3, 3, 1, 1, 0], k=25):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_71",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_72",
    "sat": "def sat(n: int, scores: List[int]=[10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=41):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=41):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_73",
    "sat": "def sat(n: int, scores: List[int]=[48, 46, 45, 44, 43, 42, 42, 42, 42, 41, 41, 41, 39, 39, 37, 37, 36, 36, 35, 34, 34, 33, 33, 32, 32, 30, 28, 27, 27, 26, 25, 25, 24, 24, 24, 23, 22, 22, 21, 21, 20, 20, 19, 18, 17, 17, 17, 17, 17, 16, 16, 14, 14, 13, 12, 12, 10, 9, 9, 8, 7, 6, 6, 5, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0], k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[48, 46, 45, 44, 43, 42, 42, 42, 42, 41, 41, 41, 39, 39, 37, 37, 36, 36, 35, 34, 34, 33, 33, 32, 32, 30, 28, 27, 27, 26, 25, 25, 24, 24, 24, 23, 22, 22, 21, 21, 20, 20, 19, 18, 17, 17, 17, 17, 17, 16, 16, 14, 14, 13, 12, 12, 10, 9, 9, 8, 7, 6, 6, 5, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0], k=12):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_74",
    "sat": "def sat(n: int, scores: List[int]=[32, 31, 31, 30, 30, 30, 29, 29, 28, 28, 28, 28, 28, 27, 27, 27, 27, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 24, 23, 23, 23, 22, 21, 21, 20, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k: int=47):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 31, 31, 30, 30, 30, 29, 29, 28, 28, 28, 28, 28, 27, 27, 27, 27, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 24, 23, 23, 23, 22, 21, 21, 20, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k=47):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_75",
    "sat": "def sat(n: int, scores: List[int]=[29, 29, 28, 27, 27, 27, 25, 25, 23, 22, 22, 21, 21, 21, 21, 20, 19, 19, 18, 18, 18, 17, 17, 16, 16, 16, 16, 15, 15, 15, 15, 14, 13, 13, 13, 13, 13, 12, 11, 11, 11, 11, 11, 10, 10, 10, 8, 8, 8, 8, 8, 7, 7, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0], k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[29, 29, 28, 27, 27, 27, 25, 25, 23, 22, 22, 21, 21, 21, 21, 20, 19, 19, 18, 18, 18, 17, 17, 16, 16, 16, 16, 15, 15, 15, 15, 14, 13, 13, 13, 13, 13, 12, 11, 11, 11, 11, 11, 10, 10, 10, 8, 8, 8, 8, 8, 7, 7, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0], k=13):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_76",
    "sat": "def sat(n: int, scores: List[int]=[44, 44, 43, 40, 38, 37, 37, 37, 37, 35, 35, 35, 34, 34, 33, 33, 31, 30, 30, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 24, 23, 23, 22, 22, 20, 20, 20, 19, 19, 18, 17, 17, 15, 15, 15, 15, 14, 14, 12, 11, 11, 11, 10, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0], k: int=39):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[44, 44, 43, 40, 38, 37, 37, 37, 37, 35, 35, 35, 34, 34, 33, 33, 31, 30, 30, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 24, 23, 23, 22, 22, 20, 20, 20, 19, 19, 18, 17, 17, 15, 15, 15, 15, 14, 14, 12, 11, 11, 11, 10, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0], k=39):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_77",
    "sat": "def sat(n: int, scores: List[int]=[43, 43, 43, 41, 41, 40, 39, 39, 39, 38, 38, 38, 37, 37, 36, 36, 36, 35, 35, 35, 35, 34, 34, 33, 33, 32, 32, 31, 28, 28, 28, 26, 25, 25, 24, 24, 23, 23, 22, 22, 22, 22, 22, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 15, 15, 14, 13, 13, 12, 11, 11, 11, 11, 10, 10, 10, 9, 8, 8, 7, 7, 5, 5, 5, 3, 2, 1, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[43, 43, 43, 41, 41, 40, 39, 39, 39, 38, 38, 38, 37, 37, 36, 36, 36, 35, 35, 35, 35, 34, 34, 33, 33, 32, 32, 31, 28, 28, 28, 26, 25, 25, 24, 24, 23, 23, 22, 22, 22, 22, 22, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 15, 15, 14, 13, 13, 12, 11, 11, 11, 11, 10, 10, 10, 9, 8, 8, 7, 7, 5, 5, 5, 3, 2, 1, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_78",
    "sat": "def sat(n: int, scores: List[int]=[47, 46, 44, 44, 44, 43, 43, 41, 41, 40, 39, 38, 38, 38, 38, 38, 37, 37, 37, 37, 37, 36, 36, 35, 33, 33, 33, 31, 29, 28, 26, 26, 26, 25, 25, 24, 23, 23, 23, 21, 20, 20, 20, 19, 19, 18, 18, 18, 16, 15, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 7, 7, 7, 6, 6, 6, 5, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k: int=69):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 46, 44, 44, 44, 43, 43, 41, 41, 40, 39, 38, 38, 38, 38, 38, 37, 37, 37, 37, 37, 36, 36, 35, 33, 33, 33, 31, 29, 28, 26, 26, 26, 25, 25, 24, 23, 23, 23, 21, 20, 20, 20, 19, 19, 18, 18, 18, 16, 15, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 7, 7, 7, 6, 6, 6, 5, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k=69):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_79",
    "sat": "def sat(n: int, scores: List[int]=[26, 26, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 17, 17, 16, 16, 16, 16, 14, 14, 13, 13, 12, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[26, 26, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 17, 17, 16, 16, 16, 16, 14, 14, 13, 13, 12, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_80",
    "sat": "def sat(n: int, scores: List[int]=[14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_81",
    "sat": "def sat(n: int, scores: List[int]=[31, 30, 30, 30, 30, 29, 29, 29, 29, 28, 28, 28, 27, 26, 26, 26, 25, 25, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 21, 20, 19, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 15, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 7, 7, 7, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0], k: int=33):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[31, 30, 30, 30, 30, 29, 29, 29, 29, 28, 28, 28, 27, 26, 26, 26, 25, 25, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 21, 20, 19, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 15, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 7, 7, 7, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0], k=33):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_82",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=22):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=22):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_83",
    "sat": "def sat(n: int, scores: List[int]=[12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=58):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=58):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_84",
    "sat": "def sat(n: int, scores: List[int]=[46, 46, 45, 45, 45, 44, 43, 43, 43, 43, 41, 40, 40, 38, 38, 38, 36, 36, 36, 35, 35, 35, 35, 35, 35, 34, 34, 33, 33, 33, 31, 31, 31, 30, 30, 30, 30, 29, 28, 27, 27, 27, 27, 25, 23, 23, 23, 22, 22, 22, 22, 21, 20, 20, 19, 18, 16, 15, 14, 14, 14, 14, 13, 12, 12, 11, 11, 9, 9, 9, 9, 7, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 1, 1, 1], k: int=37):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[46, 46, 45, 45, 45, 44, 43, 43, 43, 43, 41, 40, 40, 38, 38, 38, 36, 36, 36, 35, 35, 35, 35, 35, 35, 34, 34, 33, 33, 33, 31, 31, 31, 30, 30, 30, 30, 29, 28, 27, 27, 27, 27, 25, 23, 23, 23, 22, 22, 22, 22, 21, 20, 20, 19, 18, 16, 15, 14, 14, 14, 14, 13, 12, 12, 11, 11, 9, 9, 9, 9, 7, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 1, 1, 1], k=37):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_85",
    "sat": "def sat(n: int, scores: List[int]=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_86",
    "sat": "def sat(n: int, scores: List[int]=[8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=79):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=79):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_87",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_88",
    "sat": "def sat(n: int, scores: List[int]=[45, 43, 42, 42, 41, 39, 39, 38, 38, 37, 37, 36, 36, 36, 35, 34, 34, 33, 33, 33, 33, 32, 31, 31, 31, 31, 30, 30, 30, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 24, 24, 23, 22, 22, 21, 21, 20, 19, 19, 19, 19, 18, 18, 18, 17, 16, 16, 15, 15, 14, 13, 13, 13, 13, 11, 11, 11, 9, 9, 8, 7, 7, 6, 6, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0], k: int=50):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[45, 43, 42, 42, 41, 39, 39, 38, 38, 37, 37, 36, 36, 36, 35, 34, 34, 33, 33, 33, 33, 32, 31, 31, 31, 31, 30, 30, 30, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 24, 24, 23, 22, 22, 21, 21, 20, 19, 19, 19, 19, 18, 18, 18, 17, 16, 16, 15, 15, 14, 13, 13, 13, 13, 11, 11, 11, 9, 9, 8, 7, 7, 6, 6, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0], k=50):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_89",
    "sat": "def sat(n: int, scores: List[int]=[40, 39, 39, 39, 39, 38, 38, 38, 38, 37, 35, 35, 32, 32, 32, 31, 31, 31, 30, 30, 29, 29, 27, 27, 27, 27, 26, 26, 26, 26, 25, 24, 24, 23, 23, 23, 23, 22, 21, 20, 20, 19, 19, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 7, 6, 6, 6, 4, 4, 4, 4, 3, 2, 1, 1, 0, 0], k: int=65):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[40, 39, 39, 39, 39, 38, 38, 38, 38, 37, 35, 35, 32, 32, 32, 31, 31, 31, 30, 30, 29, 29, 27, 27, 27, 27, 26, 26, 26, 26, 25, 24, 24, 23, 23, 23, 23, 22, 21, 20, 20, 19, 19, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 7, 6, 6, 6, 4, 4, 4, 4, 3, 2, 1, 1, 0, 0], k=65):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_90",
    "sat": "def sat(n: int, scores: List[int]=[40, 40, 40, 39, 39, 39, 38, 38, 36, 36, 36, 34, 32, 32, 32, 31, 31, 31, 30, 30, 30, 30, 29, 29, 27, 27, 26, 26, 26, 26, 26, 25, 25, 25, 25, 24, 23, 23, 23, 22, 22, 21, 20, 20, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 14, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 5, 5, 5, 5, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0], k: int=54):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[40, 40, 40, 39, 39, 39, 38, 38, 36, 36, 36, 34, 32, 32, 32, 31, 31, 31, 30, 30, 30, 30, 29, 29, 27, 27, 26, 26, 26, 26, 26, 25, 25, 25, 25, 24, 23, 23, 23, 22, 22, 21, 20, 20, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 14, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 5, 5, 5, 5, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0], k=54):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_91",
    "sat": "def sat(n: int, scores: List[int]=[23, 23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17, 16, 16, 16, 16, 16, 16, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 2, 2, 2, 2, 1, 1, 0], k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[23, 23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17, 16, 16, 16, 16, 16, 16, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 2, 2, 2, 2, 1, 1, 0], k=8):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_92",
    "sat": "def sat(n: int, scores: List[int]=[14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=46):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=46):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_93",
    "sat": "def sat(n: int, scores: List[int]=[22, 22, 22, 22, 22, 22, 22, 22, 22, 21, 20, 20, 20, 20, 20, 19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0], k: int=42):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 22, 22, 22, 22, 22, 22, 22, 22, 21, 20, 20, 20, 20, 20, 19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0], k=42):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_94",
    "sat": "def sat(n: int, scores: List[int]=[47, 47, 46, 46, 44, 43, 43, 43, 42, 41, 41, 40, 40, 40, 39, 38, 36, 35, 35, 35, 34, 34, 33, 33, 33, 32, 32, 31, 31, 30, 29, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 23, 22, 22, 22, 22, 21, 20, 19, 19, 19, 19, 19, 19, 18, 17, 16, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 12, 10, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 4, 3, 2, 1, 1, 1, 1, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 47, 46, 46, 44, 43, 43, 43, 42, 41, 41, 40, 40, 40, 39, 38, 36, 35, 35, 35, 34, 34, 33, 33, 33, 32, 32, 31, 31, 30, 29, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 23, 22, 22, 22, 22, 21, 20, 19, 19, 19, 19, 19, 19, 18, 17, 16, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 12, 10, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 4, 3, 2, 1, 1, 1, 1, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_95",
    "sat": "def sat(n: int, scores: List[int]=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=85):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=85):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_96",
    "sat": "def sat(n: int, scores: List[int]=[12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_97",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 21, 21, 21, 20, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 17, 17, 17, 17, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 1, 1, 0, 0], k: int=67):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 21, 21, 21, 20, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 17, 17, 17, 17, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 1, 1, 0, 0], k=67):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_98",
    "sat": "def sat(n: int, scores: List[int]=[23, 23, 23, 22, 21, 21, 21, 21, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 16, 16, 16, 15, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=85):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[23, 23, 23, 22, 21, 21, 21, 21, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 16, 16, 16, 15, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=85):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_99",
    "sat": "def sat(n: int, scores: List[int]=[10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k: int=91):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k=91):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DominoTile_0",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=5, target: int=50):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=5, target=50):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_1",
    "sat": "def sat(squares: List[List[int]], m: int=40, n: int=45, target: int=1800):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=40, n=45, target=1800):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_2",
    "sat": "def sat(squares: List[List[int]], m: int=22, n: int=14, target: int=308):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=22, n=14, target=308):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_3",
    "sat": "def sat(squares: List[List[int]], m: int=48, n: int=23, target: int=1104):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=48, n=23, target=1104):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_4",
    "sat": "def sat(squares: List[List[int]], m: int=25, n: int=45, target: int=1124):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=25, n=45, target=1124):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_5",
    "sat": "def sat(squares: List[List[int]], m: int=26, n: int=27, target: int=702):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=26, n=27, target=702):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_6",
    "sat": "def sat(squares: List[List[int]], m: int=49, n: int=35, target: int=1714):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=49, n=35, target=1714):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_7",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=18, target: int=108):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=18, target=108):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_8",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=3, target: int=98):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=3, target=98):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_9",
    "sat": "def sat(squares: List[List[int]], m: int=31, n: int=7, target: int=216):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=31, n=7, target=216):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_10",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=46, target: int=138):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=46, target=138):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_11",
    "sat": "def sat(squares: List[List[int]], m: int=41, n: int=30, target: int=1230):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=30, target=1230):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_12",
    "sat": "def sat(squares: List[List[int]], m: int=2, n: int=40, target: int=80):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=2, n=40, target=80):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_13",
    "sat": "def sat(squares: List[List[int]], m: int=42, n: int=5, target: int=210):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=42, n=5, target=210):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_14",
    "sat": "def sat(squares: List[List[int]], m: int=4, n: int=43, target: int=172):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=4, n=43, target=172):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_15",
    "sat": "def sat(squares: List[List[int]], m: int=2, n: int=27, target: int=54):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=2, n=27, target=54):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_16",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=5, target: int=14):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=5, target=14):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_17",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=44, target: int=132):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=44, target=132):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_18",
    "sat": "def sat(squares: List[List[int]], m: int=34, n: int=28, target: int=952):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=34, n=28, target=952):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_19",
    "sat": "def sat(squares: List[List[int]], m: int=19, n: int=2, target: int=38):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=19, n=2, target=38):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_20",
    "sat": "def sat(squares: List[List[int]], m: int=35, n: int=34, target: int=1190):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=35, n=34, target=1190):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_21",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=21, target: int=692):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=21, target=692):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_22",
    "sat": "def sat(squares: List[List[int]], m: int=41, n: int=22, target: int=902):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=22, target=902):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_23",
    "sat": "def sat(squares: List[List[int]], m: int=23, n: int=48, target: int=1104):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=23, n=48, target=1104):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_24",
    "sat": "def sat(squares: List[List[int]], m: int=24, n: int=1, target: int=24):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=24, n=1, target=24):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_25",
    "sat": "def sat(squares: List[List[int]], m: int=39, n: int=22, target: int=858):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=39, n=22, target=858):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_26",
    "sat": "def sat(squares: List[List[int]], m: int=8, n: int=2, target: int=16):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=8, n=2, target=16):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_27",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=28, target: int=448):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=28, target=448):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_28",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=36, target: int=1692):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=36, target=1692):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_29",
    "sat": "def sat(squares: List[List[int]], m: int=11, n: int=25, target: int=274):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=11, n=25, target=274):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_30",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=2, target: int=12):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=2, target=12):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_31",
    "sat": "def sat(squares: List[List[int]], m: int=1, n: int=35, target: int=34):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=1, n=35, target=34):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_32",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=18, target: int=180):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=18, target=180):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_33",
    "sat": "def sat(squares: List[List[int]], m: int=2, n: int=29, target: int=58):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=2, n=29, target=58):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_34",
    "sat": "def sat(squares: List[List[int]], m: int=28, n: int=39, target: int=1092):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=28, n=39, target=1092):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_35",
    "sat": "def sat(squares: List[List[int]], m: int=28, n: int=16, target: int=448):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=28, n=16, target=448):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_36",
    "sat": "def sat(squares: List[List[int]], m: int=11, n: int=27, target: int=296):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=11, n=27, target=296):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_37",
    "sat": "def sat(squares: List[List[int]], m: int=24, n: int=29, target: int=696):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=24, n=29, target=696):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_38",
    "sat": "def sat(squares: List[List[int]], m: int=48, n: int=38, target: int=1824):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=48, n=38, target=1824):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_39",
    "sat": "def sat(squares: List[List[int]], m: int=29, n: int=25, target: int=724):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=29, n=25, target=724):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_40",
    "sat": "def sat(squares: List[List[int]], m: int=14, n: int=13, target: int=182):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=14, n=13, target=182):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_41",
    "sat": "def sat(squares: List[List[int]], m: int=21, n: int=22, target: int=462):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=21, n=22, target=462):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_42",
    "sat": "def sat(squares: List[List[int]], m: int=27, n: int=1, target: int=26):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=27, n=1, target=26):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_43",
    "sat": "def sat(squares: List[List[int]], m: int=46, n: int=49, target: int=2254):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=46, n=49, target=2254):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_44",
    "sat": "def sat(squares: List[List[int]], m: int=37, n: int=28, target: int=1036):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=37, n=28, target=1036):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_45",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=6, target: int=54):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=6, target=54):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_46",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=42, target: int=378):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=42, target=378):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_47",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=24, target: int=1128):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=24, target=1128):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_48",
    "sat": "def sat(squares: List[List[int]], m: int=39, n: int=9, target: int=350):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=39, n=9, target=350):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_49",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=2, target: int=66):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=2, target=66):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_50",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=4, target: int=40):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=4, target=40):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_51",
    "sat": "def sat(squares: List[List[int]], m: int=8, n: int=6, target: int=48):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=8, n=6, target=48):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_52",
    "sat": "def sat(squares: List[List[int]], m: int=14, n: int=17, target: int=238):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=14, n=17, target=238):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_53",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=16, target: int=752):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=16, target=752):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_54",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=43, target: int=258):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=43, target=258):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_55",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=2, target: int=20):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=2, target=20):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_56",
    "sat": "def sat(squares: List[List[int]], m: int=44, n: int=6, target: int=264):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=44, n=6, target=264):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_57",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=9, target: int=80):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=9, target=80):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_58",
    "sat": "def sat(squares: List[List[int]], m: int=27, n: int=31, target: int=836):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=27, n=31, target=836):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_59",
    "sat": "def sat(squares: List[List[int]], m: int=43, n: int=29, target: int=1246):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=43, n=29, target=1246):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_60",
    "sat": "def sat(squares: List[List[int]], m: int=32, n: int=15, target: int=480):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=32, n=15, target=480):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_61",
    "sat": "def sat(squares: List[List[int]], m: int=5, n: int=25, target: int=124):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=5, n=25, target=124):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_62",
    "sat": "def sat(squares: List[List[int]], m: int=40, n: int=47, target: int=1880):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=40, n=47, target=1880):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_63",
    "sat": "def sat(squares: List[List[int]], m: int=21, n: int=45, target: int=944):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=21, n=45, target=944):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_64",
    "sat": "def sat(squares: List[List[int]], m: int=18, n: int=31, target: int=558):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=18, n=31, target=558):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_65",
    "sat": "def sat(squares: List[List[int]], m: int=12, n: int=33, target: int=396):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=12, n=33, target=396):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_66",
    "sat": "def sat(squares: List[List[int]], m: int=43, n: int=32, target: int=1376):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=43, n=32, target=1376):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_67",
    "sat": "def sat(squares: List[List[int]], m: int=44, n: int=9, target: int=396):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=44, n=9, target=396):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_68",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=47, target: int=140):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=47, target=140):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_69",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=1, target: int=2):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=1, target=2):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_70",
    "sat": "def sat(squares: List[List[int]], m: int=41, n: int=20, target: int=820):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=20, target=820):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_71",
    "sat": "def sat(squares: List[List[int]], m: int=38, n: int=33, target: int=1254):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=38, n=33, target=1254):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_72",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=2, target: int=94):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=2, target=94):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_73",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=42, target: int=1386):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=42, target=1386):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_74",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=5, target: int=30):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=5, target=30):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_75",
    "sat": "def sat(squares: List[List[int]], m: int=45, n: int=20, target: int=900):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=45, n=20, target=900):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_76",
    "sat": "def sat(squares: List[List[int]], m: int=17, n: int=31, target: int=526):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=17, n=31, target=526):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_77",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=14, target: int=224):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=14, target=224):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_78",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=40, target: int=640):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=40, target=640):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_79",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=3, target: int=48):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=3, target=48):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_80",
    "sat": "def sat(squares: List[List[int]], m: int=28, n: int=37, target: int=1036):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=28, n=37, target=1036):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_81",
    "sat": "def sat(squares: List[List[int]], m: int=23, n: int=43, target: int=988):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=23, n=43, target=988):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_82",
    "sat": "def sat(squares: List[List[int]], m: int=46, n: int=15, target: int=690):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=46, n=15, target=690):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_83",
    "sat": "def sat(squares: List[List[int]], m: int=15, n: int=25, target: int=374):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=15, n=25, target=374):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_84",
    "sat": "def sat(squares: List[List[int]], m: int=49, n: int=34, target: int=1666):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=49, n=34, target=1666):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_85",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=19, target: int=170):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=19, target=170):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_86",
    "sat": "def sat(squares: List[List[int]], m: int=38, n: int=47, target: int=1786):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=38, n=47, target=1786):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_87",
    "sat": "def sat(squares: List[List[int]], m: int=8, n: int=24, target: int=192):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=8, n=24, target=192):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_88",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=8, target: int=72):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=8, target=72):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_89",
    "sat": "def sat(squares: List[List[int]], m: int=31, n: int=34, target: int=1054):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=31, n=34, target=1054):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_90",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=1, target: int=16):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=1, target=16):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_91",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=33, target: int=1088):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=33, target=1088):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_92",
    "sat": "def sat(squares: List[List[int]], m: int=19, n: int=3, target: int=56):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=19, n=3, target=56):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_93",
    "sat": "def sat(squares: List[List[int]], m: int=44, n: int=24, target: int=1056):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=44, n=24, target=1056):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_94",
    "sat": "def sat(squares: List[List[int]], m: int=24, n: int=13, target: int=312):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=24, n=13, target=312):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_95",
    "sat": "def sat(squares: List[List[int]], m: int=4, n: int=3, target: int=12):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=4, n=3, target=12):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_96",
    "sat": "def sat(squares: List[List[int]], m: int=21, n: int=11, target: int=230):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=21, n=11, target=230):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_97",
    "sat": "def sat(squares: List[List[int]], m: int=1, n: int=23, target: int=22):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=1, n=23, target=22):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_98",
    "sat": "def sat(squares: List[List[int]], m: int=26, n: int=13, target: int=338):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=26, n=13, target=338):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_99",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=37, target: int=110):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=37, target=110):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "IncDec_0",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x'], target: int=19143212):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x'], target=19143212):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_1",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x'], target: int=7416):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x'], target=7416):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_2",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--'], target: int=77865):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--'], target=77865):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_3",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x', 'x++'], target: int=8281):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x', 'x++'], target=8281):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_4",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x--'], target: int=95928):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x--'], target=95928):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_5",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', '++x', 'x++'], target: int=94413):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', '++x', 'x++'], target=94413):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_6",
    "sat": "def sat(n: int, ops: List[str]=['x++'], target: int=53804):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++'], target=53804):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_7",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', 'x++', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', '--x'], target: int=25224):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', 'x++', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', '--x'], target=25224):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_8",
    "sat": "def sat(n: int, ops: List[str]=['x++'], target: int=85446):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++'], target=85446):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_9",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x--'], target: int=82806):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x--'], target=82806):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_10",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x'], target: int=14977):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x'], target=14977):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_11",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', '--x', '++x', '++x', '--x'], target: int=96441):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', '--x', '++x', '++x', '--x'], target=96441):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_12",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', '++x', 'x--'], target: int=17387):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', '++x', 'x--'], target=17387):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_13",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '++x'], target: int=22109):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '++x'], target=22109):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_14",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x--', '++x'], target: int=77271):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x--', '++x'], target=77271):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_15",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--'], target: int=52997):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--'], target=52997):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_16",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x'], target: int=76065):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x'], target=76065):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_17",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--'], target: int=40964):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--'], target=40964):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_18",
    "sat": "def sat(n: int, ops: List[str]=['++x'], target: int=97753):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x'], target=97753):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_19",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', 'x--'], target: int=75063):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', 'x--'], target=75063):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_20",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x'], target: int=61835):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x'], target=61835):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_21",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--'], target: int=43959):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--'], target=43959):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_22",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--'], target: int=3345):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--'], target=3345):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_23",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++'], target: int=20286):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++'], target=20286):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_24",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++'], target: int=84438):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++'], target=84438):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_25",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++'], target: int=41260):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++'], target=41260):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_26",
    "sat": "def sat(n: int, ops: List[str]=['--x'], target: int=52217):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x'], target=52217):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_27",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '--x', '--x', '++x', 'x--', '--x', '--x'], target: int=87904):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '--x', '--x', '++x', 'x--', '--x', '--x'], target=87904):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_28",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x'], target: int=37939):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x'], target=37939):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_29",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x--'], target: int=93512):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x--'], target=93512):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_30",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x'], target: int=38343):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x'], target=38343):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_31",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x'], target: int=23531):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x'], target=23531):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_32",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=74003):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=74003):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_33",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x'], target: int=3324):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x'], target=3324):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_34",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++'], target: int=7824):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++'], target=7824):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_35",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++'], target: int=97791):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++'], target=97791):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_36",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '++x'], target: int=29930):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '++x'], target=29930):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_37",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x--'], target: int=58294):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x--'], target=58294):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_38",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++'], target: int=35414):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++'], target=35414):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_39",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', '++x', 'x--', '++x', '++x', '++x'], target: int=54587):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', '++x', 'x--', '++x', '++x', '++x'], target=54587):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_40",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '++x', '--x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--'], target: int=4263):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '++x', '--x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--'], target=4263):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_41",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++'], target: int=81876):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++'], target=81876):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_42",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '--x', '++x', '--x', '--x', '++x', '--x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++'], target: int=50138):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '--x', '++x', '--x', '--x', '++x', '--x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++'], target=50138):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_43",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', 'x--', '++x', 'x--', '--x', 'x--'], target: int=99606):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', 'x--', '++x', 'x--', '--x', 'x--'], target=99606):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_44",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', '++x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--'], target: int=40167):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', '++x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--'], target=40167):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_45",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', '--x', '++x'], target: int=82471):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', '--x', '++x'], target=82471):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_46",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x'], target: int=63915):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x'], target=63915):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_47",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x++', '--x', 'x++', '--x', '--x'], target: int=76690):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x++', '--x', 'x++', '--x', '--x'], target=76690):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_48",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=55603):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=55603):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_49",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x++', '--x'], target: int=9771):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x++', '--x'], target=9771):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_50",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x'], target: int=95079):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x'], target=95079):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_51",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=68839):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=68839):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_52",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x'], target: int=97948):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x'], target=97948):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_53",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x--'], target: int=26237):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x--'], target=26237):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_54",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x--'], target: int=14502):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x--'], target=14502):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_55",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '++x', 'x++', 'x--', '--x'], target: int=28444):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '++x', 'x++', 'x--', '--x'], target=28444):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_56",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', 'x--', 'x--', '++x'], target: int=68328):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', 'x--', 'x--', '++x'], target=68328):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_57",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x', '--x'], target: int=46849):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x', '--x'], target=46849):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_58",
    "sat": "def sat(n: int, ops: List[str]=['++x'], target: int=85114):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x'], target=85114):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_59",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++'], target: int=85076):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++'], target=85076):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_60",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--'], target: int=22581):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--'], target=22581):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_61",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x'], target: int=95564):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x'], target=95564):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_62",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x'], target: int=77175):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x'], target=77175):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_63",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--'], target: int=18398):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--'], target=18398):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_64",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x'], target: int=28931):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x'], target=28931):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_65",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x++'], target: int=65817):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x++'], target=65817):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_66",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++'], target: int=15349):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++'], target=15349):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_67",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', 'x++'], target: int=636):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', 'x++'], target=636):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_68",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x'], target: int=96574):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x'], target=96574):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_69",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', '++x', '--x', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++'], target: int=46004):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', '++x', '--x', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++'], target=46004):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_70",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x'], target: int=99410):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x'], target=99410):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_71",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', '--x'], target: int=81750):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', '--x'], target=81750):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_72",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x'], target: int=14265):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x'], target=14265):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_73",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', 'x++'], target: int=89669):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', 'x++'], target=89669):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_74",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++'], target: int=51499):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++'], target=51499):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_75",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '--x', 'x++', 'x--'], target: int=38877):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '--x', 'x++', 'x--'], target=38877):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_76",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x'], target: int=73905):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x'], target=73905):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_77",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=32706):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=32706):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_78",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--'], target: int=36903):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--'], target=36903):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_79",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x'], target: int=21):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x'], target=21):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_80",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--'], target: int=37479):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--'], target=37479):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_81",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', '++x', '--x'], target: int=26155):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', '++x', '--x'], target=26155):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_82",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x'], target: int=68747):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x'], target=68747):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_83",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x'], target: int=36031):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x'], target=36031):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_84",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', 'x++', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', 'x++', '--x'], target: int=29267):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', 'x++', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', 'x++', '--x'], target=29267):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_85",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x'], target: int=78016):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x'], target=78016):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_86",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++'], target: int=48606):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++'], target=48606):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_87",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=69826):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=69826):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_88",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x++', '--x', '--x', '++x'], target: int=39621):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x++', '--x', '--x', '++x'], target=39621):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_89",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '++x', 'x++', 'x--', '++x', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', 'x++'], target: int=35255):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '++x', 'x++', 'x--', '++x', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', 'x++'], target=35255):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_90",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x'], target: int=45283):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x'], target=45283):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_91",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x--'], target: int=86386):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x--'], target=86386):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_92",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', '--x'], target: int=82017):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', '--x'], target=82017):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_93",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x'], target: int=64476):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x'], target=64476):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_94",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '--x', 'x++', '++x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++'], target: int=78478):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '--x', 'x++', '++x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++'], target=78478):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_95",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x'], target: int=6996):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x'], target=6996):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_96",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x'], target: int=95952):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x'], target=95952):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_97",
    "sat": "def sat(n: int, ops: List[str]=[], target: int=15387):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=[], target=15387):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_98",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x++'], target: int=27383):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x++'], target=27383):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_99",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++'], target: int=28639):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++'], target=28639):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "CompareInAnyCase_0",
    "sat": "def sat(n: int, s: str=\"aaAab\", t: str=\"aAaaB\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"aaAab\", t=\"aAaaB\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_1",
    "sat": "def sat(n: int, s: str=\"COXANIxyropY\", t: str=\"cOXANixYrOpYVoFOREcHiParuKEb\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"COXANIxyropY\", t=\"cOXANixYrOpYVoFOREcHiParuKEb\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_2",
    "sat": "def sat(n: int, s: str=\"HUtuQuOWelYHEToMUHob\", t: str=\"HutuquoquobaJiXuc\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"HUtuQuOWelYHEToMUHob\", t=\"HutuquoquobaJiXuc\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_3",
    "sat": "def sat(n: int, s: str=\"tEXtUtE\", t: str=\"TeXjeX\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"tEXtUtE\", t=\"TeXjeX\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_4",
    "sat": "def sat(n: int, s: str=\"C\", t: str=\"Suh\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"C\", t=\"Suh\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_5",
    "sat": "def sat(n: int, s: str=\"lakyLiBEsU\", t: str=\"HYhODYNUtHuCHUrOsU\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"lakyLiBEsU\", t=\"HYhODYNUtHuCHUrOsU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_6",
    "sat": "def sat(n: int, s: str=\"vYRopyXUReTIs\", t: str=\"VyropYxUrETIS\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"vYRopyXUReTIs\", t=\"VyropYxUrETIS\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_7",
    "sat": "def sat(n: int, s: str=\"JYsIG\", t: str=\"HepulokOL\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JYsIG\", t=\"HepulokOL\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_8",
    "sat": "def sat(n: int, s: str=\"PESOTeXTEVar\", t: str=\"PESOteXtEVar\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"PESOTeXTEVar\", t=\"PESOteXtEVar\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_9",
    "sat": "def sat(n: int, s: str=\"chIGEmYlAzULEquuGydI\", t: str=\"CneC\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"chIGEmYlAzULEquuGydI\", t=\"CneC\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_10",
    "sat": "def sat(n: int, s: str=\"XaCYgAXequY\", t: str=\"XaCyGaxnEFiru\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"XaCYgAXequY\", t=\"XaCyGaxnEFiru\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_11",
    "sat": "def sat(n: int, s: str=\"CuPIxAJihAsukyQue\", t: str=\"CUpIXnYCIjIhyLaLOKAm\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CuPIxAJihAsukyQue\", t=\"CUpIXnYCIjIhyLaLOKAm\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_12",
    "sat": "def sat(n: int, s: str=\"v\", t: str=\"HegaKECIvavuthAtyz\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"v\", t=\"HegaKECIvavuthAtyz\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_13",
    "sat": "def sat(n: int, s: str=\"TURecigAC\", t: str=\"TURRUChufy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TURecigAC\", t=\"TURRUChufy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_14",
    "sat": "def sat(n: int, s: str=\"sYkUMAmici\", t: str=\"SyKxiWoq\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"sYkUMAmici\", t=\"SyKxiWoq\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_15",
    "sat": "def sat(n: int, s: str=\"was\", t: str=\"WAs\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"was\", t=\"WAs\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_16",
    "sat": "def sat(n: int, s: str=\"Z\", t: str=\"wYvYTARIcafaNaxoxID\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Z\", t=\"wYvYTARIcafaNaxoxID\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_17",
    "sat": "def sat(n: int, s: str=\"TY\", t: str=\"TdisAtEXTYFaM\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TY\", t=\"TdisAtEXTYFaM\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_18",
    "sat": "def sat(n: int, s: str=\"Je\", t: str=\"JEDAfaTExTyPIp\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Je\", t=\"JEDAfaTExTyPIp\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_19",
    "sat": "def sat(n: int, s: str=\"mOSEzuLyTHIXa\", t: str=\"MosjYCadeXaKEfesuGISy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mOSEzuLyTHIXa\", t=\"MosjYCadeXaKEfesuGISy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_20",
    "sat": "def sat(n: int, s: str=\"DyKIMUVoLewuGeM\", t: str=\"DYkImuVolEjatExtiwuCADErEQu\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"DyKIMUVoLewuGeM\", t=\"DYkImuVolEjatExtiwuCADErEQu\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_21",
    "sat": "def sat(n: int, s: str=\"HAquU\", t: str=\"haQUuGuXIkEjYpaf\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"HAquU\", t=\"haQUuGuXIkEjYpaf\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_22",
    "sat": "def sat(n: int, s: str=\"pezaNIZyqueTypI\", t: str=\"pezANIZyquECHOtExTEFivaTHytiJIN\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"pezaNIZyqueTypI\", t=\"pezANIZyquECHOtExTEFivaTHytiJIN\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_23",
    "sat": "def sat(n: int, s: str=\"TeXtypicETUtHuNA\", t: str=\"TeXtxAtySYZod\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TeXtypicETUtHuNA\", t=\"TeXtxAtySYZod\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_24",
    "sat": "def sat(n: int, s: str=\"RUROq\", t: str=\"wyJetE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"RUROq\", t=\"wyJetE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_25",
    "sat": "def sat(n: int, s: str=\"zoWIKACHOteXTo\", t: str=\"zpeLEGAVE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"zoWIKACHOteXTo\", t=\"zpeLEGAVE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_26",
    "sat": "def sat(n: int, s: str=\"DOpakiKujiChyDYlUlyS\", t: str=\"DOPaKiKujIChyDYlUlYsXeteXtUsEBy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"DOpakiKujiChyDYlUlyS\", t=\"DOPaKiKujIChyDYlUlYsXeteXtUsEBy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_27",
    "sat": "def sat(n: int, s: str=\"rAfoCimUtywYKUGyTH\", t: str=\"rAFOCimutYWyKUGyTH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"rAfoCimUtywYKUGyTH\", t=\"rAFOCimutYWyKUGyTH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_28",
    "sat": "def sat(n: int, s: str=\"CEdEhEgORiQUeChy\", t: str=\"ceDwUcHIJOpyXUDe\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CEdEhEgORiQUeChy\", t=\"ceDwUcHIJOpyXUDe\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_29",
    "sat": "def sat(n: int, s: str=\"cH\", t: str=\"CfUrEjo\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"cH\", t=\"CfUrEjo\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_30",
    "sat": "def sat(n: int, s: str=\"WUGivITE\", t: str=\"WUgIViXukiC\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"WUGivITE\", t=\"WUgIViXukiC\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_31",
    "sat": "def sat(n: int, s: str=\"cigOTexT\", t: str=\"ciGOtext\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"cigOTexT\", t=\"ciGOtext\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_32",
    "sat": "def sat(n: int, s: str=\"ruDuPuCHIchi\", t: str=\"rudUPuCkecARy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"ruDuPuCHIchi\", t=\"rudUPuCkecARy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_33",
    "sat": "def sat(n: int, s: str=\"goDuFiCAxOga\", t: str=\"godUFKYGENaxOZOLoTex\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"goDuFiCAxOga\", t=\"godUFKYGENaxOZOLoTex\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_34",
    "sat": "def sat(n: int, s: str=\"bybyHIHybONesUBySIr\", t: str=\"BybyhIHYBoNesuTuCUqUOrIcHuvOnot\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"bybyHIHybONesUBySIr\", t=\"BybyhIHYBoNesuTuCUqUOrIcHuvOnot\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_35",
    "sat": "def sat(n: int, s: str=\"FUL\", t: str=\"fULtukIBYzidydifAVo\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"FUL\", t=\"fULtukIBYzidydifAVo\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_36",
    "sat": "def sat(n: int, s: str=\"kabOcANuweWolATIj\", t: str=\"KAtYQ\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"kabOcANuweWolATIj\", t=\"KAtYQ\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_37",
    "sat": "def sat(n: int, s: str=\"laTos\", t: str=\"law\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"laTos\", t=\"law\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_38",
    "sat": "def sat(n: int, s: str=\"hudoGIquUchA\", t: str=\"hUdOGIqUuchA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hudoGIquUchA\", t=\"hUdOGIqUuchA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_39",
    "sat": "def sat(n: int, s: str=\"JODExEDaNekECho\", t: str=\"JOdeXeDAnEkeCdyDAbUTIFychY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JODExEDaNekECho\", t=\"JOdeXeDAnEkeCdyDAbUTIFychY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_40",
    "sat": "def sat(n: int, s: str=\"GezATeN\", t: str=\"geZATeN\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"GezATeN\", t=\"geZATeN\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_41",
    "sat": "def sat(n: int, s: str=\"hEWymUsILIXO\", t: str=\"hewymcExIfOlOgOWePABEhU\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hEWymUsILIXO\", t=\"hewymcExIfOlOgOWePABEhU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_42",
    "sat": "def sat(n: int, s: str=\"FYsycE\", t: str=\"fYSYce\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"FYsycE\", t=\"fYSYce\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_43",
    "sat": "def sat(n: int, s: str=\"TeXTefyZatEx\", t: str=\"TDOchApYWIgOtextY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TeXTefyZatEx\", t=\"TDOchApYWIgOtextY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_44",
    "sat": "def sat(n: int, s: str=\"mYvETE\", t: str=\"MyVetE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mYvETE\", t=\"MyVetE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_45",
    "sat": "def sat(n: int, s: str=\"LefYw\", t: str=\"leFYWfanutHAcAb\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"LefYw\", t=\"leFYWfanutHAcAb\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_46",
    "sat": "def sat(n: int, s: str=\"Fo\", t: str=\"CiTulAPOsI\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Fo\", t=\"CiTulAPOsI\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_47",
    "sat": "def sat(n: int, s: str=\"tarInA\", t: str=\"taCIlyfyQuA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"tarInA\", t=\"taCIlyfyQuA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_48",
    "sat": "def sat(n: int, s: str=\"hyLuhacezYFEJUV\", t: str=\"HyLuHACEzYfEjuv\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hyLuhacezYFEJUV\", t=\"HyLuHACEzYfEjuv\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_49",
    "sat": "def sat(n: int, s: str=\"vYmIPEWIJi\", t: str=\"vYmkeRoZA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"vYmIPEWIJi\", t=\"vYmkeRoZA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_50",
    "sat": "def sat(n: int, s: str=\"SuchiGAChEKOGapoN\", t: str=\"SuChigje\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"SuchiGAChEKOGapoN\", t=\"SuChigje\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_51",
    "sat": "def sat(n: int, s: str=\"tOxeJoC\", t: str=\"la\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"tOxeJoC\", t=\"la\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_52",
    "sat": "def sat(n: int, s: str=\"zufoJArujyp\", t: str=\"ZMeramiMyd\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"zufoJArujyp\", t=\"ZMeramiMyd\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_53",
    "sat": "def sat(n: int, s: str=\"thIMuquIpaV\", t: str=\"tHiMUQUIPafaTHitHeSoRiWYtEXt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"thIMuquIpaV\", t=\"tHiMUQUIPafaTHitHeSoRiWYtEXt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_54",
    "sat": "def sat(n: int, s: str=\"PIgy\", t: str=\"deThErECuREFEQUARiXI\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"PIgy\", t=\"deThErECuREFEQUARiXI\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_55",
    "sat": "def sat(n: int, s: str=\"DOnAquYWYfACiG\", t: str=\"DOnAQuyWYFaCiG\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"DOnAquYWYfACiG\", t=\"DOnAQuyWYFaCiG\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_56",
    "sat": "def sat(n: int, s: str=\"W\", t: str=\"hEGy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"W\", t=\"hEGy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_57",
    "sat": "def sat(n: int, s: str=\"hi\", t: str=\"HbikuHawaL\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hi\", t=\"HbikuHawaL\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_58",
    "sat": "def sat(n: int, s: str=\"divELAtEXTo\", t: str=\"dwelitExtaVicac\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"divELAtEXTo\", t=\"dwelitExtaVicac\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_59",
    "sat": "def sat(n: int, s: str=\"JItiHI\", t: str=\"cYcalUcH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JItiHI\", t=\"cYcalUcH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_60",
    "sat": "def sat(n: int, s: str=\"lAzusALOriCU\", t: str=\"laZUsAlORiCwIVUtEXtY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"lAzusALOriCU\", t=\"laZUsAlORiCwIVUtEXtY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_61",
    "sat": "def sat(n: int, s: str=\"jichygOwYTeXtE\", t: str=\"jichYgowyTexTE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"jichygOwYTeXtE\", t=\"jichYgowyTexTE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_62",
    "sat": "def sat(n: int, s: str=\"JER\", t: str=\"RIChAdYWiT\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JER\", t=\"RIChAdYWiT\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_63",
    "sat": "def sat(n: int, s: str=\"b\", t: str=\"hoTAzuCHYZUTH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"b\", t=\"hoTAzuCHYZUTH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_64",
    "sat": "def sat(n: int, s: str=\"SOgOQUEwykEX\", t: str=\"soGoQueWykeX\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"SOgOQUEwykEX\", t=\"soGoQueWykeX\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_65",
    "sat": "def sat(n: int, s: str=\"TEx\", t: str=\"TExmIte\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TEx\", t=\"TExmIte\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_66",
    "sat": "def sat(n: int, s: str=\"MUCAcHAMeMUwytUD\", t: str=\"MucacHaMeMUwYtula\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"MUCAcHAMeMUwytUD\", t=\"MucacHaMeMUwYtula\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_67",
    "sat": "def sat(n: int, s: str=\"moKASyRUSaWylaTHeT\", t: str=\"MOkASyrUSAWyLAThEt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"moKASyRUSaWylaTHeT\", t=\"MOkASyrUSAWyLAThEt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_68",
    "sat": "def sat(n: int, s: str=\"qUAJoTextyHogAQ\", t: str=\"quajOTeXTYKImOje\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"qUAJoTextyHogAQ\", t=\"quajOTeXTYKImOje\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_69",
    "sat": "def sat(n: int, s: str=\"jepyzul\", t: str=\"jepyZv\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"jepyzul\", t=\"jepyZv\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_70",
    "sat": "def sat(n: int, s: str=\"k\", t: str=\"QuasuMaSanahowy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"k\", t=\"QuasuMaSanahowy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_71",
    "sat": "def sat(n: int, s: str=\"RANiFYtHUTHONAmirOpO\", t: str=\"RAnifYtHuthTHYhAquiSeceTHEThu\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"RANiFYtHUTHONAmirOpO\", t=\"RAnifYtHuthTHYhAquiSeceTHEThu\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_72",
    "sat": "def sat(n: int, s: str=\"Jut\", t: str=\"JUt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Jut\", t=\"JUt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_73",
    "sat": "def sat(n: int, s: str=\"MubuHADEL\", t: str=\"hEx\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"MubuHADEL\", t=\"hEx\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_74",
    "sat": "def sat(n: int, s: str=\"QuyQUETeXtociVEKulO\", t: str=\"QuYQUEtExtCHegExEtIpachoqUITE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"QuyQUETeXtociVEKulO\", t=\"QuYQUEtExtCHegExEtIpachoqUITE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_75",
    "sat": "def sat(n: int, s: str=\"MOLAnyrYtexTEjyM\", t: str=\"w\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"MOLAnyrYtexTEjyM\", t=\"w\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_76",
    "sat": "def sat(n: int, s: str=\"ChaSUvaRECHyBeNu\", t: str=\"chAsUvarechybeTEXtICHOwyjuJE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"ChaSUvaRECHyBeNu\", t=\"chAsUvarechybeTEXtICHOwyjuJE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_77",
    "sat": "def sat(n: int, s: str=\"pEkITyXYH\", t: str=\"ToDyDoxIthavez\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"pEkITyXYH\", t=\"ToDyDoxIthavez\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_78",
    "sat": "def sat(n: int, s: str=\"mOM\", t: str=\"mtextYhIlaXInA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mOM\", t=\"mtextYhIlaXInA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_79",
    "sat": "def sat(n: int, s: str=\"RIvIjO\", t: str=\"rthirIvokaXoB\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"RIvIjO\", t=\"rthirIvokaXoB\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_80",
    "sat": "def sat(n: int, s: str=\"VydAkychiZyjEbekaL\", t: str=\"vyDAKychizYjEbeHERy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"VydAkychiZyjEbekaL\", t=\"vyDAKychizYjEbeHERy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_81",
    "sat": "def sat(n: int, s: str=\"xydav\", t: str=\"XyDAV\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"xydav\", t=\"XyDAV\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_82",
    "sat": "def sat(n: int, s: str=\"QU\", t: str=\"QJY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"QU\", t=\"QJY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_83",
    "sat": "def sat(n: int, s: str=\"CHApINYByzYtoGij\", t: str=\"cHAPINYByzYTOgIj\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CHApINYByzYtoGij\", t=\"cHAPINYByzYTOgIj\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_84",
    "sat": "def sat(n: int, s: str=\"LuTEX\", t: str=\"LuTENEzYVyteXtYfachErORa\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"LuTEX\", t=\"LuTENEzYVyteXtYfachErORa\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_85",
    "sat": "def sat(n: int, s: str=\"falyFUxodOcHachOfoCh\", t: str=\"falyfuxOdoCHAchofoCH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"falyFUxodOcHachOfoCh\", t=\"falyfuxOdoCHAchofoCH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_86",
    "sat": "def sat(n: int, s: str=\"cyxeKUThOTHIQuyBUT\", t: str=\"CYxEKUtHcyGUNUt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"cyxeKUThOTHIQuyBUT\", t=\"CYxEKUtHcyGUNUt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_87",
    "sat": "def sat(n: int, s: str=\"vERisuGeCYZUsEcHEze\", t: str=\"verisuGEcyZuFeR\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"vERisuGeCYZUsEcHEze\", t=\"verisuGEcyZuFeR\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_88",
    "sat": "def sat(n: int, s: str=\"CIFekiGucHO\", t: str=\"gUg\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CIFekiGucHO\", t=\"gUg\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_89",
    "sat": "def sat(n: int, s: str=\"hEvULEp\", t: str=\"HEvulWatex\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hEvULEp\", t=\"HEvulWatex\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_90",
    "sat": "def sat(n: int, s: str=\"maGUMug\", t: str=\"manuchoZORyjUFYvyVoGU\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"maGUMug\", t=\"manuchoZORyjUFYvyVoGU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_91",
    "sat": "def sat(n: int, s: str=\"NelUhETh\", t: str=\"nELUHetTextOpOCH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"NelUhETh\", t=\"nELUHetTextOpOCH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_92",
    "sat": "def sat(n: int, s: str=\"KIrutYCheHyChijIT\", t: str=\"KiRuTycHeHyCHIJIZoSUtHYDirA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"KIrutYCheHyChijIT\", t=\"KiRuTycHeHyCHIJIZoSUtHYDirA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_93",
    "sat": "def sat(n: int, s: str=\"fawiKOMyT\", t: str=\"FaSiSyS\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"fawiKOMyT\", t=\"FaSiSyS\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_94",
    "sat": "def sat(n: int, s: str=\"TOmANYGYCAtHaRafIQU\", t: str=\"TomAN\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TOmANYGYCAtHaRafIQU\", t=\"TomAN\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_95",
    "sat": "def sat(n: int, s: str=\"LUtEX\", t: str=\"LuTEX\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"LUtEX\", t=\"LuTEX\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_96",
    "sat": "def sat(n: int, s: str=\"FEsepUTHUkePOdeNUFAg\", t: str=\"feSEhiCHOTHEdOz\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"FEsepUTHUkePOdeNUFAg\", t=\"feSEhiCHOTHEdOz\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_97",
    "sat": "def sat(n: int, s: str=\"N\", t: str=\"njaRaNYthyVeJuk\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"N\", t=\"njaRaNYthyVeJuk\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_98",
    "sat": "def sat(n: int, s: str=\"TUWYnen\", t: str=\"tuwynEn\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TUWYnen\", t=\"tuwynEn\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_99",
    "sat": "def sat(n: int, s: str=\"mesy\", t: str=\"mesy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mesy\", t=\"mesy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "SlidingOne_0",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_1",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_2",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_3",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_4",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_5",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_6",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_7",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_8",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_9",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_10",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_11",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_12",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=0):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=0):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_13",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_14",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_15",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_16",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_17",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_18",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_19",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_20",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_21",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_22",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_23",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_24",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SortPlusPlus_0",
    "sat": "def sat(s: str, inp: str=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_1",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+2+3+2+2+3+3+2+3+2+1+3+2+2+1+3+1+1+1+1+2+1+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+2+3+2+2+3+3+2+3+2+1+3+2+2+1+3+1+1+1+1+2+1+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_2",
    "sat": "def sat(s: str, inp: str=\"3+3+3+2+2+1+1+1+1+2+2+2+3+3+3+2+3+2+2+3+1+1+3+3+2+3+3+3+1+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+2+2+1+1+1+1+2+2+2+3+3+3+2+3+2+2+3+1+1+3+3+2+3+3+3+1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_3",
    "sat": "def sat(s: str, inp: str=\"2+3+2+3+2+2+1+3+3+3+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+2+3+2+2+1+3+3+3+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_4",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+2+2+2+3+2+2+3+1+1+3+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+2+2+2+3+2+2+3+1+1+3+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_5",
    "sat": "def sat(s: str, inp: str=\"3+3+2+3+2+3+2+2+3+3+3+3+1+3+3+2+2+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+3+2+3+2+2+3+3+3+3+1+3+3+2+2+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_6",
    "sat": "def sat(s: str, inp: str=\"2+3+3+2+3+1+1+3+3+2+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+3+2+3+1+1+3+3+2+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_7",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+1+1+1+1+2+3+2+1+3+1+1+3+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+1+1+1+1+2+3+2+1+3+1+1+3+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_8",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+3+2+1+3+3+3+2+1+2+1+1+2+1+3+1+2+3+1+1+1+2+1+2+3+2+1+1+3+1+2+2+1+2+3+2+2+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+3+2+1+3+3+3+2+1+2+1+1+2+1+3+1+2+3+1+1+1+2+1+2+3+2+1+1+3+1+2+2+1+2+3+2+2+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_9",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+3+3+1+2+1+3+2+3+1+3+3+2+2+2+1+3+3+2+2+2+2+1+2+3+3+3+2+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+3+3+1+2+1+3+2+3+1+3+3+2+2+2+1+3+3+2+2+2+2+1+2+3+3+3+2+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_10",
    "sat": "def sat(s: str, inp: str=\"3+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_11",
    "sat": "def sat(s: str, inp: str=\"1+2+2+3+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+3+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_12",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+1+2+2+2+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+1+2+2+2+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_13",
    "sat": "def sat(s: str, inp: str=\"3+1+2+1+1+1+2+1+3+2+1+3+1+2+3+2+2+2+3+1+2+3+2+1+2+1+2+1+3+2+3+2+3+1+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+1+1+1+2+1+3+2+1+3+1+2+3+2+2+2+3+1+2+3+2+1+2+1+2+1+3+2+3+2+3+1+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_14",
    "sat": "def sat(s: str, inp: str=\"3+3+3+1+2+1+2+3+2+2+1+3+1+2+2+3+2+3+3+2+1+2+3+3+1+2+3+1+2+1+1+1+3+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+1+2+1+2+3+2+2+1+3+1+2+2+3+2+3+3+2+1+2+3+3+1+2+3+1+2+1+1+1+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_15",
    "sat": "def sat(s: str, inp: str=\"1+3+2+1+3+1+1+3+2+1+2+2+1+1+2+2+1+2+3+3+1+2+3+3+2+3+2+1+2+2+2+3+1+2+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+1+3+1+1+3+2+1+2+2+1+1+2+2+1+2+3+3+1+2+3+3+2+3+2+1+2+2+2+3+1+2+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_16",
    "sat": "def sat(s: str, inp: str=\"1+3+1+1+3+3+3+3+2+2+2+3+1+1+2+1+2+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+1+1+3+3+3+3+2+2+2+3+1+1+2+1+2+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_17",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+1+2+1+3+3+2+1+1+1+2+2+2+2+3+3+3+3+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+1+2+1+3+3+2+1+1+1+2+2+2+2+3+3+3+3+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_18",
    "sat": "def sat(s: str, inp: str=\"2+3+3+1+3+1+2+2+1+2+1+2+3+2+3+2+1+2+3+2+2+1+2+3+3+2+1+1+2+2+3+2+3+3+3+3+1+3+3+2+1+2+1+2+1+2+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+3+1+3+1+2+2+1+2+1+2+3+2+3+2+1+2+3+2+2+1+2+3+3+2+1+1+2+2+3+2+3+3+3+3+1+3+3+2+1+2+1+2+1+2+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_19",
    "sat": "def sat(s: str, inp: str=\"3+2+1+1+1+2+1+1+1+1+1+1+3+1+2+1+1+3+1+2+2+3+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+1+1+2+1+1+1+1+1+1+3+1+2+1+1+3+1+2+2+3+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_20",
    "sat": "def sat(s: str, inp: str=\"2+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_21",
    "sat": "def sat(s: str, inp: str=\"3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_22",
    "sat": "def sat(s: str, inp: str=\"1+2+3+1+2+1+3+1+2+3+1+3+2+1+3+2+1+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3+1+2+1+3+1+2+3+1+3+2+1+3+2+1+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_23",
    "sat": "def sat(s: str, inp: str=\"1+1+3+2+3+3+3+1+2+1+1+2+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+2+3+3+3+1+2+1+1+2+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_24",
    "sat": "def sat(s: str, inp: str=\"2+2+3+1+3+2+2+3+3+3+1+3+3+1+1+2+1+3+1+2+1+3+1+1+1+3+1+2+1+2+1+2+3+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+1+3+2+2+3+3+3+1+3+3+1+1+2+1+3+1+2+1+3+1+1+1+3+1+2+1+2+1+2+3+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_25",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+3+2+2+3+3+1+2+3+3+2+1+3+1+2+2+3+2+1+1+2+2+2+3+2+3+2+3+1+1+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+3+2+2+3+3+1+2+3+3+2+1+3+1+2+2+3+2+1+1+2+2+2+3+2+3+2+3+1+1+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_26",
    "sat": "def sat(s: str, inp: str=\"1+3+1+3+2+1+3+3+1+3+3+1+1+2+2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+1+3+2+1+3+3+1+3+3+1+1+2+2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_27",
    "sat": "def sat(s: str, inp: str=\"2+1+3+1+2+1+1+1+2+1+1+2+2+2+1+3+3+1+1+2+3+3+2+3+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+3+1+2+1+1+1+2+1+1+2+2+2+1+3+3+1+1+2+3+3+2+3+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_28",
    "sat": "def sat(s: str, inp: str=\"2+3+2+2+2+2+3+3+3+3+2+3+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+2+2+2+2+3+3+3+3+2+3+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_29",
    "sat": "def sat(s: str, inp: str=\"2+2+3+2+1+1+2+1+3+1+3+1+3+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+2+1+1+2+1+3+1+3+1+3+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_30",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+3+1+2+1+2+2+1+1+3+3+1+1+1+2+2+1+3+2+2+1+1+1+1+1+1+3+1+3+3+3+3+3+2+3+1+3+1+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+3+1+2+1+2+2+1+1+3+3+1+1+1+2+2+1+3+2+2+1+1+1+1+1+1+3+1+3+3+3+3+3+2+3+1+3+1+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_31",
    "sat": "def sat(s: str, inp: str=\"3+3+2+2+3+1+2+3+3+1+3+1+1+1+1+2+2+2+1+2+2+2+3+3+3+3+3+3+1+3+1+1+2+2+1+3+3+2+1+1+3+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+2+3+1+2+3+3+1+3+1+1+1+1+2+2+2+1+2+2+2+3+3+3+3+3+3+1+3+1+1+2+2+1+3+3+2+1+1+3+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_32",
    "sat": "def sat(s: str, inp: str=\"2+1+3+2+1+3+1+2+3+1+1+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+3+2+1+3+1+2+3+1+1+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_33",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+2+3+3+3+2+1+1+3+3+2+2+2+3+3+2+1+3+1+1+2+1+3+3+1+2+2+2+2+2+2+3+3+3+2+3+1+2+2+3+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+2+3+3+3+2+1+1+3+3+2+2+2+3+3+2+1+3+1+1+2+1+3+3+1+2+2+2+2+2+2+3+3+3+2+3+1+2+2+3+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_34",
    "sat": "def sat(s: str, inp: str=\"3+3+2+1+3+2+2+2+2+1+2+3+1+1+3+1+2+3+2+1+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+1+3+2+2+2+2+1+2+3+1+1+3+1+2+3+2+1+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_35",
    "sat": "def sat(s: str, inp: str=\"2+3+1+2+2+3+3+2+1+3+1+1+2+2+1+3+2+1+3+3+2+1+3+3+2+3+1+1+3+1+2+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+2+3+3+2+1+3+1+1+2+2+1+3+2+1+3+3+2+1+3+3+2+3+1+1+3+1+2+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_36",
    "sat": "def sat(s: str, inp: str=\"1+1+3+2+3+1+2+1+1+3+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+2+3+1+2+1+1+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_37",
    "sat": "def sat(s: str, inp: str=\"\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_38",
    "sat": "def sat(s: str, inp: str=\"1+1+2+3+1+2+3+1+3+2+2+2+1+3+2+3+1+1+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+2+3+1+2+3+1+3+2+2+2+1+3+2+3+1+1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_39",
    "sat": "def sat(s: str, inp: str=\"3+2+2+2+2+3+3+1+1+1+1+2+3+2+2+2+2+2+1+3+1+3+2+1+2+2+2+2+3+2+1+1+3+2+2+3+1+3+2+3+1+2+1+3+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+2+2+2+3+3+1+1+1+1+2+3+2+2+2+2+2+1+3+1+3+2+1+2+2+2+2+3+2+1+1+3+2+2+3+1+3+2+3+1+2+1+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_40",
    "sat": "def sat(s: str, inp: str=\"1+3+3+3+2+3+2+2+3+2+2+1+2+2+1+1+1+2+2+1+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+3+2+3+2+2+3+2+2+1+2+2+1+1+1+2+2+1+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_41",
    "sat": "def sat(s: str, inp: str=\"3+1+1+3+3+3+2+1+1+1+1+2+2+2+2+2+1+3+2+3+1+1+2+2+3+3+2+1+1+3+3+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+1+3+3+3+2+1+1+1+1+2+2+2+2+2+1+3+2+3+1+1+2+2+3+3+2+1+1+3+3+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_42",
    "sat": "def sat(s: str, inp: str=\"2+3+1+1+3+2+3+2+2+2+3+3+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+1+3+2+3+2+2+2+3+3+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_43",
    "sat": "def sat(s: str, inp: str=\"3+1+2+1+1+3+3+2+3+3+3+2+3+3+1+1+2+2+2+1+1+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+1+1+3+3+2+3+3+3+2+3+3+1+1+2+2+2+1+1+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_44",
    "sat": "def sat(s: str, inp: str=\"2+2+3+3+3+2+2+3+2+3+1+1+1+2+1+3+2+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+3+3+2+2+3+2+3+1+1+1+2+1+3+2+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_45",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+2+1+1+2+2+1+2+2+3+2+1+3+1+2+2+1+2+2+3+1+3+2+2+2+2+2+2+3+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+2+1+1+2+2+1+2+2+3+2+1+3+1+2+2+1+2+2+3+1+3+2+2+2+2+2+2+3+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_46",
    "sat": "def sat(s: str, inp: str=\"3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_47",
    "sat": "def sat(s: str, inp: str=\"3+3+1+2+1+2+3+3+1+1+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+1+2+1+2+3+3+1+1+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_48",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+1+1+2+2+1+2+1+2+2+2+3+1+1+2+2+2+3+3+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+1+1+2+2+1+2+1+2+2+2+3+1+1+2+2+2+3+3+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_49",
    "sat": "def sat(s: str, inp: str=\"2+3+1+2+2+2+2+2+1+3+3+3+1+1+3+3+3+3+1+2+1+2+1+1+1+2+1+3+1+2+3+1+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+2+2+2+2+1+3+3+3+1+1+3+3+3+3+1+2+1+2+1+1+1+2+1+3+1+2+3+1+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_50",
    "sat": "def sat(s: str, inp: str=\"2+2+2+2+2+2+2+3+2+3+2+1+1+3+1+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+2+2+2+2+2+3+2+3+2+1+1+3+1+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_51",
    "sat": "def sat(s: str, inp: str=\"3+2+3+2+2+1+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+2+2+1+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_52",
    "sat": "def sat(s: str, inp: str=\"3+1+1+2+3+3+3+1+2+2+2+2+1+1+3+3+3+2+1+2+3+3+1+2+2+3+2+1+3+3+3+3+2+3+3+1+2+2+3+1+1+3+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+1+2+3+3+3+1+2+2+2+2+1+1+3+3+3+2+1+2+3+3+1+2+2+3+2+1+3+3+3+3+2+3+3+1+2+2+3+1+1+3+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_53",
    "sat": "def sat(s: str, inp: str=\"2+2+3+2+1+1+2+3+1+3+1+1+1+2+2+1+2+3+1+1+1+3+3+3+1+3+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+2+1+1+2+3+1+3+1+1+1+2+2+1+2+3+1+1+1+3+3+3+1+3+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_54",
    "sat": "def sat(s: str, inp: str=\"2+1+1+3+2+1+2+2+2+3+3+2+2+1+1+1+3+3+1+2+3+1+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1+3+2+1+2+2+2+3+3+2+2+1+1+1+3+3+1+2+3+1+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_55",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+2+2+3+3+2+2+2+1+2+2+1+1+2+2+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+2+2+3+3+2+2+2+1+2+2+1+1+2+2+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_56",
    "sat": "def sat(s: str, inp: str=\"2+1+2+1+3+2+3+2+3+2+1+3+2+2+3+1+3+2+1+1+2+3+2+2+1+2+2+1+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+2+3+2+3+2+1+3+2+2+3+1+3+2+1+1+2+3+2+2+1+2+2+1+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_57",
    "sat": "def sat(s: str, inp: str=\"3+2+3+3+3+1+2+3+3+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+3+3+1+2+3+3+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_58",
    "sat": "def sat(s: str, inp: str=\"3+3+2+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_59",
    "sat": "def sat(s: str, inp: str=\"2+2+2+3+1+2+1+1+1+2+3+3+2+2+2+3+1+1+2+3+3+3+3+3+1+3+1+2+2+1+2+2+1+2+2+1+2+1+3+1+1+3+2+2+3+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+2+3+1+2+1+1+1+2+3+3+2+2+2+3+1+1+2+3+3+3+3+3+1+3+1+2+2+1+2+2+1+2+2+1+2+1+3+1+1+3+2+2+3+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_60",
    "sat": "def sat(s: str, inp: str=\"3+3+2+1+3+2+1+3+1+1+3+3+3+2+2+2+1+3+2+3+2+3+2+3+3+3+3+2+2+3+2+3+2+3+2+2+3+3+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+1+3+2+1+3+1+1+3+3+3+2+2+2+1+3+2+3+2+3+2+3+3+3+3+2+2+3+2+3+2+3+2+2+3+3+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_61",
    "sat": "def sat(s: str, inp: str=\"3+1+2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_62",
    "sat": "def sat(s: str, inp: str=\"3+2+2+1+2+3+1+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+2+1+2+3+1+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_63",
    "sat": "def sat(s: str, inp: str=\"3+1+3+3+2+2+3+3+2+1+3+2+1+2+3+3+1+2+1+3+2+3+2+2+3+1+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+3+2+2+3+3+2+1+3+2+1+2+3+3+1+2+1+3+2+3+2+2+3+1+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_64",
    "sat": "def sat(s: str, inp: str=\"2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_65",
    "sat": "def sat(s: str, inp: str=\"3+2+3+2+2+3+1+3+1+1+3+3+2+1+2+2+1+1+3+2+2+2+1+3+1+1+3+2+3+3+2+1+1+2+3+3+1+2+1+1+1+1+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+2+2+3+1+3+1+1+3+3+2+1+2+2+1+1+3+2+2+2+1+3+1+1+3+2+3+3+2+1+1+2+3+3+1+2+1+1+1+1+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_66",
    "sat": "def sat(s: str, inp: str=\"1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_67",
    "sat": "def sat(s: str, inp: str=\"2+3+1+2+3+2+3+3+1+2+3+2+2+3+1+2+3+1+2+3+2+1+2+1+3+1+3+3+2+2+3+2+2+2+1+1+1+3+3+2+3+1+2+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+3+2+3+3+1+2+3+2+2+3+1+2+3+1+2+3+2+1+2+1+3+1+3+3+2+2+3+2+2+2+1+1+1+3+3+2+3+1+2+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_68",
    "sat": "def sat(s: str, inp: str=\"3+3+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_69",
    "sat": "def sat(s: str, inp: str=\"1+2+2+3+3+3+2+3+1+1+1+3+2+1+3+2+2+1+2+2+2+1+2+1+3+1+3+2+2+2+2+3+3+3+1+2+1+1+1+2+1+3+3+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+3+3+3+2+3+1+1+1+3+2+1+3+2+2+1+2+2+2+1+2+1+3+1+3+2+2+2+2+3+3+3+1+2+1+1+1+2+1+3+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_70",
    "sat": "def sat(s: str, inp: str=\"3+1+2+1+1+1+3+2+2+3+3+2+1+1+1+2+1+2+3+2+1+2+2+3+2+1+1+3+1+3+2+2+2+1+2+2+2+2+2+3+3+3+2+1+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+1+1+1+3+2+2+3+3+2+1+1+1+2+1+2+3+2+1+2+2+3+2+1+1+3+1+3+2+2+2+1+2+2+2+2+2+3+3+3+2+1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_71",
    "sat": "def sat(s: str, inp: str=\"1+3+3+2+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+2+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_72",
    "sat": "def sat(s: str, inp: str=\"3+3+3+2+3+3+3+2+3+1+2+2+1+2+3+3+1+1+1+1+1+3+3+3+2+2+2+2+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+2+3+3+3+2+3+1+2+2+1+2+3+3+1+1+1+1+1+3+3+3+2+2+2+2+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_73",
    "sat": "def sat(s: str, inp: str=\"3+2+3+1+1+3+1+2+1+2+2+1+3+1+2+2+3+2+2+2+1+3+1+1+2+2+3+3+3+1+3+3+1+3+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+1+1+3+1+2+1+2+2+1+3+1+2+2+3+2+2+2+1+3+1+1+2+2+3+3+3+1+3+3+1+3+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_74",
    "sat": "def sat(s: str, inp: str=\"3+3+3+1+2+2+1+2+1+3+3+2+3+2+2+1+3+1+3+1+1+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+1+2+2+1+2+1+3+3+2+3+2+2+1+3+1+3+1+1+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_75",
    "sat": "def sat(s: str, inp: str=\"1+3+3+3+3+2+2+2+1+2+3+3+2+2+1+1+1+3+3+2+2+1+2+1+2+3+2+2+1+1+1+1+3+2+1+1+2+3+3+2+3+1+1+3+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+3+3+2+2+2+1+2+3+3+2+2+1+1+1+3+3+2+2+1+2+1+2+3+2+2+1+1+1+1+3+2+1+1+2+3+3+2+3+1+1+3+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_76",
    "sat": "def sat(s: str, inp: str=\"1+2+3+1+1+3+1+2+2+2+1+2+1+2+1+1+3+2+1+3+3+3+3+3+1+3+3+3+1+2+2+2+1+3+2+1+3+1+2+3+1+1+1+3+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3+1+1+3+1+2+2+2+1+2+1+2+1+1+3+2+1+3+3+3+3+3+1+3+3+3+1+2+2+2+1+3+2+1+3+1+2+3+1+1+1+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_77",
    "sat": "def sat(s: str, inp: str=\"2+1+2+1+3+1+3+3+3+1+2+2+2+2+2+2+3+3+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+1+3+3+3+1+2+2+2+2+2+2+3+3+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_78",
    "sat": "def sat(s: str, inp: str=\"1+1+1+1+3+1+1+3+3+3+1+2+1+3+3+3+2+2+2+1+3+3+2+3+2+3+3+2+2+1+3+1+2+2+3+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+1+1+3+1+1+3+3+3+1+2+1+3+3+3+2+2+2+1+3+3+2+3+2+3+3+2+2+1+3+1+2+2+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_79",
    "sat": "def sat(s: str, inp: str=\"3+1+3+3+3+3+3+2+2+1+1+2+3+1+1+3+2+3+2+2+3+1+2+1+3+2+1+3+3+1+3+1+2+1+1+3+2+2+3+2+3+1+1+2+3+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+3+3+3+3+2+2+1+1+2+3+1+1+3+2+3+2+2+3+1+2+1+3+2+1+3+3+1+3+1+2+1+1+3+2+2+3+2+3+1+1+2+3+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_80",
    "sat": "def sat(s: str, inp: str=\"3+2+3+3+3+3+3+2+2+1+2+3+2+3+3+1+3+3+1+1+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+3+3+3+3+2+2+1+2+3+2+3+3+1+3+3+1+1+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_81",
    "sat": "def sat(s: str, inp: str=\"3+2+3+3+2+1+2+1+1+2+1+2+2+2+3+1+2+3+3+2+1+1+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+3+2+1+2+1+1+2+1+2+2+2+3+1+2+3+3+2+1+1+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_82",
    "sat": "def sat(s: str, inp: str=\"2+1+1+3+3+1+1+1+1+3+2+1+2+2+3+3+1+3+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1+3+3+1+1+1+1+3+2+1+2+2+3+3+1+3+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_83",
    "sat": "def sat(s: str, inp: str=\"1+3+2+3+2+3+2+1+3+2+1+3+1+1+2+2+3+3+2+2+3+3+2+3+2+3+1+2+3+3+1+3+3+1+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+3+2+3+2+1+3+2+1+3+1+1+2+2+3+3+2+2+3+3+2+3+2+3+1+2+3+3+1+3+3+1+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_84",
    "sat": "def sat(s: str, inp: str=\"3+3+1+1+1+1+2+3+3+1+1+3+1+3+2+1+3+2+1+2+3+3+1+2+3+3+2+3+2+2+1+1+1+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+1+1+1+1+2+3+3+1+1+3+1+3+2+1+3+2+1+2+3+3+1+2+3+3+2+3+2+2+1+1+1+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_85",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+3+2+2+1+3+3+3+3+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+3+2+2+1+3+3+3+3+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_86",
    "sat": "def sat(s: str, inp: str=\"2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_87",
    "sat": "def sat(s: str, inp: str=\"2+1+2+2+1+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+2+1+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_88",
    "sat": "def sat(s: str, inp: str=\"3+3+2+2+2+1+3+3+3+3+3+2+2+2+2+2+1+3+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+2+2+1+3+3+3+3+3+2+2+2+2+2+1+3+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_89",
    "sat": "def sat(s: str, inp: str=\"1+3+2+1+2+3+1+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+1+2+3+1+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_90",
    "sat": "def sat(s: str, inp: str=\"1+2+3+1+2+1+2+3+3+3+2+3+3+3+1+2+1+2+1+1+2+3+1+3+1+2+3+2+3+1+3+1+3+3+3+3+2+1+1+2+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3+1+2+1+2+3+3+3+2+3+3+3+1+2+1+2+1+1+2+3+1+3+1+2+3+2+3+1+3+1+3+3+3+3+2+1+1+2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_91",
    "sat": "def sat(s: str, inp: str=\"1+3+3+2+2+3+3+3+2+2+3+1+2+2+2+2+2+3+3+2+1+3+1+2+3+1+1+3+2+1+1+3+2+1+1+2+2+1+3+2+3+1+2+3+3+3+2+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+2+2+3+3+3+2+2+3+1+2+2+2+2+2+3+3+2+1+3+1+2+3+1+1+3+2+1+1+3+2+1+1+2+2+1+3+2+3+1+2+3+3+3+2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_92",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+1+2+1+1+1+1+1+3+1+2+3+3+3+2+1+3+2+1+2+3+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+1+2+1+1+1+1+1+3+1+2+3+3+3+2+1+3+2+1+2+3+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_93",
    "sat": "def sat(s: str, inp: str=\"3+2+1+1+1+1+3+1+3+1+1+2+3+2+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+1+1+1+3+1+3+1+1+2+3+2+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_94",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_95",
    "sat": "def sat(s: str, inp: str=\"1+3+2+3+3+1+3+1+3+1+3+2+2+1+3+3+1+1+2+2+2+2+3+1+2+1+2+2+2+2+3+1+2+1+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+3+3+1+3+1+3+1+3+2+2+1+3+3+1+1+2+2+2+2+3+1+2+1+2+2+2+2+3+1+2+1+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_96",
    "sat": "def sat(s: str, inp: str=\"2+1+2+1+3+3+2+2+3+2+3+3+3+3+2+3+2+3+1+2+1+1+1+3+3+1+1+2+2+3+3+1+2+1+2+3+2+2+2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+3+2+2+3+2+3+3+3+3+2+3+2+3+1+2+1+1+1+3+3+1+1+2+2+3+3+1+2+1+2+3+2+2+2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_97",
    "sat": "def sat(s: str, inp: str=\"1+1+1+2+1+3+1+2+2+1+1+1+1+2+3+1+3+1+1+2+1+3+2+3+3+3+3+3+3+2+1+3+2+1+3+2+1+1+3+3+2+3+3+3+2+1+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+1+2+1+3+1+2+2+1+1+1+1+2+3+1+3+1+1+2+1+3+2+3+3+3+3+3+3+2+1+3+2+1+3+2+1+1+3+3+2+3+3+3+2+1+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_98",
    "sat": "def sat(s: str, inp: str=\"2+3+1+1+2+3+3+1+1+2+1+3+2+3+2+1+1+3+1+3+1+3+1+2+3+3+3+1+2+3+2+3+1+2+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+1+2+3+3+1+1+2+1+3+2+3+2+1+1+3+1+3+1+3+1+2+3+3+3+1+2+3+2+3+1+2+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_99",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+3+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+3+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_0",
    "sat": "def sat(s: str, word: str=\"konjac\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"konjac\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_1",
    "sat": "def sat(s: str, word: str=\"betivo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"betivo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_2",
    "sat": "def sat(s: str, word: str=\"habyfedomeb\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"habyfedomeb\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_3",
    "sat": "def sat(s: str, word: str=\"geziqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"geziqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_4",
    "sat": "def sat(s: str, word: str=\"zugethi\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zugethi\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_5",
    "sat": "def sat(s: str, word: str=\"ko\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ko\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_6",
    "sat": "def sat(s: str, word: str=\"fyjoc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fyjoc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_7",
    "sat": "def sat(s: str, word: str=\"gadoro\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"gadoro\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_8",
    "sat": "def sat(s: str, word: str=\"munadymubunidamu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"munadymubunidamu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_9",
    "sat": "def sat(s: str, word: str=\"h\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"h\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_10",
    "sat": "def sat(s: str, word: str=\"quahywyzarotexto\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"quahywyzarotexto\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_11",
    "sat": "def sat(s: str, word: str=\"ryvexuzychaf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ryvexuzychaf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_12",
    "sat": "def sat(s: str, word: str=\"xith\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xith\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_13",
    "sat": "def sat(s: str, word: str=\"guhe\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"guhe\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_14",
    "sat": "def sat(s: str, word: str=\"nypugychek\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nypugychek\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_15",
    "sat": "def sat(s: str, word: str=\"gotextefuthyrakahamo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"gotextefuthyrakahamo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_16",
    "sat": "def sat(s: str, word: str=\"litytextuxuxyg\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"litytextuxuxyg\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_17",
    "sat": "def sat(s: str, word: str=\"zitex\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zitex\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_18",
    "sat": "def sat(s: str, word: str=\"hovycegowubatahupyr\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"hovycegowubatahupyr\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_19",
    "sat": "def sat(s: str, word: str=\"kyhi\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"kyhi\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_20",
    "sat": "def sat(s: str, word: str=\"t\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"t\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_21",
    "sat": "def sat(s: str, word: str=\"puzewusochoc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"puzewusochoc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_22",
    "sat": "def sat(s: str, word: str=\"xipubefinegydethoto\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xipubefinegydethoto\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_23",
    "sat": "def sat(s: str, word: str=\"naquuletha\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"naquuletha\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_24",
    "sat": "def sat(s: str, word: str=\"fetalonolyqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fetalonolyqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_25",
    "sat": "def sat(s: str, word: str=\"thahidilo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thahidilo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_26",
    "sat": "def sat(s: str, word: str=\"ricibyhequoz\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ricibyhequoz\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_27",
    "sat": "def sat(s: str, word: str=\"tod\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"tod\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_28",
    "sat": "def sat(s: str, word: str=\"junopesavowurabemale\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"junopesavowurabemale\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_29",
    "sat": "def sat(s: str, word: str=\"vetyfapachivuwoka\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vetyfapachivuwoka\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_30",
    "sat": "def sat(s: str, word: str=\"va\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"va\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_31",
    "sat": "def sat(s: str, word: str=\"zunuchivuruh\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zunuchivuruh\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_32",
    "sat": "def sat(s: str, word: str=\"co\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"co\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_33",
    "sat": "def sat(s: str, word: str=\"lakapequiwach\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"lakapequiwach\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_34",
    "sat": "def sat(s: str, word: str=\"text\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"text\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_35",
    "sat": "def sat(s: str, word: str=\"xaputh\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xaputh\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_36",
    "sat": "def sat(s: str, word: str=\"suhohigohej\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"suhohigohej\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_37",
    "sat": "def sat(s: str, word: str=\"dykyfuquilymitigu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dykyfuquilymitigu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_38",
    "sat": "def sat(s: str, word: str=\"boj\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"boj\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_39",
    "sat": "def sat(s: str, word: str=\"chycitowegob\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"chycitowegob\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_40",
    "sat": "def sat(s: str, word: str=\"dunethechotynovuto\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dunethechotynovuto\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_41",
    "sat": "def sat(s: str, word: str=\"nyzafu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nyzafu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_42",
    "sat": "def sat(s: str, word: str=\"waho\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"waho\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_43",
    "sat": "def sat(s: str, word: str=\"zyd\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zyd\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_44",
    "sat": "def sat(s: str, word: str=\"pomimilochajutextuf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"pomimilochajutextuf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_45",
    "sat": "def sat(s: str, word: str=\"cetextagow\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cetextagow\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_46",
    "sat": "def sat(s: str, word: str=\"lorequehiquatithuwo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"lorequehiquatithuwo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_47",
    "sat": "def sat(s: str, word: str=\"nehufepaterup\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nehufepaterup\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_48",
    "sat": "def sat(s: str, word: str=\"vexepoc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vexepoc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_49",
    "sat": "def sat(s: str, word: str=\"vaxetextynaquomidasy\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vaxetextynaquomidasy\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_50",
    "sat": "def sat(s: str, word: str=\"woletextir\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"woletextir\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_51",
    "sat": "def sat(s: str, word: str=\"dechymegurynaby\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dechymegurynaby\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_52",
    "sat": "def sat(s: str, word: str=\"mithemegechytywinada\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"mithemegechytywinada\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_53",
    "sat": "def sat(s: str, word: str=\"fofukybuquo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fofukybuquo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_54",
    "sat": "def sat(s: str, word: str=\"rixiha\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"rixiha\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_55",
    "sat": "def sat(s: str, word: str=\"ximavilu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ximavilu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_56",
    "sat": "def sat(s: str, word: str=\"cyketyjuthinumisuf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cyketyjuthinumisuf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_57",
    "sat": "def sat(s: str, word: str=\"jynixajohothaq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jynixajohothaq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_58",
    "sat": "def sat(s: str, word: str=\"byf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"byf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_59",
    "sat": "def sat(s: str, word: str=\"diparukatyvaposyj\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"diparukatyvaposyj\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_60",
    "sat": "def sat(s: str, word: str=\"thybexadekypyc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thybexadekypyc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_61",
    "sat": "def sat(s: str, word: str=\"bov\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"bov\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_62",
    "sat": "def sat(s: str, word: str=\"mehyce\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"mehyce\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_63",
    "sat": "def sat(s: str, word: str=\"xexopycoro\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xexopycoro\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_64",
    "sat": "def sat(s: str, word: str=\"vysusizubanyzykurole\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vysusizubanyzykurole\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_65",
    "sat": "def sat(s: str, word: str=\"fudinigahijuselipapa\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fudinigahijuselipapa\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_66",
    "sat": "def sat(s: str, word: str=\"hadofyte\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"hadofyte\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_67",
    "sat": "def sat(s: str, word: str=\"henykivudotitexty\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"henykivudotitexty\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_68",
    "sat": "def sat(s: str, word: str=\"rydilezilobogitiquos\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"rydilezilobogitiquos\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_69",
    "sat": "def sat(s: str, word: str=\"vymechuhekytextech\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vymechuhekytextech\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_70",
    "sat": "def sat(s: str, word: str=\"saxaquepig\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"saxaquepig\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_71",
    "sat": "def sat(s: str, word: str=\"jithyzelahylik\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jithyzelahylik\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_72",
    "sat": "def sat(s: str, word: str=\"wo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"wo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_73",
    "sat": "def sat(s: str, word: str=\"nachejysisamuwywo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nachejysisamuwywo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_74",
    "sat": "def sat(s: str, word: str=\"vomadohyg\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vomadohyg\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_75",
    "sat": "def sat(s: str, word: str=\"nylylaq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nylylaq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_76",
    "sat": "def sat(s: str, word: str=\"j\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"j\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_77",
    "sat": "def sat(s: str, word: str=\"jotextepoq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jotextepoq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_78",
    "sat": "def sat(s: str, word: str=\"byzohuchigiso\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"byzohuchigiso\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_79",
    "sat": "def sat(s: str, word: str=\"cagocuxytextolet\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cagocuxytextolet\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_80",
    "sat": "def sat(s: str, word: str=\"mojedufida\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"mojedufida\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_81",
    "sat": "def sat(s: str, word: str=\"jy\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jy\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_82",
    "sat": "def sat(s: str, word: str=\"chaquocichobehy\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"chaquocichobehy\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_83",
    "sat": "def sat(s: str, word: str=\"myquuhacaby\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"myquuhacaby\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_84",
    "sat": "def sat(s: str, word: str=\"het\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"het\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_85",
    "sat": "def sat(s: str, word: str=\"chirikutextynoqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"chirikutextynoqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_86",
    "sat": "def sat(s: str, word: str=\"cylyxequefamuhuq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cylyxequefamuhuq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_87",
    "sat": "def sat(s: str, word: str=\"rijachinuz\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"rijachinuz\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_88",
    "sat": "def sat(s: str, word: str=\"tokinaxigi\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"tokinaxigi\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_89",
    "sat": "def sat(s: str, word: str=\"q\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"q\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_90",
    "sat": "def sat(s: str, word: str=\"quovuhagomiv\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"quovuhagomiv\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_91",
    "sat": "def sat(s: str, word: str=\"thucygyf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thucygyf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_92",
    "sat": "def sat(s: str, word: str=\"goc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"goc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_93",
    "sat": "def sat(s: str, word: str=\"wirucoch\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"wirucoch\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_94",
    "sat": "def sat(s: str, word: str=\"cyvykacubysarusyqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cyvykacubysarusyqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_95",
    "sat": "def sat(s: str, word: str=\"k\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"k\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_96",
    "sat": "def sat(s: str, word: str=\"quum\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"quum\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_97",
    "sat": "def sat(s: str, word: str=\"furibixochifexuthipe\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"furibixochifexuthipe\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_98",
    "sat": "def sat(s: str, word: str=\"hykec\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"hykec\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_99",
    "sat": "def sat(s: str, word: str=\"textoxucugis\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"textoxucugis\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "LongestSubsetString_0",
    "sat": "def sat(t: str, s: str=\"abbbcabbac\", target: int=7):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbbcabbac\", target=7):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_1",
    "sat": "def sat(t: str, s: str=\"ccac\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccac\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_2",
    "sat": "def sat(t: str, s: str=\"b\", target: int=1):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"b\", target=1):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_3",
    "sat": "def sat(t: str, s: str=\"cacc\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cacc\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_4",
    "sat": "def sat(t: str, s: str=\"cbcba\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcba\", target=5):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_5",
    "sat": "def sat(t: str, s: str=\"aacacccba\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aacacccba\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_6",
    "sat": "def sat(t: str, s: str=\"cbbba\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbba\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_7",
    "sat": "def sat(t: str, s: str=\"cbbaccacccacbacabaabacbccaaaaccababaabbccccbbbcbccbaaaccaacbacccbacbbcbacccbabbbab\", target: int=53):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbaccacccacbacabaabacbccaaaaccababaabbccccbbbcbccbaaaccaacbacccbacbbcbacccbabbbab\", target=53):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_8",
    "sat": "def sat(t: str, s: str=\"bcacaacccbcaacbbcbcabbcbbaaaabbbacabacbbaaa\", target: int=28):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcacaacccbcaacbbcbcabbcbbaaaabbbacabacbbaaa\", target=28):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_9",
    "sat": "def sat(t: str, s: str=\"ba\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ba\", target=2):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_10",
    "sat": "def sat(t: str, s: str=\"bcbacbcabaabacaacbbacbccabbaabcbbcbc\", target: int=29):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbacbcabaabacaacbbacbccabbaabcbbcbc\", target=29):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_11",
    "sat": "def sat(t: str, s: str=\"caacbbcabccacababababbbcbacbccccaabcbbcbbaccabaabccbabaaaacaacbbccbccaaabcacbbbbbacacacacbbacbbacbccbcabcbaacccabcbccbbcbacbbbbabcacccbccaacbaaaabbbacccbbbbabbbcabcbacbccbacbbcccbaccbbabbbaccacabbcbccaaabcabbccabcaccabcbaaccbbccaaacaccbccbbbbbbacbcccacaaacaacccacabbcababaabccacccbaaaabcabbbbaabcccbcbbcbababcbcccabcbcabacaaabbbcbababacacaababaaccabbcbbaacacbbaa\", target: int=243):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caacbbcabccacababababbbcbacbccccaabcbbcbbaccabaabccbabaaaacaacbbccbccaaabcacbbbbbacacacacbbacbbacbccbcabcbaacccabcbccbbcbacbbbbabcacccbccaacbaaaabbbacccbbbbabbbcabcbacbccbacbbcccbaccbbabbbaccacabbcbccaaabcabbccabcaccabcbaaccbbccaaacaccbccbbbbbbacbcccacaaacaacccacabbcababaabccacccbaaaabcabbbbaabcccbcbbcbababcbcccabcbcabacaaabbbcbababacacaababaaccabbcbbaacacbbaa\", target=243):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_12",
    "sat": "def sat(t: str, s: str=\"bcbbcccaaabbbbbaacbbcabbcabaccababacacaccbcbabbbbacabbbccabbabbbcbbaaaaaabcbccbbbbbcbacbcccacaaacabbbcacbbcbacbbbabbbbccbbabaabbbabaaaccabbcbcbababaaacaacacacaaaccaabbcaabccacccaabbcbaaacbbaaabcabbacccccaaabccacbacacbaaaabacbacbacbaacbcccaaabaabaccbcccaaacaaaaabbccbbbcacccbaacbbcbaccbabaacccaacbbbcaccbcbcacccacacbbcabbaaacabbccbacaacbbaacbccabababababbcaccacaabbaabcacbaacbcbbcacaaaabccbccaabbbaabcbbcbbccbbcacaccabacbcabbcbbaccbabacacbababcbccaabcbcabaabcbcaaabbbabaacabbbbbbcacaacabbacabccbabcbbccbcccacaabccbbccbcccbacabcbbcabbaaacbbcbcbbcbcabcbbbcaacccbccaacabccbcccacbaababbaaccbcabcbbbabbccbbbcaccabacaabbaaabccccbabcaccaababccaacaaabbaabcbacaccaaacbcbbbbbabaabbcccaabcbbacbbcaabbaccbcbbbcabaacbbcbbbbbaabaacaaabaccbccaccbaaacbbbbbcbbcccaaccabbacaccabbcccbccaacaabbaaccbcbcbcbccbaaabaabababacaccbabbbabcaac\", target: int=532):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbbcccaaabbbbbaacbbcabbcabaccababacacaccbcbabbbbacabbbccabbabbbcbbaaaaaabcbccbbbbbcbacbcccacaaacabbbcacbbcbacbbbabbbbccbbabaabbbabaaaccabbcbcbababaaacaacacacaaaccaabbcaabccacccaabbcbaaacbbaaabcabbacccccaaabccacbacacbaaaabacbacbacbaacbcccaaabaabaccbcccaaacaaaaabbccbbbcacccbaacbbcbaccbabaacccaacbbbcaccbcbcacccacacbbcabbaaacabbccbacaacbbaacbccabababababbcaccacaabbaabcacbaacbcbbcacaaaabccbccaabbbaabcbbcbbccbbcacaccabacbcabbcbbaccbabacacbababcbccaabcbcabaabcbcaaabbbabaacabbbbbbcacaacabbacabccbabcbbccbcccacaabccbbccbcccbacabcbbcabbaaacbbcbcbbcbcabcbbbcaacccbccaacabccbcccacbaababbaaccbcabcbbbabbccbbbcaccabacaabbaaabccccbabcaccaababccaacaaabbaabcbacaccaaacbcbbbbbabaabbcccaabcbbacbbcaabbaccbcbbbcabaacbbcbbbbbaabaacaaabaccbccaccbaaacbbbbbcbbcccaaccabbacaccabbcccbccaacaabbaaccbcbcbcbccbaaabaabababacaccbabbbabcaac\", target=532):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_13",
    "sat": "def sat(t: str, s: str=\"cbababc\", target: int=7):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbababc\", target=7):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_14",
    "sat": "def sat(t: str, s: str=\"abaabab\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abaabab\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_15",
    "sat": "def sat(t: str, s: str=\"ababcababcbacabbabaababaabaacaacbabacbacbbabacabbacaaaabccccbabbbabcabcaacbacbcbcbbbaaabbccbcabcacabbcbccbbabbbbccacccabacbabbaaabaaccbacaaabacaababcacbcbbacbcacabbaccccbaaabaaacaccccacabcababbacccacbaaacacbbbcabcbbaababcaacbccaabbbccbacccbbaacbcabacbcabaacabaccbaaacabcbcacabbacaaaabacbbabcaacbcabcacaaacbbccbacccbbbccababbccaaabccccccabbcbcccbabaccbbabcaabbacbcbcbaacbccabaaaabaabbcbccabacabccabacaacaaabbcbbccaccbbcaacbaabcaccccccbccccbcbaabbcaabaaccaaabaababbacabaababacbbcbbabaabaacaabaaaaabcccbcabacaaccccbacacabcbbbcbcaaacbbabbcaaacbaaacccaccccbbbbacabbcaaaaaccbbbabaccbbbaacbbcbbbccbabcccbccabbacbacbabbbaabbacbbbbaaacabcabbcccbbbaabcacaacaacccbbacaaabcbaacaaaccaaabcabbcccabbbcaccaaabbbcacbabbaccbcbbabccbcbbbbaccbbacabbccaacaacacaaaabaccccbacabbaacbcaaaacbbaaacccccbaabbabccabbbabcbcbaaacbabbbbaacbaaccbccabaabcbbaabacbbcbcbaabbbcaabcacaccabc\", target: int=565):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ababcababcbacabbabaababaabaacaacbabacbacbbabacabbacaaaabccccbabbbabcabcaacbacbcbcbbbaaabbccbcabcacabbcbccbbabbbbccacccabacbabbaaabaaccbacaaabacaababcacbcbbacbcacabbaccccbaaabaaacaccccacabcababbacccacbaaacacbbbcabcbbaababcaacbccaabbbccbacccbbaacbcabacbcabaacabaccbaaacabcbcacabbacaaaabacbbabcaacbcabcacaaacbbccbacccbbbccababbccaaabccccccabbcbcccbabaccbbabcaabbacbcbcbaacbccabaaaabaabbcbccabacabccabacaacaaabbcbbccaccbbcaacbaabcaccccccbccccbcbaabbcaabaaccaaabaababbacabaababacbbcbbabaabaacaabaaaaabcccbcabacaaccccbacacabcbbbcbcaaacbbabbcaaacbaaacccaccccbbbbacabbcaaaaaccbbbabaccbbbaacbbcbbbccbabcccbccabbacbacbabbbaabbacbbbbaaacabcabbcccbbbaabcacaacaacccbbacaaabcbaacaaaccaaabcabbcccabbbcaccaaabbbcacbabbaccbcbbabccbcbbbbaccbbacabbccaacaacacaaaabaccccbacabbaacbcaaaacbbaaacccccbaabbabccabbbabcbcbaaacbabbbbaacbaaccbccabaabcbbaabacbbcbcbaabbbcaabcacaccabc\", target=565):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_16",
    "sat": "def sat(t: str, s: str=\"bcbbcb\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbbcb\", target=5):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_17",
    "sat": "def sat(t: str, s: str=\"aba\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aba\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_18",
    "sat": "def sat(t: str, s: str=\"cacab\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cacab\", target=5):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_19",
    "sat": "def sat(t: str, s: str=\"bbaccbcacbaaaababccbbbcacabbaccbbbaccacbbccbabbcaccacbbbbccaccbbaabbabcaaccccba\", target: int=50):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbaccbcacbaaaababccbbbcacabbaccbbbaccacbbccbabbcaccacbbbbccaccbbaabbabcaaccccba\", target=50):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_20",
    "sat": "def sat(t: str, s: str=\"abacabbab\", target: int=8):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abacabbab\", target=8):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_21",
    "sat": "def sat(t: str, s: str=\"cccabbbcbaaaacacabcabbcbbbabbaaacbcaacbbcabcaaaaaaaabaaaacaaabcabcbabbcaabcbacaabacabaaccbbaabbcabcbbaacbccbaaabccbccacacbbaabcaaababaacaccaacbbcaabaaaccbbbaccaaccbbccabcbaaabcaaaacaccacbababbaaababacbcababbbbabcccacaaabcabbaabcaacbbbbcacbccccbaabbacabacaabbcaaabaccbcbbccbcabababbabbaccbbaaccbbaaccbcaccabcbbbacbbbbabbacbcaabcaabbccccacaababcacbcbbaccccabbabbbcbccacabbcabababaaacbabccbcaaaaccccccccbbbacababaacbcbcccbbcabcbbaabcbacabaaacabaccaabbabbcacbacaababbcbcbbcaccbcaacbbccbabbcabaabcaaaacabcaccaabbacacabccabcacbbbaabbaaaabbabbcbbaccccbcbbaaccacacbcaacbbcaacccbabaccccacbcbccbacacbcabbabbbcbacacbbaabaabbbcbabccabcbacbcacbbbaaacacacaabaaabcbaababbbbaccacccaccbabababaaaaabacbaccbabcbcaaccaabcbbccccaccbbcacababcabaabbabcccabaccbbcaaccbcacbacbbaabbbbcccccbbaabccacabbcccbcbabacbaabbbcbcccbacccccacacccccbcacbbcabcccbacccabcbccaabbcaabbcaacccbcaccccca\", target: int=572):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccabbbcbaaaacacabcabbcbbbabbaaacbcaacbbcabcaaaaaaaabaaaacaaabcabcbabbcaabcbacaabacabaaccbbaabbcabcbbaacbccbaaabccbccacacbbaabcaaababaacaccaacbbcaabaaaccbbbaccaaccbbccabcbaaabcaaaacaccacbababbaaababacbcababbbbabcccacaaabcabbaabcaacbbbbcacbccccbaabbacabacaabbcaaabaccbcbbccbcabababbabbaccbbaaccbbaaccbcaccabcbbbacbbbbabbacbcaabcaabbccccacaababcacbcbbaccccabbabbbcbccacabbcabababaaacbabccbcaaaaccccccccbbbacababaacbcbcccbbcabcbbaabcbacabaaacabaccaabbabbcacbacaababbcbcbbcaccbcaacbbccbabbcabaabcaaaacabcaccaabbacacabccabcacbbbaabbaaaabbabbcbbaccccbcbbaaccacacbcaacbbcaacccbabaccccacbcbccbacacbcabbabbbcbacacbbaabaabbbcbabccabcbacbcacbbbaaacacacaabaaabcbaababbbbaccacccaccbabababaaaaabacbaccbabcbcaaccaabcbbccccaccbbcacababcabaabbabcccabaccbbcaaccbcacbacbbaabbbbcccccbbaabccacabbcccbcbabacbaabbbcbcccbacccccacacccccbcacbbcabcccbacccabcbccaabbcaabbcaacccbcaccccca\", target=572):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_22",
    "sat": "def sat(t: str, s: str=\"abbac\", target: int=4):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbac\", target=4):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_23",
    "sat": "def sat(t: str, s: str=\"cbaabbcaabaabacbbbbabcacaabcaaaabcabcbbabbacbbcacccaccbbccbbabaabacababcaccabbabaacbbaaacacbcacaccaacbbcabcbabbccabcbcbabbbaacbacbbcbcbaabacbaccccbbcbaaacaccbbbbcbcabacabcbbbacccacaccccccbaabcaaababcbbcbabbcacbacaacbbccbcacbbabbbabacaccbbcbbcccaccbbbcaccbccaaaacababccaabbaaaabcbacacaacaababbbabbbabaacaacbcbabcaabbcccbabcbbbcbacbcaabcaaccaabbcbcbbbacccaacacaacaaaacbcacabcbcbabbcbbcacbacabacabaaacbbabcacbccabaccaabacabcaacbbbbcaaaabbacccacacbaaaaabbcaaabbcabacaaabcbabacbabcbcbbabbcbabcbcaccabcabcbccccbaccacacbcccaababaaaaabbbcabaacababcbacbccacbcccbabacbaaabacbbabaacccaaabbccabbbbbbaaabcbcaabccacbccbabcacacbbbaaccacacbacacbaaaaabbbbcbccbccbbcabccacccccbccacabbbbcbbbacaacbcaabcbbbccacbbaccabacaabacacaccacbbcbbcbcbcbcccccccaacccbaaabcbcbacaaacbccbabcbbbcacbccbbcbbbcbbacccbbcacbcaaccbaaccccababbbbabacbbaacaacabcaaacbacacacaabbcbaaabbccbabacbacbbcbccbaaacbccacbacabaabcbcbcbcaaacaabbaacbbccabccaabaaccabbbcacaabcacbcaabcacababbcabcccccbbaacabaaccaccaacc\", target: int=664):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbaabbcaabaabacbbbbabcacaabcaaaabcabcbbabbacbbcacccaccbbccbbabaabacababcaccabbabaacbbaaacacbcacaccaacbbcabcbabbccabcbcbabbbaacbacbbcbcbaabacbaccccbbcbaaacaccbbbbcbcabacabcbbbacccacaccccccbaabcaaababcbbcbabbcacbacaacbbccbcacbbabbbabacaccbbcbbcccaccbbbcaccbccaaaacababccaabbaaaabcbacacaacaababbbabbbabaacaacbcbabcaabbcccbabcbbbcbacbcaabcaaccaabbcbcbbbacccaacacaacaaaacbcacabcbcbabbcbbcacbacabacabaaacbbabcacbccabaccaabacabcaacbbbbcaaaabbacccacacbaaaaabbcaaabbcabacaaabcbabacbabcbcbbabbcbabcbcaccabcabcbccccbaccacacbcccaababaaaaabbbcabaacababcbacbccacbcccbabacbaaabacbbabaacccaaabbccabbbbbbaaabcbcaabccacbccbabcacacbbbaaccacacbacacbaaaaabbbbcbccbccbbcabccacccccbccacabbbbcbbbacaacbcaabcbbbccacbbaccabacaabacacaccacbbcbbcbcbcbcccccccaacccbaaabcbcbacaaacbccbabcbbbcacbccbbcbbbcbbacccbbcacbcaaccbaaccccababbbbabacbbaacaacabcaaacbacacacaabbcbaaabbccbabacbacbbcbccbaaacbccacbacabaabcbcbcbcaaacaabbaacbbccabccaabaaccabbbcacaabcacbcaabcacababbcabcccccbbaacabaaccaccaacc\", target=664):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_24",
    "sat": "def sat(t: str, s: str=\"bcaaabaacacababcaaaacbbbccbacabbbccbbaccbacbacbcbbcbabaaaabcabacacc\", target: int=48):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcaaabaacacababcaaaacbbbccbacabbbccbbaccbacbacbcbbcbabaaaabcabacacc\", target=48):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_25",
    "sat": "def sat(t: str, s: str=\"bacca\", target: int=4):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bacca\", target=4):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_26",
    "sat": "def sat(t: str, s: str=\"acbbabc\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acbbabc\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_27",
    "sat": "def sat(t: str, s: str=\"a\", target: int=1):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"a\", target=1):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_28",
    "sat": "def sat(t: str, s: str=\"aabcacb\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aabcacb\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_29",
    "sat": "def sat(t: str, s: str=\"bbbacccccacacbcbbbabbbcbbccbcccaabcccabcacbcbbbbabccacaabbbaccaacaabbbabbbabaaacccabccabaabbababccbcabbccaacabacccabbbcabccaccbcbcababaccbaacabccbbbcabcaaccabbcbcbbacbaabbccacacccaabacabccaacaaaaaccabbbaaaacccbcbcaacaacabcaabcacbbccbaacabcbabcaaccccaabaabbaccbcbabccabbbcabccbaccbaaacaaccccacbbacbabbbaacaccbaaacacccbabbbcbabccaaaaaababbbcbbacabaaccbaabcabbaccaabaacacbcabcacbcccaaaacacabbccbccbcccbccabbababcbabcbaababbabaccbcaaacacabcbaabccbaacababacbacbacaaaabacbccacbcacbcacabacccabaaabababcbccbabaaabbbabcacbaacbaccccbbcccaaaccaaacccbabaaaccbacbacabbccabaaaaabcbcabaabaccacccbcbcbbcbbabcabccccbaababbaabbaaaaacccaaacababacacaaaccccbbcccccbaacbaaaaaaaaccaccbcbbbaccaaaaccaacbacacaa\", target: int=450):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbacccccacacbcbbbabbbcbbccbcccaabcccabcacbcbbbbabccacaabbbaccaacaabbbabbbabaaacccabccabaabbababccbcabbccaacabacccabbbcabccaccbcbcababaccbaacabccbbbcabcaaccabbcbcbbacbaabbccacacccaabacabccaacaaaaaccabbbaaaacccbcbcaacaacabcaabcacbbccbaacabcbabcaaccccaabaabbaccbcbabccabbbcabccbaccbaaacaaccccacbbacbabbbaacaccbaaacacccbabbbcbabccaaaaaababbbcbbacabaaccbaabcabbaccaabaacacbcabcacbcccaaaacacabbccbccbcccbccabbababcbabcbaababbabaccbcaaacacabcbaabccbaacababacbacbacaaaabacbccacbcacbcacabacccabaaabababcbccbabaaabbbabcacbaacbaccccbbcccaaaccaaacccbabaaaccbacbacabbccabaaaaabcbcabaabaccacccbcbcbbcbbabcabccccbaababbaabbaaaaacccaaacababacacaaaccccbbcccccbaacbaaaaaaaaccaccbcbbbaccaaaaccaacbacacaa\", target=450):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_30",
    "sat": "def sat(t: str, s: str=\"ccbaacaacbbbacbaaccbccccacbbcbbcbbacaaacacacccbccbbbbacaaacbaaabcbbcbcbbcbbabbabaaabaccbbbaaaaaaabccbccbabbabaababbbaccbaacbabccbbaccbcacababaababaaacaacaccbbcaabcaacacccabacaaaaaccbccbccacbcbbabcbacbbccbcacbaacbacbbbccbacaacbaaaabbbbacaccaccaaaaaccaccabcbaccbcaabcabbccbabacbbbbacbbabbcbcbaccbcaaaacbabbcbbbcccbaaccbbacbbbaccaaacacabbcccbbbccaaabacabaababaaacaaaacbcbaabcabbacbbacacabaccbabaccabbabbababcbacbbcbcbacababcbbaccbccabbbccbcbbabaabbcabcbcbabaaacbcbccccaaaaccaaccbcbcbbbbccababcaa\", target: int=329):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccbaacaacbbbacbaaccbccccacbbcbbcbbacaaacacacccbccbbbbacaaacbaaabcbbcbcbbcbbabbabaaabaccbbbaaaaaaabccbccbabbabaababbbaccbaacbabccbbaccbcacababaababaaacaacaccbbcaabcaacacccabacaaaaaccbccbccacbcbbabcbacbbccbcacbaacbacbbbccbacaacbaaaabbbbacaccaccaaaaaccaccabcbaccbcaabcabbccbabacbbbbacbbabbcbcbaccbcaaaacbabbcbbbcccbaaccbbacbbbaccaaacacabbcccbbbccaaabacabaababaaacaaaacbcbaabcabbacbbacacabaccbabaccabbabbababcbacbbcbcbacababcbbaccbccabbbccbcbbabaabbcabcbcbabaaacbcbccccaaaaccaaccbcbcbbbbccababcaa\", target=329):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_31",
    "sat": "def sat(t: str, s: str=\"aac\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aac\", target=2):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_32",
    "sat": "def sat(t: str, s: str=\"abaccbcccaabaacccaacccca\", target: int=13):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abaccbcccaabaacccaacccca\", target=13):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_33",
    "sat": "def sat(t: str, s: str=\"acacbabcacabaaabbbacc\", target: int=16):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acacbabcacabaaabbbacc\", target=16):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_34",
    "sat": "def sat(t: str, s: str=\"abbabaacabcccccabcacacaaabbabcaccbbbbbccaabcbcbbabaccaacbcabacccbbaacbccacccabccacababbbcaaaccbcbbbacbbacbaaaaaaaaaacacaabaacccacaabbabbccbccbbcabcabccbabcbaacbcacacbabbcabbaaabaaaccbaaaccbbbcbbbaaccabacbacbccabbaabbcbacabcaccaacacaabccaabbaccbbcabcccabccbbcccbbacbcbbcbabbcbccbabbababcabbabbbacbcbcbcccaacbcbaccabaabcccccacabcbaccccacacaaaacabaabcacbabbccaaaacbccccababcbcbaabacbcbcbcabbbbbaabaaccbbbbaccccabbcbcbaccabcbcbacbcaabacbbbcbbccccabacabbacabccaaacaacbccbaaaabaaccbbbbcbcacaaabcbcaccabacbbaacacabcaaaababbacbcbbabcbbbaabbabccccbbcbcacaaccbcbbcaaaacaacbcacababaa\", target: int=387):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbabaacabcccccabcacacaaabbabcaccbbbbbccaabcbcbbabaccaacbcabacccbbaacbccacccabccacababbbcaaaccbcbbbacbbacbaaaaaaaaaacacaabaacccacaabbabbccbccbbcabcabccbabcbaacbcacacbabbcabbaaabaaaccbaaaccbbbcbbbaaccabacbacbccabbaabbcbacabcaccaacacaabccaabbaccbbcabcccabccbbcccbbacbcbbcbabbcbccbabbababcabbabbbacbcbcbcccaacbcbaccabaabcccccacabcbaccccacacaaaacabaabcacbabbccaaaacbccccababcbcbaabacbcbcbcabbbbbaabaaccbbbbaccccabbcbcbaccabcbcbacbcaabacbbbcbbccccabacabbacabccaaacaacbccbaaaabaaccbbbbcbcacaaabcbcaccabacbbaacacabcaaaababbacbcbbabcbbbaabbabccccbbcbcacaaccbcbbcaaaacaacbcacababaa\", target=387):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_35",
    "sat": "def sat(t: str, s: str=\"baabacccacbbaacba\", target: int=12):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"baabacccacbbaacba\", target=12):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_36",
    "sat": "def sat(t: str, s: str=\"acacbabbacabbbbbcccbcbaaacbbbacbbccbabbbacaaaaaabcccacbbcaabbabcaaaaacabacbaccaabbbcccabcbbccbbcbcacbbccccbbcbbbbabbbaccbbababbbbcaccbabbabcaacabbcbcacabcbbbacabccbbabccbacabccbcabacacbbaaabbab\", target: int=126):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acacbabbacabbbbbcccbcbaaacbbbacbbccbabbbacaaaaaabcccacbbcaabbabcaaaaacabacbaccaabbbcccabcbbccbbcbcacbbccccbbcbbbbabbbaccbbababbbbcaccbabbabcaacabbcbcacabcbbbacabccbbabccbacabccbcabacacbbaaabbab\", target=126):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_37",
    "sat": "def sat(t: str, s: str=\"caababaaacaacaababbcaaccccbcaaacabbcacbbacbcbababccaabcbcbabbbaccbcbcbaaabcccabbababbbcaaacaaababbbbbacbcbcccbabaaacacccaaccbabcabbcacccaabbcbbcaacaacbaccaacacbabaabbbccacbccacaabcaacabbbaacabbabcbccbccaaccabccacabaabbbbcccccbbbcaccbbbabbabbcbccbcbcaccbbccacaacabbabccbccbbaccaabababbaabcacacbbcccabbbbabbbabbcabbcbababbacbbbaaccbaabcbcabaccaabcbb\", target: int=232):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caababaaacaacaababbcaaccccbcaaacabbcacbbacbcbababccaabcbcbabbbaccbcbcbaaabcccabbababbbcaaacaaababbbbbacbcbcccbabaaacacccaaccbabcabbcacccaabbcbbcaacaacbaccaacacbabaabbbccacbccacaabcaacabbbaacabbabcbccbccaaccabccacabaabbbbcccccbbbcaccbbbabbabbcbccbcbcaccbbccacaacabbabccbccbbaccaabababbaabcacacbbcccabbbbabbbabbcabbcbababbacbbbaaccbaabcbcabaccaabcbb\", target=232):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_38",
    "sat": "def sat(t: str, s: str=\"cccbbcbcbcbcbcabcbcccabacbccabaaacbcaccccaba\", target: int=33):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccbbcbcbcbcbcabcbcccabacbccabaaacbcaccccaba\", target=33):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_39",
    "sat": "def sat(t: str, s: str=\"aabcabaaccbbacbcaccbaaaaaacaabcbcbbabcbaaaaacccaabbbbcbcbbcbcbcccabccaccaacacaccccacabcc\", target: int=56):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aabcabaaccbbacbcaccbaaaaaacaabcbcbbabcbaaaaacccaabbbbcbcbbcbcbcccabccaccaacacaccccacabcc\", target=56):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_40",
    "sat": "def sat(t: str, s: str=\"ccaabbccacaacccbcaccbccccbaaababcbacbbbbaabbbbbaccbbbaabaaacbaaccbcbaaacabacbbcccabababcaccbabaacccaaabaaaaccabbacacbccaabccccacbbaaaaabbbaaaaccbaacbcbbbaaaaabbbaaabcbccbbabcabaccbcacaacbcbbacabbacacababbcaacbaccaabbccbbbbacbaaccacbabbbbaacbcacbacbcbbccabbbaaaababcccababacaaaaabbbccaacacbbbcacabcbbcbcaacccacccbaaabbcbabbcaaaabbbbaabcbacbaacaabbcccbbacaccacbbaaccacaccaccbaaaacccabccbaacaccbcbcaababcaacacbbbbbacbcaabaacaccbbcbcababcbabbccbcaaccacaabbcacbbbbaacbaaababbaabcacbbabbbabaaacaacbaacacccbabccaababbcbbaabaacbaacababbcaaaabccbccaaaaaacacaaabcaababaaccbacaaccabccbcacbbbbacbacbabbccbbbbabbacabcaccabbccabcabbcbacacabababaaccccccaabcabcaabaaaaacccbcbbabbabcabaccaabcbbbbccbacbcacabbbaccbcccabaabbaaabcababbacbbbaaaccacbbbccacabbabccbbbacbcbc\", target: int=485):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccaabbccacaacccbcaccbccccbaaababcbacbbbbaabbbbbaccbbbaabaaacbaaccbcbaaacabacbbcccabababcaccbabaacccaaabaaaaccabbacacbccaabccccacbbaaaaabbbaaaaccbaacbcbbbaaaaabbbaaabcbccbbabcabaccbcacaacbcbbacabbacacababbcaacbaccaabbccbbbbacbaaccacbabbbbaacbcacbacbcbbccabbbaaaababcccababacaaaaabbbccaacacbbbcacabcbbcbcaacccacccbaaabbcbabbcaaaabbbbaabcbacbaacaabbcccbbacaccacbbaaccacaccaccbaaaacccabccbaacaccbcbcaababcaacacbbbbbacbcaabaacaccbbcbcababcbabbccbcaaccacaabbcacbbbbaacbaaababbaabcacbbabbbabaaacaacbaacacccbabccaababbcbbaabaacbaacababbcaaaabccbccaaaaaacacaaabcaababaaccbacaaccabccbcacbbbbacbacbabbccbbbbabbacabcaccabbccabcabbcbacacabababaaccccccaabcabcaabaaaaacccbcbbabbabcabaccaabcbbbbccbacbcacabbbaccbcccabaabbaaabcababbacbbbaaaccacbbbccacabbabccbbbacbcbc\", target=485):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_41",
    "sat": "def sat(t: str, s: str=\"bccb\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bccb\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_42",
    "sat": "def sat(t: str, s: str=\"abacabbcabbbcaccccbaccbccabccbcbbcaccaaabbbacabbabbbcabbacacbccbcabbccaabbcbcbabaacaabbabcbaaabcaacacaccbbbcbbbccbacabcbabaabcbcaccabccbbccbcbccacacbabcaabcbabbababbabacaaaacabcbbaabcbbacbccaabaabaabcbaccbacbbccacabbbcccbc\", target: int=160):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abacabbcabbbcaccccbaccbccabccbcbbcaccaaabbbacabbabbbcabbacacbccbcabbccaabbcbcbabaacaabbabcbaaabcaacacaccbbbcbbbccbacabcbabaabcbcaccabccbbccbcbccacacbabcaabcbabbababbabacaaaacabcbbaabcbbacbccaabaabaabcbaccbacbbccacabbbcccbc\", target=160):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_43",
    "sat": "def sat(t: str, s: str=\"ccbbcbcabbbbbcaaaccaabbabacbcbabbbbcaaabcbcaaacbccaccbccabcabbcaccaacabccaabbcbcccccaaacbbccbacccacaacbbaa\", target: int=66):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccbbcbcabbbbbcaaaccaabbabacbcbabbbbcaaabcbcaaacbccaccbccabcabbcaccaacabccaabbcbcccccaaacbbccbacccacaacbbaa\", target=66):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_44",
    "sat": "def sat(t: str, s: str=\"aacbcbacbcacacbbbbcacccbcccbcbcbcccacbcacbabbaccabcbaacabacaccbabaccbbaaaabcbabacaaacbaabacbccbabacbbcaabbbbaabcacbaaacccbccaccaacacaccbbcbccabaccaabaaabacabcacaccaccbcbbb\", target: int=124):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aacbcbacbcacacbbbbcacccbcccbcbcbcccacbcacbabbaccabcbaacabacaccbabaccbbaaaabcbabacaaacbaabacbccbabacbbcaabbbbaabcacbaaacccbccaccaacacaccbbcbccabaccaabaaabacabcacaccaccbcbbb\", target=124):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_45",
    "sat": "def sat(t: str, s: str=\"cbcccbabc\", target: int=7):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcccbabc\", target=7):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_46",
    "sat": "def sat(t: str, s: str=\"cbbbcbaccbaaaccbaaccacbcaaaaacbcbacccabbbc\", target: int=26):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbbcbaccbaaaccbaaccacbcaaaaacbcbacccabbbc\", target=26):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_47",
    "sat": "def sat(t: str, s: str=\"bbaccbacbcaccccbcbacbcbcbabcbcbcbacabaaabbaaacbaa\", target: int=38):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbaccbacbcaccccbcbacbcbcbabcbcbcbacabaaabbaaacbaa\", target=38):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_48",
    "sat": "def sat(t: str, s: str=\"ccbccabbaacacacbccbbbabbccacccbbccbbaabaababbaabaaacbabccccbaccbbbcacccabcbbcaccbacaacabacabcbbcaacbbcbccccccacbacaabbbabaabcabaacbbacacabbcbacababacbbbbcabbcbcbacbbcaacacacabbabbbccacaccbbcbcaabbcabcbcabccccbaacccbacabcaaacacbaabcccacbbcbaaabaabbacaccccaacbbbcacbabbabaabcbcabbbacbabcaacbabaacabcaaccbaacabbaabaacccbbbcccacacbabbcabbaaaaabbaaccbbacbcbbccacbabbabccbacacbaabbaccaacabcaacbbababbaccaabbbbacabaccbabbccbbccabacacbaaabacbaccbcabcabccbccccbacbbaabaaabcbaccccaacabaacccbabcbbaabacbabbaaccacaccabcbbbcccbcaabcabaabaccabbcccacacbcbabbbaaabaabbbcababacbbabaaabcaccbbcbbcbacacccabaaccbcbbaacccabaababcabcabaacbaabbaabaacaabbbccaacbbaabaaacbcccaacacacabaacbaaaabbbabbcaacabcbcccccccbacabbababbaacbbbaacabbcababbacbacbcccacaabcbccbabacacbccaaccbbacacaacbaccabcaaacaccbbcacabcacaaacbaaaaabbbaaacaacababacaccaababacaacabbabbacbcabbaabcaaaaaacbbbbaacccccaacbcabcaaaacbbaaaabaabaabacbaccbbcabaacbbacabbaabcaaabbcbcbaaaaccacccbcaccbbcc\", target: int=636):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccbccabbaacacacbccbbbabbccacccbbccbbaabaababbaabaaacbabccccbaccbbbcacccabcbbcaccbacaacabacabcbbcaacbbcbccccccacbacaabbbabaabcabaacbbacacabbcbacababacbbbbcabbcbcbacbbcaacacacabbabbbccacaccbbcbcaabbcabcbcabccccbaacccbacabcaaacacbaabcccacbbcbaaabaabbacaccccaacbbbcacbabbabaabcbcabbbacbabcaacbabaacabcaaccbaacabbaabaacccbbbcccacacbabbcabbaaaaabbaaccbbacbcbbccacbabbabccbacacbaabbaccaacabcaacbbababbaccaabbbbacabaccbabbccbbccabacacbaaabacbaccbcabcabccbccccbacbbaabaaabcbaccccaacabaacccbabcbbaabacbabbaaccacaccabcbbbcccbcaabcabaabaccabbcccacacbcbabbbaaabaabbbcababacbbabaaabcaccbbcbbcbacacccabaaccbcbbaacccabaababcabcabaacbaabbaabaacaabbbccaacbbaabaaacbcccaacacacabaacbaaaabbbabbcaacabcbcccccccbacabbababbaacbbbaacabbcababbacbacbcccacaabcbccbabacacbccaaccbbacacaacbaccabcaaacaccbbcacabcacaaacbaaaaabbbaaacaacababacaccaababacaacabbabbacbcabbaabcaaaaaacbbbbaacccccaacbcabcaaaacbbaaaabaabaabacbaccbbcabaacbbacabbaabcaaabbcbcbaaaaccacccbcaccbbcc\", target=636):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_49",
    "sat": "def sat(t: str, s: str=\"bcbabcabbbcbbbaaaccbcbcacabacbbcbbcaacacaacbccaacacaaaccbaacbbbaacaacacccabcabbcabbbabcacbbcacaacaabbacabccbbbbcccacabaaababababcbccaabcabbabcbabbbacaaabcacbccabcaacbbbbcaccbaabacacaabaaabacccaacbcbbcaccbabbbbcabccabbaacaaaaaabbaabcbbbcabacbbbbabbcbabbcacbcabaccbaacacbbacbbabcbaacbabbacbaacab\", target: int=206):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbabcabbbcbbbaaaccbcbcacabacbbcbbcaacacaacbccaacacaaaccbaacbbbaacaacacccabcabbcabbbabcacbbcacaacaabbacabccbbbbcccacabaaababababcbccaabcabbabcbabbbacaaabcacbccabcaacbbbbcaccbaabacacaabaaabacccaacbcbbcaccbabbbbcabccabbaacaaaaaabbaabcbbbcabacbbbbabbcbabbcacbcabaccbaacacbbacbbabcbaacbabbacbaacab\", target=206):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_50",
    "sat": "def sat(t: str, s: str=\"abbccacbcccbccccbbccabcabacaaabbabb\", target: int=22):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbccacbcccbccccbbccabcabacaaabbabb\", target=22):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_51",
    "sat": "def sat(t: str, s: str=\"abcabcbababcccbaabbcaccacbacbccbabacbbc\", target: int=32):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abcabcbababcccbaabbcaccacbacbccbabacbbc\", target=32):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_52",
    "sat": "def sat(t: str, s: str=\"\", target: int=0):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"\", target=0):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_53",
    "sat": "def sat(t: str, s: str=\"cccbbbaababacbbccabcaccbb\", target: int=16):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccbbbaababacbbccabcaccbb\", target=16):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_54",
    "sat": "def sat(t: str, s: str=\"cbcbbbaabbbbaaaccccbccbccbcbbabaaccbaaaabcaccacaaaabaabbcbacbbbcbcbbbbacccaacccbaacbbbbbbabcb\", target: int=52):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcbbbaabbbbaaaccccbccbccbcbbabaaccbaaaabcaccacaaaabaabbcbacbbbcbcbbbbacccaacccbaacbbbbbbabcb\", target=52):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_55",
    "sat": "def sat(t: str, s: str=\"babaaacb\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babaaacb\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_56",
    "sat": "def sat(t: str, s: str=\"acccbbcbccaabcbcccaacaccccbaaaabcaabcacacbcbcaccaabaccacbacccacbcc\", target: int=45):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acccbbcbccaabcbcccaacaccccbaaaabcaabcacacbcbcaccaabaccacbacccacbcc\", target=45):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_57",
    "sat": "def sat(t: str, s: str=\"caaaccacabbbabbacccabbbcacabbbabccccbabaaccba\", target: int=28):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caaaccacabbbabbacccabbbcacabbbabccccbabaaccba\", target=28):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_58",
    "sat": "def sat(t: str, s: str=\"abccbacbbccccabbbccbaccacbcca\", target: int=19):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abccbacbbccccabbbccbaccacbcca\", target=19):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_59",
    "sat": "def sat(t: str, s: str=\"bbbcaabba\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbcaabba\", target=5):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_60",
    "sat": "def sat(t: str, s: str=\"caccaaacacccaabcabcaabbccbcbcbabaabbcbacaababcbccbabacababcbaaaabbacacabbcbbbbccbbbcabacbaaacabccacacaacabbacacabaabcbccbcbbcacaaaaaabcbabaacccbccacaabaacaabaabbaaabbbbcacacbbccaaccaaacbbcbcabcaaabcbccabbcbcabbbaaaaabacbcbbbccbcbcbcbccbbcbaabcababaccabccbcacabacaabaaabacaabbcabbccbabaccbbcbcbbcabbabcbacbababaccbbccbbcccbabbcbaccbbbacccbccbccbbbbbccbacbbaabcabbcbabbbccccbccacabababcbaababbccbbaccbbccacbbcbcabacbbaababbccbccbabcabcaabbabcaaabbbabbcccbbccccccbcbcaacacacacbaaaaccaabaccaaacbcbaaabbccbcabccbaaccacacbacccabcbbabbabcbccabbaabaacbbccbabccaaaccaaacab\", target: int=388):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caccaaacacccaabcabcaabbccbcbcbabaabbcbacaababcbccbabacababcbaaaabbacacabbcbbbbccbbbcabacbaaacabccacacaacabbacacabaabcbccbcbbcacaaaaaabcbabaacccbccacaabaacaabaabbaaabbbbcacacbbccaaccaaacbbcbcabcaaabcbccabbcbcabbbaaaaabacbcbbbccbcbcbcbccbbcbaabcababaccabccbcacabacaabaaabacaabbcabbccbabaccbbcbcbbcabbabcbacbababaccbbccbbcccbabbcbaccbbbacccbccbccbbbbbccbacbbaabcabbcbabbbccccbccacabababcbaababbccbbaccbbccacbbcbcabacbbaababbccbccbabcabcaabbabcaaabbbabbcccbbccccccbcbcaacacacacbaaaaccaabaccaaacbcbaaabbccbcabccbaaccacacbacccabcbbabbabcbccabbaabaacbbccbabccaaaccaaacab\", target=388):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_61",
    "sat": "def sat(t: str, s: str=\"caaab\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caaab\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_62",
    "sat": "def sat(t: str, s: str=\"abcbaaac\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abcbaaac\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_63",
    "sat": "def sat(t: str, s: str=\"bbcabbaabbabaccbcbccbcbbbaaaccbcbaaacaacacacccbccaaaccabbaccacccabbcaabbccbaacacababaaabcabccabcbcccbbaabbbaacbaacbacaabcabcbcaacbcababbbbabccaacacaaabaaaabaccbbbbbcbcbcababbaabcacaacbaccaccbcbbbbccbcabbbaacacbaaccccbabaacbbabcaaaababccaacbcccccacccbcbcaabacbcabccccaabcaaacbccaaacaaacbbccbcacbbbaacbccbaacccbccbaabbbcbcbcacacabccbbabcbccccabaaacbbbaabacbacaccbbcbccaaccabccbbacacaacbccbccaacccabbbabbcbabaccaabcbacbcbcbaaccbaaabbacabbcbbcbcaccccbacacbcbcbbbbccbbbbacbbcaacbacbcacbabacaaacaabbabbcabbbaaccabcaaacccbbbababcabaacbaccabacacbaaccbbccabacbccbbcbaaabacaccbacaabbbcabacabbcabbaabcaacbccbbabbcbbacacabcbbcbbacbbaacabba\", target: int=427):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbcabbaabbabaccbcbccbcbbbaaaccbcbaaacaacacacccbccaaaccabbaccacccabbcaabbccbaacacababaaabcabccabcbcccbbaabbbaacbaacbacaabcabcbcaacbcababbbbabccaacacaaabaaaabaccbbbbbcbcbcababbaabcacaacbaccaccbcbbbbccbcabbbaacacbaaccccbabaacbbabcaaaababccaacbcccccacccbcbcaabacbcabccccaabcaaacbccaaacaaacbbccbcacbbbaacbccbaacccbccbaabbbcbcbcacacabccbbabcbccccabaaacbbbaabacbacaccbbcbccaaccabccbbacacaacbccbccaacccabbbabbcbabaccaabcbacbcbcbaaccbaaabbacabbcbbcbcaccccbacacbcbcbbbbccbbbbacbbcaacbacbcacbabacaaacaabbabbcabbbaaccabcaaacccbbbababcabaacbaccabacacbaaccbbccabacbccbbcbaaabacaccbacaabbbcabacabbcabbaabcaacbccbbabbcbbacacabcbbcbbacbbaacabba\", target=427):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_64",
    "sat": "def sat(t: str, s: str=\"aacbcabbccbcbbcacabccccacabbbaaacacaabbaabcbccacbacaccccbcaabcbaabaabbaccbcacabacabaabcabcbaccbcbbbbbccabbabbbcaaabbbbaaabacababcaccacbcbcbcbacbbccabcaccaacccaabbcbacacaacacabbbababbabacccabcbbbacbbabbcaababbcbbacbacbbbbccccbcbbaacaccaaccababccabcbcbaabbaaabcbaaccaaaabacccbbababcabcabaccccccacacccaabbaaaccbaaccbacabbacaacbbaabbbbbaaaaaccabbaacbcbcccbbbbcabaabccabcabccbccaacacbbaaaaacaccbccbbcaccaaaabcbccaaabcabccaaaaababaccabaaabbcc\", target: int=286):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aacbcabbccbcbbcacabccccacabbbaaacacaabbaabcbccacbacaccccbcaabcbaabaabbaccbcacabacabaabcabcbaccbcbbbbbccabbabbbcaaabbbbaaabacababcaccacbcbcbcbacbbccabcaccaacccaabbcbacacaacacabbbababbabacccabcbbbacbbabbcaababbcbbacbacbbbbccccbcbbaacaccaaccababccabcbcbaabbaaabcbaaccaaaabacccbbababcabcabaccccccacacccaabbaaaccbaaccbacabbacaacbbaabbbbbaaaaaccabbaacbcbcccbbbbcabaabccabcabccbccaacacbbaaaaacaccbccbbcaccaaaabcbccaaabcabccaaaaababaccabaaabbcc\", target=286):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_65",
    "sat": "def sat(t: str, s: str=\"bbbbacbcccbacbaacccbbbbbabbbaaccaaacbbacaccbccaaccccccacab\", target: int=31):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbbacbcccbacbaacccbbbbbabbbaaccaaacbbacaccbccaaccccccacab\", target=31):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_66",
    "sat": "def sat(t: str, s: str=\"abacaaaabbbabaaaaccabcaacccbacccbccbbbabcabbabccabccababacaccbcabbabaacccacbcababccbaacbbccbcccbbccabbbaaaabbacaaaaccacaaabbbcbcbbbbbccaabcaaacacbaaababacababcabbbcaacbccaccaababaaccaccccabbabbaacbcccabccbaccbaaabcbacbccacabbbcbcbccabcaacaaaaabbacaaacbacbcbccacaacabcbaaaccaacbcaaaccbbaaaacbccbbcaaacabcbcbbcacaacabcbacccccccccabaaacacabbaabbcbcabbcbcacbcbbcabaaabbcabccbacbbabbaaaaccbcccbbabaaacaaaaababacbcacbbbcbacaabbcabaaabababbcabaaacacabbaacbacccabaccbabbbbccccbbacacbbcabcabccaaccccaccbcabcbbaabbbacccaccacababbbbcabbaaacaccccacbccbaccacabcabbbabbaaaccacabcbaaacbccaabbcacbaabaaccabcabbbabcccacbacaccaacacabcbaaccbaaacaaacacbaacabcbcabbabaaaabcaaccaaaabccacaacba\", target: int=444):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abacaaaabbbabaaaaccabcaacccbacccbccbbbabcabbabccabccababacaccbcabbabaacccacbcababccbaacbbccbcccbbccabbbaaaabbacaaaaccacaaabbbcbcbbbbbccaabcaaacacbaaababacababcabbbcaacbccaccaababaaccaccccabbabbaacbcccabccbaccbaaabcbacbccacabbbcbcbccabcaacaaaaabbacaaacbacbcbccacaacabcbaaaccaacbcaaaccbbaaaacbccbbcaaacabcbcbbcacaacabcbacccccccccabaaacacabbaabbcbcabbcbcacbcbbcabaaabbcabccbacbbabbaaaaccbcccbbabaaacaaaaababacbcacbbbcbacaabbcabaaabababbcabaaacacabbaacbacccabaccbabbbbccccbbacacbbcabcabccaaccccaccbcabcbbaabbbacccaccacababbbbcabbaaacaccccacbccbaccacabcabbbabbaaaccacabcbaaacbccaabbcacbaabaaccabcabbbabcccacbacaccaacacabcbaaccbaaacaaacacbaacabcbcabbabaaaabcaaccaaaabccacaacba\", target=444):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_67",
    "sat": "def sat(t: str, s: str=\"caabbbbacbaabcccaacaaabbaccbaacabcababcbaaabbcbbbabacabcbcbccacacbbccbabbcaaabcbaccbbbaccaacbbcaccbbccabbabcbbccaacbbbcaaacbbcabccbabbaacbacccbabaaabbcabcaaabccbbaabbbaaccbbbbcabbcbbbabaabcbcbcaacacbbabccacccbbacaacbaccabb\", target: int=147):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caabbbbacbaabcccaacaaabbaccbaacabcababcbaaabbcbbbabacabcbcbccacacbbccbabbcaaabcbaccbbbaccaacbbcaccbbccabbabcbbccaacbbbcaaacbbcabccbabbaacbacccbabaaabbcabcaaabccbbaabbbaaccbbbbcabbcbbbabaabcbcbcaacacbbabccacccbbacaacbaccabb\", target=147):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_68",
    "sat": "def sat(t: str, s: str=\"cbbabababccaaccabccaaaccbbaaaabcaacbbabcbbbcaa\", target: int=29):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbabababccaaccabccaaaccbbaaaabcaacbbabcbbbcaa\", target=29):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_69",
    "sat": "def sat(t: str, s: str=\"abcccbaabcaacababbaccacbbbcbbbccbacabcacacbbcbcbabbccbbacbcaccacbcacbabbbcaacaacbabcccaaaccacbaaaaabbbbcbcccbcbcaccaabcbaaaaaccabaaabacacbcabbbababbccbccabaabaaacacaccacababbcacccbaabbaabcbbbbcbcbccccaaaacacacbabacbcaacbbbcacbaaccacbbabbcbacbbbabbbbbacccaaaaccabbaacaaacaacccbccccacbaacababbabcabbacaacccbcbacbbbbbcbccacbbaabbaccbcabbccbcbacacbabbacbacbabcacbaabcbcccababccbccacbacbabcabaabcaaacbbcbbbbaccabacccbcacccaccabbcbcbccbaaabaccbcbaaaabbbccabbcbababccbaabcabcaaacbbbbbbacccabccbcbacbcaacbbaabacacaccabccabbbcbaacaacaabcbacacaabbccbbababcbccaccacbcaccbbcacacaaabcbbcbabcabccbabaaabacabaaaccaaaabccbacabbbccbbaabbabbbacabaaacbbaacacabbcacbbaaaabbbbbbacbcccbacbbbbbaccaabbbbababcaababbaabcacaccbccbcacaaacbbbbaabbbcbaaccbbaccabacbbbabbccbcbbbbcccbabccbababbbcbabcbcbbcbaabbbccabaaabacaaccaaababbbccccbabcbaabbbacaaccabbbaababca\", target: int=560):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abcccbaabcaacababbaccacbbbcbbbccbacabcacacbbcbcbabbccbbacbcaccacbcacbabbbcaacaacbabcccaaaccacbaaaaabbbbcbcccbcbcaccaabcbaaaaaccabaaabacacbcabbbababbccbccabaabaaacacaccacababbcacccbaabbaabcbbbbcbcbccccaaaacacacbabacbcaacbbbcacbaaccacbbabbcbacbbbabbbbbacccaaaaccabbaacaaacaacccbccccacbaacababbabcabbacaacccbcbacbbbbbcbccacbbaabbaccbcabbccbcbacacbabbacbacbabcacbaabcbcccababccbccacbacbabcabaabcaaacbbcbbbbaccabacccbcacccaccabbcbcbccbaaabaccbcbaaaabbbccabbcbababccbaabcabcaaacbbbbbbacccabccbcbacbcaacbbaabacacaccabccabbbcbaacaacaabcbacacaabbccbbababcbccaccacbcaccbbcacacaaabcbbcbabcabccbabaaabacabaaaccaaaabccbacabbbccbbaabbabbbacabaaacbbaacacabbcacbbaaaabbbbbbacbcccbacbbbbbaccaabbbbababcaababbaabcacaccbccbcacaaacbbbbaabbbcbaaccbbaccabacbbbabbccbcbbbbcccbabccbababbbcbabcbcbbcbaabbbccabaaabacaaccaaababbbccccbabcbaabbbacaaccabbbaababca\", target=560):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_70",
    "sat": "def sat(t: str, s: str=\"babcccccccbcacbabaccccabccaacbbbcbcbbbacbcaabbbcbbcbcabcbccbcaacbbcbabbcabcabbbacb\", target: int=57):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babcccccccbcacbabaccccabccaacbbbcbcbbbacbcaabbbcbbcbcabcbccbcaacbbcbabbcabcabbbacb\", target=57):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_71",
    "sat": "def sat(t: str, s: str=\"abccabbcbabaaccccbbbcccabcaaaacabacbcaaaabacaaacbaacbaccacbacacaacccbbcacbbabaaccabbbaaa\", target: int=57):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abccabbcbabaaccccbbbcccabcaaaacabacbcaaaabacaaacbaacbaccacbacacaacccbbcacbbabaaccabbbaaa\", target=57):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_72",
    "sat": "def sat(t: str, s: str=\"acabcca\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acabcca\", target=6):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_73",
    "sat": "def sat(t: str, s: str=\"cabccbcccacbbabcbcbcabbcbabbcccaabccaaccaccbcbccbabaabacaacabbbbbcbaabcbbbac\", target: int=53):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cabccbcccacbbabcbcbcabbcbabbcccaabccaaccaccbcbccbabaabacaacabbbbbcbaabcbbbac\", target=53):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_74",
    "sat": "def sat(t: str, s: str=\"cababbbcccacaaabbcbbabbacacbcababccabbcccbabbabcbaccabbacbbbbacbabbaaacaaabaaabbaaacacabbcbacbbcaacbbaaaaccabccacabbcbaaacabbacaacbbacbcabbccbccabbcabcccbcacbcbabbbbabccbccbcbccabcbccbbbaaabaccbcccabbcaabbaabcababcbcbbbbbaacacaacbcabacbbcabcccbbbbabbbbbcccbacaabbaabaacbcbcabababcbbbaacaaaccccbcbbaaabcccbcbbabacabbbbcababbbacababaccccababbcabbacbcaacaaaabbcaaaabcbcbbbaaaaccbbcbcaaccbcaabccacbcbaaccaaaaacb\", target: int=268):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cababbbcccacaaabbcbbabbacacbcababccabbcccbabbabcbaccabbacbbbbacbabbaaacaaabaaabbaaacacabbcbacbbcaacbbaaaaccabccacabbcbaaacabbacaacbbacbcabbccbccabbcabcccbcacbcbabbbbabccbccbcbccabcbccbbbaaabaccbcccabbcaabbaabcababcbcbbbbbaacacaacbcabacbbcabcccbbbbabbbbbcccbacaabbaabaacbcbcabababcbbbaacaaaccccbcbbaaabcccbcbbabacabbbbcababbbacababaccccababbcabbacbcaacaaaabbcaaaabcbcbbbaaaaccbbcbcaaccbcaabccacbcbaaccaaaaacb\", target=268):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_75",
    "sat": "def sat(t: str, s: str=\"babcbbaacbcabcccbaabbbccbbbabcbaaaabcacabababaacccbabccbcbaacbacbbaacaabbbbcbacacbcccbacaccbcabbbcbbccbababbbcbcbbcbbabbccacccacccccabcabcbbbccacabccccacbccbbacacbbbbbbbcbaacbcbaabcccbbbacbbaccbacbbbbcacacbababbabcbcababbcaaaccccacbbbacbaabccacbbcbcbbcabcbbcbcaaabacaabbabacbabcaaaaaaacbcabbbacbcbbcbaabcbbacabababccaaabccaabccbcccabaccbacbaaabaaaccbbabcbbabcccacbacacacccbacccccbcacaaaacaaccbabbcbcabaababaababbacacaaabaabcbbccabacbcaccaacccaababcaacbaccccbbcccbcabacaaccbababcabbbaaccbabcbbabcbcbababacbbabbaabbbaacabcbaabcaabccaccbaacccbcccbaccbcbcacabababababbbaabaaacbbcabcbbaaacbabbcacbacccaaabcbbaaaccbacabbaacbbcbcabcabaabacccaabbccbabbcbacbcaacabbbbccbbabcbcabcbbbbcaccbbcaacaaabaacabbaaccabcaccbcaaaccacabacb\", target: int=498):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babcbbaacbcabcccbaabbbccbbbabcbaaaabcacabababaacccbabccbcbaacbacbbaacaabbbbcbacacbcccbacaccbcabbbcbbccbababbbcbcbbcbbabbccacccacccccabcabcbbbccacabccccacbccbbacacbbbbbbbcbaacbcbaabcccbbbacbbaccbacbbbbcacacbababbabcbcababbcaaaccccacbbbacbaabccacbbcbcbbcabcbbcbcaaabacaabbabacbabcaaaaaaacbcabbbacbcbbcbaabcbbacabababccaaabccaabccbcccabaccbacbaaabaaaccbbabcbbabcccacbacacacccbacccccbcacaaaacaaccbabbcbcabaababaababbacacaaabaabcbbccabacbcaccaacccaababcaacbaccccbbcccbcabacaaccbababcabbbaaccbabcbbabcbcbababacbbabbaabbbaacabcbaabcaabccaccbaacccbcccbaccbcbcacabababababbbaabaaacbbcabcbbaaacbabbcacbacccaaabcbbaaaccbacabbaacbbcbcabcabaabacccaabbccbabbcbacbcaacabbbbccbbabcbcabcbbbbcaccbbcaacaaabaacabbaaccabcaccbcaaaccacabacb\", target=498):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_76",
    "sat": "def sat(t: str, s: str=\"bbbcbb\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbcbb\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_77",
    "sat": "def sat(t: str, s: str=\"cbbcbaabbabbbabcbcacaaaacaaaccbbcbbbccbaacccccbbbabbcbbbbbccaccaccabcbcaccbbbacaabacbcbacacbbaabbcaaaabcaaaacbacbcaaaccaabcbbbbaabcacccabcccacaaabbbccabbbaabbbccaacbbcbcaccccbacabbbbbcbccbbcbaabaaabaaabcccbabbbcabcaabcabcabccbaaaaaaabcaaabbbccabbccacbaccaabaabcaabbcbabaccabaabbcabbccabcbbcbacaaaacbcbacabcabaaaacabbbbccacbcbcbcbacabbbabcabacbbcbcabcbbbcaccbbcbbccbbcbcabacabccabccaacbcbbcabbbbacacbabcaaccabcaccabacacabcbaacabbacacbaabcbbcabbaabaaacbacccbacbcaccabaaacbbbbaaacabaaabbabccababaccbcbcacaacbaabbbccbbbcacabcbaacababcabcbbbbabbaaaacccabbacbcacacacaaaaabbbacaabacbbcccbabbbcbbacacaaabcbcababaacabbacbcabbccbcbccababbaabaccbbaabbacb\", target: int=434):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbcbaabbabbbabcbcacaaaacaaaccbbcbbbccbaacccccbbbabbcbbbbbccaccaccabcbcaccbbbacaabacbcbacacbbaabbcaaaabcaaaacbacbcaaaccaabcbbbbaabcacccabcccacaaabbbccabbbaabbbccaacbbcbcaccccbacabbbbbcbccbbcbaabaaabaaabcccbabbbcabcaabcabcabccbaaaaaaabcaaabbbccabbccacbaccaabaabcaabbcbabaccabaabbcabbccabcbbcbacaaaacbcbacabcabaaaacabbbbccacbcbcbcbacabbbabcabacbbcbcabcbbbcaccbbcbbccbbcbcabacabccabccaacbcbbcabbbbacacbabcaaccabcaccabacacabcbaacabbacacbaabcbbcabbaabaaacbacccbacbcaccabaaacbbbbaaacabaaabbabccababaccbcbcacaacbaabbbccbbbcacabcbaacababcabcbbbbabbaaaacccabbacbcacacacaaaaabbbacaabacbbcccbabbbcbbacacaaabcbcababaacabbacbcabbccbcbccababbaabaccbbaabbacb\", target=434):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_78",
    "sat": "def sat(t: str, s: str=\"cacccbbbbacccaaacbbaabbccbaaccbaccbcccaac\", target: int=22):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cacccbbbbacccaaacbbaabbccbaaccbaccbcccaac\", target=22):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_79",
    "sat": "def sat(t: str, s: str=\"bcbbbcbbbbaaccccabbacabababccacaacbcaacbcacccabcabcabcabbabbccccbcbbcaababccacabaacbccacccbabccbacabcbbbacacbcabacccaccbcacbbbcbcbbaacabbbbabcbbcacaccccaabaabcaccabcbcccaaabccbaabbcbbcbbaacbcaaaaaacaaccaaaaaacacccbcabbbbbbaccccaaabbcabcacaaaaccacaaababcbacbbabcaabbcaacaabccaabbacabbccababbaacaabacaccacccccabcbcabcacabbbacacababbbabacbccbbabccacabcbcaccaccbabbaaccbabbabcaaccccccbcbaaabcccabcabccbbabbccbbccbbcacbbaaabbaabacaaaaaacbcbaaccbbabbbccbcbcccabbcbbcccccaabcbccbbccccbccbcaccbbbbabbaabcaabcbccaaaccbabacbcbbaaabbccbaccaababbacaccccabbcaacabaacbcabaaaacbaacacbcbccbabbccbaacabbbbbacabaabaaabbbacaaabaacbbabacbcbbacabcacabcabccbacbabaccbbababcbccbcbbccbbacbacabccaacaaabaaacbbcbcabcbbccabcbbcbcbaaaaabaccbbabaccccbcbabbabbbaabccaaaacbababbbaababbcbbaaaabccaaabcbbaaaacccccccbabaccabcbcbcacaaaaaaacababbcaaabbcbbbaaabbbbbbbacabaaaabccabcccaccaccacbaaacaccbccbbbcbacbcbbacabcaabcbabcbabbb\", target: int=586):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbbbcbbbbaaccccabbacabababccacaacbcaacbcacccabcabcabcabbabbccccbcbbcaababccacabaacbccacccbabccbacabcbbbacacbcabacccaccbcacbbbcbcbbaacabbbbabcbbcacaccccaabaabcaccabcbcccaaabccbaabbcbbcbbaacbcaaaaaacaaccaaaaaacacccbcabbbbbbaccccaaabbcabcacaaaaccacaaababcbacbbabcaabbcaacaabccaabbacabbccababbaacaabacaccacccccabcbcabcacabbbacacababbbabacbccbbabccacabcbcaccaccbabbaaccbabbabcaaccccccbcbaaabcccabcabccbbabbccbbccbbcacbbaaabbaabacaaaaaacbcbaaccbbabbbccbcbcccabbcbbcccccaabcbccbbccccbccbcaccbbbbabbaabcaabcbccaaaccbabacbcbbaaabbccbaccaababbacaccccabbcaacabaacbcabaaaacbaacacbcbccbabbccbaacabbbbbacabaabaaabbbacaaabaacbbabacbcbbacabcacabcabccbacbabaccbbababcbccbcbbccbbacbacabccaacaaabaaacbbcbcabcbbccabcbbcbcbaaaaabaccbbabaccccbcbabbabbbaabccaaaacbababbbaababbcbbaaaabccaaabcbbaaaacccccccbabaccabcbcbcacaaaaaaacababbcaaabbcbbbaaabbbbbbbacabaaaabccabcccaccaccacbaaacaccbccbbbcbacbcbbacabcaabcbabcbabbb\", target=586):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_80",
    "sat": "def sat(t: str, s: str=\"bbabbaaaccbabbcbaaccbbbccaabbb\", target: int=16):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbabbaaaccbabbcbaaccbbbccaabbb\", target=16):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_81",
    "sat": "def sat(t: str, s: str=\"cbbcaacbcbaaccabcaacaccabbabaacaaacccbaabaccbccacbbbaccbbccbbcaabaccacaacbbababccbcbbbbbcabbbbcbaaaccbabcababbacacbbacbbbabbbababaaacacbacaaabacbbcabacbccacbcccaacaaaacababcccabcbacbaacccccbbabcbaaccccabcaaaacacaaaaacaaccacacbaccabbcccbcbbaabbacbabccacbaabbccaaabbbcababbaaaaccaabcbaabcbabccabcaabcccbacabcabbbcccaaacccaabbacabbcbbaaabbbbbcbaccabaaaabaabccccaccbbcabacbabcaabbaacabcbccaaabcabaacabcabbaccbcbbcbccccaccabbcbacbabacbbcbbabaaacbacbbcacacccaababaaaaabcaccbbaabbcaacacabccccccccbcbaaaababaabbcbccabbababbccccaaabacbbaaabbbacbaaaccbabccabc\", target: int=359):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbcaacbcbaaccabcaacaccabbabaacaaacccbaabaccbccacbbbaccbbccbbcaabaccacaacbbababccbcbbbbbcabbbbcbaaaccbabcababbacacbbacbbbabbbababaaacacbacaaabacbbcabacbccacbcccaacaaaacababcccabcbacbaacccccbbabcbaaccccabcaaaacacaaaaacaaccacacbaccabbcccbcbbaabbacbabccacbaabbccaaabbbcababbaaaaccaabcbaabcbabccabcaabcccbacabcabbbcccaaacccaabbacabbcbbaaabbbbbcbaccabaaaabaabccccaccbbcabacbabcaabbaacabcbccaaabcabaacabcabbaccbcbbcbccccaccabbcbacbabacbbcbbabaaacbacbbcacacccaababaaaaabcaccbbaabbcaacacabccccccccbcbaaaababaabbcbccabbababbccccaaabacbbaaabbbacbaaaccbabccabc\", target=359):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_82",
    "sat": "def sat(t: str, s: str=\"caa\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caa\", target=2):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_83",
    "sat": "def sat(t: str, s: str=\"cbcbcacbaabacab\", target: int=14):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcbcacbaabacab\", target=14):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_84",
    "sat": "def sat(t: str, s: str=\"cccbcbcabbacbabbcaccaaabccccbcbcbbacabbbbbcaacaaabaabbcbaacaaacaaacbbaabbcbcbbcccccaccccbbccaabbcabbccccaccbccbabcaacbbbbbbacaacbbbbcaccabcbcabcccacbbcaaabcbccbcabcabcbbbcbabcacaacccacabccbcbcbbbabbbaabccccabacccbaacbcaaabcbcacbabcaabbcacbbbcbcbccccccbbbbabacccbcaaaaaabcaaccbabcaabcbcacbabcbcabcabacbaaaaaaaabbabbabaabbbcccbbaccbbaacacacabcaababaabcbcacaaaaccaaccaabbcabaccacaaacbbbccaaaabaaabaabacbabcccaaaaccccccabcbccacaabcacaccaabaababccbbbcbbccccbbbbcccaaaaaaacaacacaacaccbcabcaacabbacaacbacbbbababaacaacbcabcababccbbabaacbaabaccaccaccabcacccbaccaabbccbbcababacaabbaccaababccccaccaaabbbccabb\", target: int=382):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccbcbcabbacbabbcaccaaabccccbcbcbbacabbbbbcaacaaabaabbcbaacaaacaaacbbaabbcbcbbcccccaccccbbccaabbcabbccccaccbccbabcaacbbbbbbacaacbbbbcaccabcbcabcccacbbcaaabcbccbcabcabcbbbcbabcacaacccacabccbcbcbbbabbbaabccccabacccbaacbcaaabcbcacbabcaabbcacbbbcbcbccccccbbbbabacccbcaaaaaabcaaccbabcaabcbcacbabcbcabcabacbaaaaaaaabbabbabaabbbcccbbaccbbaacacacabcaababaabcbcacaaaaccaaccaabbcabaccacaaacbbbccaaaabaaabaabacbabcccaaaaccccccabcbccacaabcacaccaabaababccbbbcbbccccbbbbcccaaaaaaacaacacaacaccbcabcaacabbacaacbacbbbababaacaacbcabcababccbbabaacbaabaccaccaccabcacccbaccaabbccbbcababacaabbaccaababccccaccaaabbbccabb\", target=382):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_85",
    "sat": "def sat(t: str, s: str=\"bbaabbcbcaaabcbaabbbcacaccabaaacababacbbaababbbbcbabaabcbabaacaaabaccbbaacacabacccaccacbcaaabbccbcaabcacbccbccaaccbbababcaabbcccaacbbcbccbcabbcbabaaacababaaccbbccbcacbccacccbcaaacbaabcaaabbcbcacbaccacaabbbcbbccabaabacac\", target: int=153):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbaabbcbcaaabcbaabbbcacaccabaaacababacbbaababbbbcbabaabcbabaacaaabaccbbaacacabacccaccacbcaaabbccbcaabcacbccbccaaccbbababcaabbcccaacbbcbccbcabbcbabaaacababaaccbbccbcacbccacccbcaaacbaabcaaabbcbcacbaccacaabbbcbbccabaabacac\", target=153):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_86",
    "sat": "def sat(t: str, s: str=\"acacbacbbaabbcbcaccacbccbbbaccbaaaabacaabaacabcabaabccbabbaaabacacabacacbabcaaccabcaabcabcacbabaaccccbccbbcaacbcbaaaaaacabaacaababcaaccbbbcbacbababcababbcacbccbcbbcc\", target: int=122):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acacbacbbaabbcbcaccacbccbbbaccbaaaabacaabaacabcabaabccbabbaaabacacabacacbabcaaccabcaabcabcacbabaaccccbccbbcaacbcbaaaaaacabaacaababcaaccbbbcbacbababcababbcacbccbcbbcc\", target=122):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_87",
    "sat": "def sat(t: str, s: str=\"babcbabccabbbcaabbaacaaacbbccbccabaabacaacaacaaabcabcbacbcbcaccaabbaaabcbcaccbbbbccbcccccbbabbaaabacabcbcacabaababbacabaacabcaaacbaccbaaccabaccbbabacabccababccbabcbcacbcacbcbbacbababcacbbabbabccbabbcabcabccabcaacbcbbaaacbbbbacbcbbbbcbccbaaaaaabcbcbcbaccabacababaabcbbbccabacbbcbbbaabbacaccabaaaaccbbabbcaaabcbbbbcaaabacbaacacaabbbbccaccabbcbabacccbcaacacbcacbabcbabbacacabaaaababaabbaccbbcbbbbcccccccabababbabcabbaaaabbccacbabcca\", target: int=301):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babcbabccabbbcaabbaacaaacbbccbccabaabacaacaacaaabcabcbacbcbcaccaabbaaabcbcaccbbbbccbcccccbbabbaaabacabcbcacabaababbacabaacabcaaacbaccbaaccabaccbbabacabccababccbabcbcacbcacbcbbacbababcacbbabbabccbabbcabcabccabcaacbcbbaaacbbbbacbcbbbbcbccbaaaaaabcbcbcbaccabacababaabcbbbccabacbbcbbbaabbacaccabaaaaccbbabbcaaabcbbbbcaaabacbaacacaabbbbccaccabbcbabacccbcaacacbcacbabcbabbacacabaaaababaabbaccbbcbbbbcccccccabababbabcabbaaaabbccacbabcca\", target=301):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_88",
    "sat": "def sat(t: str, s: str=\"acbbabbbaabbcabbbccaaaacbbbbbcab\", target: int=17):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acbbabbbaabbcabbbccaaaacbbbbbcab\", target=17):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_89",
    "sat": "def sat(t: str, s: str=\"abccaabacabcc\", target: int=10):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abccaabacabcc\", target=10):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_90",
    "sat": "def sat(t: str, s: str=\"aaccacacbacabcabbaaaccaccacbaaabbbcbaaccbcacabbabcbaabcaacbbcbbabbbaababbababbaacacbaaccacabbcaabccccbbcbabcbccbbbbbaacbbccccbbbcacaacbbabcaacccacbabbbcbacbbcababbcbababacabbbcccbccbacacaabacccaccabcccbbcbbbacccccccbbccbaccbccbcbabaacbcabcabbbabacccbbcccbbcbbcacbbaaccbabbaccccabaabbaaccacbbabbbbaacaacaabcabacccbbbaccbbbaacaaccaacabcbbabaaaaacbbcbcbbbccbaabacbaabaccbbabacabaababaaabccaabccabbbababbbaccccacbccccaaaccbbcbaaccaacbccbabacaccbbbaaccbacbcccbccbccabaccaacaaacaababcaabcccacacabbcbcccabcbcaaabcacccbabcbbbcbccccabcbcaaaaacacbbacabacacbccacababaaaaaaacaccbbabbbaabcaaccacbaccbbaccaccbaabababaabacabbcacbacbabcaacbccbabcbbabcbbccbcaccaabccbabbbccbbaccbacaaaabbbbbbcabaaabacbaababcabcbaaaabbbaacccaabaccbbaabcbaacbcbcaabbbbabaaabcaaabbaccccbabcbbbccbcccbbabcbccbaaabbbccbaaabacacaaccaabbacacbabcbcabacabbbabcbbcaaccaaacbaaccbbbaaccacbcbaaacabcccaaacbbaaaaacbabaacbbabccaacbcaaaccaaacaaacbbcaaacabcbccabccabbcacabacaacbbbccbabc\", target: int=615):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aaccacacbacabcabbaaaccaccacbaaabbbcbaaccbcacabbabcbaabcaacbbcbbabbbaababbababbaacacbaaccacabbcaabccccbbcbabcbccbbbbbaacbbccccbbbcacaacbbabcaacccacbabbbcbacbbcababbcbababacabbbcccbccbacacaabacccaccabcccbbcbbbacccccccbbccbaccbccbcbabaacbcabcabbbabacccbbcccbbcbbcacbbaaccbabbaccccabaabbaaccacbbabbbbaacaacaabcabacccbbbaccbbbaacaaccaacabcbbabaaaaacbbcbcbbbccbaabacbaabaccbbabacabaababaaabccaabccabbbababbbaccccacbccccaaaccbbcbaaccaacbccbabacaccbbbaaccbacbcccbccbccabaccaacaaacaababcaabcccacacabbcbcccabcbcaaabcacccbabcbbbcbccccabcbcaaaaacacbbacabacacbccacababaaaaaaacaccbbabbbaabcaaccacbaccbbaccaccbaabababaabacabbcacbacbabcaacbccbabcbbabcbbccbcaccaabccbabbbccbbaccbacaaaabbbbbbcabaaabacbaababcabcbaaaabbbaacccaabaccbbaabcbaacbcbcaabbbbabaaabcaaabbaccccbabcbbbccbcccbbabcbccbaaabbbccbaaabacacaaccaabbacacbabcbcabacabbbabcbbcaaccaaacbaaccbbbaaccacbcbaaacabcccaaacbbaaaaacbabaacbbabccaacbcaaaccaaacaaacbbcaaacabcbccabccabbcacabacaacbbbccbabc\", target=615):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_91",
    "sat": "def sat(t: str, s: str=\"caaaabaaacbcaccbbabacababcacccabbacaaacbcbcbcaacabaaacabbcacbabcbbcbbbabbabbaaacccbaaccacaabbbbacabcabaacbcacbabbcbbcbcbacabbaabbbacbbcabccabbbacbaaaccbaacaabacccaabbaabccaaccacbbccbbabcabcccacaaacaaccccacbccbabbcaaccbaccbcbaacabcaababcbccbcabcbbccaaaaccccacababbacbcbcbbcbaaabaccbcccbacaaabccbbabaaaacacaacbbcbaabaabaacabacbccbbcbacaaacbbacbaacccacbbcaccacbcacccaaacbbbabbbbcacabacbaaccaaaaccaccccaaaacbbbcbbbcaccacaabaaacabbcbcbacababababbcabbcabccbbaacbcacbababcabbbcbcbbacbbaabbabbbcbccaabccbccabcaccbbbbcbccccaccbbbcbccbbababcbbbacbcbbbbbababacbaccabccacababcbbbacacbcabbbacacaacbbaaccbbbabaaaacacacbacabbbabaccbacbaccabcccbababbaaacbcbbcbbcabaacbcbacacbbbbcbabccaaaabccbbbbacabccaabbacbbbbcbbbababcabaabcaabacbccbcccbbcaabaaaccacbcabcacbccbbccabcbbacaabbcabcbaccababbabbacbacbcbaabcaaccbabbbcbcacbbbcccbaababbcaacababbaccbaccbbaacbccbabbabbcccaacbcacabcbcbcaaabaccaaabbbccaacaaccaacbccabacbcbb\", target: int=621):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caaaabaaacbcaccbbabacababcacccabbacaaacbcbcbcaacabaaacabbcacbabcbbcbbbabbabbaaacccbaaccacaabbbbacabcabaacbcacbabbcbbcbcbacabbaabbbacbbcabccabbbacbaaaccbaacaabacccaabbaabccaaccacbbccbbabcabcccacaaacaaccccacbccbabbcaaccbaccbcbaacabcaababcbccbcabcbbccaaaaccccacababbacbcbcbbcbaaabaccbcccbacaaabccbbabaaaacacaacbbcbaabaabaacabacbccbbcbacaaacbbacbaacccacbbcaccacbcacccaaacbbbabbbbcacabacbaaccaaaaccaccccaaaacbbbcbbbcaccacaabaaacabbcbcbacababababbcabbcabccbbaacbcacbababcabbbcbcbbacbbaabbabbbcbccaabccbccabcaccbbbbcbccccaccbbbcbccbbababcbbbacbcbbbbbababacbaccabccacababcbbbacacbcabbbacacaacbbaaccbbbabaaaacacacbacabbbabaccbacbaccabcccbababbaaacbcbbcbbcabaacbcbacacbbbbcbabccaaaabccbbbbacabccaabbacbbbbcbbbababcabaabcaabacbccbcccbbcaabaaaccacbcabcacbccbbccabcbbacaabbcabcbaccababbabbacbacbcbaabcaaccbabbbcbcacbbbcccbaababbcaacababbaccbaccbbaacbccbabbabbcccaacbcacabcbcbcaaabaccaaabbbccaacaaccaacbccabacbcbb\", target=621):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_92",
    "sat": "def sat(t: str, s: str=\"cbcccacbacccbccaaccaabcbabbacacbaacacbacbcccacbcacacbaaacbaaaaabaabababcacaccb\", target: int=58):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcccacbacccbccaaccaabcbabbacacbaacacbacbcccacbcacacbaaacbaaaaabaabababcacaccb\", target=58):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_93",
    "sat": "def sat(t: str, s: str=\"aabccc\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aabccc\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_94",
    "sat": "def sat(t: str, s: str=\"c\", target: int=1):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"c\", target=1):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_95",
    "sat": "def sat(t: str, s: str=\"baa\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"baa\", target=2):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_96",
    "sat": "def sat(t: str, s: str=\"acbaabcbabcacacacaccaccbbbaaababacaccbacaacacbccbababbaacbacccacbcababaabacccaacaacbacbbbbcca\", target: int=70):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acbaabcbabcacacacaccaccbbbaaababacaccbacaacacbccbababbaacbacccacbcababaabacccaacaacbacbbbbcca\", target=70):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_97",
    "sat": "def sat(t: str, s: str=\"cbcbbbccabbbcacbccbcccccacccccbaabaaabaabcaaacbbaaaacaccbcbacabacbcabacabbccbccbbbcbccbabaacbaaacabbacbcbbacbbcbcaccccbbacacbaabcbbcbaaabcbbaaabbaaabcababaccbbbabbbaacbacbabcaaabaabbaaacbbcbbbbacbcbbcacbbacbcccaacaacabaccaaaacbcbcbaacbbcabccccabacbaabacbbabbabbcbcabbccabbbbacaaaacaccccbccbbacbaabaabbbbaaabcccababcbbaaaacccaacbabcccabacbabbbaabcbccacbabbccabbcabcbccacacbabccbabcbaaabbbbcccbbbbcbacbcaacccacbacabaaacababbacacacbbccaaacacbacbbbbaccbaacacacbbbacccbbcaabcacbbcaaaabcccabacaabaaacbcccccccbccbbacaccbccbbbbccabbaaaccabcbbabbcababccaccbcbacbcabacbbacbbcaabcaabcaaccaacccbacabbbbabccacbacbbbaaccababcabcbbcaacccabbcbcbbbbcbccacbacaccaabaacaabcacaaaccbbbcccabbabcaacacaababaaacaabacbcbaccaacaccbcaaacbcccabbbbaccbabbaaaaaaaaabbcababcacabcbcaccbb\", target: int=501):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcbbbccabbbcacbccbcccccacccccbaabaaabaabcaaacbbaaaacaccbcbacabacbcabacabbccbccbbbcbccbabaacbaaacabbacbcbbacbbcbcaccccbbacacbaabcbbcbaaabcbbaaabbaaabcababaccbbbabbbaacbacbabcaaabaabbaaacbbcbbbbacbcbbcacbbacbcccaacaacabaccaaaacbcbcbaacbbcabccccabacbaabacbbabbabbcbcabbccabbbbacaaaacaccccbccbbacbaabaabbbbaaabcccababcbbaaaacccaacbabcccabacbabbbaabcbccacbabbccabbcabcbccacacbabccbabcbaaabbbbcccbbbbcbacbcaacccacbacabaaacababbacacacbbccaaacacbacbbbbaccbaacacacbbbacccbbcaabcacbbcaaaabcccabacaabaaacbcccccccbccbbacaccbccbbbbccabbaaaccabcbbabbcababccaccbcbacbcabacbbacbbcaabcaabcaaccaacccbacabbbbabccacbacbbbaaccababcabcbbcaacccabbcbcbbbbcbccacbacaccaabaacaabcacaaaccbbbcccabbabcaacacaababaaacaabacbcbaccaacaccbcaaacbcccabbbbaccbabbaaaaaaaaabbcababcacabcbcaccbb\", target=501):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_98",
    "sat": "def sat(t: str, s: str=\"bac\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bac\", target=3):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_99",
    "sat": "def sat(t: str, s: str=\"cbcabcbcbaacabcaccaaaccbcbccacbbababcbaccbacbabbbaabcbbbc\", target: int=44):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcabcbcbaacabcaccaaaccbcbccacbbababcbaccbacbabbbaabcbbbc\", target=44):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_0",
    "sat": "def sat(n: int, s: str=\"0000111111100000\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000111111100000\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000111111100000\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000111111100000\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000111111100000\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_1",
    "sat": "def sat(n: int, s: str=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_2",
    "sat": "def sat(n: int, s: str=\"0001\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_3",
    "sat": "def sat(n: int, s: str=\"1111111111111011\", k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1111111111111011\", k=11):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1111111111111011\", k=11):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1111111111111011\", k=11):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1111111111111011\", k=11):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_4",
    "sat": "def sat(n: int, s: str=\"111111111111111111100000\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111111111111111111100000\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111111111111111111100000\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111111111111111111100000\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111111111111111111100000\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_5",
    "sat": "def sat(n: int, s: str=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_6",
    "sat": "def sat(n: int, s: str=\"0011111111111001011100110011011110111111\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_7",
    "sat": "def sat(n: int, s: str=\"100000100110\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000100110\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000100110\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000100110\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000100110\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_8",
    "sat": "def sat(n: int, s: str=\"10000000001\", k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10000000001\", k=8):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10000000001\", k=8):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10000000001\", k=8):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10000000001\", k=8):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_9",
    "sat": "def sat(n: int, s: str=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_10",
    "sat": "def sat(n: int, s: str=\"1000010\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000010\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000010\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000010\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000010\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_11",
    "sat": "def sat(n: int, s: str=\"01111111110\", k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01111111110\", k=9):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01111111110\", k=9):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01111111110\", k=9):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01111111110\", k=9):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_12",
    "sat": "def sat(n: int, s: str=\"110111101111000000010110110010010111000011111111111111001101110010\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_13",
    "sat": "def sat(n: int, s: str=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_14",
    "sat": "def sat(n: int, s: str=\"1000000\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000000\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000000\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000000\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000000\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_15",
    "sat": "def sat(n: int, s: str=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_16",
    "sat": "def sat(n: int, s: str=\"01\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_17",
    "sat": "def sat(n: int, s: str=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_18",
    "sat": "def sat(n: int, s: str=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_19",
    "sat": "def sat(n: int, s: str=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_20",
    "sat": "def sat(n: int, s: str=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_21",
    "sat": "def sat(n: int, s: str=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_22",
    "sat": "def sat(n: int, s: str=\"01011110110110100011001011101100011111111111111100\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_23",
    "sat": "def sat(n: int, s: str=\"1000000000\", k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000000000\", k=9):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000000000\", k=9):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000000000\", k=9):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000000000\", k=9):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_24",
    "sat": "def sat(n: int, s: str=\"100001010101011100111111111010101\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_25",
    "sat": "def sat(n: int, s: str=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_26",
    "sat": "def sat(n: int, s: str=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_27",
    "sat": "def sat(n: int, s: str=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_28",
    "sat": "def sat(n: int, s: str=\"111000000000\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111000000000\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111000000000\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111000000000\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111000000000\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_29",
    "sat": "def sat(n: int, s: str=\"0111010101110001101100111010010011001000111110000110011100\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_30",
    "sat": "def sat(n: int, s: str=\"111000000000000010\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111000000000000010\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111000000000000010\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111000000000000010\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111000000000000010\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_31",
    "sat": "def sat(n: int, s: str=\"000010011100100101011\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000010011100100101011\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000010011100100101011\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000010011100100101011\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000010011100100101011\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_32",
    "sat": "def sat(n: int, s: str=\"01111111111110\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01111111111110\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01111111111110\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01111111111110\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01111111111110\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_33",
    "sat": "def sat(n: int, s: str=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_34",
    "sat": "def sat(n: int, s: str=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_35",
    "sat": "def sat(n: int, s: str=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_36",
    "sat": "def sat(n: int, s: str=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_37",
    "sat": "def sat(n: int, s: str=\"1100\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1100\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1100\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1100\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1100\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_38",
    "sat": "def sat(n: int, s: str=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_39",
    "sat": "def sat(n: int, s: str=\"0101111111111111110\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0101111111111111110\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0101111111111111110\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0101111111111111110\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0101111111111111110\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_40",
    "sat": "def sat(n: int, s: str=\"1111111111111\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1111111111111\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1111111111111\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1111111111111\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1111111111111\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_41",
    "sat": "def sat(n: int, s: str=\"00010\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00010\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00010\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00010\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00010\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_42",
    "sat": "def sat(n: int, s: str=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_43",
    "sat": "def sat(n: int, s: str=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_44",
    "sat": "def sat(n: int, s: str=\"1011010\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1011010\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1011010\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1011010\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1011010\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_45",
    "sat": "def sat(n: int, s: str=\"0111111111111111100\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0111111111111111100\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0111111111111111100\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0111111111111111100\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0111111111111111100\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_46",
    "sat": "def sat(n: int, s: str=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_47",
    "sat": "def sat(n: int, s: str=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_48",
    "sat": "def sat(n: int, s: str=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_49",
    "sat": "def sat(n: int, s: str=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_50",
    "sat": "def sat(n: int, s: str=\"01010000000000000000100100111101100110011001\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_51",
    "sat": "def sat(n: int, s: str=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_52",
    "sat": "def sat(n: int, s: str=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_53",
    "sat": "def sat(n: int, s: str=\"100000\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_54",
    "sat": "def sat(n: int, s: str=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_55",
    "sat": "def sat(n: int, s: str=\"10111111111111111111\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10111111111111111111\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10111111111111111111\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10111111111111111111\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10111111111111111111\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_56",
    "sat": "def sat(n: int, s: str=\"0100111111111111111110111\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0100111111111111111110111\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0100111111111111111110111\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0100111111111111111110111\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0100111111111111111110111\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_57",
    "sat": "def sat(n: int, s: str=\"01110010111100100101110000011010010\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_58",
    "sat": "def sat(n: int, s: str=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_59",
    "sat": "def sat(n: int, s: str=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_60",
    "sat": "def sat(n: int, s: str=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_61",
    "sat": "def sat(n: int, s: str=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_62",
    "sat": "def sat(n: int, s: str=\"10000000000000000000\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10000000000000000000\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10000000000000000000\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10000000000000000000\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10000000000000000000\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_63",
    "sat": "def sat(n: int, s: str=\"110111111111111111\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111111111111111\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111111111111111\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111111111111111\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111111111111111\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_64",
    "sat": "def sat(n: int, s: str=\"100000000000000000010\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000000000000000010\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000000000000000010\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000000000000000010\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000000000000000010\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_65",
    "sat": "def sat(n: int, s: str=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_66",
    "sat": "def sat(n: int, s: str=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_67",
    "sat": "def sat(n: int, s: str=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_68",
    "sat": "def sat(n: int, s: str=\"10101000000000000000000000\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10101000000000000000000000\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10101000000000000000000000\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10101000000000000000000000\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10101000000000000000000000\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_69",
    "sat": "def sat(n: int, s: str=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_70",
    "sat": "def sat(n: int, s: str=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_71",
    "sat": "def sat(n: int, s: str=\"100111111111111111100\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100111111111111111100\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100111111111111111100\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100111111111111111100\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100111111111111111100\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_72",
    "sat": "def sat(n: int, s: str=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_73",
    "sat": "def sat(n: int, s: str=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_74",
    "sat": "def sat(n: int, s: str=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_75",
    "sat": "def sat(n: int, s: str=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_76",
    "sat": "def sat(n: int, s: str=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_77",
    "sat": "def sat(n: int, s: str=\"011011001111011100111011011000000000011\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_78",
    "sat": "def sat(n: int, s: str=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_79",
    "sat": "def sat(n: int, s: str=\"00000000000000\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00000000000000\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00000000000000\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00000000000000\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00000000000000\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_80",
    "sat": "def sat(n: int, s: str=\"1111011001000\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1111011001000\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1111011001000\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1111011001000\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1111011001000\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_81",
    "sat": "def sat(n: int, s: str=\"000000000000000001\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000000000000000001\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000000000000000001\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000000000000000001\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000000000000000001\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_82",
    "sat": "def sat(n: int, s: str=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_83",
    "sat": "def sat(n: int, s: str=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_84",
    "sat": "def sat(n: int, s: str=\"0001001110111111001101011001101001111111111111111111111\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_85",
    "sat": "def sat(n: int, s: str=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_86",
    "sat": "def sat(n: int, s: str=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_87",
    "sat": "def sat(n: int, s: str=\"000000001101\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000000001101\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000000001101\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000000001101\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000000001101\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_88",
    "sat": "def sat(n: int, s: str=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_89",
    "sat": "def sat(n: int, s: str=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_90",
    "sat": "def sat(n: int, s: str=\"1100000000000000000001\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1100000000000000000001\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1100000000000000000001\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1100000000000000000001\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1100000000000000000001\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_91",
    "sat": "def sat(n: int, s: str=\"111111111111111101111\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111111111111111101111\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111111111111111101111\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111111111111111101111\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111111111111111101111\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_92",
    "sat": "def sat(n: int, s: str=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_93",
    "sat": "def sat(n: int, s: str=\"11100011000100111\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"11100011000100111\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"11100011000100111\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"11100011000100111\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"11100011000100111\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_94",
    "sat": "def sat(n: int, s: str=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_95",
    "sat": "def sat(n: int, s: str=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_96",
    "sat": "def sat(n: int, s: str=\"100010011\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100010011\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100010011\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100010011\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100010011\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_97",
    "sat": "def sat(n: int, s: str=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_98",
    "sat": "def sat(n: int, s: str=\"001001111011000101101111001000110011011001111111111111100110110001\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_99",
    "sat": "def sat(n: int, s: str=\"000\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FivePowers_0",
    "sat": "def sat(s: str, n: int=7):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=7):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_1",
    "sat": "def sat(s: str, n: int=0):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=0):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_2",
    "sat": "def sat(s: str, n: int=1):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=1):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_3",
    "sat": "def sat(s: str, n: int=2):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_4",
    "sat": "def sat(s: str, n: int=3):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=3):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_5",
    "sat": "def sat(s: str, n: int=4):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=4):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_6",
    "sat": "def sat(s: str, n: int=5):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=5):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_7",
    "sat": "def sat(s: str, n: int=6):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=6):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_8",
    "sat": "def sat(s: str, n: int=8):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=8):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_9",
    "sat": "def sat(s: str, n: int=9):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=9):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_10",
    "sat": "def sat(s: str, n: int=10):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=10):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_11",
    "sat": "def sat(s: str, n: int=11):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=11):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_12",
    "sat": "def sat(s: str, n: int=12):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=12):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_13",
    "sat": "def sat(s: str, n: int=13):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=13):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_14",
    "sat": "def sat(s: str, n: int=14):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=14):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_15",
    "sat": "def sat(s: str, n: int=15):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=15):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_16",
    "sat": "def sat(s: str, n: int=16):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=16):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_17",
    "sat": "def sat(s: str, n: int=17):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=17):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_18",
    "sat": "def sat(s: str, n: int=18):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=18):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_19",
    "sat": "def sat(s: str, n: int=19):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=19):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_20",
    "sat": "def sat(s: str, n: int=20):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=20):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_21",
    "sat": "def sat(s: str, n: int=21):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=21):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_22",
    "sat": "def sat(s: str, n: int=22):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=22):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_23",
    "sat": "def sat(s: str, n: int=23):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=23):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_24",
    "sat": "def sat(s: str, n: int=24):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=24):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_25",
    "sat": "def sat(s: str, n: int=25):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=25):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_26",
    "sat": "def sat(s: str, n: int=26):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=26):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_27",
    "sat": "def sat(s: str, n: int=27):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=27):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_28",
    "sat": "def sat(s: str, n: int=28):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=28):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_29",
    "sat": "def sat(s: str, n: int=29):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=29):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_30",
    "sat": "def sat(s: str, n: int=30):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=30):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_31",
    "sat": "def sat(s: str, n: int=31):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=31):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_32",
    "sat": "def sat(s: str, n: int=32):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=32):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_33",
    "sat": "def sat(s: str, n: int=33):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=33):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_34",
    "sat": "def sat(s: str, n: int=34):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=34):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_35",
    "sat": "def sat(s: str, n: int=35):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=35):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_36",
    "sat": "def sat(s: str, n: int=36):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=36):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_37",
    "sat": "def sat(s: str, n: int=37):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=37):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_38",
    "sat": "def sat(s: str, n: int=38):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=38):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_39",
    "sat": "def sat(s: str, n: int=39):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=39):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_40",
    "sat": "def sat(s: str, n: int=40):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=40):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_41",
    "sat": "def sat(s: str, n: int=41):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=41):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_42",
    "sat": "def sat(s: str, n: int=42):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=42):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_43",
    "sat": "def sat(s: str, n: int=43):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=43):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_44",
    "sat": "def sat(s: str, n: int=44):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=44):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_45",
    "sat": "def sat(s: str, n: int=45):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=45):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_46",
    "sat": "def sat(s: str, n: int=46):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=46):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_47",
    "sat": "def sat(s: str, n: int=47):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=47):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_48",
    "sat": "def sat(s: str, n: int=48):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=48):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_49",
    "sat": "def sat(s: str, n: int=49):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=49):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_50",
    "sat": "def sat(s: str, n: int=50):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=50):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_51",
    "sat": "def sat(s: str, n: int=51):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=51):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_52",
    "sat": "def sat(s: str, n: int=52):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=52):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_53",
    "sat": "def sat(s: str, n: int=53):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=53):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_54",
    "sat": "def sat(s: str, n: int=54):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=54):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_55",
    "sat": "def sat(s: str, n: int=55):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=55):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_56",
    "sat": "def sat(s: str, n: int=56):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=56):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_57",
    "sat": "def sat(s: str, n: int=57):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=57):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_58",
    "sat": "def sat(s: str, n: int=58):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=58):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_59",
    "sat": "def sat(s: str, n: int=59):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=59):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_60",
    "sat": "def sat(s: str, n: int=60):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=60):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_61",
    "sat": "def sat(s: str, n: int=61):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=61):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_62",
    "sat": "def sat(s: str, n: int=62):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=62):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_63",
    "sat": "def sat(s: str, n: int=63):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=63):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_64",
    "sat": "def sat(s: str, n: int=64):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=64):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_65",
    "sat": "def sat(s: str, n: int=65):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=65):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_66",
    "sat": "def sat(s: str, n: int=66):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=66):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_67",
    "sat": "def sat(s: str, n: int=67):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=67):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_68",
    "sat": "def sat(s: str, n: int=68):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=68):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_69",
    "sat": "def sat(s: str, n: int=69):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=69):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_70",
    "sat": "def sat(s: str, n: int=70):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=70):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_71",
    "sat": "def sat(s: str, n: int=71):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=71):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_72",
    "sat": "def sat(s: str, n: int=72):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=72):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_73",
    "sat": "def sat(s: str, n: int=73):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=73):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_74",
    "sat": "def sat(s: str, n: int=74):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=74):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_75",
    "sat": "def sat(s: str, n: int=75):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=75):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_76",
    "sat": "def sat(s: str, n: int=76):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=76):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_77",
    "sat": "def sat(s: str, n: int=77):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=77):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_78",
    "sat": "def sat(s: str, n: int=78):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=78):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_79",
    "sat": "def sat(s: str, n: int=79):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=79):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_80",
    "sat": "def sat(s: str, n: int=80):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=80):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_81",
    "sat": "def sat(s: str, n: int=81):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=81):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_82",
    "sat": "def sat(s: str, n: int=82):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=82):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_83",
    "sat": "def sat(s: str, n: int=83):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=83):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_84",
    "sat": "def sat(s: str, n: int=84):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=84):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_85",
    "sat": "def sat(s: str, n: int=85):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=85):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_86",
    "sat": "def sat(s: str, n: int=86):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=86):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_87",
    "sat": "def sat(s: str, n: int=87):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=87):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_88",
    "sat": "def sat(s: str, n: int=88):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=88):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_89",
    "sat": "def sat(s: str, n: int=89):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=89):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_90",
    "sat": "def sat(s: str, n: int=90):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=90):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_91",
    "sat": "def sat(s: str, n: int=91):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=91):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_92",
    "sat": "def sat(s: str, n: int=92):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=92):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_93",
    "sat": "def sat(s: str, n: int=93):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=93):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_94",
    "sat": "def sat(s: str, n: int=94):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=94):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_95",
    "sat": "def sat(s: str, n: int=95):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=95):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_96",
    "sat": "def sat(s: str, n: int=96):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=96):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_97",
    "sat": "def sat(s: str, n: int=97):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=97):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_98",
    "sat": "def sat(s: str, n: int=98):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=98):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "CombinationLock_0",
    "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"012\", combo=\"329\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_1",
    "sat": "def sat(states: List[str], start: str=\"216\", combo: str=\"998\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"216\", combo=\"998\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_2",
    "sat": "def sat(states: List[str], start: str=\"37\", combo: str=\"08\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"37\", combo=\"08\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_3",
    "sat": "def sat(states: List[str], start: str=\"1491511143\", combo: str=\"2425877025\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1491511143\", combo=\"2425877025\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_4",
    "sat": "def sat(states: List[str], start: str=\"04076\", combo: str=\"32441\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"04076\", combo=\"32441\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_5",
    "sat": "def sat(states: List[str], start: str=\"5375\", combo: str=\"9044\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5375\", combo=\"9044\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_6",
    "sat": "def sat(states: List[str], start: str=\"1112\", combo: str=\"0714\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1112\", combo=\"0714\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_7",
    "sat": "def sat(states: List[str], start: str=\"09357420\", combo: str=\"20829960\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"09357420\", combo=\"20829960\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_8",
    "sat": "def sat(states: List[str], start: str=\"9316710580\", combo: str=\"8447131092\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9316710580\", combo=\"8447131092\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_9",
    "sat": "def sat(states: List[str], start: str=\"96066072\", combo: str=\"35671171\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"96066072\", combo=\"35671171\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_10",
    "sat": "def sat(states: List[str], start: str=\"493\", combo: str=\"276\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"493\", combo=\"276\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_11",
    "sat": "def sat(states: List[str], start: str=\"7007346005\", combo: str=\"8653227796\", target_len: int=22):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7007346005\", combo=\"8653227796\", target_len=22):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_12",
    "sat": "def sat(states: List[str], start: str=\"4146\", combo: str=\"6764\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4146\", combo=\"6764\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_13",
    "sat": "def sat(states: List[str], start: str=\"069169\", combo: str=\"408609\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"069169\", combo=\"408609\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_14",
    "sat": "def sat(states: List[str], start: str=\"894\", combo: str=\"907\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"894\", combo=\"907\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_15",
    "sat": "def sat(states: List[str], start: str=\"3648\", combo: str=\"1449\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3648\", combo=\"1449\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_16",
    "sat": "def sat(states: List[str], start: str=\"03645240\", combo: str=\"09680593\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"03645240\", combo=\"09680593\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_17",
    "sat": "def sat(states: List[str], start: str=\"916\", combo: str=\"924\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"916\", combo=\"924\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_18",
    "sat": "def sat(states: List[str], start: str=\"98750140\", combo: str=\"75374849\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"98750140\", combo=\"75374849\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_19",
    "sat": "def sat(states: List[str], start: str=\"1720920724\", combo: str=\"8105118833\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1720920724\", combo=\"8105118833\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_20",
    "sat": "def sat(states: List[str], start: str=\"62908558\", combo: str=\"89905057\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"62908558\", combo=\"89905057\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_21",
    "sat": "def sat(states: List[str], start: str=\"975\", combo: str=\"797\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"975\", combo=\"797\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_22",
    "sat": "def sat(states: List[str], start: str=\"36302\", combo: str=\"79078\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"36302\", combo=\"79078\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_23",
    "sat": "def sat(states: List[str], start: str=\"18\", combo: str=\"57\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"18\", combo=\"57\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_24",
    "sat": "def sat(states: List[str], start: str=\"6\", combo: str=\"8\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6\", combo=\"8\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_25",
    "sat": "def sat(states: List[str], start: str=\"5629\", combo: str=\"9395\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5629\", combo=\"9395\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_26",
    "sat": "def sat(states: List[str], start: str=\"4320824\", combo: str=\"3484304\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4320824\", combo=\"3484304\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_27",
    "sat": "def sat(states: List[str], start: str=\"3648749541\", combo: str=\"1503240792\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3648749541\", combo=\"1503240792\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_28",
    "sat": "def sat(states: List[str], start: str=\"577212\", combo: str=\"608839\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"577212\", combo=\"608839\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_29",
    "sat": "def sat(states: List[str], start: str=\"65636527\", combo: str=\"99800171\", target_len: int=28):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"65636527\", combo=\"99800171\", target_len=28):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_30",
    "sat": "def sat(states: List[str], start: str=\"92\", combo: str=\"16\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"92\", combo=\"16\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_31",
    "sat": "def sat(states: List[str], start: str=\"42\", combo: str=\"06\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"42\", combo=\"06\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_32",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"0\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8\", combo=\"0\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_33",
    "sat": "def sat(states: List[str], start: str=\"683965052\", combo: str=\"287206495\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"683965052\", combo=\"287206495\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_34",
    "sat": "def sat(states: List[str], start: str=\"9769687746\", combo: str=\"8653683898\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9769687746\", combo=\"8653683898\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_35",
    "sat": "def sat(states: List[str], start: str=\"22217169\", combo: str=\"40818016\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"22217169\", combo=\"40818016\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_36",
    "sat": "def sat(states: List[str], start: str=\"5267\", combo: str=\"3674\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5267\", combo=\"3674\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_37",
    "sat": "def sat(states: List[str], start: str=\"59239\", combo: str=\"67535\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"59239\", combo=\"67535\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_38",
    "sat": "def sat(states: List[str], start: str=\"3412\", combo: str=\"3511\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3412\", combo=\"3511\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_39",
    "sat": "def sat(states: List[str], start: str=\"644606526\", combo: str=\"133531000\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"644606526\", combo=\"133531000\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_40",
    "sat": "def sat(states: List[str], start: str=\"470\", combo: str=\"625\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"470\", combo=\"625\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_41",
    "sat": "def sat(states: List[str], start: str=\"9043741279\", combo: str=\"8673043124\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9043741279\", combo=\"8673043124\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_42",
    "sat": "def sat(states: List[str], start: str=\"68663\", combo: str=\"60353\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"68663\", combo=\"60353\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_43",
    "sat": "def sat(states: List[str], start: str=\"9563799\", combo: str=\"3500475\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9563799\", combo=\"3500475\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_44",
    "sat": "def sat(states: List[str], start: str=\"4\", combo: str=\"5\", target_len: int=0):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4\", combo=\"5\", target_len=0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_45",
    "sat": "def sat(states: List[str], start: str=\"1512\", combo: str=\"4886\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1512\", combo=\"4886\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_46",
    "sat": "def sat(states: List[str], start: str=\"7484\", combo: str=\"3579\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7484\", combo=\"3579\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_47",
    "sat": "def sat(states: List[str], start: str=\"153389\", combo: str=\"735261\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"153389\", combo=\"735261\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_48",
    "sat": "def sat(states: List[str], start: str=\"9\", combo: str=\"4\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9\", combo=\"4\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_49",
    "sat": "def sat(states: List[str], start: str=\"6\", combo: str=\"7\", target_len: int=0):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6\", combo=\"7\", target_len=0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_50",
    "sat": "def sat(states: List[str], start: str=\"83670\", combo: str=\"35210\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"83670\", combo=\"35210\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_51",
    "sat": "def sat(states: List[str], start: str=\"8839776\", combo: str=\"0917530\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8839776\", combo=\"0917530\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_52",
    "sat": "def sat(states: List[str], start: str=\"95\", combo: str=\"56\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"95\", combo=\"56\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_53",
    "sat": "def sat(states: List[str], start: str=\"6227\", combo: str=\"4780\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6227\", combo=\"4780\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_54",
    "sat": "def sat(states: List[str], start: str=\"03\", combo: str=\"98\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"03\", combo=\"98\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_55",
    "sat": "def sat(states: List[str], start: str=\"95444\", combo: str=\"30829\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"95444\", combo=\"30829\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_56",
    "sat": "def sat(states: List[str], start: str=\"030050\", combo: str=\"818991\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"030050\", combo=\"818991\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_57",
    "sat": "def sat(states: List[str], start: str=\"2714090\", combo: str=\"4601893\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"2714090\", combo=\"4601893\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_58",
    "sat": "def sat(states: List[str], start: str=\"3174952329\", combo: str=\"0772404224\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3174952329\", combo=\"0772404224\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_59",
    "sat": "def sat(states: List[str], start: str=\"58994627\", combo: str=\"99616023\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"58994627\", combo=\"99616023\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_60",
    "sat": "def sat(states: List[str], start: str=\"82936\", combo: str=\"80547\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"82936\", combo=\"80547\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_61",
    "sat": "def sat(states: List[str], start: str=\"63844371\", combo: str=\"93680744\", target_len: int=22):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"63844371\", combo=\"93680744\", target_len=22):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_62",
    "sat": "def sat(states: List[str], start: str=\"5\", combo: str=\"8\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5\", combo=\"8\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_63",
    "sat": "def sat(states: List[str], start: str=\"486896318\", combo: str=\"110364497\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"486896318\", combo=\"110364497\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_64",
    "sat": "def sat(states: List[str], start: str=\"657\", combo: str=\"938\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"657\", combo=\"938\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_65",
    "sat": "def sat(states: List[str], start: str=\"8942458130\", combo: str=\"4743589796\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8942458130\", combo=\"4743589796\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_66",
    "sat": "def sat(states: List[str], start: str=\"76214771\", combo: str=\"11507983\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"76214771\", combo=\"11507983\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_67",
    "sat": "def sat(states: List[str], start: str=\"40784\", combo: str=\"30833\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"40784\", combo=\"30833\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_68",
    "sat": "def sat(states: List[str], start: str=\"05925\", combo: str=\"07029\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"05925\", combo=\"07029\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_69",
    "sat": "def sat(states: List[str], start: str=\"04308669\", combo: str=\"16075906\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"04308669\", combo=\"16075906\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_70",
    "sat": "def sat(states: List[str], start: str=\"9096105291\", combo: str=\"8381334790\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9096105291\", combo=\"8381334790\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_71",
    "sat": "def sat(states: List[str], start: str=\"26609261\", combo: str=\"21907313\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"26609261\", combo=\"21907313\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_72",
    "sat": "def sat(states: List[str], start: str=\"246155\", combo: str=\"744567\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"246155\", combo=\"744567\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_73",
    "sat": "def sat(states: List[str], start: str=\"61929254\", combo: str=\"10970807\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"61929254\", combo=\"10970807\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_74",
    "sat": "def sat(states: List[str], start: str=\"01\", combo: str=\"38\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"01\", combo=\"38\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_75",
    "sat": "def sat(states: List[str], start: str=\"12850100\", combo: str=\"52835573\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"12850100\", combo=\"52835573\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_76",
    "sat": "def sat(states: List[str], start: str=\"182403\", combo: str=\"660233\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"182403\", combo=\"660233\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_77",
    "sat": "def sat(states: List[str], start: str=\"67888845\", combo: str=\"31906953\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"67888845\", combo=\"31906953\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_78",
    "sat": "def sat(states: List[str], start: str=\"464088\", combo: str=\"766326\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"464088\", combo=\"766326\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_79",
    "sat": "def sat(states: List[str], start: str=\"940176\", combo: str=\"280564\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"940176\", combo=\"280564\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_80",
    "sat": "def sat(states: List[str], start: str=\"6942\", combo: str=\"0915\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6942\", combo=\"0915\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_81",
    "sat": "def sat(states: List[str], start: str=\"284009399\", combo: str=\"256258667\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"284009399\", combo=\"256258667\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_82",
    "sat": "def sat(states: List[str], start: str=\"121688\", combo: str=\"690944\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"121688\", combo=\"690944\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_83",
    "sat": "def sat(states: List[str], start: str=\"204816201\", combo: str=\"620523894\", target_len: int=24):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"204816201\", combo=\"620523894\", target_len=24):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_84",
    "sat": "def sat(states: List[str], start: str=\"8949\", combo: str=\"9502\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8949\", combo=\"9502\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_85",
    "sat": "def sat(states: List[str], start: str=\"09\", combo: str=\"35\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"09\", combo=\"35\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_86",
    "sat": "def sat(states: List[str], start: str=\"4820\", combo: str=\"1904\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4820\", combo=\"1904\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_87",
    "sat": "def sat(states: List[str], start: str=\"614872257\", combo: str=\"221198895\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"614872257\", combo=\"221198895\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_88",
    "sat": "def sat(states: List[str], start: str=\"70865467\", combo: str=\"10637573\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"70865467\", combo=\"10637573\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_89",
    "sat": "def sat(states: List[str], start: str=\"396\", combo: str=\"707\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"396\", combo=\"707\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_90",
    "sat": "def sat(states: List[str], start: str=\"905484084\", combo: str=\"738628515\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"905484084\", combo=\"738628515\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_91",
    "sat": "def sat(states: List[str], start: str=\"16372\", combo: str=\"88839\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"16372\", combo=\"88839\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_92",
    "sat": "def sat(states: List[str], start: str=\"7910442\", combo: str=\"2612321\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7910442\", combo=\"2612321\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_93",
    "sat": "def sat(states: List[str], start: str=\"30\", combo: str=\"73\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"30\", combo=\"73\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_94",
    "sat": "def sat(states: List[str], start: str=\"5010331\", combo: str=\"6851290\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5010331\", combo=\"6851290\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_95",
    "sat": "def sat(states: List[str], start: str=\"8525\", combo: str=\"4132\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8525\", combo=\"4132\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_96",
    "sat": "def sat(states: List[str], start: str=\"422\", combo: str=\"160\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"422\", combo=\"160\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_97",
    "sat": "def sat(states: List[str], start: str=\"551216090\", combo: str=\"504637022\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"551216090\", combo=\"504637022\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_98",
    "sat": "def sat(states: List[str], start: str=\"8315482\", combo: str=\"8888343\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8315482\", combo=\"8888343\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_99",
    "sat": "def sat(states: List[str], start: str=\"917770726\", combo: str=\"247138502\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"917770726\", combo=\"247138502\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_0",
    "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"012\", combo=\"329\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_1",
    "sat": "def sat(states: List[str], start: str=\"56300340\", combo: str=\"46697465\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"56300340\", combo=\"46697465\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_2",
    "sat": "def sat(states: List[str], start: str=\"2164222519\", combo: str=\"5256679468\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2164222519\", combo=\"5256679468\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_3",
    "sat": "def sat(states: List[str], start: str=\"3069977\", combo: str=\"1891210\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3069977\", combo=\"1891210\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_4",
    "sat": "def sat(states: List[str], start: str=\"3\", combo: str=\"2\", target_len: int=0):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3\", combo=\"2\", target_len=0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_5",
    "sat": "def sat(states: List[str], start: str=\"55161\", combo: str=\"08362\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"55161\", combo=\"08362\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_6",
    "sat": "def sat(states: List[str], start: str=\"7572\", combo: str=\"5907\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7572\", combo=\"5907\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_7",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"5\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8\", combo=\"5\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_8",
    "sat": "def sat(states: List[str], start: str=\"90\", combo: str=\"88\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"90\", combo=\"88\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_9",
    "sat": "def sat(states: List[str], start: str=\"4678029421\", combo: str=\"7281867890\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"4678029421\", combo=\"7281867890\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_10",
    "sat": "def sat(states: List[str], start: str=\"79014\", combo: str=\"00653\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"79014\", combo=\"00653\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_11",
    "sat": "def sat(states: List[str], start: str=\"378382\", combo: str=\"668860\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"378382\", combo=\"668860\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_12",
    "sat": "def sat(states: List[str], start: str=\"6941\", combo: str=\"0486\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6941\", combo=\"0486\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_13",
    "sat": "def sat(states: List[str], start: str=\"0387219\", combo: str=\"0466903\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"0387219\", combo=\"0466903\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_14",
    "sat": "def sat(states: List[str], start: str=\"032\", combo: str=\"431\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"032\", combo=\"431\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_15",
    "sat": "def sat(states: List[str], start: str=\"36489\", combo: str=\"39221\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"36489\", combo=\"39221\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_16",
    "sat": "def sat(states: List[str], start: str=\"14\", combo: str=\"45\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"14\", combo=\"45\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_17",
    "sat": "def sat(states: List[str], start: str=\"55079\", combo: str=\"06853\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"55079\", combo=\"06853\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_18",
    "sat": "def sat(states: List[str], start: str=\"921808733\", combo: str=\"490815978\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"921808733\", combo=\"490815978\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_19",
    "sat": "def sat(states: List[str], start: str=\"1\", combo: str=\"4\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"1\", combo=\"4\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_20",
    "sat": "def sat(states: List[str], start: str=\"203673141\", combo: str=\"064239312\", target_len: int=24):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"203673141\", combo=\"064239312\", target_len=24):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_21",
    "sat": "def sat(states: List[str], start: str=\"8876943\", combo: str=\"6216563\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8876943\", combo=\"6216563\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_22",
    "sat": "def sat(states: List[str], start: str=\"7644602\", combo: str=\"1745883\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7644602\", combo=\"1745883\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_23",
    "sat": "def sat(states: List[str], start: str=\"9939826561\", combo: str=\"2177042233\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"9939826561\", combo=\"2177042233\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_24",
    "sat": "def sat(states: List[str], start: str=\"0275398698\", combo: str=\"3863797961\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"0275398698\", combo=\"3863797961\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_25",
    "sat": "def sat(states: List[str], start: str=\"97820\", combo: str=\"39977\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"97820\", combo=\"39977\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_26",
    "sat": "def sat(states: List[str], start: str=\"55\", combo: str=\"42\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"55\", combo=\"42\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_27",
    "sat": "def sat(states: List[str], start: str=\"05678\", combo: str=\"47195\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"05678\", combo=\"47195\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_28",
    "sat": "def sat(states: List[str], start: str=\"732370981\", combo: str=\"846288075\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"732370981\", combo=\"846288075\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_29",
    "sat": "def sat(states: List[str], start: str=\"255831\", combo: str=\"095922\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"255831\", combo=\"095922\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_30",
    "sat": "def sat(states: List[str], start: str=\"621415884\", combo: str=\"682654575\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"621415884\", combo=\"682654575\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_31",
    "sat": "def sat(states: List[str], start: str=\"122130627\", combo: str=\"686000101\", target_len: int=27):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"122130627\", combo=\"686000101\", target_len=27):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_32",
    "sat": "def sat(states: List[str], start: str=\"099799323\", combo: str=\"772590431\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"099799323\", combo=\"772590431\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_33",
    "sat": "def sat(states: List[str], start: str=\"95761055\", combo: str=\"38390044\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"95761055\", combo=\"38390044\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_34",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"0\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8\", combo=\"0\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_35",
    "sat": "def sat(states: List[str], start: str=\"24221\", combo: str=\"96788\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"24221\", combo=\"96788\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_36",
    "sat": "def sat(states: List[str], start: str=\"467\", combo: str=\"954\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"467\", combo=\"954\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_37",
    "sat": "def sat(states: List[str], start: str=\"622392172\", combo: str=\"685300142\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"622392172\", combo=\"685300142\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_38",
    "sat": "def sat(states: List[str], start: str=\"5735058\", combo: str=\"0804152\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5735058\", combo=\"0804152\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_39",
    "sat": "def sat(states: List[str], start: str=\"51\", combo: str=\"09\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"51\", combo=\"09\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_40",
    "sat": "def sat(states: List[str], start: str=\"14\", combo: str=\"52\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"14\", combo=\"52\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_41",
    "sat": "def sat(states: List[str], start: str=\"3\", combo: str=\"1\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3\", combo=\"1\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_42",
    "sat": "def sat(states: List[str], start: str=\"5964\", combo: str=\"9583\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5964\", combo=\"9583\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_43",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"1\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8\", combo=\"1\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_44",
    "sat": "def sat(states: List[str], start: str=\"8398\", combo: str=\"4096\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8398\", combo=\"4096\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_45",
    "sat": "def sat(states: List[str], start: str=\"61269\", combo: str=\"54357\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"61269\", combo=\"54357\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_46",
    "sat": "def sat(states: List[str], start: str=\"61\", combo: str=\"24\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"61\", combo=\"24\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_47",
    "sat": "def sat(states: List[str], start: str=\"8030\", combo: str=\"3885\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8030\", combo=\"3885\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_48",
    "sat": "def sat(states: List[str], start: str=\"594752\", combo: str=\"334954\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"594752\", combo=\"334954\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_49",
    "sat": "def sat(states: List[str], start: str=\"4930447\", combo: str=\"4030188\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"4930447\", combo=\"4030188\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_50",
    "sat": "def sat(states: List[str], start: str=\"88853874\", combo: str=\"85111832\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"88853874\", combo=\"85111832\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_51",
    "sat": "def sat(states: List[str], start: str=\"75\", combo: str=\"70\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"75\", combo=\"70\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_52",
    "sat": "def sat(states: List[str], start: str=\"365123\", combo: str=\"713146\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"365123\", combo=\"713146\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_53",
    "sat": "def sat(states: List[str], start: str=\"944210580\", combo: str=\"600879196\", target_len: int=28):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"944210580\", combo=\"600879196\", target_len=28):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_54",
    "sat": "def sat(states: List[str], start: str=\"0147304168\", combo: str=\"6231030133\", target_len: int=27):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"0147304168\", combo=\"6231030133\", target_len=27):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_55",
    "sat": "def sat(states: List[str], start: str=\"90\", combo: str=\"79\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"90\", combo=\"79\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_56",
    "sat": "def sat(states: List[str], start: str=\"392226\", combo: str=\"172861\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"392226\", combo=\"172861\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_57",
    "sat": "def sat(states: List[str], start: str=\"52976\", combo: str=\"01223\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"52976\", combo=\"01223\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_58",
    "sat": "def sat(states: List[str], start: str=\"7379\", combo: str=\"3062\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7379\", combo=\"3062\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_59",
    "sat": "def sat(states: List[str], start: str=\"93576482\", combo: str=\"17298023\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"93576482\", combo=\"17298023\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_60",
    "sat": "def sat(states: List[str], start: str=\"8816263359\", combo: str=\"4914849140\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8816263359\", combo=\"4914849140\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_61",
    "sat": "def sat(states: List[str], start: str=\"83168\", combo: str=\"06405\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"83168\", combo=\"06405\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_62",
    "sat": "def sat(states: List[str], start: str=\"7709789710\", combo: str=\"2858456193\", target_len: int=29):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7709789710\", combo=\"2858456193\", target_len=29):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_63",
    "sat": "def sat(states: List[str], start: str=\"81251322\", combo: str=\"34504312\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"81251322\", combo=\"34504312\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_64",
    "sat": "def sat(states: List[str], start: str=\"304497\", combo: str=\"647525\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"304497\", combo=\"647525\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_65",
    "sat": "def sat(states: List[str], start: str=\"2\", combo: str=\"8\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2\", combo=\"8\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_66",
    "sat": "def sat(states: List[str], start: str=\"7578573725\", combo: str=\"0245224184\", target_len: int=29):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7578573725\", combo=\"0245224184\", target_len=29):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_67",
    "sat": "def sat(states: List[str], start: str=\"56480\", combo: str=\"29327\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"56480\", combo=\"29327\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_68",
    "sat": "def sat(states: List[str], start: str=\"1\", combo: str=\"9\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"1\", combo=\"9\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_69",
    "sat": "def sat(states: List[str], start: str=\"81088\", combo: str=\"89148\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"81088\", combo=\"89148\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_70",
    "sat": "def sat(states: List[str], start: str=\"19801078\", combo: str=\"58243505\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"19801078\", combo=\"58243505\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_71",
    "sat": "def sat(states: List[str], start: str=\"6456\", combo: str=\"9419\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6456\", combo=\"9419\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_72",
    "sat": "def sat(states: List[str], start: str=\"3192688\", combo: str=\"0283336\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3192688\", combo=\"0283336\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_73",
    "sat": "def sat(states: List[str], start: str=\"5\", combo: str=\"7\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5\", combo=\"7\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_74",
    "sat": "def sat(states: List[str], start: str=\"293128\", combo: str=\"451407\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"293128\", combo=\"451407\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_75",
    "sat": "def sat(states: List[str], start: str=\"878\", combo: str=\"969\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"878\", combo=\"969\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_76",
    "sat": "def sat(states: List[str], start: str=\"526114\", combo: str=\"312729\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"526114\", combo=\"312729\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_77",
    "sat": "def sat(states: List[str], start: str=\"2941753473\", combo: str=\"3237597846\", target_len: int=28):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2941753473\", combo=\"3237597846\", target_len=28):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_78",
    "sat": "def sat(states: List[str], start: str=\"19684412\", combo: str=\"76259103\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"19684412\", combo=\"76259103\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_79",
    "sat": "def sat(states: List[str], start: str=\"20\", combo: str=\"38\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"20\", combo=\"38\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_80",
    "sat": "def sat(states: List[str], start: str=\"7929\", combo: str=\"1644\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7929\", combo=\"1644\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_81",
    "sat": "def sat(states: List[str], start: str=\"5434094109\", combo: str=\"0473933550\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5434094109\", combo=\"0473933550\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_82",
    "sat": "def sat(states: List[str], start: str=\"46706\", combo: str=\"01542\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"46706\", combo=\"01542\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_83",
    "sat": "def sat(states: List[str], start: str=\"3504804\", combo: str=\"4727097\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3504804\", combo=\"4727097\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_84",
    "sat": "def sat(states: List[str], start: str=\"5287082107\", combo: str=\"5418795951\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5287082107\", combo=\"5418795951\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_85",
    "sat": "def sat(states: List[str], start: str=\"050\", combo: str=\"990\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"050\", combo=\"990\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_86",
    "sat": "def sat(states: List[str], start: str=\"98283623\", combo: str=\"89030615\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"98283623\", combo=\"89030615\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_87",
    "sat": "def sat(states: List[str], start: str=\"5402\", combo: str=\"2036\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5402\", combo=\"2036\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_88",
    "sat": "def sat(states: List[str], start: str=\"196\", combo: str=\"986\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"196\", combo=\"986\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_89",
    "sat": "def sat(states: List[str], start: str=\"936269908\", combo: str=\"845879488\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"936269908\", combo=\"845879488\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_90",
    "sat": "def sat(states: List[str], start: str=\"6721231\", combo: str=\"7110857\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6721231\", combo=\"7110857\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_91",
    "sat": "def sat(states: List[str], start: str=\"470678\", combo: str=\"413609\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"470678\", combo=\"413609\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_92",
    "sat": "def sat(states: List[str], start: str=\"6001656\", combo: str=\"2027128\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6001656\", combo=\"2027128\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_93",
    "sat": "def sat(states: List[str], start: str=\"71708\", combo: str=\"84283\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"71708\", combo=\"84283\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_94",
    "sat": "def sat(states: List[str], start: str=\"9\", combo: str=\"7\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"9\", combo=\"7\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_95",
    "sat": "def sat(states: List[str], start: str=\"98\", combo: str=\"23\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"98\", combo=\"23\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_96",
    "sat": "def sat(states: List[str], start: str=\"780\", combo: str=\"278\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"780\", combo=\"278\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_97",
    "sat": "def sat(states: List[str], start: str=\"466004\", combo: str=\"164623\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"466004\", combo=\"164623\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_98",
    "sat": "def sat(states: List[str], start: str=\"2387379\", combo: str=\"8746063\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2387379\", combo=\"8746063\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_99",
    "sat": "def sat(states: List[str], start: str=\"298869\", combo: str=\"566402\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"298869\", combo=\"566402\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "InvertPermutation_0",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hello are you there?\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hello are you there?\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_1",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vulunolyhinesada xorasisovof rytenada bylofyhothasyjosoc w chumaqueletexteth bugicovozu vorapeky hochydoroxososehe\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vulunolyhinesada xorasisovof rytenada bylofyhothasyjosoc w chumaqueletexteth bugicovozu vorapeky hochydoroxososehe\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_2",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quir chodytufiwefes zazibohonych\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quir chodytufiwefes zazibohonych\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_3",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gotosutextes kehipik z nocut delybiwogevefy xagumykovemabezezir guwolakopigitextac laduwowivecobikorura\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gotosutextes kehipik z nocut delybiwogevefy xagumykovemabezezir guwolakopigitextac laduwowivecobikorura\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_4",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xichugutachonanokot mu syruvugolebovazy h wyth labovamabuw lytextokatextukidom mydyfocysozonet\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xichugutachonanokot mu syruvugolebovazy h wyth labovamabuw lytextokatextukidom mydyfocysozonet\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_5",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"mogalyth gyquuzuban paz tehehujinych bedanijibathasibowop textolav robuhutextylu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mogalyth gyquuzuban paz tehehujinych bedanijibathasibowop textolav robuhutextylu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_6",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xo ryhunawehikuzum thifynavaguvug mucetetacoxiv gachuw du sivizef\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xo ryhunawehikuzum thifynavaguvug mucetetacoxiv gachuw du sivizef\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_7",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xabiwoxe lup lexofatemuxaberevu fa zilutext l paxamagonac cewydyrodisizu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xabiwoxe lup lexofatemuxaberevu fa zilutext l paxamagonac cewydyrodisizu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_8",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fyrochunu pikokevogi wychacaf\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fyrochunu pikokevogi wychacaf\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_9",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"suthoruxa quimizafidyvejite gycawaquinolufe xefote dobapihobytexto motip dogiwytex\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"suthoruxa quimizafidyvejite gycawaquinolufe xefote dobapihobytexto motip dogiwytex\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_10",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fygobotozenefoxi pylat\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fygobotozenefoxi pylat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_11",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hegejinibepogafix thisoxig rilomo\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hegejinibepogafix thisoxig rilomo\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_12",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jubof gydokariq kukawefohuthopex deth\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jubof gydokariq kukawefohuthopex deth\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_13",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"mah sitiqu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mah sitiqu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_14",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thivig biquudowonim\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thivig biquudowonim\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_15",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tot dexomica chenupythuhazaxoxy vyminykerahitak halis choquyciquapu wumexijesosatextace\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tot dexomica chenupythuhazaxoxy vyminykerahitak halis choquyciquapu wumexijesosatextace\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_16",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"b t ch que wa tyronejadadu p xubovyvitextoqu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"b t ch que wa tyronejadadu p xubovyvitextoqu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_17",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jasecemitaw muthawoce\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jasecemitaw muthawoce\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_18",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hipatexterawojas vawucagisy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hipatexterawojas vawucagisy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_19",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fapobumozywe co quirymypisuci gequocasuhotextoquyg ret xogoquotextudecepuc thachytiquijus wacimexur\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fapobumozywe co quirymypisuci gequocasuhotextoquyg ret xogoquotextudecepuc thachytiquijus wacimexur\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_20",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pabykusigy xoboroko kigi thiwibowosefapazax textibuxewelubowy totan topejyziwoquux ma\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pabykusigy xoboroko kigi thiwibowosefapazax textibuxewelubowy totan topejyziwoquux ma\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_21",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gazujuwyzawih bubitextetex bometextupy zuretyvukyquaque pegidychuseh nelowazytexticutuze jat fyverivak\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gazujuwyzawih bubitextetex bometextupy zuretyvukyquaque pegidychuseh nelowazytexticutuze jat fyverivak\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_22",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quovi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quovi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_23",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"chanakorozydexizot juhaquizyrynydi wodypitextyxodadeth textoviquoraki thetagalyzyme\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chanakorozydexizot juhaquizyrynydi wodypitextyxodadeth textoviquoraki thetagalyzyme\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_24",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vuquytextytextujojyw thechocudyxire mynakazugybydu sizozirotextuvum kalih chivisovibudufoziqu delisocut dovixynatexta\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vuquytextytextujojyw thechocudyxire mynakazugybydu sizozirotextuvum kalih chivisovibudufoziqu delisocut dovixynatexta\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_25",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"balosylafic cesigomozichotahuky rothuwiw f chinithaku\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"balosylafic cesigomozichotahuky rothuwiw f chinithaku\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_26",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"f th\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"f th\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_27",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"najimadulenuwosuzeri lachifilaxanatar vyjythuthixytextoth jagygiseritextuxuhyk\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"najimadulenuwosuzeri lachifilaxanatar vyjythuthixytextoth jagygiseritextuxuhyk\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_28",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thyz fopipisy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thyz fopipisy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_29",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zokisemy thebydu xypityxopav thythajach sodicu xycho nichuzolithojybytex nypu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zokisemy thebydu xypityxopav thythajach sodicu xycho nichuzolithojybytex nypu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_30",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thybathog sonumujethyjugoqu ri zachady thec sunehudochyrakihu textasiwoquycaxecub joquigyzowohu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thybathog sonumujethyjugoqu ri zachady thec sunehudochyrakihu textasiwoquycaxecub joquigyzowohu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_31",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"viwafyte g\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"viwafyte g\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_32",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"dumequugiwicucym naryg hefamathithor betujodyl lotalafevysopefyne sonohichitheba\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"dumequugiwicucym naryg hefamathithor betujodyl lotalafevysopefyne sonohichitheba\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_33",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"chisyvoquejururomu woraputexto lojyfechalyc rurudofyquoth gycapokelasomu cytexturetextoguwech\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chisyvoquejururomu woraputexto lojyfechalyc rurudofyquoth gycapokelasomu cytexturetextoguwech\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_34",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jathocathytyxo gemivyquugix galozexucebapudesica c lolobob\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jathocathytyxo gemivyquugix galozexucebapudesica c lolobob\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_35",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wethevepehogocape\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wethevepehogocape\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_36",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"chyquethe jesepolysy mopijigocebygumiro coquajilyw\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chyquethe jesepolysy mopijigocebygumiro coquajilyw\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_37",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"nasyhahohys xythechyquy kudojowenutigi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"nasyhahohys xythechyquy kudojowenutigi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_38",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xetextyquo puch hytextugimit rijaxa m cuxirethugirywoho lelasitorix\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xetextyquo puch hytextugimit rijaxa m cuxirethugirywoho lelasitorix\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_39",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wogitextitocyli lisaxygulemec bykyge zygopusebywachyg ralij dumywibethe bejedew fesoj\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wogitextitocyli lisaxygulemec bykyge zygopusebywachyg ralij dumywibethe bejedew fesoj\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_40",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"verogerythichi lachonaxacucutyb\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"verogerythichi lachonaxacucutyb\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_41",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xovamojewib\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xovamojewib\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_42",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pomuchunybovolum chatextugi bamiquevyniwomuxuxu gar tydatuxanogegat fa\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pomuchunybovolum chatextugi bamiquevyniwomuxuxu gar tydatuxanogegat fa\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_43",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hehechyliliruna dokote sojithihymuquadate cusaz rekosufethugipifu jo bas chocesycozuxigycyryp\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hehechyliliruna dokote sojithihymuquadate cusaz rekosufethugipifu jo bas chocesycozuxigycyryp\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_44",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"rah mujotomuques jycochopevich\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"rah mujotomuques jycochopevich\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_45",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"dypigybasatexti xeq\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"dypigybasatexti xeq\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_46",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pytextufik hy nuwymuzuchanuquomafi nawuchumed kyhi xuw\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pytextufik hy nuwymuzuchanuquomafi nawuchumed kyhi xuw\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_47",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tudemytijymy nythoquigaquiryd dexu vagecenethaj\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tudemytijymy nythoquigaquiryd dexu vagecenethaj\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_48",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"haxefulyhamomequ\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"haxefulyhamomequ\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_49",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"kegody dehekagozy tesyvocyginochykib purisav chythythatext\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kegody dehekagozy tesyvocyginochykib purisav chythythatext\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_50",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quutym quethevat catibyvopepynohesy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quutym quethevat catibyvopepynohesy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_51",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"losyquytextothoc jimitex symihosujezowiv hecuchyr topivomudechepamad byq jykajukunimaxuky\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"losyquytextothoc jimitex symihosujezowiv hecuchyr topivomudechepamad byq jykajukunimaxuky\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_52",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"sabynatextocic\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"sabynatextocic\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_53",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"rykuroderetextoxyd pamykysax tex jarumatextuza pyjeluthe quakichokov quuquysekatyq\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"rykuroderetextoxyd pamykysax tex jarumatextuza pyjeluthe quakichokov quuquysekatyq\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_54",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"nuchemev zaqu mynexunumecocewitivi dytextycocupadequo mikuduchyfecihika fupotavepysofaj d\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"nuchemev zaqu mynexunumecocewitivi dytextycocupadequo mikuduchyfecihika fupotavepysofaj d\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_55",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vapuchuthymyrofiqu doth pylyxymacozitextychi vithom\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vapuchuthymyrofiqu doth pylyxymacozitextychi vithom\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_56",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zohufax jakanemidanatufut kanethycyk\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zohufax jakanemidanatufut kanethycyk\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_57",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ropozasat\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ropozasat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_58",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ritunycoxulyjihut hotho fow\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ritunycoxulyjihut hotho fow\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_59",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zik\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zik\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_60",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"mapyheniropu vawatextohihi fudukubetowapucocyjy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mapyheniropu vawatextohihi fudukubetowapucocyjy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_61",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"kitextaxutheno bihob dolethequ zethogotext wy vivokaxusywatagi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kitextaxutheno bihob dolethequ zethogotext wy vivokaxusywatagi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_62",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"texticumiqu nahajodajuwuzahuhyfy podajyfotextekutextu busesowevatext textuchexavyfivu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"texticumiqu nahajodajuwuzahuhyfy podajyfotextekutextu busesowevatext textuchexavyfivu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_63",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wabihuzachy z textikebeth jypykohezodaf textoza pudy thacyquirufocuthypis textet\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wabihuzachy z textikebeth jypykohezodaf textoza pudy thacyquirufocuthypis textet\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_64",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"j soxyja kovowechirysyro ximepakebehizofa dybutext gelythegilygadymuth tazyjelicic sihuquufa tohathojyhutextat\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"j soxyja kovowechirysyro ximepakebehizofa dybutext gelythegilygadymuth tazyjelicic sihuquufa tohathojyhutextat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_65",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gechochify sythepony ca jechyt pinirasethythaxazy quujechothiwupa nyfykimutyr zu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gechochify sythepony ca jechyt pinirasethythaxazy quujechothiwupa nyfykimutyr zu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_66",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"het vajithyhaci\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"het vajithyhaci\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_67",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gewecutufifozethach chyzoqu tokuquitextawu quohubomaf totoj logytocaluxat lech zac giwohorowaquanimy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gewecutufifozethach chyzoqu tokuquitextawu quohubomaf totoj logytocaluxat lech zac giwohorowaquanimy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_68",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jetholuropechysumexo keguloquykythywasy textix radelego quezo budirecysic sonuchotextute\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jetholuropechysumexo keguloquykythywasy textix radelego quezo budirecysic sonuchotextute\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_69",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tychumi sif gipyvesag seguz gihi totykilohykasithyth\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tychumi sif gipyvesag seguz gihi totykilohykasithyth\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_70",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"sybivocohefudezaruj giwesyt togy vo\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"sybivocohefudezaruj giwesyt togy vo\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_71",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ko hufixyjuxicygydul jebythozec buquetahupalerirot\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ko hufixyjuxicygydul jebythozec buquetahupalerirot\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_72",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"nutextuchopuzyte chatextihopuhux chofache gorichy juthefygolevom negichyzubot difuqui xajudythuquanucura fuchadygokugu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"nutextuchopuzyte chatextihopuhux chofache gorichy juthefygolevom negichyzubot difuqui xajudythuquanucura fuchadygokugu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_73",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fuxeput mysitubiqu zypasa wylikiqu gothohykyfakal pocethithibaregozo thona bubuwivyror hajidynotypoz\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fuxeput mysitubiqu zypasa wylikiqu gothohykyfakal pocethithibaregozo thona bubuwivyror hajidynotypoz\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_74",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"sunizyzofufohyn va nuroratufokohudomon fexiparo fybevujin nirinojelecul\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"sunizyzofufohyn va nuroratufokohudomon fexiparo fybevujin nirinojelecul\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_75",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gilukifaratexticylan vynagocatyfiquogujig\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gilukifaratexticylan vynagocatyfiquogujig\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_76",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"cemyxugax maboniq chethogytextetuxed gabuthofuthewukequ xikyli\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"cemyxugax maboniq chethogytextetuxed gabuthofuthewukequ xikyli\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_77",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thogocovapodat cafyjuhijama fycithuj piraquupatewigebythi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thogocovapodat cafyjuhijama fycithuj piraquupatewigebythi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_78",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tagimodyryjowotexty nuthurased\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tagimodyryjowotexty nuthurased\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_79",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"textufuque kykacozed chethachuzizotextafa kewab cudax jo pifosylodiletex textejetextetextaka\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"textufuque kykacozed chethachuzizotextafa kewab cudax jo pifosylodiletex textejetextetextaka\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_80",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ryzugacheq darudy guquecojitextuxumef\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ryzugacheq darudy guquecojitextuxumef\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_81",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jenilasoquyq depusufavokiquo pijob kerudatozyfasochu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jenilasoquyq depusufavokiquo pijob kerudatozyfasochu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_82",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tiquukag vufijijery textec surathu cebazopajani mequoveremyp pikicycutopemuhukoni cowugotexte\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tiquukag vufijijery textec surathu cebazopajani mequoveremyp pikicycutopemuhukoni cowugotexte\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_83",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quetygach chus textytextovydytex cugapahyku d zuwoladujudacutex dovucoxotextomazot qua ty\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quetygach chus textytextovydytex cugapahyku d zuwoladujudacutex dovucoxotextomazot qua ty\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_84",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tochuchevexelavuteda ce hach fuf rafazichokojothiz dytenurojihethi chaji dasig pot\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tochuchevexelavuteda ce hach fuf rafazichokojothiz dytenurojihethi chaji dasig pot\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_85",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hoseq sopuc fibafiladym bapuhavysi na fyfuxiwokowyvi zypyx henithythaxi sejethequahithyc\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hoseq sopuc fibafiladym bapuhavysi na fyfuxiwokowyvi zypyx henithythaxi sejethequahithyc\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_86",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ha kefywag fepel rewekutha gucosew noroz quavutexta\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ha kefywag fepel rewekutha gucosew noroz quavutexta\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_87",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"le ze go murawulachochitext quygymevethulyzazo\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"le ze go murawulachochitext quygymevethulyzazo\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_88",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"dycypuz textasuthathe thahythetha quonychew libaruteth cufomyquyxefewe netextyth thyc je\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"dycypuz textasuthathe thahythetha quonychew libaruteth cufomyquyxefewe netextyth thyc je\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_89",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ris fabaxy gugyquachetext fixejozebofute t kusosutedykily quaquytextychajugy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ris fabaxy gugyquachetext fixejozebofute t kusosutedykily quaquytextychajugy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_90",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"textohipu tuwatextihejajes thich vi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"textohipu tuwatextihejajes thich vi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_91",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wohul chan bohuhovomykacu puryzejajetextarop hocutextegifeque mequojuxowivychusich papamutextitiherito fykuhemywynichetexti\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wohul chan bohuhovomykacu puryzejajetextarop hocutextegifeque mequojuxowivychusich papamutextitiherito fykuhemywynichetexti\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_92",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"potextixyqu jochonyh fipywitextyxukelavom ma zothymesu quylygaxe tuzuxehufu wyfyvatext mokuvycotoco\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"potextixyqu jochonyh fipywitextyxukelavom ma zothymesu quylygaxe tuzuxehufu wyfyvatext mokuvycotoco\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_93",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vil mequofe tubachyminekumuv quacy kyb novirudozy thafitarywiratono\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vil mequofe tubachyminekumuv quacy kyb novirudozy thafitarywiratono\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_94",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"kifagebunedothete jaxajirelugut gyme quamibyji hokarazodetezafyquu lulechuthichukopif\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kifagebunedothete jaxajirelugut gyme quamibyji hokarazodetezafyquu lulechuthichukopif\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_95",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pelyvi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pelyvi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_96",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zusitikit cechewiquov texto\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zusitikit cechewiquov texto\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_97",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"judu wutad\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"judu wutad\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_98",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fehaquiwoxocih thuquasyquedapuquequ cuzichubak sazugyditext sodufahotextitex x dyvirira cuchivygelasafiwy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fehaquiwoxocih thuquasyquedapuquequ cuzichubak sazugyditext sodufahotextitex x dyvirira cuchivygelasafiwy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_99",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quu cirufup cymevudyloxirujivac\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quu cirufup cymevudyloxirujivac\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "SameDifferent_0",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_1",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 8, 7, 1, 9, 4, 7, 3, 7, 7, 7, 4, 6, 4, 8, 7, 0, 1, 2, 2, 4, 0, 2, 1, 6, 3, 5, 8, 5, 7, 7, 7, 2, 6, 9, 8, 9, 4, 5, 7, 2, 9, 9, 0, 5, 0, 5, 7, 9, 1, 6, 8, 9, 2, 2, 3, 4, 5, 4, 6, 7, 3, 3, 1, 3, 8, 2, 4, 2, 4, 4, 5, 0, 9, 7, 9, 3, 2, 1, 6, 0, 3], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 8, 7, 1, 9, 4, 7, 3, 7, 7, 7, 4, 6, 4, 8, 7, 0, 1, 2, 2, 4, 0, 2, 1, 6, 3, 5, 8, 5, 7, 7, 7, 2, 6, 9, 8, 9, 4, 5, 7, 2, 9, 9, 0, 5, 0, 5, 7, 9, 1, 6, 8, 9, 2, 2, 3, 4, 5, 4, 6, 7, 3, 3, 1, 3, 8, 2, 4, 2, 4, 4, 5, 0, 9, 7, 9, 3, 2, 1, 6, 0, 3], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_2",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 0, 4, 6, 9, 9, 6, 3, 0, 9, 4, 0, 9, 2, 3, 3, 4, 4, 9, 1, 7, 0, 8, 2, 1, 2, 2, 7, 7, 5, 2, 5, 3, 2, 2, 8, 6, 9, 2, 0, 7, 4, 3, 2, 7, 2, 7, 5, 1, 0, 2, 6, 0, 6, 0, 2, 7, 0, 1, 4, 7, 5, 9, 8, 0, 8, 7, 8, 3, 4, 3, 9, 9, 1, 9, 4, 5, 9, 9, 2, 3, 2, 2, 4, 4, 9, 3, 5, 5, 7, 6, 0, 3, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 0, 4, 6, 9, 9, 6, 3, 0, 9, 4, 0, 9, 2, 3, 3, 4, 4, 9, 1, 7, 0, 8, 2, 1, 2, 2, 7, 7, 5, 2, 5, 3, 2, 2, 8, 6, 9, 2, 0, 7, 4, 3, 2, 7, 2, 7, 5, 1, 0, 2, 6, 0, 6, 0, 2, 7, 0, 1, 4, 7, 5, 9, 8, 0, 8, 7, 8, 3, 4, 3, 9, 9, 1, 9, 4, 5, 9, 9, 2, 3, 2, 2, 4, 4, 9, 3, 5, 5, 7, 6, 0, 3, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_3",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 1, 7, 8, 8, 8, 8, 8, 0, 4, 5, 0, 0, 4, 8, 9, 2, 5, 4, 1, 6, 8, 0, 2, 9, 4, 3, 5, 2, 6, 1, 5, 9, 4, 1, 9, 7, 3, 2, 8, 8, 0, 0, 0, 8, 1, 4, 5, 4, 4, 6, 8, 1, 3, 9, 1, 9, 1, 3, 8, 6, 5, 0], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 1, 7, 8, 8, 8, 8, 8, 0, 4, 5, 0, 0, 4, 8, 9, 2, 5, 4, 1, 6, 8, 0, 2, 9, 4, 3, 5, 2, 6, 1, 5, 9, 4, 1, 9, 7, 3, 2, 8, 8, 0, 0, 0, 8, 1, 4, 5, 4, 4, 6, 8, 1, 3, 9, 1, 9, 1, 3, 8, 6, 5, 0], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_4",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 7, 5, 8, 2, 7, 4, 8, 4, 5, 9, 0, 4, 9, 3, 1, 1, 3, 2, 9, 1, 6, 8, 4, 9, 7, 5, 1, 5, 6, 7, 9, 1, 9, 4, 1, 5, 1, 5], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 7, 5, 8, 2, 7, 4, 8, 4, 5, 9, 0, 4, 9, 3, 1, 1, 3, 2, 9, 1, 6, 8, 4, 9, 7, 5, 1, 5, 6, 7, 9, 1, 9, 4, 1, 5, 1, 5], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_5",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 5, 5, 6, 1, 0, 6, 3, 8, 4, 6, 9, 0, 2, 3, 0, 0, 3, 3, 6, 9, 7, 4, 0, 7, 3, 1, 7, 0, 1, 9, 8, 7, 5, 0, 4, 4, 6], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 5, 5, 6, 1, 0, 6, 3, 8, 4, 6, 9, 0, 2, 3, 0, 0, 3, 3, 6, 9, 7, 4, 0, 7, 3, 1, 7, 0, 1, 9, 8, 7, 5, 0, 4, 4, 6], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_6",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 3, 1, 2, 0, 9, 3, 3, 0, 9, 8, 9, 8, 6, 5, 8, 1, 0, 0, 4, 9, 3, 5, 4, 2, 3, 3, 4, 0, 0, 6, 5, 0, 5, 5, 0, 3, 1, 3, 8, 5, 3, 4, 8, 1, 2, 5, 4, 0, 9, 1, 6, 8, 1, 5, 7, 1, 3, 6, 5, 1, 6, 6, 1, 8, 1], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 3, 1, 2, 0, 9, 3, 3, 0, 9, 8, 9, 8, 6, 5, 8, 1, 0, 0, 4, 9, 3, 5, 4, 2, 3, 3, 4, 0, 0, 6, 5, 0, 5, 5, 0, 3, 1, 3, 8, 5, 3, 4, 8, 1, 2, 5, 4, 0, 9, 1, 6, 8, 1, 5, 7, 1, 3, 6, 5, 1, 6, 6, 1, 8, 1], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_7",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 3, 0, 8, 8, 9, 3, 1, 6, 1, 2, 9, 2, 0, 0, 6, 8, 8, 0, 9, 0, 5, 2, 9, 5, 3, 3, 4, 4, 4, 3, 9, 9, 9, 4, 6, 7, 5, 8, 3, 8, 2, 4, 4, 3, 6, 4, 1, 4, 1, 8, 4, 7, 8, 5, 0, 9, 5, 9, 5, 7, 5, 4, 7, 1, 7, 5, 9, 5, 5, 3, 4, 2, 9, 4, 0, 6, 6, 4, 7, 5, 0, 4, 4, 9, 9, 0, 6, 1, 7, 2, 5, 1, 7, 1, 4, 0, 3], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 3, 0, 8, 8, 9, 3, 1, 6, 1, 2, 9, 2, 0, 0, 6, 8, 8, 0, 9, 0, 5, 2, 9, 5, 3, 3, 4, 4, 4, 3, 9, 9, 9, 4, 6, 7, 5, 8, 3, 8, 2, 4, 4, 3, 6, 4, 1, 4, 1, 8, 4, 7, 8, 5, 0, 9, 5, 9, 5, 7, 5, 4, 7, 1, 7, 5, 9, 5, 5, 3, 4, 2, 9, 4, 0, 6, 6, 4, 7, 5, 0, 4, 4, 9, 9, 0, 6, 1, 7, 2, 5, 1, 7, 1, 4, 0, 3], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_8",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 2, 8, 4, 4, 6, 8, 4], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 2, 8, 4, 4, 6, 8, 4], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_9",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 8, 4, 3, 0, 9, 8, 8, 3, 2, 8, 4, 5, 7, 6, 8, 7, 5, 2, 1, 2, 4, 7, 1, 2, 9, 7, 8, 8, 2, 0, 8, 4, 3, 7, 2, 4, 2, 8, 5, 8, 7, 8, 4, 6, 3, 8, 6, 7, 8, 5, 5, 1, 4, 8, 5, 4, 1, 4, 8, 7, 0], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 8, 4, 3, 0, 9, 8, 8, 3, 2, 8, 4, 5, 7, 6, 8, 7, 5, 2, 1, 2, 4, 7, 1, 2, 9, 7, 8, 8, 2, 0, 8, 4, 3, 7, 2, 4, 2, 8, 5, 8, 7, 8, 4, 6, 3, 8, 6, 7, 8, 5, 5, 1, 4, 8, 5, 4, 1, 4, 8, 7, 0], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_10",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 4, 6, 7, 6, 0, 8, 0, 1, 7, 5, 3, 4, 7, 0, 4, 9, 0, 5, 7, 8, 7, 1, 0, 0, 5, 3, 7, 7, 7, 8, 7, 7, 6, 7, 3, 7, 2, 8, 0, 0, 6, 3, 8, 6, 0, 1, 4, 0, 7, 0, 2, 0, 4, 9, 2, 7, 4, 2, 0, 7, 6, 6, 3, 9, 1, 9, 6, 1, 8, 9, 3, 0, 2, 2, 8, 1, 0], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 4, 6, 7, 6, 0, 8, 0, 1, 7, 5, 3, 4, 7, 0, 4, 9, 0, 5, 7, 8, 7, 1, 0, 0, 5, 3, 7, 7, 7, 8, 7, 7, 6, 7, 3, 7, 2, 8, 0, 0, 6, 3, 8, 6, 0, 1, 4, 0, 7, 0, 2, 0, 4, 9, 2, 7, 4, 2, 0, 7, 6, 6, 3, 9, 1, 9, 6, 1, 8, 9, 3, 0, 2, 2, 8, 1, 0], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_11",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 3, 3, 4, 4, 9, 5, 7, 9, 0, 0, 5, 6, 1, 5, 2, 9], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 3, 3, 4, 4, 9, 5, 7, 9, 0, 0, 5, 6, 1, 5, 2, 9], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_12",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[9, 2, 4, 6, 8, 5, 6, 4, 8, 7, 6, 5, 5, 6], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[9, 2, 4, 6, 8, 5, 6, 4, 8, 7, 6, 5, 5, 6], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_13",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 6, 6, 7, 8, 4, 2, 1, 7, 6, 5, 9, 1, 7, 5, 9, 0, 5, 3, 0, 3, 3, 7, 6, 0, 2, 9, 7, 0, 4, 5, 7, 9, 8, 4, 0, 0, 5, 7, 1, 9, 4, 5, 4, 7, 2, 8, 5, 4, 5, 2, 4, 9], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 6, 6, 7, 8, 4, 2, 1, 7, 6, 5, 9, 1, 7, 5, 9, 0, 5, 3, 0, 3, 3, 7, 6, 0, 2, 9, 7, 0, 4, 5, 7, 9, 8, 4, 0, 0, 5, 7, 1, 9, 4, 5, 4, 7, 2, 8, 5, 4, 5, 2, 4, 9], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_14",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 7, 5, 6, 2, 1, 2, 6, 7, 1, 6, 1, 3, 9, 1, 1, 4, 4, 5, 6, 2, 5, 2, 6, 3, 3, 4, 0, 2, 3, 1, 6, 3, 9, 9, 4, 9], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 7, 5, 6, 2, 1, 2, 6, 7, 1, 6, 1, 3, 9, 1, 1, 4, 4, 5, 6, 2, 5, 2, 6, 3, 3, 4, 0, 2, 3, 1, 6, 3, 9, 9, 4, 9], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_15",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[9, 2, 0, 5, 0, 9, 4, 0, 7, 4, 5, 2, 8, 2, 7, 2, 4, 0, 7, 3, 8], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[9, 2, 0, 5, 0, 9, 4, 0, 7, 4, 5, 2, 8, 2, 7, 2, 4, 0, 7, 3, 8], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_16",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 2, 3, 0, 3, 7, 2, 8, 0, 6, 1, 8, 0, 9, 4, 4, 5, 4, 3, 0, 3, 3, 8, 6, 8, 9, 3, 1, 1, 7, 9, 1, 9, 1, 6, 0, 2, 2, 8, 0, 2, 2, 4, 6, 0, 5, 5, 8, 9, 3, 4, 4, 1, 7, 2, 9, 0, 2, 6, 5, 4, 8, 9, 6, 6, 9, 6, 4, 9, 2, 8, 7, 3, 7, 7], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 2, 3, 0, 3, 7, 2, 8, 0, 6, 1, 8, 0, 9, 4, 4, 5, 4, 3, 0, 3, 3, 8, 6, 8, 9, 3, 1, 1, 7, 9, 1, 9, 1, 6, 0, 2, 2, 8, 0, 2, 2, 4, 6, 0, 5, 5, 8, 9, 3, 4, 4, 1, 7, 2, 9, 0, 2, 6, 5, 4, 8, 9, 6, 6, 9, 6, 4, 9, 2, 8, 7, 3, 7, 7], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_17",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 4, 9, 4, 0, 9, 0, 8, 4, 6, 5, 2, 8, 4, 5, 4, 9, 2, 1, 2, 4, 9, 1, 9, 9, 5, 0, 7, 7, 6, 9, 9, 1, 4, 9, 8, 6, 4, 7, 8, 2, 3, 5, 1, 0, 4, 6, 4, 4, 3, 0, 5, 1, 4, 1, 0, 5, 5, 4, 5], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 4, 9, 4, 0, 9, 0, 8, 4, 6, 5, 2, 8, 4, 5, 4, 9, 2, 1, 2, 4, 9, 1, 9, 9, 5, 0, 7, 7, 6, 9, 9, 1, 4, 9, 8, 6, 4, 7, 8, 2, 3, 5, 1, 0, 4, 6, 4, 4, 3, 0, 5, 1, 4, 1, 0, 5, 5, 4, 5], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_18",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 8, 8, 8, 4, 2, 7, 4, 4, 9, 7, 3, 1, 6, 4, 4, 5, 4, 4, 7, 2, 9, 0, 3, 4, 8, 8, 1, 4, 3, 0, 1, 2, 7, 7, 9, 3, 1, 2, 4, 1], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 8, 8, 8, 4, 2, 7, 4, 4, 9, 7, 3, 1, 6, 4, 4, 5, 4, 4, 7, 2, 9, 0, 3, 4, 8, 8, 1, 4, 3, 0, 1, 2, 7, 7, 9, 3, 1, 2, 4, 1], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_19",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 2, 3, 8, 5, 2, 2, 4, 6, 0, 6, 1, 4, 8, 7, 9, 7, 3, 2, 3, 1, 7, 0, 5, 3, 2, 5, 7, 5, 6, 2, 1, 6, 3, 5, 0, 7, 3, 8, 6, 7, 9, 3, 9, 9, 4, 8, 9, 6, 7, 5, 1, 4, 5, 6], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 2, 3, 8, 5, 2, 2, 4, 6, 0, 6, 1, 4, 8, 7, 9, 7, 3, 2, 3, 1, 7, 0, 5, 3, 2, 5, 7, 5, 6, 2, 1, 6, 3, 5, 0, 7, 3, 8, 6, 7, 9, 3, 9, 9, 4, 8, 9, 6, 7, 5, 1, 4, 5, 6], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_20",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 7, 1, 4, 0, 2, 1, 2, 7, 6, 7, 5, 5, 0, 7, 8, 2, 2, 1, 6, 3, 2, 6, 4, 1, 0, 0, 4, 0, 9, 5, 2, 6, 0, 3, 9, 1, 6, 4, 0, 7, 0, 1, 8, 8, 8, 2, 9, 4, 5, 0, 4, 7, 4, 7, 9, 2, 9, 8, 2, 6, 4, 7, 2, 4, 8, 7, 0, 0, 0, 6, 1, 1, 8, 0, 2, 3, 4, 5, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 7, 1, 4, 0, 2, 1, 2, 7, 6, 7, 5, 5, 0, 7, 8, 2, 2, 1, 6, 3, 2, 6, 4, 1, 0, 0, 4, 0, 9, 5, 2, 6, 0, 3, 9, 1, 6, 4, 0, 7, 0, 1, 8, 8, 8, 2, 9, 4, 5, 0, 4, 7, 4, 7, 9, 2, 9, 8, 2, 6, 4, 7, 2, 4, 8, 7, 0, 0, 0, 6, 1, 1, 8, 0, 2, 3, 4, 5, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_21",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 5, 6, 7, 8, 2, 1, 4, 2, 1, 1, 2, 3, 1, 4, 4, 4, 3, 2, 1, 7, 5, 4, 5, 2, 2, 4, 3, 6, 3, 8, 3, 4, 8, 4, 1, 9, 8, 0, 4, 1, 5, 5, 8, 6, 6, 9, 2, 7, 5, 6, 8, 5, 2, 3, 3, 5, 6, 8, 0, 7, 3, 3, 7, 5, 9, 0, 9, 3, 1, 3, 7], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 5, 6, 7, 8, 2, 1, 4, 2, 1, 1, 2, 3, 1, 4, 4, 4, 3, 2, 1, 7, 5, 4, 5, 2, 2, 4, 3, 6, 3, 8, 3, 4, 8, 4, 1, 9, 8, 0, 4, 1, 5, 5, 8, 6, 6, 9, 2, 7, 5, 6, 8, 5, 2, 3, 3, 5, 6, 8, 0, 7, 3, 3, 7, 5, 9, 0, 9, 3, 1, 3, 7], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_22",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 3, 8, 6, 2, 3, 1, 3, 2, 2, 9, 7, 0, 5, 7, 9, 7, 0, 9, 4, 0, 1, 8, 4], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 3, 8, 6, 2, 3, 1, 3, 2, 2, 9, 7, 0, 5, 7, 9, 7, 0, 9, 4, 0, 1, 8, 4], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_23",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 5, 0, 9, 6], length: int=1):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 5, 0, 9, 6], length=1):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_24",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 5, 1, 7, 5, 5, 7, 2, 0, 0, 6, 2, 2, 2, 9, 2, 7, 7, 8, 4], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 5, 1, 7, 5, 5, 7, 2, 0, 0, 6, 2, 2, 2, 9, 2, 7, 7, 8, 4], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_25",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 5, 5, 5, 3, 2, 9, 8, 0, 3, 4, 3, 4, 6, 3, 4, 8, 1, 3, 2, 4, 2, 7, 0, 9, 9, 8, 1, 7, 9, 2], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 5, 5, 5, 3, 2, 9, 8, 0, 3, 4, 3, 4, 6, 3, 4, 8, 1, 3, 2, 4, 2, 7, 0, 9, 9, 8, 1, 7, 9, 2], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_26",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 4, 6, 8, 9, 8, 6, 9, 8, 7, 6, 8, 9, 9, 9, 0, 6, 2, 6, 7, 6, 1, 9, 3, 4, 5, 4, 4, 8, 4, 4, 7, 1, 4, 3, 6, 1, 9, 5, 5, 2, 5, 2, 7, 4, 0, 5, 4, 1, 2, 0, 4, 8, 0, 0, 3, 9, 2, 3, 5, 3, 7, 3, 0, 6, 5, 9, 0, 7, 5, 4, 4, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 4, 6, 8, 9, 8, 6, 9, 8, 7, 6, 8, 9, 9, 9, 0, 6, 2, 6, 7, 6, 1, 9, 3, 4, 5, 4, 4, 8, 4, 4, 7, 1, 4, 3, 6, 1, 9, 5, 5, 2, 5, 2, 7, 4, 0, 5, 4, 1, 2, 0, 4, 8, 0, 0, 3, 9, 2, 3, 5, 3, 7, 3, 0, 6, 5, 9, 0, 7, 5, 4, 4, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_27",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 2, 5, 2, 2, 8, 6, 1, 9, 7, 9, 0, 0, 2, 6, 1, 0, 7, 4, 1, 6, 1, 6, 8, 5, 3, 5, 5, 8, 0, 7, 4, 7, 3, 8, 6, 9, 6, 3, 0, 4, 6, 9, 2, 0, 4, 2, 1, 2, 8, 9, 0, 6, 7, 7, 8, 8, 7, 5, 5, 9, 0, 9, 6, 3, 2, 7, 8], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 2, 5, 2, 2, 8, 6, 1, 9, 7, 9, 0, 0, 2, 6, 1, 0, 7, 4, 1, 6, 1, 6, 8, 5, 3, 5, 5, 8, 0, 7, 4, 7, 3, 8, 6, 9, 6, 3, 0, 4, 6, 9, 2, 0, 4, 2, 1, 2, 8, 9, 0, 6, 7, 7, 8, 8, 7, 5, 5, 9, 0, 9, 6, 3, 2, 7, 8], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_28",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 2, 1, 2, 1, 7, 3, 9, 0, 9, 0, 0, 3, 3, 7, 7, 1, 8, 7, 5, 4, 1, 9, 3, 9, 1, 3, 6, 1, 8, 9, 8, 3, 4, 1, 1, 9, 0, 4, 4, 3, 1, 6, 9, 9, 0, 3, 6, 1, 2, 7, 2, 6, 8, 5, 2, 7, 2, 8, 8, 3, 8, 2, 4, 6, 6, 0, 7, 9, 1, 4, 0, 2, 4, 6, 5, 1, 6, 4, 9, 0, 8, 6, 9, 9, 1, 1, 9, 6, 7, 0, 7, 7, 3, 3], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 2, 1, 2, 1, 7, 3, 9, 0, 9, 0, 0, 3, 3, 7, 7, 1, 8, 7, 5, 4, 1, 9, 3, 9, 1, 3, 6, 1, 8, 9, 8, 3, 4, 1, 1, 9, 0, 4, 4, 3, 1, 6, 9, 9, 0, 3, 6, 1, 2, 7, 2, 6, 8, 5, 2, 7, 2, 8, 8, 3, 8, 2, 4, 6, 6, 0, 7, 9, 1, 4, 0, 2, 4, 6, 5, 1, 6, 4, 9, 0, 8, 6, 9, 9, 1, 1, 9, 6, 7, 0, 7, 7, 3, 3], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_29",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 0, 7, 1, 8, 7, 4, 6, 0, 5, 5, 0, 4], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 0, 7, 1, 8, 7, 4, 6, 0, 5, 5, 0, 4], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_30",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 6, 6, 1, 9, 5, 4], length: int=2):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 6, 6, 1, 9, 5, 4], length=2):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_31",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 8, 7, 3, 9, 1, 9, 1, 0, 3, 2, 3, 8, 6, 1], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 8, 7, 3, 9, 1, 9, 1, 0, 3, 2, 3, 8, 6, 1], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_32",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 8, 5, 1, 3, 3, 2, 0, 4, 3, 0, 2, 4, 4, 5, 6, 9, 8, 6, 0, 3, 7, 5, 4, 1, 1, 8, 6, 3, 5, 5, 5, 6, 0, 3, 0, 5, 1, 1, 3, 0, 0, 6, 6, 3, 6, 1, 1, 9, 6, 7, 0, 7, 3, 6, 8, 2, 7, 1, 0, 4], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 8, 5, 1, 3, 3, 2, 0, 4, 3, 0, 2, 4, 4, 5, 6, 9, 8, 6, 0, 3, 7, 5, 4, 1, 1, 8, 6, 3, 5, 5, 5, 6, 0, 3, 0, 5, 1, 1, 3, 0, 0, 6, 6, 3, 6, 1, 1, 9, 6, 7, 0, 7, 3, 6, 8, 2, 7, 1, 0, 4], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_33",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 3, 8, 2, 9, 2, 6, 1, 1, 5, 6, 1, 2, 6, 8, 0, 4, 8, 4, 8, 6, 9, 3, 9, 1, 8, 5, 0, 4, 3, 0, 0, 1, 6, 1, 8, 7, 8, 4, 8, 0, 7, 7, 3, 8, 2, 0, 5, 5, 5, 7, 9, 2, 3, 7, 0, 5], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 3, 8, 2, 9, 2, 6, 1, 1, 5, 6, 1, 2, 6, 8, 0, 4, 8, 4, 8, 6, 9, 3, 9, 1, 8, 5, 0, 4, 3, 0, 0, 1, 6, 1, 8, 7, 8, 4, 8, 0, 7, 7, 3, 8, 2, 0, 5, 5, 5, 7, 9, 2, 3, 7, 0, 5], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_34",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 7, 6, 4, 5, 2, 4, 4, 8, 6, 2, 8, 0, 3, 3, 8, 4, 1, 0, 1, 5, 7, 7, 0, 7, 2, 5, 9, 8, 0, 0, 5, 5, 0, 5, 8, 0, 2, 6, 4, 2, 1, 8, 2, 7, 4, 7, 4, 6, 9, 1, 7, 8, 6, 6, 5, 8, 9, 6, 3, 0, 1, 9, 3, 6, 4, 8, 3, 0, 3], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 7, 6, 4, 5, 2, 4, 4, 8, 6, 2, 8, 0, 3, 3, 8, 4, 1, 0, 1, 5, 7, 7, 0, 7, 2, 5, 9, 8, 0, 0, 5, 5, 0, 5, 8, 0, 2, 6, 4, 2, 1, 8, 2, 7, 4, 7, 4, 6, 9, 1, 7, 8, 6, 6, 5, 8, 9, 6, 3, 0, 1, 9, 3, 6, 4, 8, 3, 0, 3], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_35",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 0, 5, 0, 1, 2, 9, 7, 5, 8, 9, 2, 1, 7, 9, 2, 2, 5, 6, 9, 2, 3, 8, 0, 6, 1, 8, 3, 6, 3, 3, 7, 3, 9, 8, 6, 4, 4, 9, 2, 1, 9, 3, 5, 3, 6, 7, 6, 2, 7, 1, 4, 6, 5, 4, 9, 8, 5, 2, 5, 0, 1, 8], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 0, 5, 0, 1, 2, 9, 7, 5, 8, 9, 2, 1, 7, 9, 2, 2, 5, 6, 9, 2, 3, 8, 0, 6, 1, 8, 3, 6, 3, 3, 7, 3, 9, 8, 6, 4, 4, 9, 2, 1, 9, 3, 5, 3, 6, 7, 6, 2, 7, 1, 4, 6, 5, 4, 9, 8, 5, 2, 5, 0, 1, 8], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_36",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 9, 7, 3, 5, 5, 6, 5], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 9, 7, 3, 5, 5, 6, 5], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_37",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 1, 9, 7, 2, 2, 4, 2, 7, 4, 2, 5, 9, 3, 9, 8, 7, 3, 0, 8, 3, 3, 2, 4, 8, 7, 2, 2, 1, 8, 6, 0, 6, 3, 2, 5, 5, 2, 6, 2, 6, 6, 0, 4, 1, 0, 1, 9, 4, 9, 8, 8, 7, 5, 6, 7, 2, 0, 1, 1, 3, 9, 5, 4, 2, 4, 8, 1, 7, 5, 9, 0], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 1, 9, 7, 2, 2, 4, 2, 7, 4, 2, 5, 9, 3, 9, 8, 7, 3, 0, 8, 3, 3, 2, 4, 8, 7, 2, 2, 1, 8, 6, 0, 6, 3, 2, 5, 5, 2, 6, 2, 6, 6, 0, 4, 1, 0, 1, 9, 4, 9, 8, 8, 7, 5, 6, 7, 2, 0, 1, 1, 3, 9, 5, 4, 2, 4, 8, 1, 7, 5, 9, 0], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_38",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 2, 1, 0, 7, 0, 9, 6, 4, 7, 4, 6, 6, 5, 4, 0, 3, 6, 0, 6, 6, 1, 4, 2, 4, 0, 1, 2, 2, 7, 0, 0], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 2, 1, 0, 7, 0, 9, 6, 4, 7, 4, 6, 6, 5, 4, 0, 3, 6, 0, 6, 6, 1, 4, 2, 4, 0, 1, 2, 2, 7, 0, 0], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_39",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 9, 6, 2, 0, 4, 0, 5, 2, 5, 8, 6, 4, 6, 4, 5, 6, 6, 9, 5, 0, 4, 6, 4, 8, 6], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 9, 6, 2, 0, 4, 0, 5, 2, 5, 8, 6, 4, 6, 4, 5, 6, 6, 9, 5, 0, 4, 6, 4, 8, 6], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_40",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 5, 2, 2, 3, 1, 1, 7, 0, 5, 8, 7, 9, 3, 3, 1, 8, 2, 8, 4, 3, 4, 0, 6, 5, 7, 2, 3, 6, 5, 5, 7, 2, 6, 1, 7, 4, 1, 7], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 5, 2, 2, 3, 1, 1, 7, 0, 5, 8, 7, 9, 3, 3, 1, 8, 2, 8, 4, 3, 4, 0, 6, 5, 7, 2, 3, 6, 5, 5, 7, 2, 6, 1, 7, 4, 1, 7], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_41",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 9, 8, 0, 3, 3, 3, 1, 2, 9, 2, 9, 6, 7, 7, 1, 0, 8, 3, 6, 2, 4, 5, 4, 8, 8, 5, 4, 2, 0], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 9, 8, 0, 3, 3, 3, 1, 2, 9, 2, 9, 6, 7, 7, 1, 0, 8, 3, 6, 2, 4, 5, 4, 8, 8, 5, 4, 2, 0], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_42",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 0, 1, 7, 9, 3, 3, 1, 9, 1, 3, 3, 8, 9, 6, 7, 7, 2, 6, 5, 3, 1, 4, 6, 0, 7, 7, 7, 8, 6, 1, 1, 7, 0, 5, 8, 8, 7, 4, 8, 2, 3, 0, 0, 1, 2, 0, 3, 2, 5, 9, 4, 7, 6, 8, 7, 3, 8, 7, 7, 8, 4, 2, 6, 4, 8, 3, 0, 9, 4, 0, 5, 8, 9, 9, 2, 8, 9, 3, 6, 0, 0, 1, 6, 7, 6], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 0, 1, 7, 9, 3, 3, 1, 9, 1, 3, 3, 8, 9, 6, 7, 7, 2, 6, 5, 3, 1, 4, 6, 0, 7, 7, 7, 8, 6, 1, 1, 7, 0, 5, 8, 8, 7, 4, 8, 2, 3, 0, 0, 1, 2, 0, 3, 2, 5, 9, 4, 7, 6, 8, 7, 3, 8, 7, 7, 8, 4, 2, 6, 4, 8, 3, 0, 9, 4, 0, 5, 8, 9, 9, 2, 8, 9, 3, 6, 0, 0, 1, 6, 7, 6], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_43",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 3, 8, 4, 6, 3, 7, 7, 8, 4, 2, 4, 3, 3, 1, 9, 6, 4, 3, 5, 4, 4, 3, 0, 0, 0, 5, 0, 1, 6, 8, 5, 1, 4, 0, 2, 9, 2, 6, 8, 6, 2, 4, 3, 7, 2, 1, 2, 7], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 3, 8, 4, 6, 3, 7, 7, 8, 4, 2, 4, 3, 3, 1, 9, 6, 4, 3, 5, 4, 4, 3, 0, 0, 0, 5, 0, 1, 6, 8, 5, 1, 4, 0, 2, 9, 2, 6, 8, 6, 2, 4, 3, 7, 2, 1, 2, 7], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_44",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 5, 5, 0, 0, 2, 7, 2, 8, 7, 6, 5, 5, 8, 3, 0, 4, 3, 3, 6, 9, 5, 5, 9, 0, 0, 0, 8, 8, 8, 4, 9, 6, 2, 9, 2, 5, 6, 5, 9, 6, 8, 5, 5, 1, 7, 4, 8, 8, 0, 5, 9, 2, 7, 0, 6, 3, 0, 2, 6, 7, 5, 0, 0, 9, 4, 6, 2, 1, 2, 2, 2, 6, 9, 9, 7, 1, 9, 3, 7], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 5, 5, 0, 0, 2, 7, 2, 8, 7, 6, 5, 5, 8, 3, 0, 4, 3, 3, 6, 9, 5, 5, 9, 0, 0, 0, 8, 8, 8, 4, 9, 6, 2, 9, 2, 5, 6, 5, 9, 6, 8, 5, 5, 1, 7, 4, 8, 8, 0, 5, 9, 2, 7, 0, 6, 3, 0, 2, 6, 7, 5, 0, 0, 9, 4, 6, 2, 1, 2, 2, 2, 6, 9, 9, 7, 1, 9, 3, 7], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_45",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 2, 7, 5, 3, 1, 6, 1, 8, 8, 5, 5, 3, 6, 2, 0, 5, 3, 3, 2, 5, 6, 8, 0, 1, 0, 8, 4, 6, 6, 5, 7, 5, 6, 5, 3, 1, 9, 9, 4, 2, 1, 5, 6, 8, 0, 1, 7, 5, 2, 8, 8, 5, 7, 4, 1, 2, 4, 4, 0, 7, 2, 5, 9, 9, 7, 5, 0, 7, 3, 9, 1, 3, 2, 1, 5, 8, 8, 4, 3, 9, 1, 1, 9, 9, 4, 7, 0, 7, 5, 5, 2, 9, 8, 3, 1, 7, 9, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 2, 7, 5, 3, 1, 6, 1, 8, 8, 5, 5, 3, 6, 2, 0, 5, 3, 3, 2, 5, 6, 8, 0, 1, 0, 8, 4, 6, 6, 5, 7, 5, 6, 5, 3, 1, 9, 9, 4, 2, 1, 5, 6, 8, 0, 1, 7, 5, 2, 8, 8, 5, 7, 4, 1, 2, 4, 4, 0, 7, 2, 5, 9, 9, 7, 5, 0, 7, 3, 9, 1, 3, 2, 1, 5, 8, 8, 4, 3, 9, 1, 1, 9, 9, 4, 7, 0, 7, 5, 5, 2, 9, 8, 3, 1, 7, 9, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_46",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 8, 4, 0, 8, 4, 0, 6, 1, 5, 7, 7, 6, 5, 5, 5, 8, 3, 1, 6, 6, 9, 1, 6, 8, 0, 9, 3, 4, 0, 4, 8, 8], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 8, 4, 0, 8, 4, 0, 6, 1, 5, 7, 7, 6, 5, 5, 5, 8, 3, 1, 6, 6, 9, 1, 6, 8, 0, 9, 3, 4, 0, 4, 8, 8], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_47",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 2, 2, 4, 4, 2, 1, 6, 7, 7, 2, 4, 4, 6, 6, 7, 7, 9, 0, 1, 2, 3, 2, 2, 4, 4, 1, 3, 1, 8, 0, 9, 5, 1, 9, 6, 9], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 2, 2, 4, 4, 2, 1, 6, 7, 7, 2, 4, 4, 6, 6, 7, 7, 9, 0, 1, 2, 3, 2, 2, 4, 4, 1, 3, 1, 8, 0, 9, 5, 1, 9, 6, 9], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_48",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 5, 4, 7, 7, 4, 1, 4, 8, 8, 2, 5, 9], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 5, 4, 7, 7, 4, 1, 4, 8, 8, 2, 5, 9], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_49",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 3, 5, 4, 3, 1, 4, 3, 8, 4, 6], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 3, 5, 4, 3, 1, 4, 3, 8, 4, 6], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_50",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 2, 3, 6, 0, 6, 5, 2, 9, 1, 8, 9, 0, 7, 5, 6, 9, 8, 9, 1, 1, 0, 8, 9, 7, 3, 0, 1, 5, 3, 3, 5, 0, 0, 3], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 2, 3, 6, 0, 6, 5, 2, 9, 1, 8, 9, 0, 7, 5, 6, 9, 8, 9, 1, 1, 0, 8, 9, 7, 3, 0, 1, 5, 3, 3, 5, 0, 0, 3], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_51",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 9, 0, 4, 8, 1, 5, 3, 8, 0, 7, 0, 2, 8, 6, 1, 4, 3, 3, 2, 9, 7, 2, 5, 5, 3, 1, 0, 7, 9, 0, 4, 1, 1, 9, 5, 9, 1, 7, 2, 6, 8, 2, 2, 6, 7, 2, 4, 4, 5, 0, 1, 9, 8, 9, 7, 7, 2, 6, 9, 5, 7, 0, 5, 7, 1, 3, 4, 0, 4, 9, 1, 2, 9, 8, 7, 9, 4, 5, 8, 5, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 9, 0, 4, 8, 1, 5, 3, 8, 0, 7, 0, 2, 8, 6, 1, 4, 3, 3, 2, 9, 7, 2, 5, 5, 3, 1, 0, 7, 9, 0, 4, 1, 1, 9, 5, 9, 1, 7, 2, 6, 8, 2, 2, 6, 7, 2, 4, 4, 5, 0, 1, 9, 8, 9, 7, 7, 2, 6, 9, 5, 7, 0, 5, 7, 1, 3, 4, 0, 4, 9, 1, 2, 9, 8, 7, 9, 4, 5, 8, 5, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_52",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 0, 2, 4, 2, 3, 0], length: int=2):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 0, 2, 4, 2, 3, 0], length=2):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_53",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 7, 1, 8, 5, 3, 0, 1, 9, 4, 9, 6, 9, 9, 2, 0, 9, 0, 0, 3, 5, 8, 8, 3], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 7, 1, 8, 5, 3, 0, 1, 9, 4, 9, 6, 9, 9, 2, 0, 9, 0, 0, 3, 5, 8, 8, 3], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_54",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 1, 9, 1, 3, 3, 6, 6, 6, 7, 8, 4, 8, 9, 8, 2, 6, 6, 9, 1, 3, 0, 6, 9, 8, 3, 1, 3, 4, 1, 3, 0, 7, 4, 9, 0, 6, 6, 6, 2, 1, 7, 1, 1, 5, 9, 7, 2, 3, 6, 3, 1, 9, 1, 8, 9, 2, 4, 8, 7, 4, 3, 5, 3, 9, 1, 4, 9, 8, 4, 0, 3, 5, 3, 1, 4, 0, 8, 8, 4, 8, 6, 3, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 1, 9, 1, 3, 3, 6, 6, 6, 7, 8, 4, 8, 9, 8, 2, 6, 6, 9, 1, 3, 0, 6, 9, 8, 3, 1, 3, 4, 1, 3, 0, 7, 4, 9, 0, 6, 6, 6, 2, 1, 7, 1, 1, 5, 9, 7, 2, 3, 6, 3, 1, 9, 1, 8, 9, 2, 4, 8, 7, 4, 3, 5, 3, 9, 1, 4, 9, 8, 4, 0, 3, 5, 3, 1, 4, 0, 8, 8, 4, 8, 6, 3, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_55",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 1, 7, 6, 2, 8, 4, 0, 7, 5, 6, 3, 3, 6, 2, 9, 6, 2, 8, 5, 6, 9, 9, 4, 7, 2, 1, 9, 9, 0, 0, 8, 3, 7, 9, 9, 3, 4, 4, 4, 9, 9, 3, 1, 8, 1, 5, 5, 6, 0, 8, 8, 7, 3, 7, 6, 0, 8, 0, 6, 1, 6, 2, 4, 5, 7], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 1, 7, 6, 2, 8, 4, 0, 7, 5, 6, 3, 3, 6, 2, 9, 6, 2, 8, 5, 6, 9, 9, 4, 7, 2, 1, 9, 9, 0, 0, 8, 3, 7, 9, 9, 3, 4, 4, 4, 9, 9, 3, 1, 8, 1, 5, 5, 6, 0, 8, 8, 7, 3, 7, 6, 0, 8, 0, 6, 1, 6, 2, 4, 5, 7], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_56",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 3, 2, 3, 6, 2, 3, 3, 9, 4, 3, 9, 5, 8, 9, 6, 9, 9, 3, 8, 2, 2, 0, 4, 6, 3, 7, 3, 0, 9, 6, 2, 5, 8, 7, 8, 9, 9, 5, 2, 4, 4, 8, 8, 9, 9, 0, 6, 0, 8, 8, 7, 8, 1, 6, 8, 5, 7, 1, 7, 5, 7, 9, 5, 2, 9, 6, 3, 8, 4, 0, 5, 9, 2, 5, 9, 5, 6, 0, 5, 6, 2, 1, 0, 8, 1, 8, 9, 4, 3, 1, 3], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 3, 2, 3, 6, 2, 3, 3, 9, 4, 3, 9, 5, 8, 9, 6, 9, 9, 3, 8, 2, 2, 0, 4, 6, 3, 7, 3, 0, 9, 6, 2, 5, 8, 7, 8, 9, 9, 5, 2, 4, 4, 8, 8, 9, 9, 0, 6, 0, 8, 8, 7, 8, 1, 6, 8, 5, 7, 1, 7, 5, 7, 9, 5, 2, 9, 6, 3, 8, 4, 0, 5, 9, 2, 5, 9, 5, 6, 0, 5, 6, 2, 1, 0, 8, 1, 8, 9, 4, 3, 1, 3], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_57",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 6, 6, 8, 0, 6, 4, 5, 1, 1, 6, 3, 2, 9, 1, 9, 9, 9, 0, 4, 3, 2, 4, 5, 8, 3, 8, 4, 2, 9, 9, 9, 6, 0, 5, 9, 6, 2, 4, 4, 8, 5, 4, 1, 9, 8, 1, 1], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 6, 6, 8, 0, 6, 4, 5, 1, 1, 6, 3, 2, 9, 1, 9, 9, 9, 0, 4, 3, 2, 4, 5, 8, 3, 8, 4, 2, 9, 9, 9, 6, 0, 5, 9, 6, 2, 4, 4, 8, 5, 4, 1, 9, 8, 1, 1], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_58",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 1, 8, 3, 0, 1, 4, 9, 3, 5, 9, 2, 8, 2, 6, 4, 5, 2, 9, 6, 2, 8, 9, 0, 5, 3, 2, 7, 9, 9, 4, 5, 5, 7, 3, 7, 0, 9, 9, 9, 1, 7, 3, 2, 8, 2, 5, 5, 6, 6, 1, 3, 5, 4, 6, 2, 8, 0, 1, 9, 7, 4, 6, 7, 6, 0, 7, 4, 3, 0, 0, 3, 8, 7, 3, 2, 4, 8, 8, 9, 4, 6, 5, 7, 1, 8, 9, 8, 3, 3, 7, 7, 2, 7], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 1, 8, 3, 0, 1, 4, 9, 3, 5, 9, 2, 8, 2, 6, 4, 5, 2, 9, 6, 2, 8, 9, 0, 5, 3, 2, 7, 9, 9, 4, 5, 5, 7, 3, 7, 0, 9, 9, 9, 1, 7, 3, 2, 8, 2, 5, 5, 6, 6, 1, 3, 5, 4, 6, 2, 8, 0, 1, 9, 7, 4, 6, 7, 6, 0, 7, 4, 3, 0, 0, 3, 8, 7, 3, 2, 4, 8, 8, 9, 4, 6, 5, 7, 1, 8, 9, 8, 3, 3, 7, 7, 2, 7], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_59",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[9, 9, 4, 4, 2, 5, 8, 3, 9, 8, 2, 8, 6, 1, 7, 4, 2, 9], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[9, 9, 4, 4, 2, 5, 8, 3, 9, 8, 2, 8, 6, 1, 7, 4, 2, 9], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_60",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 1, 0, 9, 6, 2, 5, 4, 3, 6, 9, 9, 8, 7, 3, 0, 9, 2, 8, 6, 3, 6, 4, 9, 8, 6, 0, 7, 9, 7, 6, 3, 7, 4, 4, 4, 5, 3, 7, 4, 4, 1, 6, 8, 4, 5, 6, 2, 2, 0, 9, 7, 6, 4, 9, 6, 9, 9, 4, 4, 6, 8, 8], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 1, 0, 9, 6, 2, 5, 4, 3, 6, 9, 9, 8, 7, 3, 0, 9, 2, 8, 6, 3, 6, 4, 9, 8, 6, 0, 7, 9, 7, 6, 3, 7, 4, 4, 4, 5, 3, 7, 4, 4, 1, 6, 8, 4, 5, 6, 2, 2, 0, 9, 7, 6, 4, 9, 6, 9, 9, 4, 4, 6, 8, 8], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_61",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 4, 3, 9, 0, 3, 7, 1, 9, 8, 3, 3, 9, 1, 4, 2, 4, 4, 7, 7, 3, 8, 4, 4, 6, 2, 1, 0, 6, 0, 0, 9, 3, 7], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 4, 3, 9, 0, 3, 7, 1, 9, 8, 3, 3, 9, 1, 4, 2, 4, 4, 7, 7, 3, 8, 4, 4, 6, 2, 1, 0, 6, 0, 0, 9, 3, 7], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_62",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 6, 0, 4, 5, 3, 4, 8, 1, 7, 1, 2, 2, 3, 2, 1, 4, 1], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 6, 0, 4, 5, 3, 4, 8, 1, 7, 1, 2, 2, 3, 2, 1, 4, 1], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_63",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 5, 7, 8, 0, 9, 2, 3, 0, 3, 7, 8, 5, 5, 8, 2, 8, 2, 2, 7, 7, 4, 7], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 5, 7, 8, 0, 9, 2, 3, 0, 3, 7, 8, 5, 5, 8, 2, 8, 2, 2, 7, 7, 4, 7], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_64",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 6, 7, 1, 9, 5, 0, 9, 9, 3, 3, 3, 4, 8, 4, 5, 6, 1, 5, 8, 2, 0, 6, 1, 2, 0, 9, 5, 0, 0, 7, 2, 1, 0, 9, 4, 2, 8, 9, 2, 8, 0, 4, 0, 6, 5, 3, 9, 1, 1, 7, 4, 0, 2, 1, 5, 4, 7, 4], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 6, 7, 1, 9, 5, 0, 9, 9, 3, 3, 3, 4, 8, 4, 5, 6, 1, 5, 8, 2, 0, 6, 1, 2, 0, 9, 5, 0, 0, 7, 2, 1, 0, 9, 4, 2, 8, 9, 2, 8, 0, 4, 0, 6, 5, 3, 9, 1, 1, 7, 4, 0, 2, 1, 5, 4, 7, 4], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_65",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[5, 5, 4, 6, 9, 2, 7, 3, 9, 8, 2, 9, 9, 6, 9, 0, 4, 0, 7, 6, 8, 8, 2, 1, 9, 8, 7, 6, 0, 6, 3, 8, 7, 9, 5, 5, 5, 3, 6, 2, 4, 2, 2, 3, 0, 9, 1, 5, 8, 1], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[5, 5, 4, 6, 9, 2, 7, 3, 9, 8, 2, 9, 9, 6, 9, 0, 4, 0, 7, 6, 8, 8, 2, 1, 9, 8, 7, 6, 0, 6, 3, 8, 7, 9, 5, 5, 5, 3, 6, 2, 4, 2, 2, 3, 0, 9, 1, 5, 8, 1], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_66",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 3, 2, 5, 4, 7, 5, 7, 7, 7, 7, 1, 0, 0, 1, 8, 3, 9, 2, 8, 4, 1, 7, 8, 7, 6, 7, 3, 6, 5, 4, 2, 8, 3, 3, 5, 7, 5, 2, 6, 4, 9, 4, 5, 1, 2, 5, 7, 3, 9, 4, 5, 9, 2, 3, 0, 7, 2, 1, 5, 6, 4, 5, 3, 9, 4, 2, 2, 0, 7, 7, 4], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 3, 2, 5, 4, 7, 5, 7, 7, 7, 7, 1, 0, 0, 1, 8, 3, 9, 2, 8, 4, 1, 7, 8, 7, 6, 7, 3, 6, 5, 4, 2, 8, 3, 3, 5, 7, 5, 2, 6, 4, 9, 4, 5, 1, 2, 5, 7, 3, 9, 4, 5, 9, 2, 3, 0, 7, 2, 1, 5, 6, 4, 5, 3, 9, 4, 2, 2, 0, 7, 7, 4], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_67",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 6, 7, 6, 4, 1, 0, 6, 8, 4, 9, 6, 6, 7, 5, 4, 0, 9, 7, 4, 7, 4, 1, 0, 3, 7, 0, 9, 4, 6, 4, 5, 4, 1, 9, 9, 0, 5, 1, 6, 2, 5], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 6, 7, 6, 4, 1, 0, 6, 8, 4, 9, 6, 6, 7, 5, 4, 0, 9, 7, 4, 7, 4, 1, 0, 3, 7, 0, 9, 4, 6, 4, 5, 4, 1, 9, 9, 0, 5, 1, 6, 2, 5], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_68",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 6, 2, 8, 0, 3, 8, 3, 7, 8, 7, 1, 1, 5, 5, 0, 2, 2, 6, 4, 7, 9, 0, 4, 7, 0, 5, 4, 2, 4, 5, 6, 8, 8, 9, 9, 3], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 6, 2, 8, 0, 3, 8, 3, 7, 8, 7, 1, 1, 5, 5, 0, 2, 2, 6, 4, 7, 9, 0, 4, 7, 0, 5, 4, 2, 4, 5, 6, 8, 8, 9, 9, 3], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_69",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 7, 3, 8, 2, 5, 3, 0, 6, 4, 0, 7, 2, 1, 7, 8, 5, 2, 3, 7, 6, 7, 3, 6, 4, 3, 8, 1, 4, 7, 3, 1, 9, 2, 8, 3, 0, 3, 1, 5, 4, 2, 3, 7, 6, 1, 2, 1, 4, 5, 5, 2, 5], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 7, 3, 8, 2, 5, 3, 0, 6, 4, 0, 7, 2, 1, 7, 8, 5, 2, 3, 7, 6, 7, 3, 6, 4, 3, 8, 1, 4, 7, 3, 1, 9, 2, 8, 3, 0, 3, 1, 5, 4, 2, 3, 7, 6, 1, 2, 1, 4, 5, 5, 2, 5], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_70",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 9, 2, 2, 9, 2, 1, 2, 7, 8, 2, 4, 9, 6, 6, 4, 5, 1, 1, 9, 6, 2, 2, 7, 1, 9, 5, 1, 0, 6, 7, 1, 9, 9, 3, 4, 2, 2, 2, 8, 9, 1, 3, 7, 2, 1, 8, 5, 2, 2, 3, 4, 3, 1, 6, 6, 2, 7, 9, 5, 5, 6, 6, 3, 1, 9, 7, 0, 7, 2, 9, 5, 5, 6, 8, 4, 3, 4, 5, 4, 8, 3, 6, 8, 5, 6, 3, 8], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 9, 2, 2, 9, 2, 1, 2, 7, 8, 2, 4, 9, 6, 6, 4, 5, 1, 1, 9, 6, 2, 2, 7, 1, 9, 5, 1, 0, 6, 7, 1, 9, 9, 3, 4, 2, 2, 2, 8, 9, 1, 3, 7, 2, 1, 8, 5, 2, 2, 3, 4, 3, 1, 6, 6, 2, 7, 9, 5, 5, 6, 6, 3, 1, 9, 7, 0, 7, 2, 9, 5, 5, 6, 8, 4, 3, 4, 5, 4, 8, 3, 6, 8, 5, 6, 3, 8], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_71",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 1, 9, 8, 8, 2, 8, 5, 9, 2, 0, 9, 5, 1, 4, 0, 2, 8, 2, 0, 2, 0, 7, 3, 3, 6, 4, 2, 2, 1, 9, 5, 9, 3, 8, 5, 6, 8, 3, 7, 3, 4, 6, 3, 4, 8, 6, 1, 4, 7, 7, 9, 3, 2, 1, 1, 5, 7], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 1, 9, 8, 8, 2, 8, 5, 9, 2, 0, 9, 5, 1, 4, 0, 2, 8, 2, 0, 2, 0, 7, 3, 3, 6, 4, 2, 2, 1, 9, 5, 9, 3, 8, 5, 6, 8, 3, 7, 3, 4, 6, 3, 4, 8, 6, 1, 4, 7, 7, 9, 3, 2, 1, 1, 5, 7], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_72",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 8, 6, 3, 5, 1, 9, 8, 6, 9, 6, 4, 4, 7, 5, 1, 0, 2], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 8, 6, 3, 5, 1, 9, 8, 6, 9, 6, 4, 4, 7, 5, 1, 0, 2], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_73",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 9, 1, 9, 0, 6, 5, 6, 1, 8, 1, 7, 3, 9, 8, 3, 4, 1, 6, 7, 6, 4, 6, 8, 0, 8, 9, 9, 7], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 9, 1, 9, 0, 6, 5, 6, 1, 8, 1, 7, 3, 9, 8, 3, 4, 1, 6, 7, 6, 4, 6, 8, 0, 8, 9, 9, 7], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_74",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 6, 5, 8, 0, 1, 1, 8, 5, 3, 1, 5, 9, 6, 8, 4, 7, 7, 6, 1, 0, 2, 5, 9, 3, 6, 3, 3, 0, 6, 2, 2, 3, 3, 1, 9, 7, 1, 1, 8, 4, 5, 6, 7, 0, 8, 9, 4, 8, 1, 5, 5, 3, 9, 3, 9, 5, 6, 5, 9, 4, 6, 2, 8, 5, 4, 1, 5, 3, 3, 2, 8, 8, 8, 8, 8, 4, 2, 9, 4, 9, 8, 8, 0, 7, 5, 2, 5, 6, 9, 5, 3, 1, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 6, 5, 8, 0, 1, 1, 8, 5, 3, 1, 5, 9, 6, 8, 4, 7, 7, 6, 1, 0, 2, 5, 9, 3, 6, 3, 3, 0, 6, 2, 2, 3, 3, 1, 9, 7, 1, 1, 8, 4, 5, 6, 7, 0, 8, 9, 4, 8, 1, 5, 5, 3, 9, 3, 9, 5, 6, 5, 9, 4, 6, 2, 8, 5, 4, 1, 5, 3, 3, 2, 8, 8, 8, 8, 8, 4, 2, 9, 4, 9, 8, 8, 0, 7, 5, 2, 5, 6, 9, 5, 3, 1, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_75",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 5, 6, 8, 8, 7, 7, 4, 5, 3, 2, 6, 2, 1, 8, 4, 9, 2, 6, 8, 5, 4, 1, 7, 1, 3, 9, 5, 0, 8, 6, 4, 0, 8, 9, 3, 8, 6, 3, 2, 0, 2, 0, 0, 4, 3, 9, 4, 4, 3, 1, 6, 9, 0, 2, 5, 6, 4, 7, 1, 9], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 5, 6, 8, 8, 7, 7, 4, 5, 3, 2, 6, 2, 1, 8, 4, 9, 2, 6, 8, 5, 4, 1, 7, 1, 3, 9, 5, 0, 8, 6, 4, 0, 8, 9, 3, 8, 6, 3, 2, 0, 2, 0, 0, 4, 3, 9, 4, 4, 3, 1, 6, 9, 0, 2, 5, 6, 4, 7, 1, 9], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_76",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 7, 7, 7, 5, 6, 0, 1, 5, 8, 2, 3, 0, 7, 6, 3, 3, 3, 1, 2, 3, 7, 5, 3, 7, 9, 8, 5, 3, 7, 6, 1, 8, 4, 0, 9, 0, 5, 5, 8, 4, 0, 0, 9, 3, 5, 7, 4, 6, 7, 8, 8, 3, 8, 7, 8, 3, 9, 9, 1, 7, 4, 2, 1, 6, 4, 1, 0, 3, 6, 7, 1, 9, 0, 3, 5, 6, 7, 2, 3, 5, 8], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 7, 7, 7, 5, 6, 0, 1, 5, 8, 2, 3, 0, 7, 6, 3, 3, 3, 1, 2, 3, 7, 5, 3, 7, 9, 8, 5, 3, 7, 6, 1, 8, 4, 0, 9, 0, 5, 5, 8, 4, 0, 0, 9, 3, 5, 7, 4, 6, 7, 8, 8, 3, 8, 7, 8, 3, 9, 9, 1, 7, 4, 2, 1, 6, 4, 1, 0, 3, 6, 7, 1, 9, 0, 3, 5, 6, 7, 2, 3, 5, 8], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_77",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 4, 6, 9, 9, 1, 7, 7, 9, 6, 9, 7, 8, 5, 6, 3, 3, 0, 6, 7, 3, 2, 2, 9, 5, 6, 6, 3, 6, 8, 6, 5, 2, 0, 3, 0, 7, 4, 2, 2], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 4, 6, 9, 9, 1, 7, 7, 9, 6, 9, 7, 8, 5, 6, 3, 3, 0, 6, 7, 3, 2, 2, 9, 5, 6, 6, 3, 6, 8, 6, 5, 2, 0, 3, 0, 7, 4, 2, 2], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_78",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 7, 9, 2, 3, 0, 0, 5, 7, 8, 6, 6, 4, 2, 9, 1, 5, 5, 2, 6, 8, 6, 2, 2, 7, 8, 6, 4, 1, 1, 5, 3, 6, 3, 8, 3, 0, 0, 1, 8, 1, 9, 3, 0, 6, 6, 4, 0, 3, 7, 8, 0, 6, 4, 9, 0, 3, 3, 2, 9, 1, 8, 5, 0, 6, 7, 9, 0, 4, 2, 9, 3, 8, 8, 7, 9, 2, 3, 9, 9, 7, 2, 2, 7, 4, 2, 9, 0, 7, 0, 2], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 7, 9, 2, 3, 0, 0, 5, 7, 8, 6, 6, 4, 2, 9, 1, 5, 5, 2, 6, 8, 6, 2, 2, 7, 8, 6, 4, 1, 1, 5, 3, 6, 3, 8, 3, 0, 0, 1, 8, 1, 9, 3, 0, 6, 6, 4, 0, 3, 7, 8, 0, 6, 4, 9, 0, 3, 3, 2, 9, 1, 8, 5, 0, 6, 7, 9, 0, 4, 2, 9, 3, 8, 8, 7, 9, 2, 3, 9, 9, 7, 2, 2, 7, 4, 2, 9, 0, 7, 0, 2], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_79",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 7, 1, 3, 8, 2, 9, 4, 4, 5, 0, 7, 2, 8, 4, 5, 6, 7, 3, 6, 8, 0, 4, 6, 9, 2, 6, 1, 4, 6, 7, 6, 2, 1, 9, 6, 0, 0, 9, 7, 8, 6, 9, 3, 9, 9, 6, 8, 4, 7, 2, 2, 8, 3, 5, 4, 7, 3, 2, 2, 8, 2, 3, 8, 4, 3, 9, 9, 2, 7], length: int=9):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 7, 1, 3, 8, 2, 9, 4, 4, 5, 0, 7, 2, 8, 4, 5, 6, 7, 3, 6, 8, 0, 4, 6, 9, 2, 6, 1, 4, 6, 7, 6, 2, 1, 9, 6, 0, 0, 9, 7, 8, 6, 9, 3, 9, 9, 6, 8, 4, 7, 2, 2, 8, 3, 5, 4, 7, 3, 2, 2, 8, 2, 3, 8, 4, 3, 9, 9, 2, 7], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_80",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 6, 2, 1, 3, 8, 5, 6, 7, 8, 9, 4, 1, 3, 0, 8, 7, 6, 7, 1, 2, 6, 1, 5, 2, 4, 2, 0, 6, 9, 8, 0, 2, 4, 6, 0, 8, 3, 7], length: int=6):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 6, 2, 1, 3, 8, 5, 6, 7, 8, 9, 4, 1, 3, 0, 8, 7, 6, 7, 1, 2, 6, 1, 5, 2, 4, 2, 0, 6, 9, 8, 0, 2, 4, 6, 0, 8, 3, 7], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_81",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[6, 2, 3, 2, 0, 3, 0, 2, 9, 5, 5, 1, 5, 4, 9, 9, 9, 0, 5, 8, 4, 8, 5, 8, 6, 3, 5, 1, 5, 6, 0], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[6, 2, 3, 2, 0, 3, 0, 2, 9, 5, 5, 1, 5, 4, 9, 9, 9, 0, 5, 8, 4, 8, 5, 8, 6, 3, 5, 1, 5, 6, 0], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_82",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 6, 1, 7, 3, 7, 6, 3, 5, 1, 5, 4, 6, 7, 2, 6, 8, 9, 2, 5, 5, 0, 8, 3, 3, 8, 5, 8, 3, 7, 7, 7, 9, 7, 4, 8, 5, 0, 9, 8, 8, 3, 3, 8, 2], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 6, 1, 7, 3, 7, 6, 3, 5, 1, 5, 4, 6, 7, 2, 6, 8, 9, 2, 5, 5, 0, 8, 3, 3, 8, 5, 8, 3, 7, 7, 7, 9, 7, 4, 8, 5, 0, 9, 8, 8, 3, 3, 8, 2], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_83",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 7, 5, 1, 1, 6, 8, 9, 6, 8, 6, 5], length: int=3):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 7, 5, 1, 1, 6, 8, 9, 6, 8, 6, 5], length=3):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_84",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[4, 6, 8, 2, 7, 1, 2, 6, 6, 7, 1, 0, 9, 6, 3, 0, 2, 9, 4, 0], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[4, 6, 8, 2, 7, 1, 2, 6, 6, 7, 1, 0, 9, 6, 3, 0, 2, 9, 4, 0], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_85",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[9, 8, 4, 7, 2, 5, 6, 5, 2, 4, 9, 4, 7, 6, 8, 3, 3, 6, 3, 4, 1, 5, 1, 4, 7, 4, 1, 3, 1, 0, 1, 8, 5, 6, 0, 2, 7, 7, 2, 2, 3, 1, 4, 2, 4, 3], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[9, 8, 4, 7, 2, 5, 6, 5, 2, 4, 9, 4, 7, 6, 8, 3, 3, 6, 3, 4, 1, 5, 1, 4, 7, 4, 1, 3, 1, 0, 1, 8, 5, 6, 0, 2, 7, 7, 2, 2, 3, 1, 4, 2, 4, 3], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_86",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 2, 6, 7, 2, 3, 3, 8, 2, 1, 9, 9, 1, 0, 9, 9, 6, 6, 7, 7, 6], length: int=4):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 2, 6, 7, 2, 3, 3, 8, 2, 1, 9, 9, 1, 0, 9, 9, 6, 6, 7, 7, 6], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_87",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 3, 2, 3, 0, 3, 4, 1, 4, 6, 0, 2, 3, 6, 0, 1, 3, 8, 5, 8, 8, 3, 4, 0, 8, 6, 3, 8, 0, 8, 1, 9, 8, 3, 8, 0, 9, 1, 1, 5, 1, 8, 9, 5, 3, 9, 7, 9, 0, 7, 3, 1, 8, 5, 8, 9, 2, 1, 0, 5, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 3, 2, 3, 0, 3, 4, 1, 4, 6, 0, 2, 3, 6, 0, 1, 3, 8, 5, 8, 8, 3, 4, 0, 8, 6, 3, 8, 0, 8, 1, 9, 8, 3, 8, 0, 9, 1, 1, 5, 1, 8, 9, 5, 3, 9, 7, 9, 0, 7, 3, 1, 8, 5, 8, 9, 2, 1, 0, 5, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_88",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 1, 4, 7, 1, 9, 6, 6, 9, 8, 6, 3, 4, 4, 1, 0, 2, 5, 4, 7, 4, 4, 3, 5, 8, 8, 0, 1, 2, 8, 8, 1, 5, 6, 4, 5], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 1, 4, 7, 1, 9, 6, 6, 9, 8, 6, 3, 4, 4, 1, 0, 2, 5, 4, 7, 4, 4, 3, 5, 8, 8, 0, 1, 2, 8, 8, 1, 5, 6, 4, 5], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_89",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 4, 3, 7, 5, 9, 7, 3, 3, 4, 2, 0, 8, 3, 5, 4, 3, 9, 4, 1, 7, 4, 2, 2, 0, 8, 3, 0, 9, 4, 7, 5, 2, 7, 3, 1], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 4, 3, 7, 5, 9, 7, 3, 3, 4, 2, 0, 8, 3, 5, 4, 3, 9, 4, 1, 7, 4, 2, 2, 0, 8, 3, 0, 9, 4, 7, 5, 2, 7, 3, 1], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_90",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 0, 0, 1, 9, 6, 0, 4, 8, 8, 3, 1, 0, 2, 4, 7, 4, 2, 4, 3, 8, 4, 0, 9, 5, 2, 1, 9, 9, 8, 2, 1, 5, 7, 6, 6, 8, 6, 9, 3, 2, 0, 4, 2, 4, 1, 5, 8, 9, 9, 9], length: int=8):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 0, 0, 1, 9, 6, 0, 4, 8, 8, 3, 1, 0, 2, 4, 7, 4, 2, 4, 3, 8, 4, 0, 9, 5, 2, 1, 9, 9, 8, 2, 1, 5, 7, 6, 6, 8, 6, 9, 3, 2, 0, 4, 2, 4, 1, 5, 8, 9, 9, 9], length=8):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_91",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[1, 0, 4, 9, 8, 5, 9, 1, 6, 5, 2, 9, 0, 8, 6, 0, 1, 2, 0, 5, 8, 8, 2, 5, 0, 7, 0, 5, 5, 6, 1, 0, 5, 2, 7, 6, 6], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[1, 0, 4, 9, 8, 5, 9, 1, 6, 5, 2, 9, 0, 8, 6, 0, 1, 2, 0, 5, 8, 8, 2, 5, 0, 7, 0, 5, 5, 6, 1, 0, 5, 2, 7, 6, 6], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_92",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[3, 9, 9, 1, 3, 4, 7, 6, 1, 0, 4, 8, 9, 8, 6, 0, 9, 6, 3, 8, 0, 5, 7, 1, 2, 4, 6, 6, 5, 2, 2, 7, 3, 9, 7, 2, 9, 1, 1, 7, 4, 3, 6, 8, 1, 9, 7, 0, 5, 2, 3, 5, 3, 6, 4, 8, 6, 7, 9, 9, 0, 7, 2, 0, 3, 1, 2, 5, 5, 3, 9, 2, 8, 7, 6, 8, 7, 8, 8, 9, 6, 1, 2, 8, 8, 5, 3, 1, 9, 3, 8, 3, 4, 5, 7, 7, 8], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[3, 9, 9, 1, 3, 4, 7, 6, 1, 0, 4, 8, 9, 8, 6, 0, 9, 6, 3, 8, 0, 5, 7, 1, 2, 4, 6, 6, 5, 2, 2, 7, 3, 9, 7, 2, 9, 1, 1, 7, 4, 3, 6, 8, 1, 9, 7, 0, 5, 2, 3, 5, 3, 6, 4, 8, 6, 7, 9, 9, 0, 7, 2, 0, 3, 1, 2, 5, 5, 3, 9, 2, 8, 7, 6, 8, 7, 8, 8, 9, 6, 1, 2, 8, 8, 5, 3, 1, 9, 3, 8, 3, 4, 5, 7, 7, 8], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_93",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 4, 9, 4, 9, 9, 5, 9, 6, 5, 6, 1, 6, 1, 5, 9], length: int=5):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 4, 9, 4, 9, 9, 5, 9, 6, 5, 6, 1, 6, 1, 5, 9], length=5):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_94",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 9, 0, 8, 4, 6, 5, 0, 2, 3, 9, 8, 9, 7, 8, 9, 7, 9, 9, 2, 4, 8, 0, 1, 6, 9], length: int=7):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 9, 0, 8, 4, 6, 5, 0, 2, 3, 9, 8, 9, 7, 8, 9, 7, 9, 9, 2, 4, 8, 0, 1, 6, 9], length=7):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_95",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 3, 6, 2, 0, 5, 4, 0, 4, 8, 3, 2, 9, 0, 2, 5, 0, 8, 2, 6, 3, 6, 1, 2, 9, 7, 1, 6, 4, 5, 1, 0, 1, 6, 2, 0, 1, 1, 6, 5, 4, 0, 6, 2, 7, 2, 5, 6, 2, 2, 2, 5, 5, 7, 7, 8, 2, 3, 1, 5, 3, 2, 1, 7, 0, 8, 2, 8, 7, 7, 6], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 3, 6, 2, 0, 5, 4, 0, 4, 8, 3, 2, 9, 0, 2, 5, 0, 8, 2, 6, 3, 6, 1, 2, 9, 7, 1, 6, 4, 5, 1, 0, 1, 6, 2, 0, 1, 1, 6, 5, 4, 0, 6, 2, 7, 2, 5, 6, 2, 2, 2, 5, 5, 7, 7, 8, 2, 3, 1, 5, 3, 2, 1, 7, 0, 8, 2, 8, 7, 7, 6], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_96",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[0, 0, 7, 8, 2, 1, 7, 8, 2, 8, 4, 9, 0, 5, 8, 5, 3, 2, 2, 1, 7, 1, 3, 1, 9, 4, 4, 1, 8, 7, 5, 6, 2, 9, 6, 1, 0, 0, 5, 6, 4, 7, 9, 1, 3, 7, 9, 2, 7, 9, 8, 2, 1, 0, 8, 4, 5, 3, 8, 3, 6, 3, 6, 3, 9, 6, 0, 2, 8, 2, 4, 8, 4, 1, 5, 0, 6, 6, 3, 7, 0, 1, 9, 7, 4, 4, 8, 7, 2, 9, 0, 2, 1, 7, 9], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[0, 0, 7, 8, 2, 1, 7, 8, 2, 8, 4, 9, 0, 5, 8, 5, 3, 2, 2, 1, 7, 1, 3, 1, 9, 4, 4, 1, 8, 7, 5, 6, 2, 9, 6, 1, 0, 0, 5, 6, 4, 7, 9, 1, 3, 7, 9, 2, 7, 9, 8, 2, 1, 0, 8, 4, 5, 3, 8, 3, 6, 3, 6, 3, 9, 6, 0, 2, 8, 2, 4, 8, 4, 1, 5, 0, 6, 6, 3, 7, 0, 1, 9, 7, 4, 4, 8, 7, 2, 9, 0, 2, 1, 7, 9], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_97",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[7, 7, 2, 5, 5, 8, 6, 4, 6, 0, 3, 1, 5, 0, 8, 5, 3, 4, 8, 1, 8, 4, 6, 8, 7, 1, 7, 1, 3, 5, 3, 7, 9, 9, 6, 2, 1, 1, 5, 8, 4, 8, 1, 5, 5, 3, 9, 7, 1, 6, 1, 1, 5, 1, 5, 9, 4, 6, 9, 4, 5, 9, 3, 3, 8, 1, 1, 6, 9, 3, 0, 1, 9, 7, 6, 9, 4, 2, 0, 0, 8, 6, 1, 5, 5, 9, 6, 8, 3, 1, 3, 7], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[7, 7, 2, 5, 5, 8, 6, 4, 6, 0, 3, 1, 5, 0, 8, 5, 3, 4, 8, 1, 8, 4, 6, 8, 7, 1, 7, 1, 3, 5, 3, 7, 9, 9, 6, 2, 1, 1, 5, 8, 4, 8, 1, 5, 5, 3, 9, 7, 1, 6, 1, 1, 5, 1, 5, 9, 4, 6, 9, 4, 5, 9, 3, 3, 8, 1, 1, 6, 9, 3, 0, 1, 9, 7, 6, 9, 4, 2, 0, 0, 8, 6, 1, 5, 5, 9, 6, 8, 3, 1, 3, 7], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_98",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[2, 7, 1, 0, 3, 9, 4, 3, 6, 1, 4, 2, 2, 6, 5, 0, 1, 1, 8, 4, 5, 4, 1, 7, 6, 9, 7, 9, 5, 8, 2, 7, 6, 8, 1, 4, 1, 4, 3, 5, 5, 8, 0, 6, 9, 5, 9, 6, 7, 7, 8, 9, 1, 1, 1, 4, 7, 3, 6, 5, 1, 6, 2, 5, 5, 8, 7, 9, 5, 0, 4, 4, 3, 3, 3, 9, 8, 6, 9, 7, 8, 4, 2, 9, 1, 0, 1, 2, 4, 3], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[2, 7, 1, 0, 3, 9, 4, 3, 6, 1, 4, 2, 2, 6, 5, 0, 1, 1, 8, 4, 5, 4, 1, 7, 6, 9, 7, 9, 5, 8, 2, 7, 6, 8, 1, 4, 1, 4, 3, 5, 5, 8, 0, 6, 9, 5, 9, 6, 7, 7, 8, 9, 1, 1, 1, 4, 7, 3, 6, 5, 1, 6, 2, 5, 5, 8, 7, 9, 5, 0, 4, 4, 3, 3, 3, 9, 8, 6, 9, 7, 8, 4, 2, 9, 1, 0, 1, 2, 4, 3], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "SameDifferent_99",
    "sat": "def sat(lists: List[List[int]], items: List[int]=[8, 7, 1, 3, 4, 2, 4, 0, 8, 8, 7, 5, 2, 6, 5, 9, 4, 4, 7, 9, 3, 3, 4, 9, 7, 6, 8, 7, 4, 0, 4, 6, 4, 0, 8, 0, 3, 2, 0, 7, 6, 7, 7, 3, 6, 7, 5, 9, 0, 1, 7, 0, 3, 5, 5, 7, 9, 0, 6, 2, 0, 1, 9, 5, 2, 7, 8, 5, 3, 0, 0, 8, 5, 6, 6], length: int=10):\n    assert type(lists) is list and all(type(a) is list and all(type(b) is int for b in a) for a in lists), 'lists must be of type List[List[int]]'\n    a, b = lists\n    assert len(set(a)) == len(a) == len(b) == length and len(set(b)) == 1 and set(a + b) <= set(items)\n    i = b[0]\n    return (a + b).count(i) <= items.count(i)",
    "sols": [
      "def sol(items=[8, 7, 1, 3, 4, 2, 4, 0, 8, 8, 7, 5, 2, 6, 5, 9, 4, 4, 7, 9, 3, 3, 4, 9, 7, 6, 8, 7, 4, 0, 4, 6, 4, 0, 8, 0, 3, 2, 0, 7, 6, 7, 7, 3, 6, 7, 5, 9, 0, 1, 7, 0, 3, 5, 5, 7, 9, 0, 6, 2, 0, 1, 9, 5, 2, 7, 8, 5, 3, 0, 0, 8, 5, 6, 6], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ]
  },
  {
    "name": "OnesAndTwos_0",
    "sat": "def sat(seq: List[int], n: int=10000, length: int=5017):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=10000, length=5017):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_1",
    "sat": "def sat(seq: List[int], n: int=7355, length: int=6711):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=7355, length=6711):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_2",
    "sat": "def sat(seq: List[int], n: int=793, length: int=556):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=793, length=556):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_3",
    "sat": "def sat(seq: List[int], n: int=6, length: int=3):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6, length=3):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_4",
    "sat": "def sat(seq: List[int], n: int=174, length: int=149):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=174, length=149):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_5",
    "sat": "def sat(seq: List[int], n: int=0, length: int=0):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=0, length=0):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_6",
    "sat": "def sat(seq: List[int], n: int=93, length: int=71):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=93, length=71):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_7",
    "sat": "def sat(seq: List[int], n: int=265, length: int=173):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=265, length=173):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_8",
    "sat": "def sat(seq: List[int], n: int=173, length: int=143):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=173, length=143):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_9",
    "sat": "def sat(seq: List[int], n: int=6, length: int=6):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6, length=6):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_10",
    "sat": "def sat(seq: List[int], n: int=173, length: int=104):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=173, length=104):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_11",
    "sat": "def sat(seq: List[int], n: int=9, length: int=7):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=9, length=7):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_12",
    "sat": "def sat(seq: List[int], n: int=45, length: int=40):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=45, length=40):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_13",
    "sat": "def sat(seq: List[int], n: int=1, length: int=1):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=1, length=1):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_14",
    "sat": "def sat(seq: List[int], n: int=41, length: int=32):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=41, length=32):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_15",
    "sat": "def sat(seq: List[int], n: int=6594, length: int=3830):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6594, length=3830):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_16",
    "sat": "def sat(seq: List[int], n: int=43, length: int=22):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=43, length=22):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_17",
    "sat": "def sat(seq: List[int], n: int=7, length: int=5):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=7, length=5):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_18",
    "sat": "def sat(seq: List[int], n: int=673, length: int=671):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=673, length=671):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_19",
    "sat": "def sat(seq: List[int], n: int=3098, length: int=2890):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=3098, length=2890):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_20",
    "sat": "def sat(seq: List[int], n: int=50, length: int=49):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=50, length=49):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_21",
    "sat": "def sat(seq: List[int], n: int=95, length: int=73):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=95, length=73):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_22",
    "sat": "def sat(seq: List[int], n: int=4, length: int=2):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=4, length=2):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_23",
    "sat": "def sat(seq: List[int], n: int=405, length: int=220):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=405, length=220):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_24",
    "sat": "def sat(seq: List[int], n: int=3, length: int=2):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=3, length=2):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_25",
    "sat": "def sat(seq: List[int], n: int=2330, length: int=1811):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=2330, length=1811):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_26",
    "sat": "def sat(seq: List[int], n: int=6, length: int=4):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6, length=4):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_27",
    "sat": "def sat(seq: List[int], n: int=7281, length: int=6217):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=7281, length=6217):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_28",
    "sat": "def sat(seq: List[int], n: int=3178, length: int=2710):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=3178, length=2710):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_29",
    "sat": "def sat(seq: List[int], n: int=12, length: int=9):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=12, length=9):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_30",
    "sat": "def sat(seq: List[int], n: int=647, length: int=354):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=647, length=354):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_31",
    "sat": "def sat(seq: List[int], n: int=49, length: int=33):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=49, length=33):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_32",
    "sat": "def sat(seq: List[int], n: int=2396, length: int=1277):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=2396, length=1277):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_33",
    "sat": "def sat(seq: List[int], n: int=7058, length: int=5372):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=7058, length=5372):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_34",
    "sat": "def sat(seq: List[int], n: int=4134, length: int=2383):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=4134, length=2383):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_35",
    "sat": "def sat(seq: List[int], n: int=512, length: int=491):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=512, length=491):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_36",
    "sat": "def sat(seq: List[int], n: int=166, length: int=108):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=166, length=108):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_37",
    "sat": "def sat(seq: List[int], n: int=52, length: int=50):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=52, length=50):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_38",
    "sat": "def sat(seq: List[int], n: int=44, length: int=24):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=44, length=24):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_39",
    "sat": "def sat(seq: List[int], n: int=933, length: int=793):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=933, length=793):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_40",
    "sat": "def sat(seq: List[int], n: int=42, length: int=22):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=42, length=22):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_41",
    "sat": "def sat(seq: List[int], n: int=97, length: int=92):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=97, length=92):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_42",
    "sat": "def sat(seq: List[int], n: int=2869, length: int=1701):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=2869, length=1701):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_43",
    "sat": "def sat(seq: List[int], n: int=82, length: int=57):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=82, length=57):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_44",
    "sat": "def sat(seq: List[int], n: int=4, length: int=3):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=4, length=3):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_45",
    "sat": "def sat(seq: List[int], n: int=96, length: int=63):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=96, length=63):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_46",
    "sat": "def sat(seq: List[int], n: int=3, length: int=3):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=3, length=3):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_47",
    "sat": "def sat(seq: List[int], n: int=5, length: int=3):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=5, length=3):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_48",
    "sat": "def sat(seq: List[int], n: int=34, length: int=20):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=34, length=20):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_49",
    "sat": "def sat(seq: List[int], n: int=9697, length: int=9573):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=9697, length=9573):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_50",
    "sat": "def sat(seq: List[int], n: int=25, length: int=15):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=25, length=15):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_51",
    "sat": "def sat(seq: List[int], n: int=43, length: int=28):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=43, length=28):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_52",
    "sat": "def sat(seq: List[int], n: int=37, length: int=34):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=37, length=34):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_53",
    "sat": "def sat(seq: List[int], n: int=879, length: int=505):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=879, length=505):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_54",
    "sat": "def sat(seq: List[int], n: int=5, length: int=4):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=5, length=4):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_55",
    "sat": "def sat(seq: List[int], n: int=91, length: int=55):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=91, length=55):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_56",
    "sat": "def sat(seq: List[int], n: int=9222, length: int=6875):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=9222, length=6875):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_57",
    "sat": "def sat(seq: List[int], n: int=5, length: int=5):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=5, length=5):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_58",
    "sat": "def sat(seq: List[int], n: int=50, length: int=30):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=50, length=30):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_59",
    "sat": "def sat(seq: List[int], n: int=2641, length: int=1684):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=2641, length=1684):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_60",
    "sat": "def sat(seq: List[int], n: int=705, length: int=705):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=705, length=705):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_61",
    "sat": "def sat(seq: List[int], n: int=864, length: int=855):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=864, length=855):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_62",
    "sat": "def sat(seq: List[int], n: int=6615, length: int=3392):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6615, length=3392):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_63",
    "sat": "def sat(seq: List[int], n: int=710, length: int=455):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=710, length=455):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_64",
    "sat": "def sat(seq: List[int], n: int=458, length: int=296):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=458, length=296):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_65",
    "sat": "def sat(seq: List[int], n: int=55, length: int=38):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=55, length=38):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_66",
    "sat": "def sat(seq: List[int], n: int=40, length: int=20):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=40, length=20):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_67",
    "sat": "def sat(seq: List[int], n: int=880, length: int=821):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=880, length=821):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_68",
    "sat": "def sat(seq: List[int], n: int=9, length: int=5):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=9, length=5):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_69",
    "sat": "def sat(seq: List[int], n: int=6599, length: int=3998):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6599, length=3998):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_70",
    "sat": "def sat(seq: List[int], n: int=4758, length: int=2426):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=4758, length=2426):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_71",
    "sat": "def sat(seq: List[int], n: int=8677, length: int=5269):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=8677, length=5269):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_72",
    "sat": "def sat(seq: List[int], n: int=35, length: int=28):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=35, length=28):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_73",
    "sat": "def sat(seq: List[int], n: int=9, length: int=8):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=9, length=8):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_74",
    "sat": "def sat(seq: List[int], n: int=7128, length: int=6376):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=7128, length=6376):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_75",
    "sat": "def sat(seq: List[int], n: int=3707, length: int=2331):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=3707, length=2331):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_76",
    "sat": "def sat(seq: List[int], n: int=8, length: int=8):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=8, length=8):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_77",
    "sat": "def sat(seq: List[int], n: int=6784, length: int=3564):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=6784, length=3564):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_78",
    "sat": "def sat(seq: List[int], n: int=88, length: int=71):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=88, length=71):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_79",
    "sat": "def sat(seq: List[int], n: int=8169, length: int=7143):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=8169, length=7143):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_80",
    "sat": "def sat(seq: List[int], n: int=203, length: int=125):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=203, length=125):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_81",
    "sat": "def sat(seq: List[int], n: int=172, length: int=88):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=172, length=88):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_82",
    "sat": "def sat(seq: List[int], n: int=337, length: int=288):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=337, length=288):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_83",
    "sat": "def sat(seq: List[int], n: int=677, length: int=510):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=677, length=510):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_84",
    "sat": "def sat(seq: List[int], n: int=197, length: int=138):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=197, length=138):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_85",
    "sat": "def sat(seq: List[int], n: int=345, length: int=209):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=345, length=209):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_86",
    "sat": "def sat(seq: List[int], n: int=43, length: int=41):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=43, length=41):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_87",
    "sat": "def sat(seq: List[int], n: int=22, length: int=22):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=22, length=22):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_88",
    "sat": "def sat(seq: List[int], n: int=42, length: int=23):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=42, length=23):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_89",
    "sat": "def sat(seq: List[int], n: int=1453, length: int=1164):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=1453, length=1164):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_90",
    "sat": "def sat(seq: List[int], n: int=167, length: int=115):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=167, length=115):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_91",
    "sat": "def sat(seq: List[int], n: int=615, length: int=577):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=615, length=577):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_92",
    "sat": "def sat(seq: List[int], n: int=4891, length: int=4147):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=4891, length=4147):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_93",
    "sat": "def sat(seq: List[int], n: int=7, length: int=6):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=7, length=6):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_94",
    "sat": "def sat(seq: List[int], n: int=215, length: int=185):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=215, length=185):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_95",
    "sat": "def sat(seq: List[int], n: int=93, length: int=65):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=93, length=65):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_96",
    "sat": "def sat(seq: List[int], n: int=891, length: int=484):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=891, length=484):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_97",
    "sat": "def sat(seq: List[int], n: int=45, length: int=34):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=45, length=34):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_98",
    "sat": "def sat(seq: List[int], n: int=505, length: int=320):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=505, length=320):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "OnesAndTwos_99",
    "sat": "def sat(seq: List[int], n: int=44, length: int=42):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=44, length=42):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ]
  },
  {
    "name": "MinConsecutiveSum_0",
    "sat": "def sat(start: int, k: int=3, upper: int=6, seq: List[int]=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_1",
    "sat": "def sat(start: int, k: int=3, upper: int=-219, seq: List[int]=[-74, 97, -6, -73, -59, -87, 1, 74, 91, 57, -16, -98, -8, 15, 43, -75, -43, 84, 55, 45, -13, -88, 95, -28, 19, 3, 86, 7, -79, 73, -1, -63, 33, 20, 47, -61, 94, 24, -76, 20, 37, 88, 46, -67, -85, 54, -1, -52, -32, 39, -48, 66, 28, 25, -52, 76, 45, 81, 76, 39, 56, -92, -32, -24, -62, 63, 66, -78, -82, 84, 96, 76, 37, 0, 21, 21, 88, -30, -60, -34, -77]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-219, seq=[-74, 97, -6, -73, -59, -87, 1, 74, 91, 57, -16, -98, -8, 15, 43, -75, -43, 84, 55, 45, -13, -88, 95, -28, 19, 3, 86, 7, -79, 73, -1, -63, 33, 20, 47, -61, 94, 24, -76, 20, 37, 88, 46, -67, -85, 54, -1, -52, -32, 39, -48, 66, 28, 25, -52, 76, 45, 81, 76, 39, 56, -92, -32, -24, -62, 63, 66, -78, -82, 84, 96, 76, 37, 0, 21, 21, 88, -30, -60, -34, -77]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_2",
    "sat": "def sat(start: int, k: int=10, upper: int=58, seq: List[int]=[-24, -88, -56, -22, 95, -21, 52, 8, 72, 42]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=10, upper=58, seq=[-24, -88, -56, -22, 95, -21, 52, 8, 72, 42]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_3",
    "sat": "def sat(start: int, k: int=3, upper: int=-50, seq: List[int]=[-39, -61, 50]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-50, seq=[-39, -61, 50]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_4",
    "sat": "def sat(start: int, k: int=1, upper: int=39, seq: List[int]=[39, 59]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=39, seq=[39, 59]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_5",
    "sat": "def sat(start: int, k: int=8, upper: int=17, seq: List[int]=[-85, 3, -97, 9, 64, 77, -3, 49]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=17, seq=[-85, 3, -97, 9, 64, 77, -3, 49]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_6",
    "sat": "def sat(start: int, k: int=10, upper: int=196, seq: List[int]=[35, 84, 60, 7, -13, 43, -2, 79, -46, -51]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=10, upper=196, seq=[35, 84, 60, 7, -13, 43, -2, 79, -46, -51]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_7",
    "sat": "def sat(start: int, k: int=3, upper: int=-206, seq: List[int]=[20, 17, -77, -23, -40, -26, 52, -4, -25, -8, -95, 76, 76, 72, -10, 9, -35, -56, 40, 39, 65, -82, 59, 77, 10, 80, -43, 46, 37, -42, -41, 85, 62, 25, -3, -64, -100, -42, 63, -58, -68, 43, 27, -37, -98, -1, 54, -11, -27, -33, -91, 51, 82, 65, 88, -2, -95, 93, 88, -34, -55, 73, 36, -11, -11, 6, 94, -14, 63, -39, -21, 9, 90, -9, 2, -34, -28, -34, -83, -84, 66, 81, 29, -61, -49, -36, -6, -46, -80, -15]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-206, seq=[20, 17, -77, -23, -40, -26, 52, -4, -25, -8, -95, 76, 76, 72, -10, 9, -35, -56, 40, 39, 65, -82, 59, 77, 10, 80, -43, 46, 37, -42, -41, 85, 62, 25, -3, -64, -100, -42, 63, -58, -68, 43, 27, -37, -98, -1, 54, -11, -27, -33, -91, 51, 82, 65, 88, -2, -95, 93, 88, -34, -55, 73, 36, -11, -11, 6, 94, -14, 63, -39, -21, 9, 90, -9, 2, -34, -28, -34, -83, -84, 66, 81, 29, -61, -49, -36, -6, -46, -80, -15]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_8",
    "sat": "def sat(start: int, k: int=4, upper: int=92, seq: List[int]=[42, 93, 44, -2, 76, -26, 44]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=92, seq=[42, 93, 44, -2, 76, -26, 44]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_9",
    "sat": "def sat(start: int, k: int=7, upper: int=-250, seq: List[int]=[-29, -3, -59, -96, -45, 87, -73, 63, 37, -4, -78, 77, 68, 41, -68, 53, 16, -65, 32, 4, 68, -56, -76, 82, 82, 0, 35, 4, 70, -16, -84, 9, -95, 10, 0, -3, 37, 72, -52, 72, 64, 53, -86, -40, -78, 57, -16, -30, 62, -15, 3, 89, 11, 89, -33, 83, 96, 70, -21, 73, 50, -76, -43, -78, 17, -83, 96, -83, 7, 15, 66, -87, 13, -57, 22, 41, -7, 26, 52, 86, -35, 62, -70, -88, 64, -44, -4, -82, 79, 96, 76, 15, 55, 32, -93, -33, -78, 59, 51, -63, 82]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-250, seq=[-29, -3, -59, -96, -45, 87, -73, 63, 37, -4, -78, 77, 68, 41, -68, 53, 16, -65, 32, 4, 68, -56, -76, 82, 82, 0, 35, 4, 70, -16, -84, 9, -95, 10, 0, -3, 37, 72, -52, 72, 64, 53, -86, -40, -78, 57, -16, -30, 62, -15, 3, 89, 11, 89, -33, 83, 96, 70, -21, 73, 50, -76, -43, -78, 17, -83, 96, -83, 7, 15, 66, -87, 13, -57, 22, 41, -7, 26, 52, 86, -35, 62, -70, -88, 64, -44, -4, -82, 79, 96, 76, 15, 55, 32, -93, -33, -78, 59, 51, -63, 82]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_10",
    "sat": "def sat(start: int, k: int=10, upper: int=-347, seq: List[int]=[-19, -83, -45, -86, -7, 4, -48, 22, 32, -46, -90, 42, 85, 14, -23, -43, 44, -83, 30, 53, -12, -59, 41, -92, -15, 42, -12, -27, -14, 11, -4, 7, 35, 29, -63, -36, -56, -88, 78, 31, -95, 35, -36, -44, -100, 46, -66, 96, -74, 82, -97, 89, -32, 61, -48, 96, 76, -69, -64, -31, 72, -53, 44, -98, -86, 84, -25, 45, 39, -74, 63, 74, 67, 56, 11, -6, -87, -47, 82, 41, 93, -77, 65, -45, -39, -1, 4, -66, -45, -98, 86]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=10, upper=-347, seq=[-19, -83, -45, -86, -7, 4, -48, 22, 32, -46, -90, 42, 85, 14, -23, -43, 44, -83, 30, 53, -12, -59, 41, -92, -15, 42, -12, -27, -14, 11, -4, 7, 35, 29, -63, -36, -56, -88, 78, 31, -95, 35, -36, -44, -100, 46, -66, 96, -74, 82, -97, 89, -32, 61, -48, 96, 76, -69, -64, -31, 72, -53, 44, -98, -86, 84, -25, 45, 39, -74, 63, 74, 67, 56, 11, -6, -87, -47, 82, 41, 93, -77, 65, -45, -39, -1, 4, -66, -45, -98, 86]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_11",
    "sat": "def sat(start: int, k: int=4, upper: int=-108, seq: List[int]=[-67, 12, -87, 34]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-108, seq=[-67, 12, -87, 34]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_12",
    "sat": "def sat(start: int, k: int=4, upper: int=-231, seq: List[int]=[-53, -100, 15, -86, -60, 28]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-231, seq=[-53, -100, 15, -86, -60, 28]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_13",
    "sat": "def sat(start: int, k: int=6, upper: int=-162, seq: List[int]=[5, -72, 64, 53, 35, 97, -79, -8, 44, 45, -62, -97, 1, -93]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-162, seq=[5, -72, 64, 53, 35, 97, -79, -8, 44, 45, -62, -97, 1, -93]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_14",
    "sat": "def sat(start: int, k: int=5, upper: int=-186, seq: List[int]=[-5, -27, 78, -10, 79, -79, -51, 81, 24, -4, -55, 25, -63, -89]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-186, seq=[-5, -27, 78, -10, 79, -79, -51, 81, 24, -4, -55, 25, -63, -89]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_15",
    "sat": "def sat(start: int, k: int=5, upper: int=-303, seq: List[int]=[84, 5, 15, -96, -35, -83, 8, -97]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-303, seq=[84, 5, 15, -96, -35, -83, 8, -97]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_16",
    "sat": "def sat(start: int, k: int=5, upper: int=-232, seq: List[int]=[1, 12, -58, 93, 8, -68, -81, 19, 8, -81, -56, -25, -78, 44, -8, 95, -76, 68, -3, 66, 45, -30, 6, 64, -81, 61, -73, -5, 88, 94, -71, -63, 12, -65, -33]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-232, seq=[1, 12, -58, 93, 8, -68, -81, 19, 8, -81, -56, -25, -78, 44, -8, 95, -76, 68, -3, 66, 45, -30, 6, 64, -81, 61, -73, -5, 88, 94, -71, -63, 12, -65, -33]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_17",
    "sat": "def sat(start: int, k: int=6, upper: int=-422, seq: List[int]=[-48, -49, 2, 21, 25, 8, -8, 2, -39, -32, 72, -6, 62, -99, -94, -22, -99, 51, 78, 83, -82, 32, 27, 99, -31, 77, -55, -24, -39, -37, 43, 90, 76, -48, 71, -19, 67, -5, -86, 1, 80, 59, -93, -4, -74, 72, 75, 66, 87, -44, -95, -92, -45, -78, -68, -20, 20, -15, 74, 18, -94, -71, 29, 89, -37, 9, -56, 98, -63, -24, -81, -1, 44, 71, 2, -75, 37, 60, 63, -50, 35, -9, -9, -51, -78, -61, -23, 71, 3, 30, 85, -78, -29, -1, -46, 88, -67, -67, 7, 99, -61, -68, -85, 49, 61]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-422, seq=[-48, -49, 2, 21, 25, 8, -8, 2, -39, -32, 72, -6, 62, -99, -94, -22, -99, 51, 78, 83, -82, 32, 27, 99, -31, 77, -55, -24, -39, -37, 43, 90, 76, -48, 71, -19, 67, -5, -86, 1, 80, 59, -93, -4, -74, 72, 75, 66, 87, -44, -95, -92, -45, -78, -68, -20, 20, -15, 74, 18, -94, -71, 29, 89, -37, 9, -56, 98, -63, -24, -81, -1, 44, 71, 2, -75, 37, 60, 63, -50, 35, -9, -9, -51, -78, -61, -23, 71, 3, 30, 85, -78, -29, -1, -46, 88, -67, -67, 7, 99, -61, -68, -85, 49, 61]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_18",
    "sat": "def sat(start: int, k: int=7, upper: int=52, seq: List[int]=[25, 0, -63, 59, 57, -59, 33]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=52, seq=[25, 0, -63, 59, 57, -59, 33]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_19",
    "sat": "def sat(start: int, k: int=9, upper: int=-277, seq: List[int]=[-51, 26, 26, -30, -73, 77, 9, -74, -38, -83, 65, 15, 99, 26, -25, 25, -22, 81, -76, 87, 88, 8, 9, 85, 99, 70, -65, -1, -33, -59, -85, 7, 86, 76, 32, -33, -28, 36, 78, -64, 44, -72, 51, 89, 13, -97, 51, 98, 5, 8, -93, 14, 41, 84, -84, 33, -57, -21, -45, -24, -64, 4, 49, -71, -48, 95, -6, -49, 47, -30, -78, -27, 54, 29, 81, 99, 21]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-277, seq=[-51, 26, 26, -30, -73, 77, 9, -74, -38, -83, 65, 15, 99, 26, -25, 25, -22, 81, -76, 87, 88, 8, 9, 85, 99, 70, -65, -1, -33, -59, -85, 7, 86, 76, 32, -33, -28, 36, 78, -64, 44, -72, 51, 89, 13, -97, 51, 98, 5, 8, -93, 14, 41, 84, -84, 33, -57, -21, -45, -24, -64, 4, 49, -71, -48, 95, -6, -49, 47, -30, -78, -27, 54, 29, 81, 99, 21]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_20",
    "sat": "def sat(start: int, k: int=4, upper: int=-243, seq: List[int]=[22, 0, -72, 0, -6, -91, -48, -98, 56, 36, 17, 47, 79]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-243, seq=[22, 0, -72, 0, -6, -91, -48, -98, 56, 36, 17, 47, 79]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_21",
    "sat": "def sat(start: int, k: int=7, upper: int=-109, seq: List[int]=[79, -13, -3, 67, -85, -94, 14, 5]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-109, seq=[79, -13, -3, 67, -85, -94, 14, 5]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_22",
    "sat": "def sat(start: int, k: int=1, upper: int=82, seq: List[int]=[82]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=82, seq=[82]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_23",
    "sat": "def sat(start: int, k: int=3, upper: int=-187, seq: List[int]=[51, 54, -55, 11, -67, 47, 52, 82, 56, -97, -11, 81, -52, 78, 58, -7, -78, -73, -17, -97, 2, -76, -45, 92, -15, -2, 89, -47, -49, -68, 84, -6, -41, 91, -88, 55, -45, 31, 48, 27, 39, -8, -41, -1, 0, 52, -16, 28, 78, 59, 57, 89, -38, -15, -59, 97, 7, 19, -24, -58, 42, 85, -61, -2, -54, 48, -37, 89, 15]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-187, seq=[51, 54, -55, 11, -67, 47, 52, 82, 56, -97, -11, 81, -52, 78, 58, -7, -78, -73, -17, -97, 2, -76, -45, 92, -15, -2, 89, -47, -49, -68, 84, -6, -41, 91, -88, 55, -45, 31, 48, 27, 39, -8, -41, -1, 0, 52, -16, 28, 78, 59, 57, 89, -38, -15, -59, 97, 7, 19, -24, -58, 42, 85, -61, -2, -54, 48, -37, 89, 15]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_24",
    "sat": "def sat(start: int, k: int=8, upper: int=-162, seq: List[int]=[-91, -87, 92, -57, -59, -24, 75, -11, -29, 10, 85, -67, 99, -19, -41, -49]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-162, seq=[-91, -87, 92, -57, -59, -24, 75, -11, -29, 10, 85, -67, 99, -19, -41, -49]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_25",
    "sat": "def sat(start: int, k: int=7, upper: int=20, seq: List[int]=[83, -68, -12, -47, 97, -12, 56, 6, 97, -60, -49]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=20, seq=[83, -68, -12, -47, 97, -12, 56, 6, 97, -60, -49]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_26",
    "sat": "def sat(start: int, k: int=6, upper: int=-186, seq: List[int]=[-57, -92, 26, -9, -41, -13, 12, -40, 99, 34, -38, -46, -12, -27, 95]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-186, seq=[-57, -92, 26, -9, -41, -13, 12, -40, 99, 34, -38, -46, -12, -27, 95]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_27",
    "sat": "def sat(start: int, k: int=10, upper: int=35, seq: List[int]=[-55, 38, -51, 16, -29, 71, 63, -13, -9, 23, 24, -17, -54, -24, 52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=10, upper=35, seq=[-55, 38, -51, 16, -29, 71, 63, -13, -9, 23, 24, -17, -54, -24, 52]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_28",
    "sat": "def sat(start: int, k: int=6, upper: int=-303, seq: List[int]=[5, -82, -29, -12, -3, 36, 62, 28, 69, -7, 27, -56, 40, -32, -4, 38, 5, 6, -74, -98, -22, 32, 28, 37, 1, -10, 23, 20, 13, 69, -50, 26, 87, 41, 23, -61, -87, -68, 0, -37, 54, 62, 5, 50, -96, 47, 19, 63, -8, -19, 60, -11, -40, -48, -84, -69, 28, -33, -65, 68, 42, 51, -25, 59, 54, 96, -31, 9, 35, -59, 75, 12, 43, 62, 82, 99, -78, -34, 32, 29, 77, -82, -16, -66, 97, 54, 2, -90, 80, 0, -77, 80, -51, -79, 17, -80, 25, -64, -67, -23, -94, -38]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-303, seq=[5, -82, -29, -12, -3, 36, 62, 28, 69, -7, 27, -56, 40, -32, -4, 38, 5, 6, -74, -98, -22, 32, 28, 37, 1, -10, 23, 20, 13, 69, -50, 26, 87, 41, 23, -61, -87, -68, 0, -37, 54, 62, 5, 50, -96, 47, 19, 63, -8, -19, 60, -11, -40, -48, -84, -69, 28, -33, -65, 68, 42, 51, -25, 59, 54, 96, -31, 9, 35, -59, 75, 12, 43, 62, 82, 99, -78, -34, 32, 29, 77, -82, -16, -66, 97, 54, 2, -90, 80, 0, -77, 80, -51, -79, 17, -80, 25, -64, -67, -23, -94, -38]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_29",
    "sat": "def sat(start: int, k: int=7, upper: int=-182, seq: List[int]=[-9, -86, -80, -16, 27, 34, -52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-182, seq=[-9, -86, -80, -16, 27, 34, -52]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_30",
    "sat": "def sat(start: int, k: int=5, upper: int=-144, seq: List[int]=[-28, 15, 59, -95, -86, -37, 93]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-144, seq=[-28, 15, 59, -95, -86, -37, 93]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_31",
    "sat": "def sat(start: int, k: int=7, upper: int=-53, seq: List[int]=[-48, -31, -100, -46, 95, -11, 88, 72, -58, 97, 40, -7, 85, -41]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-53, seq=[-48, -31, -100, -46, 95, -11, 88, 72, -58, 97, 40, -7, 85, -41]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_32",
    "sat": "def sat(start: int, k: int=3, upper: int=-203, seq: List[int]=[98, -38, 42, -96, 28, -2, 70, -100, -10, -93, 37, -33, -88, -53, 9, 67, 38, 19, 42, 32, 57, -58, -87]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-203, seq=[98, -38, 42, -96, 28, -2, 70, -100, -10, -93, 37, -33, -88, -53, 9, 67, 38, 19, 42, 32, 57, -58, -87]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_33",
    "sat": "def sat(start: int, k: int=6, upper: int=48, seq: List[int]=[22, 62, 18, 94, 43, -65, -21, 71, 85, -65]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=48, seq=[22, 62, 18, 94, 43, -65, -21, 71, 85, -65]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_34",
    "sat": "def sat(start: int, k: int=3, upper: int=-47, seq: List[int]=[-27, -56, 36]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-47, seq=[-27, -56, 36]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_35",
    "sat": "def sat(start: int, k: int=3, upper: int=-164, seq: List[int]=[16, -15, -51, -28, 54, -89, 54, 93, 68, -72, -86, 74, 21, -53, 27, -60, -18, -86, 4, -13, -95, -46, 34, 96, 61, 94]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-164, seq=[16, -15, -51, -28, 54, -89, 54, 93, 68, -72, -86, 74, 21, -53, 27, -60, -18, -86, 4, -13, -95, -46, 34, 96, 61, 94]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_36",
    "sat": "def sat(start: int, k: int=4, upper: int=-46, seq: List[int]=[-67, -39, -11, 71]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-46, seq=[-67, -39, -11, 71]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_37",
    "sat": "def sat(start: int, k: int=3, upper: int=-169, seq: List[int]=[15, 98, -29, -25, -50, 70, -45, 57, -28, 95, 85, -51, -29, 65, 71, -49, 7, 34, 10, 64, -43, -21, -100, 92, -87, -100, 18, -38, 54, 52, -59, 91]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-169, seq=[15, 98, -29, -25, -50, 70, -45, 57, -28, 95, 85, -51, -29, 65, 71, -49, 7, 34, 10, 64, -43, -21, -100, 92, -87, -100, 18, -38, 54, 52, -59, 91]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_38",
    "sat": "def sat(start: int, k: int=8, upper: int=-59, seq: List[int]=[-11, 91, 23, 54, 30, -98, -62, 34, -95, 73, 5]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-59, seq=[-11, 91, 23, 54, 30, -98, -62, 34, -95, 73, 5]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_39",
    "sat": "def sat(start: int, k: int=8, upper: int=-305, seq: List[int]=[-71, -97, -62, 49, -72, -20, -18, 5, -90, -43, 33, 45, 85, -25, -75, -99, 89, -56, 54, 15, 73, -78, -87, 47, -78, -30, 0, 0, 17, 1, -6, 19, 94, 63, 9, -90, 70, 96, -52, -96, 87, -42, -2, 62, -85, 10, 7, -95, -6, -56, 92, -80, 18, -29, 65, -70, 32, 86, 82, -78]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-305, seq=[-71, -97, -62, 49, -72, -20, -18, 5, -90, -43, 33, 45, 85, -25, -75, -99, 89, -56, 54, 15, 73, -78, -87, 47, -78, -30, 0, 0, 17, 1, -6, 19, 94, 63, 9, -90, 70, 96, -52, -96, 87, -42, -2, 62, -85, 10, 7, -95, -6, -56, 92, -80, 18, -29, 65, -70, 32, 86, 82, -78]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_40",
    "sat": "def sat(start: int, k: int=10, upper: int=-269, seq: List[int]=[-93, 34, 85, -49, 82, 44, -44, -81, 56, 74, -53, 28, -12, 62, -97, 94, 62, 33, 58, 99, -31, 39, 5, 33, -82, -87, -47, -42, 54, -14, 37, 85, -37, 20, 37, 73, -16, 80, 94, 24, 82, 87, 71, 82, 88, -47, 46, -2, 56, -91, -63, 27, 54, -24, -78, 7, 25, -78, -48, 98, -47, -22, -68, -30, 14, 29, -6, -23, 36, 59, 25, -98, -75, -54, 20, -57, 80, -100, 98, 29, 38, -45, -20, -37]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=10, upper=-269, seq=[-93, 34, 85, -49, 82, 44, -44, -81, 56, 74, -53, 28, -12, 62, -97, 94, 62, 33, 58, 99, -31, 39, 5, 33, -82, -87, -47, -42, 54, -14, 37, 85, -37, 20, 37, 73, -16, 80, 94, 24, 82, 87, 71, 82, 88, -47, 46, -2, 56, -91, -63, 27, 54, -24, -78, 7, 25, -78, -48, 98, -47, -22, -68, -30, 14, 29, -6, -23, 36, 59, 25, -98, -75, -54, 20, -57, 80, -100, 98, 29, 38, -45, -20, -37]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_41",
    "sat": "def sat(start: int, k: int=8, upper: int=-85, seq: List[int]=[-80, 60, -20, -90, 57, 7, -37, 18, -39, 45, 82]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-85, seq=[-80, 60, -20, -90, 57, 7, -37, 18, -39, 45, 82]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_42",
    "sat": "def sat(start: int, k: int=8, upper: int=-239, seq: List[int]=[17, -33, -99, -85, 34, 57, -62, -68, 44, -42, 24, 55, -13, 81, -24, 63, 78, 81, -24]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-239, seq=[17, -33, -99, -85, 34, 57, -62, -68, 44, -42, 24, 55, -13, 81, -24, 63, 78, 81, -24]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_43",
    "sat": "def sat(start: int, k: int=6, upper: int=-324, seq: List[int]=[-66, -31, -81, 62, 63, -80, 48, 68, 21, -74, 82, 70, -47, -100, 71, -29, -49, -21, 74, 44, 5, 54, 58, -92, 99, 85, 40, 96, -54, -71, 56, -16, 93, 18, -53, 15, 42, -66, 27, 90, -10, 52, 50, -15, 55, -98, 23, 70, -88, -36, 7, -52, 1, 60, 54, -9, -67, 54, -87, -90, -66, -68, 32, 5, 9, -84, -45, -16, -36, -33]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-324, seq=[-66, -31, -81, 62, 63, -80, 48, 68, 21, -74, 82, 70, -47, -100, 71, -29, -49, -21, 74, 44, 5, 54, 58, -92, 99, 85, 40, 96, -54, -71, 56, -16, 93, 18, -53, 15, 42, -66, 27, 90, -10, 52, 50, -15, 55, -98, 23, 70, -88, -36, 7, -52, 1, 60, 54, -9, -67, 54, -87, -90, -66, -68, 32, 5, 9, -84, -45, -16, -36, -33]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_44",
    "sat": "def sat(start: int, k: int=6, upper: int=59, seq: List[int]=[77, 20, 54, -82, 48, -58]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=59, seq=[77, 20, 54, -82, 48, -58]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_45",
    "sat": "def sat(start: int, k: int=2, upper: int=-7, seq: List[int]=[53, 86, 20, 84, 77, 9, 56, -63]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-7, seq=[53, 86, 20, 84, 77, 9, 56, -63]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_46",
    "sat": "def sat(start: int, k: int=9, upper: int=-192, seq: List[int]=[-6, -46, 73, 8, -19, -63, -22, -74, -43]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-192, seq=[-6, -46, 73, 8, -19, -63, -22, -74, -43]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_47",
    "sat": "def sat(start: int, k: int=5, upper: int=-15, seq: List[int]=[-41, -78, -10, 27, 87]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-15, seq=[-41, -78, -10, 27, 87]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_48",
    "sat": "def sat(start: int, k: int=6, upper: int=-194, seq: List[int]=[82, 82, -83, 52, 43, -69, 98, 18, 56, -94, 44, -13, -93, -49, 11, -12, 89, -64, 9, 91, 71, -28, 79, 36, 22, 94, 62, 12, -100, 97, -51, 34, -49, -36, -69, 76, -44]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-194, seq=[82, 82, -83, 52, 43, -69, 98, 18, 56, -94, 44, -13, -93, -49, 11, -12, 89, -64, 9, 91, 71, -28, 79, 36, 22, 94, 62, 12, -100, 97, -51, 34, -49, -36, -69, 76, -44]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_49",
    "sat": "def sat(start: int, k: int=10, upper: int=-243, seq: List[int]=[-83, -83, 8, -35, 74, 97, -90, -10, -43, -73, 95, -88, -56, 85, 29, -92, 10, 59, -47]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=10, upper=-243, seq=[-83, -83, 8, -35, 74, 97, -90, -10, -43, -73, 95, -88, -56, 85, 29, -92, 10, 59, -47]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_50",
    "sat": "def sat(start: int, k: int=3, upper: int=-192, seq: List[int]=[-11, 81, 64, -91, -17, -54, 40, 4, -53, 44, 93, -57, -59, -29, -55, -45, -72, -75, 94, 35]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-192, seq=[-11, 81, 64, -91, -17, -54, 40, 4, -53, 44, 93, -57, -59, -29, -55, -45, -72, -75, 94, 35]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_51",
    "sat": "def sat(start: int, k: int=6, upper: int=94, seq: List[int]=[-15, 54, -42, 90, 88, -81, 11, 84, -23]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=94, seq=[-15, 54, -42, 90, 88, -81, 11, 84, -23]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_52",
    "sat": "def sat(start: int, k: int=2, upper: int=-153, seq: List[int]=[-79, 90, -63, -90, -32, 37, -4, -20, 86, 2]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-153, seq=[-79, 90, -63, -90, -32, 37, -4, -20, 86, 2]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_53",
    "sat": "def sat(start: int, k: int=8, upper: int=-88, seq: List[int]=[73, 88, -2, -23, -64, -35, 81, -64, 52, -27, -8, 14, 15, -15, 0, 49, -53, 99, 46, -87, -27, 2, -77, 39]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-88, seq=[73, 88, -2, -23, -64, -35, 81, -64, 52, -27, -8, 14, 15, -15, 0, 49, -53, 99, 46, -87, -27, 2, -77, 39]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_54",
    "sat": "def sat(start: int, k: int=2, upper: int=101, seq: List[int]=[31, 70]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=101, seq=[31, 70]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_55",
    "sat": "def sat(start: int, k: int=9, upper: int=-311, seq: List[int]=[13, 39, -95, -6, -79, -89, 40, 1, -52, -18, -13, 75, -80]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-311, seq=[13, 39, -95, -6, -79, -89, 40, 1, -52, -18, -13, 75, -80]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_56",
    "sat": "def sat(start: int, k: int=4, upper: int=-82, seq: List[int]=[-25, -46, -84, 73, 19, -61]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-82, seq=[-25, -46, -84, 73, 19, -61]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_57",
    "sat": "def sat(start: int, k: int=8, upper: int=-258, seq: List[int]=[-75, 67, 12, 80, -72, 57, -88, -64, -16, 71, 12, -80, 32, 47, -61, -95, -38, -26, 8, 37, -50, 81, 84, 44, 57, -34, 54, 54, -68, 92, 14, -71, 4, -35, -61, 0, -11, -66, -18, -5, -26, 9, -17, -42, -52, -52, -41, 26, 44, -51, 79, 27, 29, -62, 87, 17]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-258, seq=[-75, 67, 12, 80, -72, 57, -88, -64, -16, 71, 12, -80, 32, 47, -61, -95, -38, -26, 8, 37, -50, 81, 84, 44, 57, -34, 54, 54, -68, 92, 14, -71, 4, -35, -61, 0, -11, -66, -18, -5, -26, 9, -17, -42, -52, -52, -41, 26, 44, -51, 79, 27, 29, -62, 87, 17]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_58",
    "sat": "def sat(start: int, k: int=2, upper: int=-86, seq: List[int]=[14, -100]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-86, seq=[14, -100]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_59",
    "sat": "def sat(start: int, k: int=2, upper: int=-63, seq: List[int]=[4, 79, -44, 11, -74]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-63, seq=[4, 79, -44, 11, -74]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_60",
    "sat": "def sat(start: int, k: int=5, upper: int=73, seq: List[int]=[86, 56, 25, -37, 55, 7, 23, 51, 81, -17]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=73, seq=[86, 56, 25, -37, 55, 7, 23, 51, 81, -17]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_61",
    "sat": "def sat(start: int, k: int=8, upper: int=-249, seq: List[int]=[63, 52, 60, 10, 88, -67, 38, 30, 32, 75, -89, -7, 41, -97, -99, 85, -62, 51, 15, -44, 19, -14, 92, 81, 99, 91, -60, 3, 9, 61, 19, -37, -17, -18, -20, -87, -45, -6, 75, -27, -82, 12, -82, 98, -29, -46, 60, 48, 44, 54, 91, -72, 12, -5, 6, 37, -36, 44, -74, -36, 50, -44, -77, -38, 32, -62, 93, -74, 15]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-249, seq=[63, 52, 60, 10, 88, -67, 38, 30, 32, 75, -89, -7, 41, -97, -99, 85, -62, 51, 15, -44, 19, -14, 92, 81, 99, 91, -60, 3, 9, 61, 19, -37, -17, -18, -20, -87, -45, -6, 75, -27, -82, 12, -82, 98, -29, -46, 60, 48, 44, 54, 91, -72, 12, -5, 6, 37, -36, 44, -74, -36, 50, -44, -77, -38, 32, -62, 93, -74, 15]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_62",
    "sat": "def sat(start: int, k: int=4, upper: int=-267, seq: List[int]=[-41, -55, -27, -10, -43, -8, -84, 77, 55, -76, -76, 73, -86, 43, 11, -60, -23, 45, -42, 41, -72, 8, 94, 63, 94, -20, 76, -85, -35, -62, -85, 84, 54, -16, 37, 44, -38, 18, 80, -89, -14, -54, 47, -20, 66, 20, 9, -39, -24, 86, -36, -16, 69, 95, -73, 97, -72, -12, 23, 88, 98, 45, -15, 2, 90, -88, 14, 21, -80, -63, -59, -10, 73, 24, -62, -74, -19, 76, 38, 71, -29, -92, 8, -52, -45, -38, 95, 63, 46, 42, -76, 15, 26, -13, 51, -98, -56, 6, -15, -1, 8, -26, 74]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-267, seq=[-41, -55, -27, -10, -43, -8, -84, 77, 55, -76, -76, 73, -86, 43, 11, -60, -23, 45, -42, 41, -72, 8, 94, 63, 94, -20, 76, -85, -35, -62, -85, 84, 54, -16, 37, 44, -38, 18, 80, -89, -14, -54, 47, -20, 66, 20, 9, -39, -24, 86, -36, -16, 69, 95, -73, 97, -72, -12, 23, 88, 98, 45, -15, 2, 90, -88, 14, 21, -80, -63, -59, -10, 73, 24, -62, -74, -19, 76, 38, 71, -29, -92, 8, -52, -45, -38, 95, 63, 46, 42, -76, 15, 26, -13, 51, -98, -56, 6, -15, -1, 8, -26, 74]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_63",
    "sat": "def sat(start: int, k: int=1, upper: int=98, seq: List[int]=[98]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=98, seq=[98]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_64",
    "sat": "def sat(start: int, k: int=6, upper: int=-5, seq: List[int]=[-23, 94, 90, 4, 84, -81, 40, 14, -48, -14]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-5, seq=[-23, 94, 90, 4, 84, -81, 40, 14, -48, -14]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_65",
    "sat": "def sat(start: int, k: int=9, upper: int=119, seq: List[int]=[-7, 7, 76, 38, 47, 44, -18, -96, 28]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=119, seq=[-7, 7, 76, 38, 47, 44, -18, -96, 28]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_66",
    "sat": "def sat(start: int, k: int=6, upper: int=-329, seq: List[int]=[69, -79, -78, 60, 81, -85, 21, 46, -78, -30, -10, -13, -55, -57, 45, 13, -85, 3, 37, 26, 83, -41, 64, 70, 18, 32, -17, 83, 24, -100, 85, -58, -13, 63, -33, 60, -89, 49, -81, -97, -91, -7, 34, -30, -73, -34, -20, 86, -31, -40, 92, 87, 98, 82, 95, 19, -84, 94, -67, -80, -48, -86, 26, -49, -79, -93, -46, 30, 19, -75, -73, -81, 82, -21, -11, -32, 63, 46, 7, -62, 36, -56, 66, 46, -46, -33, 65, 6, 4, 51, -77, -57, -88, -16, -82, 73, 97, -30, -92, -80, 85, 84, -53, -40]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-329, seq=[69, -79, -78, 60, 81, -85, 21, 46, -78, -30, -10, -13, -55, -57, 45, 13, -85, 3, 37, 26, 83, -41, 64, 70, 18, 32, -17, 83, 24, -100, 85, -58, -13, 63, -33, 60, -89, 49, -81, -97, -91, -7, 34, -30, -73, -34, -20, 86, -31, -40, 92, 87, 98, 82, 95, 19, -84, 94, -67, -80, -48, -86, 26, -49, -79, -93, -46, 30, 19, -75, -73, -81, 82, -21, -11, -32, 63, 46, 7, -62, 36, -56, 66, 46, -46, -33, 65, 6, 4, 51, -77, -57, -88, -16, -82, 73, 97, -30, -92, -80, 85, 84, -53, -40]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_67",
    "sat": "def sat(start: int, k: int=8, upper: int=-355, seq: List[int]=[-70, -10, -12, 32, -45, 10, -95, -44, 67, 73, 31, 23, 35, -3, 1, 37, 4, 97, -94, 12, -7, -70, -90, 57, 54, 22, 28, 92, -91, 77, -17, 32, 71, -98, 0, 86, 30, -65, -45, 24, 73, 2, 53, 32, -45, 2, 32, -98, -22, -9, 83, -57, -73, 67, 83, -32, 56, 88, -39, 89, 86, 95, 5, -41, -81, -84, -31, -96, -1, -26, 19, 41, -29, -98, -45, -79, 16]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-355, seq=[-70, -10, -12, 32, -45, 10, -95, -44, 67, 73, 31, 23, 35, -3, 1, 37, 4, 97, -94, 12, -7, -70, -90, 57, 54, 22, 28, 92, -91, 77, -17, 32, 71, -98, 0, 86, 30, -65, -45, 24, 73, 2, 53, 32, -45, 2, 32, -98, -22, -9, 83, -57, -73, 67, 83, -32, 56, 88, -39, 89, 86, 95, 5, -41, -81, -84, -31, -96, -1, -26, 19, 41, -29, -98, -45, -79, 16]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_68",
    "sat": "def sat(start: int, k: int=1, upper: int=-89, seq: List[int]=[-41, 2, -22, -38, -63, -89, -33, 84, 22]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=-89, seq=[-41, 2, -22, -38, -63, -89, -33, 84, 22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_69",
    "sat": "def sat(start: int, k: int=3, upper: int=-230, seq: List[int]=[86, 98, -83, -57, 26, -96, -64, -42, 62, 24, 96, 18, -43, -25, -38, 28, -37, -32, -14, 86, -99, 64, -93, 12, 13, -18, 48, -27, 81, -54, -22, -55, 14, 60, -2, -36, -39, -80, -77, -58, -95, 20, 56, 20, 81, -82, 69, -70, 67, 79, 1, -24, 26, -61, 93, 9, -1, 61, 35, 37, -90]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-230, seq=[86, 98, -83, -57, 26, -96, -64, -42, 62, 24, 96, 18, -43, -25, -38, 28, -37, -32, -14, 86, -99, 64, -93, 12, 13, -18, 48, -27, 81, -54, -22, -55, 14, 60, -2, -36, -39, -80, -77, -58, -95, 20, 56, 20, 81, -82, 69, -70, 67, 79, 1, -24, 26, -61, 93, 9, -1, 61, 35, 37, -90]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_70",
    "sat": "def sat(start: int, k: int=1, upper: int=23, seq: List[int]=[23]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=23, seq=[23]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_71",
    "sat": "def sat(start: int, k: int=8, upper: int=-375, seq: List[int]=[75, 4, -53, -18, 91, -9, 42, 22, 14, 60, 99, 47, 39, -87, 52, 95, 99, -14, -48, -90, -23, 23, -25, 41, -83, -76, -29, -27, -72, -88, 24, -24, 99, -16, -67, 29, -12, 75, 30, 17, -58, -9, -21, -31, 84, -29, 28, 59, -21, -38, -75, -23, -84, -42, -31, -44, 81, -31, 30, 66, -98, 9, 90, 78, 61, 58, -81, 23, 90, 40, 30, -30, -36, 90, 57, -44, -84, -53, 21, 53, -36, -78, -100, 9, 94, 78, -75, 27, -18]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-375, seq=[75, 4, -53, -18, 91, -9, 42, 22, 14, 60, 99, 47, 39, -87, 52, 95, 99, -14, -48, -90, -23, 23, -25, 41, -83, -76, -29, -27, -72, -88, 24, -24, 99, -16, -67, 29, -12, 75, 30, 17, -58, -9, -21, -31, 84, -29, 28, 59, -21, -38, -75, -23, -84, -42, -31, -44, 81, -31, 30, 66, -98, 9, 90, 78, 61, 58, -81, 23, 90, 40, 30, -30, -36, 90, 57, -44, -84, -53, 21, 53, -36, -78, -100, 9, 94, 78, -75, 27, -18]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_72",
    "sat": "def sat(start: int, k: int=7, upper: int=212, seq: List[int]=[-58, 13, 80, -16, 87, 65, 41]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=212, seq=[-58, 13, 80, -16, 87, 65, 41]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_73",
    "sat": "def sat(start: int, k: int=5, upper: int=-26, seq: List[int]=[-57, -77, 48, 42, 18]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-26, seq=[-57, -77, 48, 42, 18]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_74",
    "sat": "def sat(start: int, k: int=4, upper: int=-260, seq: List[int]=[-87, -100, -85, 94, -35, 97, 68, -100, -4, 49, 34, -33, -56, -70, 92, 25, -1, 18, 94, 79, -60, -22, 53, -9, -92, -81, -78, -3, -43, 86, 21, -86, -81, 11, -14, -21, -37, -19, 28, -74, -62, -25, 24]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-260, seq=[-87, -100, -85, 94, -35, 97, 68, -100, -4, 49, 34, -33, -56, -70, 92, 25, -1, 18, 94, 79, -60, -22, 53, -9, -92, -81, -78, -3, -43, 86, 21, -86, -81, 11, -14, -21, -37, -19, 28, -74, -62, -25, 24]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_75",
    "sat": "def sat(start: int, k: int=9, upper: int=-374, seq: List[int]=[29, 68, -29, -20, -41, -27, -65, -82, -36, -28, -46, -11, 51, 0, -4, -92, 7, -11, -25, -55, 48, -59, -64, 97, 11, -84, -69, 43, 9, -47, -72, -56, -14, -30, -20, -56, 40, 71, 67]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-374, seq=[29, 68, -29, -20, -41, -27, -65, -82, -36, -28, -46, -11, 51, 0, -4, -92, 7, -11, -25, -55, 48, -59, -64, 97, 11, -84, -69, 43, 9, -47, -72, -56, -14, -30, -20, -56, 40, 71, 67]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_76",
    "sat": "def sat(start: int, k: int=8, upper: int=240, seq: List[int]=[98, 15, 92, 36, -39, 59, -6, 11, 72, 99]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=240, seq=[98, 15, 92, 36, -39, 59, -6, 11, 72, 99]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_77",
    "sat": "def sat(start: int, k: int=4, upper: int=-5, seq: List[int]=[-13, -68, 90, -14]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-5, seq=[-13, -68, 90, -14]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_78",
    "sat": "def sat(start: int, k: int=2, upper: int=-56, seq: List[int]=[-26, -30]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-56, seq=[-26, -30]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_79",
    "sat": "def sat(start: int, k: int=2, upper: int=43, seq: List[int]=[74, -17, 60]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=43, seq=[74, -17, 60]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_80",
    "sat": "def sat(start: int, k: int=5, upper: int=117, seq: List[int]=[71, 86, -46, 45, -39]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=117, seq=[71, 86, -46, 45, -39]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_81",
    "sat": "def sat(start: int, k: int=1, upper: int=26, seq: List[int]=[26]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=26, seq=[26]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_82",
    "sat": "def sat(start: int, k: int=1, upper: int=-98, seq: List[int]=[7, 80, 35, -12, 5, 69, -44, 82, 68, 93, 21, -55, 85, 20, -35, 90, -9, 18, 18, -67, -69, -24, 69, -76, 28, -38, 57, -96, 87, 40, -90, -88, 28, -98, 93, -53, -96, 78, -37, 45, -3, 57, 2, -33, -65, 59, 70, -23, -88, 52, -85, -54, -45, -8, -8, 48, -52, 54, -49, -37, -92, 44, -72, -15, -53, 69, 63, -26, -53, -49, 47, 7]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=-98, seq=[7, 80, 35, -12, 5, 69, -44, 82, 68, 93, 21, -55, 85, 20, -35, 90, -9, 18, 18, -67, -69, -24, 69, -76, 28, -38, 57, -96, 87, 40, -90, -88, 28, -98, 93, -53, -96, 78, -37, 45, -3, 57, 2, -33, -65, 59, 70, -23, -88, 52, -85, -54, -45, -8, -8, 48, -52, 54, -49, -37, -92, 44, -72, -15, -53, 69, 63, -26, -53, -49, 47, 7]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_83",
    "sat": "def sat(start: int, k: int=6, upper: int=-262, seq: List[int]=[-2, -25, -27, 53, 92, 27, -71, -89, 83, 54, -31, 33, 91, -65, -22, 95, -55, -89, 27, -100, -70, 25, -44, -92, 64, 17, -76, 9, 7, -2, -97, 23, 67, -81, -17, -17, -84, -31, 74, -42, -68, -87, 17, -80, 48, 39, 92, -29, -16, 72, -24, 93, 55, -68, -78, 75, -77, 46, 27, 18, 50, -75, -90, 88, -91, 18, 68, 74, -86, -63, -83, 50, 6, -23, 43, -77, 53, 26, -73, 81, 33, -100, -60, -13, 76, -57, -73, 92, 10, 76]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-262, seq=[-2, -25, -27, 53, 92, 27, -71, -89, 83, 54, -31, 33, 91, -65, -22, 95, -55, -89, 27, -100, -70, 25, -44, -92, 64, 17, -76, 9, 7, -2, -97, 23, 67, -81, -17, -17, -84, -31, 74, -42, -68, -87, 17, -80, 48, 39, 92, -29, -16, 72, -24, 93, 55, -68, -78, 75, -77, 46, 27, 18, 50, -75, -90, 88, -91, 18, 68, 74, -86, -63, -83, 50, 6, -23, 43, -77, 53, 26, -73, 81, 33, -100, -60, -13, 76, -57, -73, 92, 10, 76]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_84",
    "sat": "def sat(start: int, k: int=4, upper: int=-188, seq: List[int]=[93, 59, -86, -93, -68, 88, -33, -7, 83, -40]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-188, seq=[93, 59, -86, -93, -68, 88, -33, -7, 83, -40]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_85",
    "sat": "def sat(start: int, k: int=9, upper: int=-143, seq: List[int]=[81, -56, 24, 49, -22, -67, 14, -100, -66]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-143, seq=[81, -56, 24, 49, -22, -67, 14, -100, -66]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_86",
    "sat": "def sat(start: int, k: int=8, upper: int=-242, seq: List[int]=[-40, 39, -59, 43, -57, -18, -44, -64, 44, -87, -51, 67, 80, -53, 20, 54, 46, -89, 37, 2, 16, -72, 26, -67, 29, -9, -67, 40, -67, 50, -61, -14, -22, -18, -29, 45, 61, 81, 49, 82, -96, 6, 4, -85, -41]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-242, seq=[-40, 39, -59, 43, -57, -18, -44, -64, 44, -87, -51, 67, 80, -53, 20, 54, 46, -89, 37, 2, 16, -72, 26, -67, 29, -9, -67, 40, -67, 50, -61, -14, -22, -18, -29, 45, 61, 81, 49, 82, -96, 6, 4, -85, -41]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_87",
    "sat": "def sat(start: int, k: int=6, upper: int=-243, seq: List[int]=[-78, -48, -38, 80, -98, 8, -74, 8, 41, -91, -54, -73, 64, -46]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-243, seq=[-78, -48, -38, 80, -98, 8, -74, 8, 41, -91, -54, -73, 64, -46]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_88",
    "sat": "def sat(start: int, k: int=2, upper: int=-171, seq: List[int]=[-76, 73, 5, -72, 89, 70, 98, -52, -77, -46, 84, -33, -98, -52, 33, 88, -78, -93, 70, -34, -10, 91, 62, 67, -59, 67, -44, 99, 56, -69, -28, -16, -61, -13, 10, 25, 73, -41, -82, 62, 98, 21, 61, 91, 71, -71, 1, -11, 61, -86, -49, -18, -55, 94, -15, 36, -47, 39, -15, 40, -40, -72, -39, 69, 28, 28, -50, 53, 30, -54, -19, -91, 30, -86, 52, -75, -36, 26, 33, -71, -56, -84, -12, -73, 52, 90, 26, 69, -55, 19, 19, -81, 92, 41, 14]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-171, seq=[-76, 73, 5, -72, 89, 70, 98, -52, -77, -46, 84, -33, -98, -52, 33, 88, -78, -93, 70, -34, -10, 91, 62, 67, -59, 67, -44, 99, 56, -69, -28, -16, -61, -13, 10, 25, 73, -41, -82, 62, 98, 21, 61, 91, 71, -71, 1, -11, 61, -86, -49, -18, -55, 94, -15, 36, -47, 39, -15, 40, -40, -72, -39, 69, 28, 28, -50, 53, 30, -54, -19, -91, 30, -86, 52, -75, -36, 26, 33, -71, -56, -84, -12, -73, 52, 90, 26, 69, -55, 19, 19, -81, 92, 41, 14]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_89",
    "sat": "def sat(start: int, k: int=4, upper: int=-163, seq: List[int]=[-2, -67, -46, 55, -77, -95]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=4, upper=-163, seq=[-2, -67, -46, 55, -77, -95]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_90",
    "sat": "def sat(start: int, k: int=9, upper: int=-38, seq: List[int]=[25, -71, -85, -41, 75, -97, 93, 30, 33]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-38, seq=[25, -71, -85, -41, 75, -97, 93, 30, 33]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_91",
    "sat": "def sat(start: int, k: int=1, upper: int=-96, seq: List[int]=[-13, 81, -81, -96, 61, -90, -89, -43, -79, 52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=-96, seq=[-13, 81, -81, -96, 61, -90, -89, -43, -79, 52]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_92",
    "sat": "def sat(start: int, k: int=3, upper: int=-94, seq: List[int]=[-14, 15, -95]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=-94, seq=[-14, 15, -95]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_93",
    "sat": "def sat(start: int, k: int=2, upper: int=-125, seq: List[int]=[-81, 62, 22, -95, -30, 75]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-125, seq=[-81, 62, 22, -95, -30, 75]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_94",
    "sat": "def sat(start: int, k: int=8, upper: int=-242, seq: List[int]=[-97, 32, -15, -48, -52, -69, 27, 94, 80, 22, 41, 55, -21, 16, -22, -73, 65, -8, 32, -37, 1, -98, -97, 86, -56, -73]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-242, seq=[-97, 32, -15, -48, -52, -69, 27, 94, 80, 22, 41, 55, -21, 16, -22, -73, 65, -8, 32, -37, 1, -98, -97, 86, -56, -73]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_95",
    "sat": "def sat(start: int, k: int=5, upper: int=-279, seq: List[int]=[-63, 40, 21, 27, -56, -48, 72, -51, 99, 51, 62, -62, 89, 59, 32, 1, -48, -85, 1, -26, -87, -55, -46, 6, 23, 60, -74, -49, 3, 37, 85, -89, -46, 11, -17, 38, 55, -60, -52, -2, 94, 99, 54, -14, -13, 61, -34, -16, -69, -100, 6, -100, 49, -77, 71, -35, 61, -45, 98]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=5, upper=-279, seq=[-63, 40, 21, 27, -56, -48, 72, -51, 99, 51, 62, -62, 89, 59, 32, 1, -48, -85, 1, -26, -87, -55, -46, 6, 23, 60, -74, -49, 3, 37, 85, -89, -46, 11, -17, 38, 55, -60, -52, -2, 94, 99, 54, -14, -13, 61, -34, -16, -69, -100, 6, -100, 49, -77, 71, -35, 61, -45, 98]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_96",
    "sat": "def sat(start: int, k: int=7, upper: int=52, seq: List[int]=[71, 69, 89, 72, 80, 30, -40, -77, -45, 32]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=52, seq=[71, 69, 89, 72, 80, 30, -40, -77, -45, 32]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_97",
    "sat": "def sat(start: int, k: int=7, upper: int=-46, seq: List[int]=[-100, -35, 72, 82, -43, -87, 65, 12, 86, 51, 28, 34]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-46, seq=[-100, -35, 72, 82, -43, -87, 65, 12, 86, 51, 28, 34]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_98",
    "sat": "def sat(start: int, k: int=6, upper: int=-326, seq: List[int]=[-50, -97, -78, 2, 27, 93, 73, 97, 35, -75, -27, 83, -23, 44, -22, -9, 97, -5, 94, 79, 71, -43, -84, 28, 69, 10, -91, -69, -51, -83, -19, -13, -76, 91, 4, -46, -46, -78, -94, 10, 16, 90, 52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-326, seq=[-50, -97, -78, 2, 27, 93, 73, 97, 35, -75, -27, 83, -23, 44, -22, -9, 97, -5, 94, 79, 71, -43, -84, 28, 69, 10, -91, -69, -51, -83, -19, -13, -76, 91, 4, -46, -46, -78, -94, 10, 16, 90, 52]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MinConsecutiveSum_99",
    "sat": "def sat(start: int, k: int=2, upper: int=-91, seq: List[int]=[-60, -31]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=-91, seq=[-60, -31]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_0",
    "sat": "def sat(start: int, k: int=3, lower: int=150, seq: List[int]=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_1",
    "sat": "def sat(start: int, k: int=1, lower: int=74, seq: List[int]=[-3, 24, 74, 15, 29, 27, -53, 12, -52, 61, 42, 55, -91, -17, -47, -87, 34, -92, 18]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=74, seq=[-3, 24, 74, 15, 29, 27, -53, 12, -52, 61, 42, 55, -91, -17, -47, -87, 34, -92, 18]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_2",
    "sat": "def sat(start: int, k: int=7, lower: int=-86, seq: List[int]=[71, -84, 31, -62, 3, -72, 27]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=-86, seq=[71, -84, 31, -62, 3, -72, 27]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_3",
    "sat": "def sat(start: int, k: int=3, lower: int=-90, seq: List[int]=[-28, -12, -50]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=-90, seq=[-28, -12, -50]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_4",
    "sat": "def sat(start: int, k: int=5, lower: int=241, seq: List[int]=[-35, -81, -20, 59, 81, -31, -62, 39, 47, 55, 82, 18]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=241, seq=[-35, -81, -20, 59, 81, -31, -62, 39, 47, 55, 82, 18]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_5",
    "sat": "def sat(start: int, k: int=5, lower: int=277, seq: List[int]=[86, -96, -8, 50, -97, -22, -46, 73, 19, 42, -36, -53, 96, 21, 60, -53, 51, 59, 59, -82, -70, -73, 58, -99, 8, -38, 15, 35, -24, -19, 24, -37, -52, -11, 38, 24, -30, -55, 58, -42, -54, 18, -21, 41, 68, 78, 60, 27, 44, -100, -45, -54, -61, -53, 46, 82, -47, -91, 34, 69, 19, -76, 78, -83, -47, 58, -14, 72, -91, -15, 79, -90, 8, -44, 29, 23]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=277, seq=[86, -96, -8, 50, -97, -22, -46, 73, 19, 42, -36, -53, 96, 21, 60, -53, 51, 59, 59, -82, -70, -73, 58, -99, 8, -38, 15, 35, -24, -19, 24, -37, -52, -11, 38, 24, -30, -55, 58, -42, -54, 18, -21, 41, 68, 78, 60, 27, 44, -100, -45, -54, -61, -53, 46, 82, -47, -91, 34, 69, 19, -76, 78, -83, -47, 58, -14, 72, -91, -15, 79, -90, 8, -44, 29, 23]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_6",
    "sat": "def sat(start: int, k: int=10, lower: int=172, seq: List[int]=[35, 4, -85, -90, 96, 87, 48, 54, -2, 25]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=172, seq=[35, 4, -85, -90, 96, 87, 48, 54, -2, 25]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_7",
    "sat": "def sat(start: int, k: int=5, lower: int=380, seq: List[int]=[54, -17, 37, -97, 43, 72, 47, -44, -7, 25, 20, -36, 9, -96, 5, -8, -19, -33, -9, -72, -69, -6, -17, -36, 42, 92, -29, 97, -81, 86, 99, 43, 69, 83, 1, -41, 73, -22, 0, 35, -34, 6, 51, 69, -20, -90, 37, -68, 53, -33, -75, 36, 65, 89, 54, -2, 45, -67, 33, 61, 8, 64, -7, 17, -40]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=380, seq=[54, -17, 37, -97, 43, 72, 47, -44, -7, 25, 20, -36, 9, -96, 5, -8, -19, -33, -9, -72, -69, -6, -17, -36, 42, 92, -29, 97, -81, 86, 99, 43, 69, 83, 1, -41, 73, -22, 0, 35, -34, 6, 51, 69, -20, -90, 37, -68, 53, -33, -75, 36, 65, 89, 54, -2, 45, -67, 33, 61, 8, 64, -7, 17, -40]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_8",
    "sat": "def sat(start: int, k: int=3, lower: int=79, seq: List[int]=[-95, -90, -42, 54, -71, 64, 77, -62, -92, -64, 82]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=79, seq=[-95, -90, -42, 54, -71, 64, 77, -62, -92, -64, 82]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_9",
    "sat": "def sat(start: int, k: int=5, lower: int=289, seq: List[int]=[-17, 29, 24, -67, -73, -58, -85, -14, -70, 63, 59, -14, 84, -35, 58, -18, -77, -25, 67, -51, 80, -30, -95, 20, -73, -83, 81, 87, 72, 38, 7, 85, 19]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=289, seq=[-17, 29, 24, -67, -73, -58, -85, -14, -70, 63, 59, -14, 84, -35, 58, -18, -77, -25, 67, -51, 80, -30, -95, 20, -73, -83, 81, 87, 72, 38, 7, 85, 19]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_10",
    "sat": "def sat(start: int, k: int=1, lower: int=97, seq: List[int]=[-58, -90, 16, -57, 84, 77, 21, -68, 49, -93, 79, 72, -49, 38, -53, 12, -100, -48, 92, -37, -2, -22, -52, 20, -90, 46, -54, 97, -45, -49, 21, -88, 57, -92, -83, 30, -97, 5, -22, -73, 8, 6, 33, 54, -83, 40, 92, -84, 78, -13, 53, 39, -17, -59, 86, 20, 81, -66, -18, -97, 89, -7, 80, -65, 50, 76, -14, 94, 25, 42, 77]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=97, seq=[-58, -90, 16, -57, 84, 77, 21, -68, 49, -93, 79, 72, -49, 38, -53, 12, -100, -48, 92, -37, -2, -22, -52, 20, -90, 46, -54, 97, -45, -49, 21, -88, 57, -92, -83, 30, -97, 5, -22, -73, 8, 6, 33, 54, -83, 40, 92, -84, 78, -13, 53, 39, -17, -59, 86, 20, 81, -66, -18, -97, 89, -7, 80, -65, 50, 76, -14, 94, 25, 42, 77]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_11",
    "sat": "def sat(start: int, k: int=8, lower: int=162, seq: List[int]=[-39, 28, -44, 80, 45, -22, 34, 80]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=162, seq=[-39, 28, -44, 80, 45, -22, 34, 80]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_12",
    "sat": "def sat(start: int, k: int=8, lower: int=158, seq: List[int]=[-48, 39, -60, -92, 83, -69, -33, -97, -74, 24, -32, -41, 0, 35, -13, 94, 91]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=158, seq=[-48, 39, -60, -92, 83, -69, -33, -97, -74, 24, -32, -41, 0, 35, -13, 94, 91]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_13",
    "sat": "def sat(start: int, k: int=6, lower: int=60, seq: List[int]=[64, -100, 14, -12, 56, 38, -99, 62, -8, -100, -12, -86, 49, -76]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=60, seq=[64, -100, 14, -12, 56, 38, -99, 62, -8, -100, -12, -86, 49, -76]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_14",
    "sat": "def sat(start: int, k: int=9, lower: int=-101, seq: List[int]=[31, -88, -56, -93, -38, -68, 96, 57, 58]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=-101, seq=[31, -88, -56, -93, -38, -68, 96, 57, 58]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_15",
    "sat": "def sat(start: int, k: int=4, lower: int=116, seq: List[int]=[22, -19, 33, 80]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=116, seq=[22, -19, 33, 80]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_16",
    "sat": "def sat(start: int, k: int=9, lower: int=194, seq: List[int]=[-62, -61, -3, 19, -73, -39, 92, 12, -62, 57, 5, -66, 93, 40, 23, -96, -100, -75, -19, 75, -2, -84, 16, -7, -5, 15, -94, -50, -97, -26, -73, 68, -60, -46, -91, 85, -6, -18, 77, 37, 14, -66, -44, 15, -97]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=194, seq=[-62, -61, -3, 19, -73, -39, 92, 12, -62, 57, 5, -66, 93, 40, 23, -96, -100, -75, -19, 75, -2, -84, 16, -7, -5, 15, -94, -50, -97, -26, -73, 68, -60, -46, -91, 85, -6, -18, 77, 37, 14, -66, -44, 15, -97]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_17",
    "sat": "def sat(start: int, k: int=3, lower: int=214, seq: List[int]=[-29, 55, 71, 88, -42, 43]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=214, seq=[-29, 55, 71, 88, -42, 43]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_18",
    "sat": "def sat(start: int, k: int=1, lower: int=94, seq: List[int]=[49, 64, 32, 72, 44, -49, 82, 26, -89, -94, 87, -83, -2, -62, -45, 8, -66, -7, -74, 8, -36, -24, -30, 8, 47, -64, -52, 27, -33, 8, -78, -73, -57, -55, -33, -97, 77, -66, 81, 55, -30, 21, -96, -27, -78, -43, -3, 55, -81, 48, 56, 28, 85, -38, -18, -10, 11, 94]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=94, seq=[49, 64, 32, 72, 44, -49, 82, 26, -89, -94, 87, -83, -2, -62, -45, 8, -66, -7, -74, 8, -36, -24, -30, 8, 47, -64, -52, 27, -33, 8, -78, -73, -57, -55, -33, -97, 77, -66, 81, 55, -30, 21, -96, -27, -78, -43, -3, 55, -81, 48, 56, 28, 85, -38, -18, -10, 11, 94]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_19",
    "sat": "def sat(start: int, k: int=2, lower: int=148, seq: List[int]=[98, -39, 65, -78, 99, 49, -62, -40, 77]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=148, seq=[98, -39, 65, -78, 99, 49, -62, -40, 77]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_20",
    "sat": "def sat(start: int, k: int=10, lower: int=-471, seq: List[int]=[-61, -99, -10, 69, -75, -85, -88, -46, -55, -21]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-471, seq=[-61, -99, -10, 69, -75, -85, -88, -46, -55, -21]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_21",
    "sat": "def sat(start: int, k: int=10, lower: int=162, seq: List[int]=[-26, -42, 83, 4, -11, -93, 20, -21, -43, 39, 0, 76, -10, -24, 61, -13, -35, -68, 75, 20, 41, -76, 41, -27, 83, -73, -62, 33, 69, -12, -58, -63, 87, -48, -59, 82, -84, 19, 84, -36, 80, 37, -39, 23, -58, 23, 2, -47, 99, -71, 11, -49, -92, -33, -47, 28, 93, -78, 20, -64, 53, -7, -72, 72, 99, -21, -68]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=162, seq=[-26, -42, 83, 4, -11, -93, 20, -21, -43, 39, 0, 76, -10, -24, 61, -13, -35, -68, 75, 20, 41, -76, 41, -27, 83, -73, -62, 33, 69, -12, -58, -63, 87, -48, -59, 82, -84, 19, 84, -36, 80, 37, -39, 23, -58, 23, 2, -47, 99, -71, 11, -49, -92, -33, -47, 28, 93, -78, 20, -64, 53, -7, -72, 72, 99, -21, -68]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_22",
    "sat": "def sat(start: int, k: int=5, lower: int=6, seq: List[int]=[50, -55, 2, -75, -66, 53, 44, 50, -79, -66, -23, 4, 2]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=6, seq=[50, -55, 2, -75, -66, 53, 44, 50, -79, -66, -23, 4, 2]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_23",
    "sat": "def sat(start: int, k: int=2, lower: int=185, seq: List[int]=[35, -59, 96, -97, -17, 45, -33, 72, -5, 65, 17, -12, 52, 10, 61, 53, -85, 51, 43, 19, 7, -37, -53, -90, -99, -70, -41, 64, 90, 38, -96, 55, 34, 58, -74, 93, 70, 38, 56, -17, -21, -95, 8, 40, 47, 23, 26, -13, -21, -23, 96, 89, 2, 87, 19, -73, 72, 7, 6, -30, -38, -25, 83, -82, 17, 28, 22, 39, 73, 60, -67, 91, 73, 55, 34, -21, 0, -75, 89, -84]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=185, seq=[35, -59, 96, -97, -17, 45, -33, 72, -5, 65, 17, -12, 52, 10, 61, 53, -85, 51, 43, 19, 7, -37, -53, -90, -99, -70, -41, 64, 90, 38, -96, 55, 34, 58, -74, 93, 70, 38, 56, -17, -21, -95, 8, 40, 47, 23, 26, -13, -21, -23, 96, 89, 2, 87, 19, -73, 72, 7, 6, -30, -38, -25, 83, -82, 17, 28, 22, 39, 73, 60, -67, 91, 73, 55, 34, -21, 0, -75, 89, -84]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_24",
    "sat": "def sat(start: int, k: int=10, lower: int=-79, seq: List[int]=[-1, -77, 39, -72, 50, 58, -47, -25, 78, -83, -69, -8, 19, -69, -97, 81]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-79, seq=[-1, -77, 39, -72, 50, 58, -47, -25, 78, -83, -69, -8, 19, -69, -97, 81]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_25",
    "sat": "def sat(start: int, k: int=9, lower: int=143, seq: List[int]=[-28, 61, 34, -20, -14, -70, -46, 80, 71, -79, -70, 74, 47, -50, -88, 45, 48, 40, 90, -97, -78, 16, -74, 17, 64, -1, 53, 61, -50, 20, -52, 31, -77, -22, -61, 46, -14, -92, -45, -10, 14, -88, -55, -5, -85, -99, -31, 92, -58, -65, 2, -42]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=143, seq=[-28, 61, 34, -20, -14, -70, -46, 80, 71, -79, -70, 74, 47, -50, -88, 45, 48, 40, 90, -97, -78, 16, -74, 17, 64, -1, 53, 61, -50, 20, -52, 31, -77, -22, -61, 46, -14, -92, -45, -10, 14, -88, -55, -5, -85, -99, -31, 92, -58, -65, 2, -42]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_26",
    "sat": "def sat(start: int, k: int=2, lower: int=133, seq: List[int]=[-88, -40, -65, -59, -4, -50, -16, 12, -98, -48, 51, -74, -88, -13, -38, 1, -10, 98, 35, -66, -77, -10, -32, -17, -45, -7, 83, 32, 93, -31, 61, 13, -54, -57, 22, 41]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=133, seq=[-88, -40, -65, -59, -4, -50, -16, 12, -98, -48, 51, -74, -88, -13, -38, 1, -10, 98, 35, -66, -77, -10, -32, -17, -45, -7, 83, 32, 93, -31, 61, 13, -54, -57, 22, 41]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_27",
    "sat": "def sat(start: int, k: int=9, lower: int=-187, seq: List[int]=[-72, -6, -61, -54, -51, -83, 60, 80, -34, -61, -34, -16, -48]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=-187, seq=[-72, -6, -61, -54, -51, -83, 60, 80, -34, -61, -34, -16, -48]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_28",
    "sat": "def sat(start: int, k: int=2, lower: int=41, seq: List[int]=[-10, 51]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=41, seq=[-10, 51]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_29",
    "sat": "def sat(start: int, k: int=1, lower: int=11, seq: List[int]=[5, -68, -21, 11]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=11, seq=[5, -68, -21, 11]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_30",
    "sat": "def sat(start: int, k: int=8, lower: int=267, seq: List[int]=[42, 69, 92, 52, 60, -8, 6, -46, 21, -80, -100, 5, 37, 93, -45, 64, -90, 27, 60, -9, 31, 39]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=267, seq=[42, 69, 92, 52, 60, -8, 6, -46, 21, -80, -100, 5, 37, 93, -45, 64, -90, 27, 60, -9, 31, 39]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_31",
    "sat": "def sat(start: int, k: int=1, lower: int=95, seq: List[int]=[-56, 91, -86, -98, 66, 10, -61, 58, 95, 24, 70, -64, 46, -74, -22]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=95, seq=[-56, 91, -86, -98, 66, 10, -61, 58, 95, 24, 70, -64, 46, -74, -22]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_32",
    "sat": "def sat(start: int, k: int=4, lower: int=33, seq: List[int]=[-58, -88, -21, 30, 33, -42, -31, 73, -26, -88, 4]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=33, seq=[-58, -88, -21, 30, 33, -42, -31, 73, -26, -88, 4]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_33",
    "sat": "def sat(start: int, k: int=8, lower: int=140, seq: List[int]=[-67, 38, -12, 65, 55, 21, -22, 62]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=140, seq=[-67, 38, -12, 65, 55, 21, -22, 62]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_34",
    "sat": "def sat(start: int, k: int=5, lower: int=-81, seq: List[int]=[-58, -99, -14, 44, 46]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=-81, seq=[-58, -99, -14, 44, 46]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_35",
    "sat": "def sat(start: int, k: int=9, lower: int=42, seq: List[int]=[16, -73, 85, 25, -46, 57, 9, -82, 51, 16, -79, 40, -57, 42, -50, 94]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=42, seq=[16, -73, 85, 25, -46, 57, 9, -82, 51, 16, -79, 40, -57, 42, -50, 94]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_36",
    "sat": "def sat(start: int, k: int=8, lower: int=90, seq: List[int]=[98, -26, 27, 0, -95, 61, -63, -27, 76, 71, 67, -56]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=90, seq=[98, -26, 27, 0, -95, 61, -63, -27, 76, 71, 67, -56]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_37",
    "sat": "def sat(start: int, k: int=5, lower: int=264, seq: List[int]=[20, -69, -89, -32, -75, 82, -67, 0, 71, -77, 97, 26, 47, 55, 39, -4, -86, -76, 41, -43, 32, 71, -74, 66, -31, -46, 69, 47, 43, -60, 48, 63]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=264, seq=[20, -69, -89, -32, -75, 82, -67, 0, 71, -77, 97, 26, 47, 55, 39, -4, -86, -76, 41, -43, 32, 71, -74, 66, -31, -46, 69, 47, 43, -60, 48, 63]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_38",
    "sat": "def sat(start: int, k: int=5, lower: int=-141, seq: List[int]=[-69, 77, -86, -31, -32]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=-141, seq=[-69, 77, -86, -31, -32]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_39",
    "sat": "def sat(start: int, k: int=3, lower: int=0, seq: List[int]=[-25, 25, -43, 18, -63, -7, 54, -81]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=0, seq=[-25, 25, -43, 18, -63, -7, 54, -81]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_40",
    "sat": "def sat(start: int, k: int=8, lower: int=348, seq: List[int]=[27, -38, -67, -85, -6, 21, 5, 60, -22, 12, 56, -8, -39, 33, 54, -61, 82, -1, -54, 34, -4, 50, 60, -36, 0, -18, -92, 97, 52, -55, -79, -48, 10, -35, -3, -15, -99, -66, -3, 99, 14, 52, 5, -45, 66, 47, -43, 17, 70, 48, 49, 55, -44, 34, 79, -60, 91, -30, 74, 79, 32, 83, -70, 83]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=348, seq=[27, -38, -67, -85, -6, 21, 5, 60, -22, 12, 56, -8, -39, 33, 54, -61, 82, -1, -54, 34, -4, 50, 60, -36, 0, -18, -92, 97, 52, -55, -79, -48, 10, -35, -3, -15, -99, -66, -3, 99, 14, 52, 5, -45, 66, 47, -43, 17, 70, 48, 49, 55, -44, 34, 79, -60, 91, -30, 74, 79, 32, 83, -70, 83]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_41",
    "sat": "def sat(start: int, k: int=1, lower: int=84, seq: List[int]=[-86, -45, -7, 84]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=84, seq=[-86, -45, -7, 84]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_42",
    "sat": "def sat(start: int, k: int=8, lower: int=271, seq: List[int]=[-34, 50, -39, -46, 92, 24, 40, -72, 24, -58, 97, -47, -20, -16, 65, 67, 45, -58, 93, 54, -30, 35, -69, 64, 86, 37, 91, 4, -68, 39, -84, -26, 91, -67, -6, 8, -50, -79, -82, 46, 44, 25, 42, 45, -36, 25, -60, 17, -91, -13]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=271, seq=[-34, 50, -39, -46, 92, 24, 40, -72, 24, -58, 97, -47, -20, -16, 65, 67, 45, -58, 93, 54, -30, 35, -69, 64, 86, 37, 91, 4, -68, 39, -84, -26, 91, -67, -6, 8, -50, -79, -82, 46, 44, 25, 42, 45, -36, 25, -60, 17, -91, -13]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_43",
    "sat": "def sat(start: int, k: int=9, lower: int=-232, seq: List[int]=[-81, 76, 26, -36, -73, -43, -14, -55, -32]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=-232, seq=[-81, 76, 26, -36, -73, -43, -14, -55, -32]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_44",
    "sat": "def sat(start: int, k: int=10, lower: int=-83, seq: List[int]=[88, -78, 53, 51, -9, -67, -90, 19, 9, -59]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-83, seq=[88, -78, 53, 51, -9, -67, -90, 19, 9, -59]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_45",
    "sat": "def sat(start: int, k: int=7, lower: int=435, seq: List[int]=[-54, -23, -66, -36, -15, 71, -74, 65, -46, 17, 3, -52, 12, 64, 32, -45, -94, 68, -19, -3, -85, 28, -41, -1, 19, -92, -66, -71, 30, -26, -56, -11, -82, -96, -56, -13, 36, -38, 3, -32, -55, -19, 90, -43, 70, 67, 82, 83, 86, 75, -99, 83]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=435, seq=[-54, -23, -66, -36, -15, 71, -74, 65, -46, 17, 3, -52, 12, 64, 32, -45, -94, 68, -19, -3, -85, 28, -41, -1, 19, -92, -66, -71, 30, -26, -56, -11, -82, -96, -56, -13, 36, -38, 3, -32, -55, -19, 90, -43, 70, 67, 82, 83, 86, 75, -99, 83]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_46",
    "sat": "def sat(start: int, k: int=1, lower: int=98, seq: List[int]=[89, -96, -69, -44, 80, -26, -77, 55, -60, -67, 56, 29, -5, -12, -3, -93, -24, -13, 59, 97, 49, -47, 46, -73, -30, -34, -61, -79, -25, -46, 97, 0, 23, -96, 98, 80, -51, -90, -14, -1]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=98, seq=[89, -96, -69, -44, 80, -26, -77, 55, -60, -67, 56, 29, -5, -12, -3, -93, -24, -13, 59, 97, 49, -47, 46, -73, -30, -34, -61, -79, -25, -46, 97, 0, 23, -96, 98, 80, -51, -90, -14, -1]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_47",
    "sat": "def sat(start: int, k: int=6, lower: int=17, seq: List[int]=[-1, -38, -20, 10, 50, 16]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=17, seq=[-1, -38, -20, 10, 50, 16]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_48",
    "sat": "def sat(start: int, k: int=9, lower: int=118, seq: List[int]=[-35, 34, -85, 52, 93, 72, 11, 17, -41]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=118, seq=[-35, 34, -85, 52, 93, 72, 11, 17, -41]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_49",
    "sat": "def sat(start: int, k: int=3, lower: int=191, seq: List[int]=[-14, 47, 57, 5, 69, 26, -64, 79, 63, 49, -74, 58, -86, 65, 85, 6, -21, -43, 92, -29, -85, -21, -38, 98, 8, 45, -75, 27, -79, -10, -51, 86, -8, -75, -6, -12, 66, -43, -78]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=191, seq=[-14, 47, 57, 5, 69, 26, -64, 79, 63, 49, -74, 58, -86, 65, 85, 6, -21, -43, 92, -29, -85, -21, -38, 98, 8, 45, -75, 27, -79, -10, -51, 86, -8, -75, -6, -12, 66, -43, -78]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_50",
    "sat": "def sat(start: int, k: int=7, lower: int=272, seq: List[int]=[23, 72, -28, 82, 79, 43, -59, 38, 79, 10, -70, -59, 84]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=272, seq=[23, 72, -28, 82, 79, 43, -59, 38, 79, 10, -70, -59, 84]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_51",
    "sat": "def sat(start: int, k: int=8, lower: int=273, seq: List[int]=[78, -26, 87, 77, 86, 70, -1, -98]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=273, seq=[78, -26, 87, 77, 86, 70, -1, -98]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_52",
    "sat": "def sat(start: int, k: int=4, lower: int=-11, seq: List[int]=[89, 18, -46, -72]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=-11, seq=[89, 18, -46, -72]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_53",
    "sat": "def sat(start: int, k: int=2, lower: int=191, seq: List[int]=[82, 95, 96, 53, 85, -52, 33, -33, -53, 82, 46, -60, -22, -29, 46, -6, -18, 38, 61, -62, -93, 98]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=191, seq=[82, 95, 96, 53, 85, -52, 33, -33, -53, 82, 46, -60, -22, -29, 46, -6, -18, 38, 61, -62, -93, 98]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_54",
    "sat": "def sat(start: int, k: int=6, lower: int=-111, seq: List[int]=[49, -71, -43, -26, -17, -3]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=-111, seq=[49, -71, -43, -26, -17, -3]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_55",
    "sat": "def sat(start: int, k: int=5, lower: int=20, seq: List[int]=[25, -73, -12, 10, 70]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=20, seq=[25, -73, -12, 10, 70]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_56",
    "sat": "def sat(start: int, k: int=5, lower: int=207, seq: List[int]=[9, 63, 72, -9, 33, 48, 16, -93, 54, 22]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=207, seq=[9, 63, 72, -9, 33, 48, 16, -93, 54, 22]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_57",
    "sat": "def sat(start: int, k: int=9, lower: int=299, seq: List[int]=[26, 95, 84, -13, 27, -92, -4, 88, 88]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=299, seq=[26, 95, 84, -13, 27, -92, -4, 88, 88]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_58",
    "sat": "def sat(start: int, k: int=9, lower: int=329, seq: List[int]=[-1, -33, -46, 36, 25, 88, -21, 77, -96, 1, -56, 98, 40, -71, -55, 80, -36, 94, -24, -52, -22, -29, 93, -10, -12, -80, 88, 86, 60, -38, -86, -83, 61, 97, 14, -24, -24, -45, -41, 36, 83, 32, 85, -3, 64, -33, 4, 61, 26, 55, -24, -12, -10, 74, -85, 60, -51, 23, 99, -9, -49, 68, -21, 50, 44, -94, -63, 56, -45, 41, 15, -92, 43]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=329, seq=[-1, -33, -46, 36, 25, 88, -21, 77, -96, 1, -56, 98, 40, -71, -55, 80, -36, 94, -24, -52, -22, -29, 93, -10, -12, -80, 88, 86, 60, -38, -86, -83, 61, 97, 14, -24, -24, -45, -41, 36, 83, 32, 85, -3, 64, -33, 4, 61, 26, 55, -24, -12, -10, 74, -85, 60, -51, 23, 99, -9, -49, 68, -21, 50, 44, -94, -63, 56, -45, 41, 15, -92, 43]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_59",
    "sat": "def sat(start: int, k: int=5, lower: int=205, seq: List[int]=[-13, -67, 1, -99, 34, 13, -85, -12, -63, -57, 98, -47, -70, 13, 98, 85, 20, -11, -98, -68]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=205, seq=[-13, -67, 1, -99, 34, 13, -85, -12, -63, -57, 98, -47, -70, 13, 98, 85, 20, -11, -98, -68]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_60",
    "sat": "def sat(start: int, k: int=10, lower: int=-29, seq: List[int]=[77, 48, 63, -37, -87, -60, -29, 27, -16, -15]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-29, seq=[77, 48, 63, -37, -87, -60, -29, 27, -16, -15]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_61",
    "sat": "def sat(start: int, k: int=7, lower: int=-112, seq: List[int]=[-39, 30, 48, -8, -54, -49, -40]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=-112, seq=[-39, 30, 48, -8, -54, -49, -40]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_62",
    "sat": "def sat(start: int, k: int=8, lower: int=47, seq: List[int]=[-9, 67, 9, -24, -44, -14, 84, -46, 15, -71, 78]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=47, seq=[-9, 67, 9, -24, -44, -14, 84, -46, 15, -71, 78]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_63",
    "sat": "def sat(start: int, k: int=10, lower: int=196, seq: List[int]=[-56, 19, 4, 14, -45, 35, 1, 57, 83, 84, -64, -10]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=196, seq=[-56, 19, 4, 14, -45, 35, 1, 57, 83, 84, -64, -10]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_64",
    "sat": "def sat(start: int, k: int=4, lower: int=198, seq: List[int]=[-24, -11, -55, 77, -93, 50, -9, -20, 87, 79, -69, 12, 90, 17, 59, 32, -84, 56, -75, -52, -7, 43, 50, 53, -77, 79, -51, -40, -41, -85, 97, -53, 66, -55, 23, -77, 36, -45, 15, -11, 46, 21, -92, 35, -34, -39, -45, 66]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=198, seq=[-24, -11, -55, 77, -93, 50, -9, -20, 87, 79, -69, 12, 90, 17, 59, 32, -84, 56, -75, -52, -7, 43, 50, 53, -77, 79, -51, -40, -41, -85, 97, -53, 66, -55, 23, -77, 36, -45, 15, -11, 46, 21, -92, 35, -34, -39, -45, 66]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_65",
    "sat": "def sat(start: int, k: int=10, lower: int=-292, seq: List[int]=[-78, 38, -88, -64, -70, -93, -42, 3, 53, 49]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-292, seq=[-78, 38, -88, -64, -70, -93, -42, 3, 53, 49]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_66",
    "sat": "def sat(start: int, k: int=3, lower: int=27, seq: List[int]=[14, 46, -33, -67, 67]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=27, seq=[14, 46, -33, -67, 67]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_67",
    "sat": "def sat(start: int, k: int=6, lower: int=-74, seq: List[int]=[-1, 16, -80, 89, -30, -68]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=-74, seq=[-1, 16, -80, 89, -30, -68]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_68",
    "sat": "def sat(start: int, k: int=8, lower: int=91, seq: List[int]=[-34, 3, 99, 65, -70, 19, 61, -52, -81, -42, -98, 58, -100, -17, 88, 46, -99]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=91, seq=[-34, 3, 99, 65, -70, 19, 61, -52, -81, -42, -98, 58, -100, -17, 88, 46, -99]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_69",
    "sat": "def sat(start: int, k: int=4, lower: int=235, seq: List[int]=[99, 71, -50, 56, 60, 81, 38, -5, 81, 66]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=235, seq=[99, 71, -50, 56, 60, 81, 38, -5, 81, 66]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_70",
    "sat": "def sat(start: int, k: int=10, lower: int=300, seq: List[int]=[13, -52, 74, -74, -26, -53, -94, -81, 89, 91, -37, -36, 14, -92, 44, -12, -98, 82, -83, 8, 34, -22, 91, -67, -78, 66, 42, 89, -5, 91, 93, -80, 22, -11, -33, -82, 88, 38, -75, -64, -94, -77, 63, -87, -51, 54, -4, 3, -4, -46, 80, -35, -39, -19, 73, -11, -38, -8, -86, -53, 90, -89, 15, 38, -28, -26, 36, 92, 97, -26, 23, 75, -45, -6, -51, 21, -73, -15, 20, -67, 28, 74, -22, -81, -23, 90, 12, 4, 54, 71, 54, -18, 33, -48, -81, 89, 82, -4]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=300, seq=[13, -52, 74, -74, -26, -53, -94, -81, 89, 91, -37, -36, 14, -92, 44, -12, -98, 82, -83, 8, 34, -22, 91, -67, -78, 66, 42, 89, -5, 91, 93, -80, 22, -11, -33, -82, 88, 38, -75, -64, -94, -77, 63, -87, -51, 54, -4, 3, -4, -46, 80, -35, -39, -19, 73, -11, -38, -8, -86, -53, 90, -89, 15, 38, -28, -26, 36, 92, 97, -26, 23, 75, -45, -6, -51, 21, -73, -15, 20, -67, 28, 74, -22, -81, -23, 90, 12, 4, 54, 71, 54, -18, 33, -48, -81, 89, 82, -4]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_71",
    "sat": "def sat(start: int, k: int=5, lower: int=190, seq: List[int]=[-44, -49, 67, -84, 7, -88, -57, -69, -34, -28, 14, 31, -68, -64, 52, 54, 91, 49, -65, -66, 55, 23, 22, -5, -59, 78, 20, 30, 12, -41, 89, 3, -78, -70, -24, 72, 0, 28, 82, -76, -41, -83, -36, -51, -19, -82, -33, -68, -61, 40, 73, 75, -50, 52, -19, -37, 69, 77, -81, 37, -40, 24, 6, -96, 75, -80, -78, -17, -24, -87, -6, 93, -20, -83, 81, -14, -90, -40, -3]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=190, seq=[-44, -49, 67, -84, 7, -88, -57, -69, -34, -28, 14, 31, -68, -64, 52, 54, 91, 49, -65, -66, 55, 23, 22, -5, -59, 78, 20, 30, 12, -41, 89, 3, -78, -70, -24, 72, 0, 28, 82, -76, -41, -83, -36, -51, -19, -82, -33, -68, -61, 40, 73, 75, -50, 52, -19, -37, 69, 77, -81, 37, -40, 24, 6, -96, 75, -80, -78, -17, -24, -87, -6, 93, -20, -83, 81, -14, -90, -40, -3]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_72",
    "sat": "def sat(start: int, k: int=2, lower: int=164, seq: List[int]=[-100, -80, 63, 4, 3, -25, 92, -67, 73, -30, -86, 5, 3, -8, -43, 31, -70, 22, 53, 64, -27, 61, 84, -49, -28, 25, 54, 22, -24, -60, 79, 55, -6, -37, -73, 20, 88, 76, -38, 51, -25, -72, -7, 36, 31, 99, -34, 96, 27, 11, 65, 22, -51, -97, -86, 40, 70, -73, -24, -33, 18, -74, -39, -58, -3, 63, 79, -41, -29, 97, 3, 27, 77, -44]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=164, seq=[-100, -80, 63, 4, 3, -25, 92, -67, 73, -30, -86, 5, 3, -8, -43, 31, -70, 22, 53, 64, -27, 61, 84, -49, -28, 25, 54, 22, -24, -60, 79, 55, -6, -37, -73, 20, 88, 76, -38, 51, -25, -72, -7, 36, 31, 99, -34, 96, 27, 11, 65, 22, -51, -97, -86, 40, 70, -73, -24, -33, 18, -74, -39, -58, -3, 63, 79, -41, -29, 97, 3, 27, 77, -44]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_73",
    "sat": "def sat(start: int, k: int=8, lower: int=190, seq: List[int]=[39, -20, 57, 85, -24, -53, -64, -61, -72, 31, 97, 85, 61, 6, 43]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=190, seq=[39, -20, 57, 85, -24, -53, -64, -61, -72, 31, 97, 85, 61, 6, 43]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_74",
    "sat": "def sat(start: int, k: int=10, lower: int=-56, seq: List[int]=[-62, -57, 2, 43, -6, -100, -80, 62, -38, 59, -46, -74, -50, 23, -28, 90, -54, 26, -58]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-56, seq=[-62, -57, 2, 43, -6, -100, -80, 62, -38, 59, -46, -74, -50, 23, -28, 90, -54, 26, -58]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_75",
    "sat": "def sat(start: int, k: int=9, lower: int=-102, seq: List[int]=[86, -38, -88, 1, 33, -75, -75, 83, -29]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=-102, seq=[86, -38, -88, 1, 33, -75, -75, 83, -29]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_76",
    "sat": "def sat(start: int, k: int=8, lower: int=186, seq: List[int]=[-66, 93, -31, 52, -47, 84, -72, 37, 69, 46, 17, -22, -50]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=186, seq=[-66, 93, -31, 52, -47, 84, -72, 37, 69, 46, 17, -22, -50]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_77",
    "sat": "def sat(start: int, k: int=8, lower: int=31, seq: List[int]=[-68, -49, 44, -78, -14, 16, 89, 91]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=31, seq=[-68, -49, 44, -78, -14, 16, 89, 91]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_78",
    "sat": "def sat(start: int, k: int=6, lower: int=217, seq: List[int]=[53, 85, 97, 34, -96, -94, 41, -82, 51, -75, 82, 67, 89, 3, -84, -45, 52, -66, 18, 57, 61, -47, -42, 70, -13, 99, -68]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=217, seq=[53, 85, 97, 34, -96, -94, 41, -82, 51, -75, 82, 67, 89, 3, -84, -45, 52, -66, 18, 57, 61, -47, -42, 70, -13, 99, -68]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_79",
    "sat": "def sat(start: int, k: int=10, lower: int=140, seq: List[int]=[-41, -16, 39, 87, 30, -95, 74, 28, 5, 29]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=140, seq=[-41, -16, 39, 87, 30, -95, 74, 28, 5, 29]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_80",
    "sat": "def sat(start: int, k: int=2, lower: int=-5, seq: List[int]=[-32, 27]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=-5, seq=[-32, 27]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_81",
    "sat": "def sat(start: int, k: int=4, lower: int=233, seq: List[int]=[99, -16, 50, -42, 29, 62, 46, 94, -93, 59, 31, 51, 92, -13, -94, -14, 65, 27, 67, -46, 95, 98, 82, -66, -2, 11, 89, 97, -39, 84, -23, 8, 35, 7, -23, -38, -39, 57, 39, -46, -94, -51, 80, -82, -28]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=233, seq=[99, -16, 50, -42, 29, 62, 46, 94, -93, 59, 31, 51, 92, -13, -94, -14, 65, 27, 67, -46, 95, 98, 82, -66, -2, 11, 89, 97, -39, 84, -23, 8, 35, 7, -23, -38, -39, 57, 39, -46, -94, -51, 80, -82, -28]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_82",
    "sat": "def sat(start: int, k: int=10, lower: int=246, seq: List[int]=[18, 76, -42, -62, 11, -39, 43, -90, 24, 85, -33, 49, 47, -7, 7, -34, -54, 0, 44, -30, 10, 75, 41, 47, -92, 17, -56, -79, 4, 68, -52, 85, -49, 18, 20, 25, -37, -77, -65, -6, 15, -94, -27, -33, 18, 43, 37, 61, 44, 19, 56, -91, -48, 56, 69, -22, -60, -7, 41, 10, 26]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=246, seq=[18, 76, -42, -62, 11, -39, 43, -90, 24, 85, -33, 49, 47, -7, 7, -34, -54, 0, 44, -30, 10, 75, 41, 47, -92, 17, -56, -79, 4, 68, -52, 85, -49, 18, 20, 25, -37, -77, -65, -6, 15, -94, -27, -33, 18, 43, 37, 61, 44, 19, 56, -91, -48, 56, 69, -22, -60, -7, 41, 10, 26]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_83",
    "sat": "def sat(start: int, k: int=10, lower: int=227, seq: List[int]=[27, 31, 82, 31, 24, 9, 42, 39, 14, -72, -14]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=227, seq=[27, 31, 82, 31, 24, 9, 42, 39, 14, -72, -14]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_84",
    "sat": "def sat(start: int, k: int=8, lower: int=279, seq: List[int]=[-70, -6, -24, 25, -28, 40, 70, -17, 89, 78, -1, 15, -49, 42, 67, 38, 33]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=8, lower=279, seq=[-70, -6, -24, 25, -28, 40, 70, -17, 89, 78, -1, 15, -49, 42, 67, 38, 33]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_85",
    "sat": "def sat(start: int, k: int=4, lower: int=148, seq: List[int]=[-65, -70, -69, 81, -10, -65, -71, 42, 74, -9, 41, -98, 69, -58, -65, 74, -85, -17, -77, -100, -78, -51, 58, -71, -32, -98, -82, 73, 72, 39, -50, 40, -25, 12, 16, 52, -42, -84, 14, 10]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=148, seq=[-65, -70, -69, 81, -10, -65, -71, 42, 74, -9, 41, -98, 69, -58, -65, 74, -85, -17, -77, -100, -78, -51, 58, -71, -32, -98, -82, 73, 72, 39, -50, 40, -25, 12, 16, 52, -42, -84, 14, 10]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_86",
    "sat": "def sat(start: int, k: int=10, lower: int=154, seq: List[int]=[80, -92, 70, -30, -42, 70, 35, -6, -32, -93, -35, 62, 17, -46, -67, 68, 55, 0, 55, -52, 62, 0, 22, -50, -83, -74, -24, -9, 14, 79, 3, -81, -75, -17, 58, -20, 64, 73, -66, -27, 78, 35, -70]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=154, seq=[80, -92, 70, -30, -42, 70, 35, -6, -32, -93, -35, 62, 17, -46, -67, 68, 55, 0, 55, -52, 62, 0, 22, -50, -83, -74, -24, -9, 14, 79, 3, -81, -75, -17, 58, -20, 64, 73, -66, -27, 78, 35, -70]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_87",
    "sat": "def sat(start: int, k: int=9, lower: int=-165, seq: List[int]=[-5, 21, -98, -66, -4, -1, -22, 43, -33]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=-165, seq=[-5, 21, -98, -66, -4, -1, -22, 43, -33]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_88",
    "sat": "def sat(start: int, k: int=5, lower: int=251, seq: List[int]=[18, -26, 85, 67, -69, -49, -7, -37, 12, -9, -63, 29, 8, -81, -78, -88, -61, 23, -66, 91, 31, -53, 87, 91, 54, -46, 65]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=251, seq=[18, -26, 85, 67, -69, -49, -7, -37, 12, -9, -63, 29, 8, -81, -78, -88, -61, 23, -66, 91, 31, -53, 87, 91, 54, -46, 65]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_89",
    "sat": "def sat(start: int, k: int=6, lower: int=36, seq: List[int]=[-52, 32, -2, 89, -94, -90, 87, -35, -49, -32, -24, 89]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=36, seq=[-52, 32, -2, 89, -94, -90, 87, -35, -49, -32, -24, 89]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_90",
    "sat": "def sat(start: int, k: int=2, lower: int=89, seq: List[int]=[-65, 50, 26, 63, -42, 19, 37, -52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=89, seq=[-65, 50, 26, 63, -42, 19, 37, -52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_91",
    "sat": "def sat(start: int, k: int=4, lower: int=228, seq: List[int]=[-31, 60, 75, -54, -13, -8, 20, -36, 47, 51, -72, 29, 97, -45, -66, -31, -72, 57, -26, 68, -78, 74, -85, 45, -15, -63, 65, 86, -61, 35, -27, -71, -73, 34, -52, 91, 84, -80, 8, 13, 62, 62, 33, 16, -44, 26, 68, 59, 75, -81, 47, -63, 51, 21, -68, 31, 61, -10, 26, 64, 65, 41, 43, 50, 33, 52, 55, -23, -23, -10, -20, -21]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=228, seq=[-31, 60, 75, -54, -13, -8, 20, -36, 47, 51, -72, 29, 97, -45, -66, -31, -72, 57, -26, 68, -78, 74, -85, 45, -15, -63, 65, 86, -61, 35, -27, -71, -73, 34, -52, 91, 84, -80, 8, 13, 62, 62, 33, 16, -44, 26, 68, 59, 75, -81, 47, -63, 51, 21, -68, 31, 61, -10, 26, 64, 65, 41, 43, 50, 33, 52, 55, -23, -23, -10, -20, -21]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_92",
    "sat": "def sat(start: int, k: int=7, lower: int=-85, seq: List[int]=[99, 57, 16, -82, -55, -24, -96]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=-85, seq=[99, 57, 16, -82, -55, -24, -96]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_93",
    "sat": "def sat(start: int, k: int=10, lower: int=-68, seq: List[int]=[-45, 79, -3, -73, 36, -52, -65, 31, 25, -1]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=-68, seq=[-45, 79, -3, -73, 36, -52, -65, 31, 25, -1]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_94",
    "sat": "def sat(start: int, k: int=10, lower: int=100, seq: List[int]=[11, -98, -1, 93, 87, 32, -7, -12, 69, -90, -60, -11, -68, 96, -74, 43, -44, 52, -27, 80, -67, -6, -6]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=100, seq=[11, -98, -1, 93, 87, 32, -7, -12, 69, -90, -60, -11, -68, 96, -74, 43, -44, 52, -27, 80, -67, -6, -6]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_95",
    "sat": "def sat(start: int, k: int=10, lower: int=199, seq: List[int]=[54, -58, -41, 8, 11, 77, -16, 39, 28, 97, -56, -15, -56, -15, -26, -98, -84, 17, 22]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=10, lower=199, seq=[54, -58, -41, 8, 11, 77, -16, 39, 28, 97, -56, -15, -56, -15, -26, -98, -84, 17, 22]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_96",
    "sat": "def sat(start: int, k: int=5, lower: int=214, seq: List[int]=[-70, -74, -46, 24, 71, 2, 84, -42, 19, 8, 21, 42, -56, 80, -5, 98, 4, 37, -87, 6, 25, -23]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=5, lower=214, seq=[-70, -74, -46, 24, 71, 2, 84, -42, 19, 8, 21, 42, -56, 80, -5, 98, 4, 37, -87, 6, 25, -23]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_97",
    "sat": "def sat(start: int, k: int=4, lower: int=248, seq: List[int]=[73, -31, -96, -48, -98, 1, -6, -34, -38, 22, 35, 91, 44, -79, -73, 71, -84, -100, 57, 65, 47, 19, -86, -82, -94, 91, 37, 67, -15, -41, 99, -16, 51, -88, -58, 69, 62, 5, 54, -74, 74, -2, 96, 60, -41, -17, -8, -17, -47, 36, -14, 87, 22, -29, -54, 32, 45, 91, -39, 54, 43, 82, -52, 56, -66, 18, -70, 54, 41, 68, 5, -59, -6, 77, 54, -49, 48, -32, 27, 21, -65, -59, 0, -81, -43, -50, 79, -51, 5, 71, 31, 4, -6, -19, 80, 81, -9, 96]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=4, lower=248, seq=[73, -31, -96, -48, -98, 1, -6, -34, -38, 22, 35, 91, 44, -79, -73, 71, -84, -100, 57, 65, 47, 19, -86, -82, -94, 91, 37, 67, -15, -41, 99, -16, 51, -88, -58, 69, 62, 5, 54, -74, 74, -2, 96, 60, -41, -17, -8, -17, -47, 36, -14, 87, 22, -29, -54, 32, 45, 91, -39, 54, 43, 82, -52, 56, -66, 18, -70, 54, 41, 68, 5, -59, -6, 77, 54, -49, 48, -32, 27, 21, -65, -59, 0, -81, -43, -50, 79, -51, 5, 71, 31, 4, -6, -19, 80, 81, -9, 96]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_98",
    "sat": "def sat(start: int, k: int=6, lower: int=101, seq: List[int]=[62, -74, -89, 48, 6, -63, 0, -75, -35, 48, 85, 65, 13]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=101, seq=[62, -74, -89, 48, 6, -63, 0, -75, -35, 48, 85, 65, 13]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveSum_99",
    "sat": "def sat(start: int, k: int=2, lower: int=-33, seq: List[int]=[51, -84]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=-33, seq=[51, -84]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_0",
    "sat": "def sat(start: int, k: int=3, lower: int=100000, seq: List[int]=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_1",
    "sat": "def sat(start: int, k: int=10, lower: int=0, seq: List[int]=[-49, 74, -6, -94, 51, -36, 66, 0, -13, 86]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=0, seq=[-49, 74, -6, -94, 51, -36, 66, 0, -13, 86]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_2",
    "sat": "def sat(start: int, k: int=2, lower: int=9300, seq: List[int]=[-61, -61, 20, 5, -57, 9, 73, -62, -100, -93, 65, -11, 11, -99, -24, 61, 33, -100, -91, 3, 33, -45]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=9300, seq=[-61, -61, 20, 5, -57, 9, 73, -62, -100, -93, 65, -11, 11, -99, -24, 61, 33, -100, -91, 3, 33, -45]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_3",
    "sat": "def sat(start: int, k: int=8, lower: int=162600164496000, seq: List[int]=[58, -49, 94, 0, -91, -7, 39, -27, -91, -4, -7, -61, 5, -39, -96, 20, 99, 40, 40, 65, -66, -14, 30, 57, 7, 32, -42, 85, -36, 36, 71, -33, -85, -24, 4, 46, -16, 20, 51, -1, 83, -66, -87, -100, -53, -20]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=162600164496000, seq=[58, -49, 94, 0, -91, -7, 39, -27, -91, -4, -7, -61, 5, -39, -96, 20, 99, 40, 40, 65, -66, -14, 30, 57, 7, 32, -42, 85, -36, 36, 71, -33, -85, -24, 4, 46, -16, 20, 51, -1, 83, -66, -87, -100, -53, -20]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_4",
    "sat": "def sat(start: int, k: int=8, lower: int=1136095994880, seq: List[int]=[-88, 6, 67, -72, 59, 28, -18, -15]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=1136095994880, seq=[-88, 6, 67, -72, 59, 28, -18, -15]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_5",
    "sat": "def sat(start: int, k: int=4, lower: int=20994336, seq: List[int]=[49, 18, 59, 25, -65, -3, -68, -44, 5, -85, -91, -69, 74, -15, -11, -96, -5, -94, -10, 81, 18, -54, 39, -81, 57, -54, 47, -72, 62, -4, 36, -88, -94, 47, 54, 15, -10]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=20994336, seq=[49, 18, 59, 25, -65, -3, -68, -44, 5, -85, -91, -69, 74, -15, -11, -96, -5, -94, -10, 81, 18, -54, 39, -81, 57, -54, 47, -72, 62, -4, 36, -88, -94, 47, 54, 15, -10]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_6",
    "sat": "def sat(start: int, k: int=9, lower: int=-15002910720000, seq: List[int]=[40, -18, -40, 70, 4, 38, 68, -30, 24]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=-15002910720000, seq=[40, -18, -40, 70, 4, 38, 68, -30, 24]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_7",
    "sat": "def sat(start: int, k: int=7, lower: int=-9627984000, seq: List[int]=[-12, -32, 45, -57, 23, -85, -5]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=-9627984000, seq=[-12, -32, 45, -57, 23, -85, -5]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_8",
    "sat": "def sat(start: int, k: int=9, lower: int=-3328625664000, seq: List[int]=[-18, 42, -14, -6, 2, -39, -70, -100, -96]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=-3328625664000, seq=[-18, 42, -14, -6, 2, -39, -70, -100, -96]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_9",
    "sat": "def sat(start: int, k: int=2, lower: int=2993, seq: List[int]=[29, 73, 41, -18, -5, -56, 15, -27, 51, 53]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=2993, seq=[29, 73, 41, -18, -5, -56, 15, -27, 51, 53]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_10",
    "sat": "def sat(start: int, k: int=8, lower: int=45955373473152, seq: List[int]=[52, -44, 63, -71, -23, 47, -40, 80, -72, -7, -94, -21, 91, -10, -82, 56, -5, 27, -93, -41, 69, 81, 37, -76, -18, -71]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=45955373473152, seq=[52, -44, 63, -71, -23, 47, -40, 80, -72, -7, -94, -21, 91, -10, -82, 56, -5, 27, -93, -41, 69, 81, 37, -76, -18, -71]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_11",
    "sat": "def sat(start: int, k: int=9, lower: int=-463134672000, seq: List[int]=[54, 2, -51, -2, -2, -44, -98, -65, -75]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=-463134672000, seq=[54, 2, -51, -2, -2, -44, -98, -65, -75]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_12",
    "sat": "def sat(start: int, k: int=3, lower: int=526680, seq: List[int]=[-28, 32, 47, -95, 88, -63, 40, -25, -4, 34, 17, 90, 21, -6, -28, -80, 8, -63, 68, 27, 69, 73, 96, 48, -38, 54, -56, 68, -77, -53, -15, -14, 11, 71, 36, 78, -16, 34, 88, -45, -56, 46, -95, -10, 92, -11, 51, 5, 93, 92, -10, -84, -51, 93, -48, -13, -13, -3, 69, 50, 96, -66, -15]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=526680, seq=[-28, 32, 47, -95, 88, -63, 40, -25, -4, 34, 17, 90, 21, -6, -28, -80, 8, -63, 68, 27, 69, 73, 96, 48, -38, 54, -56, 68, -77, -53, -15, -14, 11, 71, 36, 78, -16, 34, 88, -45, -56, 46, -95, -10, 92, -11, 51, 5, 93, 92, -10, -84, -51, 93, -48, -13, -13, -3, 69, 50, 96, -66, -15]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_13",
    "sat": "def sat(start: int, k: int=10, lower: int=249076816816988160, seq: List[int]=[78, -71, 54, -90, 54, 44, -37, -43, 6, -10, -62, -66, 18, -44, 70, 8, -6, -29, -52, 88, 11, -98, 92, -90, 52, -25, -48, -75, -52, 1, 72, -52, 49, 19, 75, 82, 94, -57, -62, -28, 58, -33, 64, 1, -72, 57, 99, 45, -29, -14, 56, 64, 18, -34, -1, 9, -63, -32, 14, -92, 84, -36]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=249076816816988160, seq=[78, -71, 54, -90, 54, 44, -37, -43, 6, -10, -62, -66, 18, -44, 70, 8, -6, -29, -52, 88, 11, -98, 92, -90, 52, -25, -48, -75, -52, 1, 72, -52, 49, 19, 75, 82, 94, -57, -62, -28, 58, -33, 64, 1, -72, 57, 99, 45, -29, -14, 56, 64, 18, -34, -1, 9, -63, -32, 14, -92, 84, -36]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_14",
    "sat": "def sat(start: int, k: int=7, lower: int=1034121816000, seq: List[int]=[19, 21, -20, 76, 46, 44, -15, -26, 94, -20, -18, -66, -81, 46, -39, 88, -4, -42, -22, 19, -23, 23, -32, 64, 27, -31, 94, 38, 15, -12, 64, 2, -40, -48, 57, -99, -27, 6, 42, -51, 74, 4, -41, 30, -22, -26, 65, -86, 52, -31, 27, -71, 45, 19, 91, 75, 32, -78, 7, -40, -22, 79, 26]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=1034121816000, seq=[19, 21, -20, 76, 46, 44, -15, -26, 94, -20, -18, -66, -81, 46, -39, 88, -4, -42, -22, 19, -23, 23, -32, 64, 27, -31, 94, 38, 15, -12, 64, 2, -40, -48, 57, -99, -27, 6, 42, -51, 74, 4, -41, 30, -22, -26, 65, -86, 52, -31, 27, -71, 45, 19, 91, 75, 32, -78, 7, -40, -22, 79, 26]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_15",
    "sat": "def sat(start: int, k: int=10, lower: int=2218631815886653440, seq: List[int]=[72, -84, -94, 43, -78, 99, -3, 39, -89, -38, -61, 94, 60]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=2218631815886653440, seq=[72, -84, -94, 43, -78, 99, -3, 39, -89, -38, -61, 94, 60]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_16",
    "sat": "def sat(start: int, k: int=3, lower: int=4230, seq: List[int]=[-47, -90, 1]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=4230, seq=[-47, -90, 1]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_17",
    "sat": "def sat(start: int, k: int=5, lower: int=129771520, seq: List[int]=[-64, 84, -12, 70, -84, 12, -2, -80, -46, 19, -29]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=129771520, seq=[-64, 84, -12, 70, -84, 12, -2, -80, -46, 19, -29]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_18",
    "sat": "def sat(start: int, k: int=8, lower: int=460330053480000, seq: List[int]=[5, -11, -8, -51, -86, -82, 10, -84, -93, -57, 0, 90, 29, 39, -36, -82, 80, -58, -45, -22, 46, 67, -39, -65, 49, 58, -17, 85, 14, 55, -16, -77, -22, 63, -66, -92, 72, -43, 7, 45, 86, -1, 91, 76, -81, 68, 24, -84, 58, -23, -4, -19, 38, -3, 10, -31, 53, -29, -65, -80, 89, 3, -60, 22, -59, -68, 41, -55, 35, -60, 40, -14, -38, 13, 8, -65, -58, -85, 36, -71, -50, 82, 99, 90, -3, -35]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=460330053480000, seq=[5, -11, -8, -51, -86, -82, 10, -84, -93, -57, 0, 90, 29, 39, -36, -82, 80, -58, -45, -22, 46, 67, -39, -65, 49, 58, -17, 85, 14, 55, -16, -77, -22, 63, -66, -92, 72, -43, 7, 45, 86, -1, 91, 76, -81, 68, 24, -84, 58, -23, -4, -19, 38, -3, 10, -31, 53, -29, -65, -80, 89, 3, -60, 22, -59, -68, 41, -55, 35, -60, 40, -14, -38, 13, 8, -65, -58, -85, 36, -71, -50, 82, 99, 90, -3, -35]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_19",
    "sat": "def sat(start: int, k: int=10, lower: int=807998765333760, seq: List[int]=[82, -48, -52, 77, -74, -19, -5, -11, -17, -39]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=807998765333760, seq=[82, -48, -52, 77, -74, -19, -5, -11, -17, -39]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_20",
    "sat": "def sat(start: int, k: int=8, lower: int=136308002220000, seq: List[int]=[45, -47, 82, 95, -87, -57, 0, 50, 80, 65, -37, 43]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=136308002220000, seq=[45, -47, 82, 95, -87, -57, 0, 50, 80, 65, -37, 43]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_21",
    "sat": "def sat(start: int, k: int=9, lower: int=694997066889216, seq: List[int]=[-28, -18, 46, -72, -91, 68, 9, -11, -11, -64, 48, 11, -78, 4, -35, -89, -9, 84]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=694997066889216, seq=[-28, -18, 46, -72, -91, 68, 9, -11, -11, -64, 48, 11, -78, 4, -35, -89, -9, 84]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_22",
    "sat": "def sat(start: int, k: int=9, lower: int=0, seq: List[int]=[0, 33, 41, 38, 64, -92, -53, -48, 86]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=0, seq=[0, 33, 41, 38, 64, -92, -53, -48, 86]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_23",
    "sat": "def sat(start: int, k: int=10, lower: int=270153721212480000, seq: List[int]=[51, 79, -100, 50, -86, 59, 76, 46, -27, -28]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=270153721212480000, seq=[51, 79, -100, 50, -86, 59, 76, 46, -27, -28]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_24",
    "sat": "def sat(start: int, k: int=6, lower: int=6143346000, seq: List[int]=[22, -23, -38, 75, 71, 60]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=6, lower=6143346000, seq=[22, -23, -38, 75, 71, 60]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_25",
    "sat": "def sat(start: int, k: int=8, lower: int=9839520576000, seq: List[int]=[34, 38, -22, -68, -80, 34, 9, 75, 61]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=9839520576000, seq=[34, 38, -22, -68, -80, 34, 9, 75, 61]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_26",
    "sat": "def sat(start: int, k: int=9, lower: int=12879586621440000, seq: List[int]=[-70, 55, 56, 97, 37, 13, 9, 25, 91, 20, -30, 45, -64, 88, -81]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=12879586621440000, seq=[-70, 55, 56, 97, 37, 13, 9, 25, 91, 20, -30, 45, -64, 88, -81]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_27",
    "sat": "def sat(start: int, k: int=9, lower: int=0, seq: List[int]=[61, 44, 24, 0, -68, 32, -16, 64, 9]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=0, seq=[61, 44, 24, 0, -68, 32, -16, 64, 9]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_28",
    "sat": "def sat(start: int, k: int=4, lower: int=36367650, seq: List[int]=[50, -7, 86, -17, -14, -39, -15, -88, 74, -21, 81, 9, -86, -41, -61, 0, 19, -48, -52, 7, 34, 49, 96, -5, 48, -28, 51, -38, 33, 13, -51, 47, 2, -77, -100, -6, 80, -55, -26, -88, -23, 12, -91, -58, 33, -90, 2, -69, 26, 20, -62, 54, -58, 13, -85, 98, 31, 28, 67, 99, -92, 25, -67, 60, 49, 99, 77, 17, 17, 23, 60, -33, -93, -79, 90, 55, -90, -27, -47, -77, -3]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=36367650, seq=[50, -7, 86, -17, -14, -39, -15, -88, 74, -21, 81, 9, -86, -41, -61, 0, 19, -48, -52, 7, 34, 49, 96, -5, 48, -28, 51, -38, 33, 13, -51, 47, 2, -77, -100, -6, 80, -55, -26, -88, -23, 12, -91, -58, 33, -90, 2, -69, 26, 20, -62, 54, -58, 13, -85, 98, 31, 28, 67, 99, -92, 25, -67, 60, 49, 99, 77, 17, 17, 23, 60, -33, -93, -79, 90, 55, -90, -27, -47, -77, -3]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_29",
    "sat": "def sat(start: int, k: int=2, lower: int=9120, seq: List[int]=[95, 19, 24, -15, 60, 70, 40, -4, -2, 77, -36, -70, -4, 30, 19, 58, -4, 79, 56, -67, 75, 35, -96, -37, -25, -45, -83, 35, 96]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=9120, seq=[95, 19, 24, -15, 60, 70, 40, -4, -2, 77, -36, -70, -4, 30, 19, 58, -4, 79, 56, -67, 75, 35, -96, -37, -25, -45, -83, 35, 96]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_30",
    "sat": "def sat(start: int, k: int=9, lower: int=1543301769461760, seq: List[int]=[19, 86, 1, -36, 96, 80, -33, -21, -96, -48, -92]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=1543301769461760, seq=[19, 86, 1, -36, 96, 80, -33, -21, -96, -48, -92]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_31",
    "sat": "def sat(start: int, k: int=5, lower: int=4775379840, seq: List[int]=[-95, -53, -61, 63, 67, 87, -23, -63, 18, 47, -15, -2, -10, -14, 66, -21, 80, -36, 41, 98, -15, 62, -99, 98, -20, 66, 36, 86, -9, -26, -29, 11, -57, 39, -63, -76, -16, 97, -21, 19, 42, 69, -23, 67, -11, 42, 59, 30, -92, 61, 25, -1, -59, 1, -32, -66, -81, -58, -17, -31, -27, -49, 66, -88, 57, 7, 77, -30, -80, -99, 84, -74, -97, 76, 34, 25, 52, -15, -12, -53, 9, 92, -60, 83, 56, -43, -24, 66]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=4775379840, seq=[-95, -53, -61, 63, 67, 87, -23, -63, 18, 47, -15, -2, -10, -14, 66, -21, 80, -36, 41, 98, -15, 62, -99, 98, -20, 66, 36, 86, -9, -26, -29, 11, -57, 39, -63, -76, -16, 97, -21, 19, 42, 69, -23, 67, -11, 42, 59, 30, -92, 61, 25, -1, -59, 1, -32, -66, -81, -58, -17, -31, -27, -49, 66, -88, 57, 7, 77, -30, -80, -99, 84, -74, -97, 76, 34, 25, 52, -15, -12, -53, 9, 92, -60, 83, 56, -43, -24, 66]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_32",
    "sat": "def sat(start: int, k: int=7, lower: int=32165248500, seq: List[int]=[-66, 97, 75, 29, 22, 21, -5]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=32165248500, seq=[-66, 97, 75, 29, 22, 21, -5]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_33",
    "sat": "def sat(start: int, k: int=3, lower: int=-13300, seq: List[int]=[-95, 2, 70]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=-13300, seq=[-95, 2, 70]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_34",
    "sat": "def sat(start: int, k: int=4, lower: int=5432508, seq: List[int]=[-34, 81, 36, -23, -81, 6, 32]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=5432508, seq=[-34, 81, 36, -23, -81, 6, 32]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_35",
    "sat": "def sat(start: int, k: int=8, lower: int=56571735220000, seq: List[int]=[82, -82, -25, -77, 82, -26, -82, -25, 63, 55, -6, -25, 30]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=56571735220000, seq=[82, -82, -25, -77, 82, -26, -82, -25, 63, 55, -6, -25, 30]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_36",
    "sat": "def sat(start: int, k: int=5, lower: int=1833096960, seq: List[int]=[-58, 80, 93, 72, -59, 56, -81, 38]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=1833096960, seq=[-58, 80, 93, 72, -59, 56, -81, 38]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_37",
    "sat": "def sat(start: int, k: int=9, lower: int=27439606565280000, seq: List[int]=[-51, -53, -29, 30, -68, 20, 77, 9, -54, 1, 89, 11, -46, 68, -43, 87, 63, -93, -24, -95, 0, 23, 5, -36, -40, 89, 17, -41, -41, -93, 90, -85, -35, 70, -91, -53, 51, -64, -80, 33, -30, -38, 55, -42, 60, 61, -51, -93, 78, -13, -17, 43, -6, 84, -41, -71, -16, 77, -97, 84, -59, 93, 76, 71, -88, 50, 92, -24, -65, 66, -49, -13, 72, 87, -83, 58, -68, -79, 14, 27, -8, 48, -8, -72, -69, -88, 84, 26, -23]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=27439606565280000, seq=[-51, -53, -29, 30, -68, 20, 77, 9, -54, 1, 89, 11, -46, 68, -43, 87, 63, -93, -24, -95, 0, 23, 5, -36, -40, 89, 17, -41, -41, -93, 90, -85, -35, 70, -91, -53, 51, -64, -80, 33, -30, -38, 55, -42, 60, 61, -51, -93, 78, -13, -17, 43, -6, 84, -41, -71, -16, 77, -97, 84, -59, 93, 76, 71, -88, 50, 92, -24, -65, 66, -49, -13, 72, 87, -83, 58, -68, -79, 14, 27, -8, 48, -8, -72, -69, -88, 84, 26, -23]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_38",
    "sat": "def sat(start: int, k: int=10, lower: int=1431042556976640000, seq: List[int]=[87, -33, 43, 60, -76, -35, -64, 97, 14, -36, -95, -72, 40, -81, -69, -83, 80, 45]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=1431042556976640000, seq=[87, -33, 43, 60, -76, -35, -64, 97, 14, -36, -95, -72, 40, -81, -69, -83, 80, 45]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_39",
    "sat": "def sat(start: int, k: int=1, lower: int=97, seq: List[int]=[97, 74, 86, 2, -66, -45, 48, 22, 36, -87, -56, -74, -11, -71, 30, -62, 14, -4, -54, 57, 2, -6, 56, -90, -44, 35, -75, -8, 37, 93, -35, -31, -11, -8, -81, 64, -18, 52, 2, -51, -26, 25, 58, -70, -47, 96, -23, 64, -100, 21, -65, -97, -7, -76, -8, 9, 75, 33, 34, 73]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=97, seq=[97, 74, 86, 2, -66, -45, 48, 22, 36, -87, -56, -74, -11, -71, 30, -62, 14, -4, -54, 57, 2, -6, 56, -90, -44, 35, -75, -8, 37, 93, -35, -31, -11, -8, -81, 64, -18, 52, 2, -51, -26, 25, 58, -70, -47, 96, -23, 64, -100, 21, -65, -97, -7, -76, -8, 9, 75, 33, 34, 73]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_40",
    "sat": "def sat(start: int, k: int=9, lower: int=9898724937024000, seq: List[int]=[24, -79, -7, -8, -100, 23, -51, -49, -52, 93, 57, 59, -59, -66, 22, -96, 40, 63, 86, 97, 44, 31, 75, 6, 68, 73, -32, 76, 65, -29, -46, -47, 34, -45, 70, -40, -81, 58, -54, 92, 99, -82, 4, -46, -87, 96, 93, 41, -32, -5, 34, 7, -33, -64, -76, -48, -11, -29]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=9898724937024000, seq=[24, -79, -7, -8, -100, 23, -51, -49, -52, 93, 57, 59, -59, -66, 22, -96, 40, 63, 86, 97, 44, 31, 75, 6, 68, 73, -32, 76, 65, -29, -46, -47, 34, -45, 70, -40, -81, 58, -54, 92, 99, -82, 4, -46, -87, 96, 93, 41, -32, -5, 34, 7, -33, -64, -76, -48, -11, -29]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_41",
    "sat": "def sat(start: int, k: int=3, lower: int=-154280, seq: List[int]=[-58, 38, 70]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=-154280, seq=[-58, 38, 70]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_42",
    "sat": "def sat(start: int, k: int=8, lower: int=-189819630000, seq: List[int]=[-77, 5, 15, -26, -35, -20, 43, -42]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=-189819630000, seq=[-77, 5, 15, -26, -35, -20, 43, -42]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_43",
    "sat": "def sat(start: int, k: int=7, lower: int=0, seq: List[int]=[-22, -5, -33, 85, -22, 0, 61]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=0, seq=[-22, -5, -33, 85, -22, 0, 61]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_44",
    "sat": "def sat(start: int, k: int=10, lower: int=212931405534855168, seq: List[int]=[36, -17, 4, 96, -66, 5, 93, 37, 80, -13, -83, 32, -95, -56, 7, 81, -15, 72, 47, 97, -37, -18, -6, -38, 76, -46, 10, 52, -77, 91, 41, 91, -87, 16, -66, -44, -13, -70, -66, -56, -43, -82, -82, 38, 35, -29, 91, -86, -15, 24, -24, -72, -24, 11, -92, -40, -86, -55, 10, -69, 46, 21, 88, -65, 0, -75, 19, 4, -77, 34, -70, -34, -64, -71, 96, 98, -9, 48, 67, 46, 43, -87, 98, -58]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=212931405534855168, seq=[36, -17, 4, 96, -66, 5, 93, 37, 80, -13, -83, 32, -95, -56, 7, 81, -15, 72, 47, 97, -37, -18, -6, -38, 76, -46, 10, 52, -77, 91, 41, 91, -87, 16, -66, -44, -13, -70, -66, -56, -43, -82, -82, 38, 35, -29, 91, -86, -15, 24, -24, -72, -24, 11, -92, -40, -86, -55, 10, -69, 46, 21, 88, -65, 0, -75, 19, 4, -77, 34, -70, -34, -64, -71, 96, 98, -9, 48, 67, 46, 43, -87, 98, -58]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_45",
    "sat": "def sat(start: int, k: int=2, lower: int=6318, seq: List[int]=[3, -45, 81, 78, 62, -28, 24, 84]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=6318, seq=[3, -45, 81, 78, 62, -28, 24, 84]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_46",
    "sat": "def sat(start: int, k: int=8, lower: int=215835971088000, seq: List[int]=[-6, -88, -5, -92, 96, -33, 86, -76, -82, -2, -14, 55, 4, -41, 21, 60, 12, -55, 26, -2, 90, -73, 47, -40, -1, 45, 99, 84, 85, -8, -57, 45, -87, 18, 44, -14, -83, 7, -11, 93, -44, 96, -39, 94, -24, -52, -17, -64, 74, 39, 46, 72, -34, -42, -44, 41, -84, 46, -54, 69, 59, 50, -93, 16, -70, -4, 26, 55, -89, 68, -5, 82, 78, -46, 84, -55, 40, -62, 39, 65, -32, 73, 90, -30, -40, 61, 97, 37, -92, -94, 95]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=215835971088000, seq=[-6, -88, -5, -92, 96, -33, 86, -76, -82, -2, -14, 55, 4, -41, 21, 60, 12, -55, 26, -2, 90, -73, 47, -40, -1, 45, 99, 84, 85, -8, -57, 45, -87, 18, 44, -14, -83, 7, -11, 93, -44, 96, -39, 94, -24, -52, -17, -64, 74, 39, 46, 72, -34, -42, -44, 41, -84, 46, -54, 69, 59, 50, -93, 16, -70, -4, 26, 55, -89, 68, -5, 82, 78, -46, 84, -55, 40, -62, 39, 65, -32, 73, 90, -30, -40, 61, 97, 37, -92, -94, 95]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_47",
    "sat": "def sat(start: int, k: int=7, lower: int=22855701960, seq: List[int]=[-39, 9, -91, -9, -67, -12, -13, -16, 15, -8, 67, -89]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=22855701960, seq=[-39, 9, -91, -9, -67, -12, -13, -16, 15, -8, 67, -89]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_48",
    "sat": "def sat(start: int, k: int=2, lower: int=741, seq: List[int]=[57, 13]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=741, seq=[57, 13]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_49",
    "sat": "def sat(start: int, k: int=9, lower: int=513633341362176, seq: List[int]=[-87, 48, 22, 28, 79, 79, -76, -32, 6, 42, 49, -24, -93, 97, -20, 1]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=513633341362176, seq=[-87, 48, 22, 28, 79, 79, -76, -32, 6, 42, 49, -24, -93, 97, -20, 1]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_50",
    "sat": "def sat(start: int, k: int=3, lower: int=-20706, seq: List[int]=[-34, 87, 7]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=-20706, seq=[-34, 87, 7]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_51",
    "sat": "def sat(start: int, k: int=7, lower: int=295389029760, seq: List[int]=[95, 38, 53, 68, 11, -43, -48]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=295389029760, seq=[95, 38, 53, 68, 11, -43, -48]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_52",
    "sat": "def sat(start: int, k: int=8, lower: int=64360998462816, seq: List[int]=[-46, 22, -71, -43, -61, -39, -81, -67, -57, 63, 26, 52, -32, 31, 33, 58, 2, 50, 17, -8, 8, -21, 88, -49, 76, -12, 56, -60, 5, -48, -2, -13, 37, -83, -91, -47, -19, -72, -90, -39, -8, 48, -23, 2, 54, 79, -15, 33, -40, 97, -11, 3, 23, 30, -2, 66, 73, -6, 15, -44, -66, -54, -74, 7, -14, -49, -84, 21, -17, -36, 73, 4, 51, -94, 85, -43, -70, -18, -100, 47, 2, -54, 1, 32, 38, 27, -16, 21, -42, 46, 1, -72, -51, 93]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=64360998462816, seq=[-46, 22, -71, -43, -61, -39, -81, -67, -57, 63, 26, 52, -32, 31, 33, 58, 2, 50, 17, -8, 8, -21, 88, -49, 76, -12, 56, -60, 5, -48, -2, -13, 37, -83, -91, -47, -19, -72, -90, -39, -8, 48, -23, 2, 54, 79, -15, 33, -40, 97, -11, 3, 23, 30, -2, 66, 73, -6, 15, -44, -66, -54, -74, 7, -14, -49, -84, 21, -17, -36, 73, 4, 51, -94, 85, -43, -70, -18, -100, 47, 2, -54, 1, 32, 38, 27, -16, 21, -42, 46, 1, -72, -51, 93]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_53",
    "sat": "def sat(start: int, k: int=10, lower: int=660951075623731200, seq: List[int]=[-64, 61, 88, -5, -93, 79, 28, 28, -96, 98, 25, -96, 66, -77, 80, 34, 90, -11, 13]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=660951075623731200, seq=[-64, 61, 88, -5, -93, 79, 28, 28, -96, 98, 25, -96, 66, -77, 80, 34, 90, -11, 13]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_54",
    "sat": "def sat(start: int, k: int=10, lower: int=13448380635144, seq: List[int]=[49, 14, -1, -67, -21, -26, -41, -2, 51, -23, -78]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=13448380635144, seq=[49, 14, -1, -67, -21, -26, -41, -2, 51, -23, -78]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_55",
    "sat": "def sat(start: int, k: int=2, lower: int=8455, seq: List[int]=[23, -69, 70, -78, 69, -33, 44, 64, 4, -57, -77, 96, 15, 62, -94, 51, 32, -51, 32, 22, -94, 89, 75, 85, -70, 9, 93, 73, -65, -77, 22, -85, 76, -87, 31, 38, 28, -11, -92, -6, -95, -89, -7, 49, -93, 56, 41, 38, 48, 37, 34, 39, 69, -20, -10, 97, -80, 67, 29, 30, 41, -95, 87, 69, -62, 17, 72, -72, -37, 98, -28, 58, 42, -55, -44, 26, -59, -11, -32, 8, 91, -90, 14]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=8455, seq=[23, -69, 70, -78, 69, -33, 44, 64, 4, -57, -77, 96, 15, 62, -94, 51, 32, -51, 32, 22, -94, 89, 75, 85, -70, 9, 93, 73, -65, -77, 22, -85, 76, -87, 31, 38, 28, -11, -92, -6, -95, -89, -7, 49, -93, 56, 41, 38, 48, 37, 34, 39, 69, -20, -10, 97, -80, 67, 29, 30, 41, -95, 87, 69, -62, 17, 72, -72, -37, 98, -28, 58, 42, -55, -44, 26, -59, -11, -32, 8, 91, -90, 14]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_56",
    "sat": "def sat(start: int, k: int=8, lower: int=505364623117200, seq: List[int]=[42, 62, 18, -59, -82, -88, -54, -65, -36, -36, 77, 85, -66, 57, -99, 73, 40, 71, -60, -90, -42, -2, 35, 97, 26, 10, -62, -52, -26, 44, -1, 87, 66, -31, -40, -93, -30, 84, 73, 40, -69, -76, 61, 33, 42, -87, -45, -82, 7, 44, 60, 1, 46, -30, 13, -25, -53, -98, -75, 19, 7, 98, -72, 48, -73, 86, 42, -44, 98, -93, 45, -69, 74, -54, -7, 38, -63, 15, -58, 89, -40, 0, -83, 91, 42, 33, -93, -35]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=505364623117200, seq=[42, 62, 18, -59, -82, -88, -54, -65, -36, -36, 77, 85, -66, 57, -99, 73, 40, 71, -60, -90, -42, -2, 35, 97, 26, 10, -62, -52, -26, 44, -1, 87, 66, -31, -40, -93, -30, 84, 73, 40, -69, -76, 61, 33, 42, -87, -45, -82, 7, 44, 60, 1, 46, -30, 13, -25, -53, -98, -75, 19, 7, 98, -72, 48, -73, 86, 42, -44, 98, -93, 45, -69, 74, -54, -7, 38, -63, 15, -58, 89, -40, 0, -83, 91, 42, 33, -93, -35]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_57",
    "sat": "def sat(start: int, k: int=7, lower: int=0, seq: List[int]=[49, -4, 0, 37, -4, 0, -79]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=0, seq=[49, -4, 0, 37, -4, 0, -79]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_58",
    "sat": "def sat(start: int, k: int=2, lower: int=7568, seq: List[int]=[-86, 15, -59, -14, -12, -88]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=7568, seq=[-86, 15, -59, -14, -12, -88]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_59",
    "sat": "def sat(start: int, k: int=2, lower: int=8184, seq: List[int]=[86, 80, -100, -57, 21, -6, 7, -63, 23, 62, 67, 7, 81, 25, -39, -64, 21, -52, 42, -34, 3, 17, 2, -62, 69, -63, 8, 52, 98, -73, -80, -65, 38, -67, -40, -12, -30, 28, 93, 88, -98, 4, 4, -25, 27, -34, 67, 3, -19, 5, 38, -11, -61, -33, -35, 39, -73, -39, 23, -94, 12, 59, 22, -98, -5, 0, 3, -37, 61, -16, -73, 94, 48, -93, -42, -10, 24]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=8184, seq=[86, 80, -100, -57, 21, -6, 7, -63, 23, 62, 67, 7, 81, 25, -39, -64, 21, -52, 42, -34, 3, 17, 2, -62, 69, -63, 8, 52, 98, -73, -80, -65, 38, -67, -40, -12, -30, 28, 93, 88, -98, 4, 4, -25, 27, -34, 67, 3, -19, 5, 38, -11, -61, -33, -35, 39, -73, -39, 23, -94, 12, 59, 22, -98, -5, 0, 3, -37, 61, -16, -73, 94, 48, -93, -42, -10, 24]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_60",
    "sat": "def sat(start: int, k: int=4, lower: int=56761056, seq: List[int]=[-76, -99, -82, -92, -9, 48, 45, -42, 97, -85, 90, 3, 55, 17, -82, -52, 99, 77, 23, -95, 82, 46, 32, 76, -96, 83, -76, -89, 43, -83, -18]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=56761056, seq=[-76, -99, -82, -92, -9, 48, 45, -42, 97, -85, 90, 3, 55, 17, -82, -52, 99, 77, 23, -95, 82, 46, 32, 76, -96, 83, -76, -89, 43, -83, -18]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_61",
    "sat": "def sat(start: int, k: int=6, lower: int=105944368608, seq: List[int]=[84, -63, 30, -99, -51, -90, 71, 22, -36, 16, -83, -51, -55, 46, -37, -2, 51, 79, -25, 2, -53, 61, 22, -34, 97, 56, -45, -100, 1, 71, 30, -13, -40, 24, -31, 81, 61, 9, 7, -61, 69, -78, 48, 81, 83, 4, -14, -76, 62, 43, -73, 61, -44, -54, 25, -52, 63, 63, -71, -63, -33, -92, 16, -61, 42, -54, -67]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=6, lower=105944368608, seq=[84, -63, 30, -99, -51, -90, 71, 22, -36, 16, -83, -51, -55, 46, -37, -2, 51, 79, -25, 2, -53, 61, 22, -34, 97, 56, -45, -100, 1, 71, 30, -13, -40, 24, -31, 81, 61, 9, 7, -61, 69, -78, 48, 81, 83, 4, -14, -76, 62, 43, -73, 61, -44, -54, 25, -52, 63, 63, -71, -63, -33, -92, 16, -61, 42, -54, -67]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_62",
    "sat": "def sat(start: int, k: int=3, lower: int=468480, seq: List[int]=[-76, -43, -95, 35, 94, 80, -61, -96, -40]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=468480, seq=[-76, -43, -95, 35, 94, 80, -61, -96, -40]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_63",
    "sat": "def sat(start: int, k: int=8, lower: int=602815158400, seq: List[int]=[52, 34, 10, -91, 58, 5, -34, 38]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=602815158400, seq=[52, 34, 10, -91, 58, 5, -34, 38]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_64",
    "sat": "def sat(start: int, k: int=10, lower: int=135197764162384000, seq: List[int]=[43, 50, 56, 59, 22, 55, 62, -68, 15, -100, -45, -33, -49, 21, 73, 44, 83, 59]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=135197764162384000, seq=[43, 50, 56, 59, 22, 55, 62, -68, 15, -100, -45, -33, -49, 21, 73, 44, 83, 59]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_65",
    "sat": "def sat(start: int, k: int=8, lower: int=38737236787200, seq: List[int]=[52, -23, -30, 75, -21, -62, -45, -74, -60, -21, -64, 20, 69, -48, -98, 7, -96]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=38737236787200, seq=[52, -23, -30, 75, -21, -62, -45, -74, -60, -21, -64, 20, 69, -48, -98, 7, -96]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_66",
    "sat": "def sat(start: int, k: int=9, lower: int=-9443025543600, seq: List[int]=[-97, 34, 86, 3, -18, -22, 19, 25, 59]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=-9443025543600, seq=[-97, 34, 86, 3, -18, -22, 19, 25, 59]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_67",
    "sat": "def sat(start: int, k: int=6, lower: int=13703289600, seq: List[int]=[-39, -9, -55, -91, 12, 92, -80, -31, -31, -86, -6, 81, 97, 38]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=6, lower=13703289600, seq=[-39, -9, -55, -91, 12, 92, -80, -31, -31, -86, -6, 81, 97, 38]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_68",
    "sat": "def sat(start: int, k: int=1, lower: int=88, seq: List[int]=[72, 57, -54, 43, -43, 23, -31, 58, -64, 44, 27, 17, -53, 88, -83, 73]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=88, seq=[72, 57, -54, 43, -43, 23, -31, 58, -64, 44, 27, 17, -53, 88, -83, 73]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_69",
    "sat": "def sat(start: int, k: int=7, lower: int=3013787320320, seq: List[int]=[-84, 13, -6, 33, 65, 65, 32, -75, 57, 10, -37, 32, 70, 64, -76, -89]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=3013787320320, seq=[-84, 13, -6, 33, 65, 65, 32, -75, 57, 10, -37, 32, 70, 64, -76, -89]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_70",
    "sat": "def sat(start: int, k: int=10, lower: int=283590856733184000, seq: List[int]=[50, 69, 96, -12, 72, -67, 65, -74, -30, 20, 16, -14, 95, -60, -72, 90, 15, 18, 27, -91, 98, -76, 26, 30, -94, -16, -86, 20, -21, 6, -47, 39, 47, -78, -77, -79, 45, -94, 86, 17, -28, 58, 70, -19, 10, -51, 32, 65, -42, -28, -77, 21, 1, -50, 59, 17, -85, -44, 99, 21, -96, 54, -88, -39, 25, -82, 46, -29, 47, -2, -12, -52, -92, 80, 95, 15, -80, 63, -31, -49, 68, -6, 32, 74, -86, 23, -56, 54, -2, -93, -66, 50, -58, 19, -58, -85, 49, 19, 74, -39, 3, 16, -78, -1, -67, -54, 96, -5, 43]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=283590856733184000, seq=[50, 69, 96, -12, 72, -67, 65, -74, -30, 20, 16, -14, 95, -60, -72, 90, 15, 18, 27, -91, 98, -76, 26, 30, -94, -16, -86, 20, -21, 6, -47, 39, 47, -78, -77, -79, 45, -94, 86, 17, -28, 58, 70, -19, 10, -51, 32, 65, -42, -28, -77, 21, 1, -50, 59, 17, -85, -44, 99, 21, -96, 54, -88, -39, 25, -82, 46, -29, 47, -2, -12, -52, -92, 80, 95, 15, -80, 63, -31, -49, 68, -6, 32, 74, -86, 23, -56, 54, -2, -93, -66, 50, -58, 19, -58, -85, 49, 19, 74, -39, 3, 16, -78, -1, -67, -54, 96, -5, 43]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_71",
    "sat": "def sat(start: int, k: int=6, lower: int=-299880000, seq: List[int]=[-25, 30, 21, -20, -68, 14]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=6, lower=-299880000, seq=[-25, 30, 21, -20, -68, 14]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_72",
    "sat": "def sat(start: int, k: int=3, lower: int=85140, seq: List[int]=[-66, 43, -30]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=85140, seq=[-66, 43, -30]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_73",
    "sat": "def sat(start: int, k: int=10, lower: int=145766164710865920, seq: List[int]=[-92, 53, 64, 34, -22, -8, -17, -45, 16, -61, -56, -4, -7, 17, -18, -78, -96, -9, -42, -85, -2, 44, 91, -90, -55, 16, 21, 79, 45, -45, 87, 65, -53, -26, 43, -41]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=145766164710865920, seq=[-92, 53, 64, 34, -22, -8, -17, -45, 16, -61, -56, -4, -7, 17, -18, -78, -96, -9, -42, -85, -2, 44, 91, -90, -55, 16, 21, 79, 45, -45, 87, 65, -53, -26, 43, -41]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_74",
    "sat": "def sat(start: int, k: int=1, lower: int=80, seq: List[int]=[31, 80, -24, -87, -88, -83, 67, -85, 13, -56]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=80, seq=[31, 80, -24, -87, -88, -83, 67, -85, 13, -56]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_75",
    "sat": "def sat(start: int, k: int=1, lower: int=91, seq: List[int]=[44, 68, 45, -84, -9, 53, 48, 91, 36]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=91, seq=[44, 68, 45, -84, -9, 53, 48, 91, 36]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_76",
    "sat": "def sat(start: int, k: int=8, lower: int=12119454547200, seq: List[int]=[-25, 44, 13, -74, 36, 76, -91, -46]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=12119454547200, seq=[-25, 44, 13, -74, 36, 76, -91, -46]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_77",
    "sat": "def sat(start: int, k: int=4, lower: int=19986816, seq: List[int]=[54, 20, 62, 80, -17, 51, 56, -38, -73, 85, 44, -71, -5, -73, 56, 85, -23, -4, -80, -90, -40, 0, 67, -41, 73, 92, -31, -96, -41, -46, 43, -80, -97, -43, -53, 42, -5, -55]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=19986816, seq=[54, 20, 62, 80, -17, 51, 56, -38, -73, 85, 44, -71, -5, -73, 56, 85, -23, -4, -80, -90, -40, 0, 67, -41, 73, 92, -31, -96, -41, -46, 43, -80, -97, -43, -53, 42, -5, -55]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_78",
    "sat": "def sat(start: int, k: int=6, lower: int=225069465600, seq: List[int]=[-27, 52, 15, -70, 89, -48, 96, -100, 56, 98, 78, -35, 65, -79, -94, 31, 37, 76, -45, 0, 27, 41, -6, 68, 31, -91, -71, -1, 3, 85, 53, -88, -34, 83, -84, -32, -88, 67, 41, -55, 79, -71, -13, 58, 7, -62, -48, -70, -13, 57, 55, 89, 8, -64, 42, 42, -11, 73, 39, -39, 27, 57, 68, 18, -52, -9, 82, 54, -94, 28, -3, 35, 95, 30, 81, 26, -78, 89, 36, 98, 71, -50, -46, -21, 69, 98, 89, 61, 91, -29]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=6, lower=225069465600, seq=[-27, 52, 15, -70, 89, -48, 96, -100, 56, 98, 78, -35, 65, -79, -94, 31, 37, 76, -45, 0, 27, 41, -6, 68, 31, -91, -71, -1, 3, 85, 53, -88, -34, 83, -84, -32, -88, 67, 41, -55, 79, -71, -13, 58, 7, -62, -48, -70, -13, 57, 55, 89, 8, -64, 42, 42, -11, 73, 39, -39, 27, 57, 68, 18, -52, -9, 82, 54, -94, 28, -3, 35, 95, 30, 81, 26, -78, 89, 36, 98, 71, -50, -46, -21, 69, 98, 89, 61, 91, -29]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_79",
    "sat": "def sat(start: int, k: int=4, lower: int=-209814, seq: List[int]=[-11, -33, -34, 17]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=-209814, seq=[-11, -33, -34, 17]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_80",
    "sat": "def sat(start: int, k: int=5, lower: int=720598032, seq: List[int]=[-54, 87, 8, 40, -60, -41, -20, -80, -78, -44, 42, 83]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=720598032, seq=[-54, 87, 8, 40, -60, -41, -20, -80, -78, -44, 42, 83]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_81",
    "sat": "def sat(start: int, k: int=3, lower: int=-26082, seq: List[int]=[-23, -14, -81]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=-26082, seq=[-23, -14, -81]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_82",
    "sat": "def sat(start: int, k: int=10, lower: int=71113165111296, seq: List[int]=[-12, -43, 68, 28, 88, 32, -18, 28, -1, 51]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=71113165111296, seq=[-12, -43, 68, 28, 88, 32, -18, 28, -1, 51]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_83",
    "sat": "def sat(start: int, k: int=8, lower: int=654852930600960, seq: List[int]=[4, -33, 43, 29, -98, -88, 34, 97, -64, -23, -95, -69, 61, 40, -58, 89, 10, -83, 86, 53, -61, 90, 18, 54, -52, 80, -78, 74, 56, 89, 57, 96, -29, 79, -81, 58, -95, -34, 74, 18, -48, 68, 45, -65, 40, 92, 67, -98, -88, -92, -17, -70, 52, 74, -10, 94, 56, -29, 94, -46, -30, 55, -2, 29, -37, -54, 64, -51, -15, -31, 44, 88, 71, -56, 63, 75, -40, 12, 89, 21, 0, 60, -28]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=654852930600960, seq=[4, -33, 43, 29, -98, -88, 34, 97, -64, -23, -95, -69, 61, 40, -58, 89, 10, -83, 86, 53, -61, 90, 18, 54, -52, 80, -78, 74, 56, 89, 57, 96, -29, 79, -81, 58, -95, -34, 74, 18, -48, 68, 45, -65, 40, 92, 67, -98, -88, -92, -17, -70, 52, 74, -10, 94, 56, -29, 94, -46, -30, 55, -2, 29, -37, -54, 64, -51, -15, -31, 44, 88, 71, -56, 63, 75, -40, 12, 89, 21, 0, 60, -28]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_84",
    "sat": "def sat(start: int, k: int=2, lower: int=4158, seq: List[int]=[-1, -47, 63, 66, -45]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=4158, seq=[-1, -47, 63, 66, -45]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_85",
    "sat": "def sat(start: int, k: int=3, lower: int=661230, seq: List[int]=[-3, 20, 56, 51, -21, -24, -13, 10, 9, 82, -50, -44, 86, -74, 41, 90, -93, -79, 11, -1, -19, -21, -67, -66, 8, -40, -57, 95, 40, -25, -71, -51, -54, -88, -67, 53, -16, -70, 97, -59, 11, 80, 36, -32, 0, 83, -9, 63, -19, -70, 28, 8, 55, 95, -90, 2, -7, -58, -76, 56, -73, 90, -5, -33, 73, 97, -31, 65, 3, -31, 24]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=661230, seq=[-3, 20, 56, 51, -21, -24, -13, 10, 9, 82, -50, -44, 86, -74, 41, 90, -93, -79, 11, -1, -19, -21, -67, -66, 8, -40, -57, 95, 40, -25, -71, -51, -54, -88, -67, 53, -16, -70, 97, -59, 11, 80, 36, -32, 0, 83, -9, 63, -19, -70, 28, 8, 55, 95, -90, 2, -7, -58, -76, 56, -73, 90, -5, -33, 73, 97, -31, 65, 3, -31, 24]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_86",
    "sat": "def sat(start: int, k: int=9, lower: int=16794996042908160, seq: List[int]=[-62, 15, -84, 65, -43, -47, 4, 53, 15, -15, 54, 91, -30, -32, -2, -6, 95, 59, -71, -52, -77, 39, -84, 9, -12, 80, 18, 8, 93, 16, -28, 69, 47, 53, 9, -30, -17, 94, 84, 92, -15, -53, -33, 77, 8, 30, -2, 97, 47, -95, 4, -64, -57, 5, 63, -6, 5, 4, 37, 80, 85, 81, -28, 52, 81, -7, -67, 63, -75, -23, 60, -72, -87, -56, 42, -71, -99, 53, -51, 39, 65, -17, 45, -78, 87]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=16794996042908160, seq=[-62, 15, -84, 65, -43, -47, 4, 53, 15, -15, 54, 91, -30, -32, -2, -6, 95, 59, -71, -52, -77, 39, -84, 9, -12, 80, 18, 8, 93, 16, -28, 69, 47, 53, 9, -30, -17, 94, 84, 92, -15, -53, -33, 77, 8, 30, -2, 97, 47, -95, 4, -64, -57, 5, 63, -6, 5, 4, 37, 80, 85, 81, -28, 52, 81, -7, -67, 63, -75, -23, 60, -72, -87, -56, 42, -71, -99, 53, -51, 39, 65, -17, 45, -78, 87]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_87",
    "sat": "def sat(start: int, k: int=2, lower: int=8118, seq: List[int]=[64, 5, -43, 69, 9, -86, -69, -46, -27, 8, -100, -38, 42, 17, 85, -9, -65, -7, -7, 16, 28, -77, -82, -1, 13, -55, 24, -3, -79, 22, -63, -91, 80, 8, -57, 93, 77, 86, 59, 36, -45, -33, -5, -71, 5, -78, 69, 59, -29, -41, -59, 37, 83, 82, 86, 30, 48, -55, 45, 50, 29, 80, -83, 14, 65, -82, -99, 80, 74, -67, -69, -10, -98, -12, 34, -7, 45, 62, 66, 19, -23, -64, -64, -24, -73, -23, -89, -58, -40, 65, -60, 34, 33, 78, 67, 38, 53, 91, -94, -52, 92]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=8118, seq=[64, 5, -43, 69, 9, -86, -69, -46, -27, 8, -100, -38, 42, 17, 85, -9, -65, -7, -7, 16, 28, -77, -82, -1, 13, -55, 24, -3, -79, 22, -63, -91, 80, 8, -57, 93, 77, 86, 59, 36, -45, -33, -5, -71, 5, -78, 69, 59, -29, -41, -59, 37, 83, 82, 86, 30, 48, -55, 45, 50, 29, 80, -83, 14, 65, -82, -99, 80, 74, -67, -69, -10, -98, -12, 34, -7, 45, 62, 66, 19, -23, -64, -64, -24, -73, -23, -89, -58, -40, 65, -60, 34, 33, 78, 67, 38, 53, 91, -94, -52, 92]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_88",
    "sat": "def sat(start: int, k: int=5, lower: int=-22869000, seq: List[int]=[33, 20, -25, 99, 14]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=-22869000, seq=[33, 20, -25, 99, 14]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_89",
    "sat": "def sat(start: int, k: int=8, lower: int=577416139163136, seq: List[int]=[-20, 7, 81, -52, 32, 8, -31, 53, -18, 63, -29, -78, 69, -39, -46, -33, 33, -88, 90, -73, 3, 13, -43, 91, 50, -77, 72, 47, -43, -100, -17, -49, 59, -77, -4, 9, -56, 14, 30, 76, -2, -41, 92, 59, 42, -91, 91, -59, -54, -96, 16, -56, -93, -75, -53, -72, 21, -50, 86, -78, 7, 22, 20, -77, -43, -71, -99]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=577416139163136, seq=[-20, 7, 81, -52, 32, 8, -31, 53, -18, 63, -29, -78, 69, -39, -46, -33, 33, -88, 90, -73, 3, 13, -43, 91, 50, -77, 72, 47, -43, -100, -17, -49, 59, -77, -4, 9, -56, 14, 30, 76, -2, -41, 92, 59, 42, -91, 91, -59, -54, -96, 16, -56, -93, -75, -53, -72, 21, -50, 86, -78, 7, 22, 20, -77, -43, -71, -99]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_90",
    "sat": "def sat(start: int, k: int=10, lower: int=25886589153384960, seq: List[int]=[-54, -44, 26, 91, -92, -13, -88, 28, -37, 12, 48, -5, 81, -74, 30, 24, 97, -11]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=25886589153384960, seq=[-54, -44, 26, 91, -92, -13, -88, 28, -37, 12, 48, -5, 81, -74, 30, 24, 97, -11]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_91",
    "sat": "def sat(start: int, k: int=4, lower: int=34369972, seq: List[int]=[-1, -62, -69, -76, -67, -56, -90, 81, 72, 0, 91, 55, -46, 80, 97, -17, -63, 5, 69, 49, -91, 94, -82, -14, -38, -48, 64, -10, -44]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=34369972, seq=[-1, -62, -69, -76, -67, -56, -90, 81, 72, 0, 91, 55, -46, 80, 97, -17, -63, 5, 69, 49, -91, 94, -82, -14, -38, -48, 64, -10, -44]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_92",
    "sat": "def sat(start: int, k: int=1, lower: int=88, seq: List[int]=[88, 64, 61, 24, 52, 81]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=88, seq=[88, 64, 61, 24, 52, 81]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_93",
    "sat": "def sat(start: int, k: int=4, lower: int=18166064, seq: List[int]=[-49, 68, -31, -17, 10, 75, -28, 4, -10, 34, -45, -56, -85, -49, -31, -69, 63, 12, -17, 12, -33, 37, 45, 57, -77, -82, 33, -51, 90, -68, -8, -15, -28, 43, -69, -25, -55, -100, -17, -58, -82, 35, 21, -59, 31, 5, -64, 29, -63, 58, -94]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=18166064, seq=[-49, 68, -31, -17, 10, 75, -28, 4, -10, 34, -45, -56, -85, -49, -31, -69, 63, 12, -17, 12, -33, 37, 45, 57, -77, -82, 33, -51, 90, -68, -8, -15, -28, 43, -69, -25, -55, -100, -17, -58, -82, 35, 21, -59, 31, 5, -64, 29, -63, 58, -94]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_94",
    "sat": "def sat(start: int, k: int=1, lower: int=98, seq: List[int]=[81, 87, -76, 37, 65, -15, 45, -56, -6, 3, 11, -89, 13, -7, 40, 21, 62, 87, -4, 4, 28, -63, -94, -100, 26, 3, -24, -46, -88, -89, 3, 18, 21, -30, -7, 54, 48, 29, 23, 19, 98, -38, -87, 90, 21, 66, 20, -97, 7, -26, -20, -40]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=98, seq=[81, 87, -76, 37, 65, -15, 45, -56, -6, 3, 11, -89, 13, -7, 40, 21, 62, 87, -4, 4, 28, -63, -94, -100, 26, 3, -24, -46, -88, -89, 3, 18, 21, -30, -7, 54, 48, 29, 23, 19, 98, -38, -87, 90, 21, 66, 20, -97, 7, -26, -20, -40]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_95",
    "sat": "def sat(start: int, k: int=7, lower: int=8054018703360, seq: List[int]=[17, 44, 30, 4, -37, -97, -46, -24, -61, -54, 35, -51, -51, 96, 80, -54, -18, -90, 74, -45, -55, -57, -9, 96, 45, 76, -59, -10, -63, -64, -4, 1, 36, -65, 32, -52, 62, 10, -58, -47, 21, -53, 84, -48, 61, 64, -98, -51, -83, -79, -40, -96, -38, 21, -28, 0, -66, 14, 84, -90, 16, 90, -65]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=8054018703360, seq=[17, 44, 30, 4, -37, -97, -46, -24, -61, -54, 35, -51, -51, 96, 80, -54, -18, -90, 74, -45, -55, -57, -9, 96, 45, 76, -59, -10, -63, -64, -4, 1, 36, -65, 32, -52, 62, 10, -58, -47, 21, -53, 84, -48, 61, 64, -98, -51, -83, -79, -40, -96, -38, 21, -28, 0, -66, 14, 84, -90, 16, 90, -65]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_96",
    "sat": "def sat(start: int, k: int=10, lower: int=136524691150848000, seq: List[int]=[85, 88, -32, -47, -98, -63, 8, -65, 54, -70, -4, -49]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=10, lower=136524691150848000, seq=[85, 88, -32, -47, -98, -63, 8, -65, 54, -70, -4, -49]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_97",
    "sat": "def sat(start: int, k: int=2, lower: int=7663, seq: List[int]=[88, 53, -18, -6, 43, -63, -68, 70, 33, -95, 90, 37, -4, -62, -58, 99, 69, 44, 11, 65, 84, -22, -70, -41, 16, -78, 45, -15, -98, 13, 16, 11, 74, -56, -26, -84, -86, 13, -75, 1, -45, 60, 20, 49, 64, 22, -100, 39, 17, -48, 83, -96, 86, 9, 75, -89, -8, 32, 97, 68, -18, 21, 50, -6, 18, -86, 96, -97, -79, 64, -44, 16, -94, -13, 88, -37, 90, 84, -100, 75, 20, 77, -14, -98]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=7663, seq=[88, 53, -18, -6, 43, -63, -68, 70, 33, -95, 90, 37, -4, -62, -58, 99, 69, 44, 11, 65, 84, -22, -70, -41, 16, -78, 45, -15, -98, 13, 16, 11, 74, -56, -26, -84, -86, 13, -75, 1, -45, 60, 20, 49, 64, 22, -100, 39, 17, -48, 83, -96, 86, 9, 75, -89, -8, 32, 97, 68, -18, 21, 50, -6, 18, -86, 96, -97, -79, 64, -44, 16, -94, -13, 88, -37, 90, 84, -100, 75, 20, 77, -14, -98]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_98",
    "sat": "def sat(start: int, k: int=5, lower: int=-263774720, seq: List[int]=[-58, -64, -55, -76, -17]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=-263774720, seq=[-58, -64, -55, -76, -17]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "MaxConsecutiveProduct_99",
    "sat": "def sat(start: int, k: int=4, lower: int=35064880, seq: List[int]=[19, 15, 28, 97, -37, -29, -84, 47, -67, 81, -9, 18, -67, -29, -31, 98, 97, 10, 92, 35, 20, -97, -55, 92, 59, -85, -76, 17, -39, -51, -58, -50, -58, 67, -55, -55, 52, 79, 11, -15, -19, 84, -73, 15, -31, -43, -62, 46, -17, -87, -10, -96, -60, -64, -65]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=4, lower=35064880, seq=[19, 15, 28, 97, -37, -29, -84, 47, -67, 81, -9, 18, -67, -29, -31, 98, 97, 10, 92, 35, 20, -97, -55, 92, 59, -85, -76, 17, -39, -51, -58, -50, -58, 67, -55, -55, 52, 79, 11, -15, -19, 84, -73, 15, -31, -43, -62, 46, -17, -87, -10, -96, -60, -64, -65]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ]
  },
  {
    "name": "DistinctOddSum_0",
    "sat": "def sat(nums: List[int], tot: int=12345, n: int=5):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=12345, n=5):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_1",
    "sat": "def sat(nums: List[int], tot: int=44524, n: int=94):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=44524, n=94):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_2",
    "sat": "def sat(nums: List[int], tot: int=889, n: int=1):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=889, n=1):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_3",
    "sat": "def sat(nums: List[int], tot: int=33998, n: int=64):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=33998, n=64):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_4",
    "sat": "def sat(nums: List[int], tot: int=4534, n: int=10):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=4534, n=10):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_5",
    "sat": "def sat(nums: List[int], tot: int=36432, n: int=72):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=36432, n=72):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_6",
    "sat": "def sat(nums: List[int], tot: int=10767, n: int=21):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=10767, n=21):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_7",
    "sat": "def sat(nums: List[int], tot: int=6157, n: int=17):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=6157, n=17):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_8",
    "sat": "def sat(nums: List[int], tot: int=11566, n: int=24):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=11566, n=24):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_9",
    "sat": "def sat(nums: List[int], tot: int=49416, n: int=98):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=49416, n=98):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_10",
    "sat": "def sat(nums: List[int], tot: int=49713, n: int=95):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=49713, n=95):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_11",
    "sat": "def sat(nums: List[int], tot: int=35572, n: int=76):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=35572, n=76):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_12",
    "sat": "def sat(nums: List[int], tot: int=32891, n: int=61):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=32891, n=61):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_13",
    "sat": "def sat(nums: List[int], tot: int=43765, n: int=83):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=43765, n=83):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_14",
    "sat": "def sat(nums: List[int], tot: int=25489, n: int=47):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=25489, n=47):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_15",
    "sat": "def sat(nums: List[int], tot: int=18689, n: int=41):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=18689, n=41):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_16",
    "sat": "def sat(nums: List[int], tot: int=2206, n: int=4):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=2206, n=4):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_17",
    "sat": "def sat(nums: List[int], tot: int=11716, n: int=24):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=11716, n=24):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_18",
    "sat": "def sat(nums: List[int], tot: int=37434, n: int=70):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=37434, n=70):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_19",
    "sat": "def sat(nums: List[int], tot: int=16451, n: int=29):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=16451, n=29):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_20",
    "sat": "def sat(nums: List[int], tot: int=30155, n: int=55):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=30155, n=55):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_21",
    "sat": "def sat(nums: List[int], tot: int=44002, n: int=84):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=44002, n=84):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_22",
    "sat": "def sat(nums: List[int], tot: int=35512, n: int=64):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=35512, n=64):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_23",
    "sat": "def sat(nums: List[int], tot: int=10273, n: int=19):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=10273, n=19):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_24",
    "sat": "def sat(nums: List[int], tot: int=34611, n: int=61):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=34611, n=61):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_25",
    "sat": "def sat(nums: List[int], tot: int=39280, n: int=82):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=39280, n=82):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_26",
    "sat": "def sat(nums: List[int], tot: int=37747, n: int=69):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=37747, n=69):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_27",
    "sat": "def sat(nums: List[int], tot: int=3509, n: int=7):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=3509, n=7):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_28",
    "sat": "def sat(nums: List[int], tot: int=40081, n: int=75):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=40081, n=75):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_29",
    "sat": "def sat(nums: List[int], tot: int=30398, n: int=64):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=30398, n=64):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_30",
    "sat": "def sat(nums: List[int], tot: int=34183, n: int=71):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=34183, n=71):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_31",
    "sat": "def sat(nums: List[int], tot: int=16770, n: int=36):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=16770, n=36):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_32",
    "sat": "def sat(nums: List[int], tot: int=34757, n: int=71):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=34757, n=71):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_33",
    "sat": "def sat(nums: List[int], tot: int=11039, n: int=23):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=11039, n=23):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_34",
    "sat": "def sat(nums: List[int], tot: int=31915, n: int=57):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=31915, n=57):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_35",
    "sat": "def sat(nums: List[int], tot: int=48649, n: int=95):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=48649, n=95):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_36",
    "sat": "def sat(nums: List[int], tot: int=52684, n: int=98):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=52684, n=98):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_37",
    "sat": "def sat(nums: List[int], tot: int=16056, n: int=36):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=16056, n=36):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_38",
    "sat": "def sat(nums: List[int], tot: int=22642, n: int=48):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=22642, n=48):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_39",
    "sat": "def sat(nums: List[int], tot: int=13703, n: int=25):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=13703, n=25):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_40",
    "sat": "def sat(nums: List[int], tot: int=39033, n: int=77):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=39033, n=77):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_41",
    "sat": "def sat(nums: List[int], tot: int=18385, n: int=37):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=18385, n=37):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_42",
    "sat": "def sat(nums: List[int], tot: int=20913, n: int=47):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=20913, n=47):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_43",
    "sat": "def sat(nums: List[int], tot: int=2525, n: int=5):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=2525, n=5):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_44",
    "sat": "def sat(nums: List[int], tot: int=48353, n: int=91):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=48353, n=91):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_45",
    "sat": "def sat(nums: List[int], tot: int=20372, n: int=40):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=20372, n=40):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_46",
    "sat": "def sat(nums: List[int], tot: int=44611, n: int=93):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=44611, n=93):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_47",
    "sat": "def sat(nums: List[int], tot: int=37739, n: int=77):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=37739, n=77):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_48",
    "sat": "def sat(nums: List[int], tot: int=6791, n: int=11):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=6791, n=11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_49",
    "sat": "def sat(nums: List[int], tot: int=15415, n: int=35):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=15415, n=35):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_50",
    "sat": "def sat(nums: List[int], tot: int=27014, n: int=56):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=27014, n=56):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_51",
    "sat": "def sat(nums: List[int], tot: int=25829, n: int=55):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=25829, n=55):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_52",
    "sat": "def sat(nums: List[int], tot: int=36313, n: int=69):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=36313, n=69):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_53",
    "sat": "def sat(nums: List[int], tot: int=10268, n: int=18):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=10268, n=18):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_54",
    "sat": "def sat(nums: List[int], tot: int=34569, n: int=69):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=34569, n=69):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_55",
    "sat": "def sat(nums: List[int], tot: int=35461, n: int=71):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=35461, n=71):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_56",
    "sat": "def sat(nums: List[int], tot: int=18473, n: int=31):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=18473, n=31):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_57",
    "sat": "def sat(nums: List[int], tot: int=36878, n: int=70):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=36878, n=70):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_58",
    "sat": "def sat(nums: List[int], tot: int=9594, n: int=18):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=9594, n=18):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_59",
    "sat": "def sat(nums: List[int], tot: int=38031, n: int=73):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=38031, n=73):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_60",
    "sat": "def sat(nums: List[int], tot: int=5651, n: int=13):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=5651, n=13):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_61",
    "sat": "def sat(nums: List[int], tot: int=41580, n: int=84):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=41580, n=84):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_62",
    "sat": "def sat(nums: List[int], tot: int=46777, n: int=85):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=46777, n=85):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_63",
    "sat": "def sat(nums: List[int], tot: int=11680, n: int=20):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=11680, n=20):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_64",
    "sat": "def sat(nums: List[int], tot: int=1011, n: int=3):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=1011, n=3):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_65",
    "sat": "def sat(nums: List[int], tot: int=45564, n: int=94):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=45564, n=94):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_66",
    "sat": "def sat(nums: List[int], tot: int=40888, n: int=80):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=40888, n=80):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_67",
    "sat": "def sat(nums: List[int], tot: int=29289, n: int=51):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=29289, n=51):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_68",
    "sat": "def sat(nums: List[int], tot: int=15655, n: int=29):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=15655, n=29):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_69",
    "sat": "def sat(nums: List[int], tot: int=41102, n: int=80):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=41102, n=80):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_70",
    "sat": "def sat(nums: List[int], tot: int=44832, n: int=82):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=44832, n=82):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_71",
    "sat": "def sat(nums: List[int], tot: int=26148, n: int=68):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=26148, n=68):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_72",
    "sat": "def sat(nums: List[int], tot: int=57767, n: int=97):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=57767, n=97):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_73",
    "sat": "def sat(nums: List[int], tot: int=6723, n: int=13):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=6723, n=13):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_74",
    "sat": "def sat(nums: List[int], tot: int=21141, n: int=47):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=21141, n=47):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_75",
    "sat": "def sat(nums: List[int], tot: int=5619, n: int=13):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=5619, n=13):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_76",
    "sat": "def sat(nums: List[int], tot: int=18656, n: int=42):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=18656, n=42):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_77",
    "sat": "def sat(nums: List[int], tot: int=28461, n: int=55):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=28461, n=55):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_78",
    "sat": "def sat(nums: List[int], tot: int=27843, n: int=49):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=27843, n=49):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_79",
    "sat": "def sat(nums: List[int], tot: int=3207, n: int=7):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=3207, n=7):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_80",
    "sat": "def sat(nums: List[int], tot: int=43301, n: int=85):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=43301, n=85):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_81",
    "sat": "def sat(nums: List[int], tot: int=6012, n: int=14):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=6012, n=14):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_82",
    "sat": "def sat(nums: List[int], tot: int=39852, n: int=80):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=39852, n=80):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_83",
    "sat": "def sat(nums: List[int], tot: int=15516, n: int=44):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=15516, n=44):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_84",
    "sat": "def sat(nums: List[int], tot: int=1959, n: int=5):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=1959, n=5):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_85",
    "sat": "def sat(nums: List[int], tot: int=30041, n: int=59):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=30041, n=59):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_86",
    "sat": "def sat(nums: List[int], tot: int=48413, n: int=99):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=48413, n=99):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_87",
    "sat": "def sat(nums: List[int], tot: int=23368, n: int=44):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=23368, n=44):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_88",
    "sat": "def sat(nums: List[int], tot: int=39636, n: int=80):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=39636, n=80):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_89",
    "sat": "def sat(nums: List[int], tot: int=240, n: int=2):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=240, n=2):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_90",
    "sat": "def sat(nums: List[int], tot: int=2926, n: int=6):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=2926, n=6):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_91",
    "sat": "def sat(nums: List[int], tot: int=30439, n: int=63):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=30439, n=63):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_92",
    "sat": "def sat(nums: List[int], tot: int=24601, n: int=49):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=24601, n=49):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_93",
    "sat": "def sat(nums: List[int], tot: int=7504, n: int=16):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=7504, n=16):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_94",
    "sat": "def sat(nums: List[int], tot: int=5746, n: int=14):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=5746, n=14):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_95",
    "sat": "def sat(nums: List[int], tot: int=18022, n: int=32):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=18022, n=32):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_96",
    "sat": "def sat(nums: List[int], tot: int=41396, n: int=88):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=41396, n=88):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_97",
    "sat": "def sat(nums: List[int], tot: int=12231, n: int=21):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=12231, n=21):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_98",
    "sat": "def sat(nums: List[int], tot: int=22169, n: int=41):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=22169, n=41):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "DistinctOddSum_99",
    "sat": "def sat(nums: List[int], tot: int=50999, n: int=97):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=50999, n=97):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ]
  },
  {
    "name": "MinRotations_0",
    "sat": "def sat(rotations: List[int], target: str=\"dad\", upper: int=9):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"dad\", upper=9):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_1",
    "sat": "def sat(rotations: List[int], target: str=\"zy\", upper: int=2):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"zy\", upper=2):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_2",
    "sat": "def sat(rotations: List[int], target: str=\"gycaketextenikutotho\", upper: int=136):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"gycaketextenikutotho\", upper=136):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_3",
    "sat": "def sat(rotations: List[int], target: str=\"xaketazafov\", upper: int=63):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"xaketazafov\", upper=63):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_4",
    "sat": "def sat(rotations: List[int], target: str=\"mu\", upper: int=20):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"mu\", upper=20):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_5",
    "sat": "def sat(rotations: List[int], target: str=\"j\", upper: int=9):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"j\", upper=9):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_6",
    "sat": "def sat(rotations: List[int], target: str=\"waxotextonegepaquy\", upper: int=106):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"waxotextonegepaquy\", upper=106):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_7",
    "sat": "def sat(rotations: List[int], target: str=\"wydyvicheloch\", upper: int=73):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"wydyvicheloch\", upper=73):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_8",
    "sat": "def sat(rotations: List[int], target: str=\"bypysyci\", upper: int=44):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"bypysyci\", upper=44):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_9",
    "sat": "def sat(rotations: List[int], target: str=\"fa\", upper: int=10):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fa\", upper=10):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_10",
    "sat": "def sat(rotations: List[int], target: str=\"xaxime\", upper: int=32):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"xaxime\", upper=32):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_11",
    "sat": "def sat(rotations: List[int], target: str=\"fesy\", upper: int=24):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fesy\", upper=24):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_12",
    "sat": "def sat(rotations: List[int], target: str=\"myfezechocezaxoz\", upper: int=99):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"myfezechocezaxoz\", upper=99):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_13",
    "sat": "def sat(rotations: List[int], target: str=\"gyhatiryquiquo\", upper: int=106):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"gyhatiryquiquo\", upper=106):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_14",
    "sat": "def sat(rotations: List[int], target: str=\"lithuryquikythir\", upper: int=125):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"lithuryquikythir\", upper=125):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_15",
    "sat": "def sat(rotations: List[int], target: str=\"textemuzyf\", upper: int=69):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"textemuzyf\", upper=69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_16",
    "sat": "def sat(rotations: List[int], target: str=\"wo\", upper: int=12):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"wo\", upper=12):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_17",
    "sat": "def sat(rotations: List[int], target: str=\"theju\", upper: int=38):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"theju\", upper=38):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_18",
    "sat": "def sat(rotations: List[int], target: str=\"ti\", upper: int=18):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"ti\", upper=18):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_19",
    "sat": "def sat(rotations: List[int], target: str=\"gugogunenity\", upper: int=104):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"gugogunenity\", upper=104):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_20",
    "sat": "def sat(rotations: List[int], target: str=\"narocuroh\", upper: int=71):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"narocuroh\", upper=71):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_21",
    "sat": "def sat(rotations: List[int], target: str=\"m\", upper: int=12):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"m\", upper=12):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_22",
    "sat": "def sat(rotations: List[int], target: str=\"sixynymafygavewuban\", upper: int=147):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"sixynymafygavewuban\", upper=147):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_23",
    "sat": "def sat(rotations: List[int], target: str=\"tisuvathegysadythe\", upper: int=110):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"tisuvathegysadythe\", upper=110):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_24",
    "sat": "def sat(rotations: List[int], target: str=\"ch\", upper: int=7):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"ch\", upper=7):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_25",
    "sat": "def sat(rotations: List[int], target: str=\"tato\", upper: int=26):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"tato\", upper=26):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_26",
    "sat": "def sat(rotations: List[int], target: str=\"holufifek\", upper: int=50):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"holufifek\", upper=50):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_27",
    "sat": "def sat(rotations: List[int], target: str=\"chyputizahi\", upper: int=60):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"chyputizahi\", upper=60):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_28",
    "sat": "def sat(rotations: List[int], target: str=\"dokusiguthorycys\", upper: int=98):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"dokusiguthorycys\", upper=98):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_29",
    "sat": "def sat(rotations: List[int], target: str=\"vocynuriwylebi\", upper: int=102):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"vocynuriwylebi\", upper=102):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_30",
    "sat": "def sat(rotations: List[int], target: str=\"pikohojokylaquujixuq\", upper: int=132):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"pikohojokylaquujixuq\", upper=132):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_31",
    "sat": "def sat(rotations: List[int], target: str=\"micumithugasethox\", upper: int=155):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"micumithugasethox\", upper=155):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_32",
    "sat": "def sat(rotations: List[int], target: str=\"textumuku\", upper: int=66):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"textumuku\", upper=66):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_33",
    "sat": "def sat(rotations: List[int], target: str=\"pyfakacy\", upper: int=58):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"pyfakacy\", upper=58):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_34",
    "sat": "def sat(rotations: List[int], target: str=\"fasogutexty\", upper: int=70):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fasogutexty\", upper=70):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_35",
    "sat": "def sat(rotations: List[int], target: str=\"robufyramysyl\", upper: int=115):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"robufyramysyl\", upper=115):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_36",
    "sat": "def sat(rotations: List[int], target: str=\"re\", upper: int=22):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"re\", upper=22):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_37",
    "sat": "def sat(rotations: List[int], target: str=\"nywivoverysutext\", upper: int=125):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"nywivoverysutext\", upper=125):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_38",
    "sat": "def sat(rotations: List[int], target: str=\"lax\", upper: int=25):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"lax\", upper=25):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_39",
    "sat": "def sat(rotations: List[int], target: str=\"fexunycy\", upper: int=42):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fexunycy\", upper=42):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_40",
    "sat": "def sat(rotations: List[int], target: str=\"hejucilachax\", upper: int=71):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"hejucilachax\", upper=71):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_41",
    "sat": "def sat(rotations: List[int], target: str=\"dochisizifijacibevat\", upper: int=125):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"dochisizifijacibevat\", upper=125):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_42",
    "sat": "def sat(rotations: List[int], target: str=\"vequicuvothythotud\", upper: int=129):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"vequicuvothythotud\", upper=129):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_43",
    "sat": "def sat(rotations: List[int], target: str=\"quotyfihetex\", upper: int=73):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"quotyfihetex\", upper=73):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_44",
    "sat": "def sat(rotations: List[int], target: str=\"tyte\", upper: int=28):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"tyte\", upper=28):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_45",
    "sat": "def sat(rotations: List[int], target: str=\"zana\", upper: int=28):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"zana\", upper=28):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_46",
    "sat": "def sat(rotations: List[int], target: str=\"sybutextopywichofo\", upper: int=112):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"sybutextopywichofo\", upper=112):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_47",
    "sat": "def sat(rotations: List[int], target: str=\"mikatextamysav\", upper: int=107):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"mikatextamysav\", upper=107):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_48",
    "sat": "def sat(rotations: List[int], target: str=\"jatexturawytex\", upper: int=89):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"jatexturawytex\", upper=89):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_49",
    "sat": "def sat(rotations: List[int], target: str=\"wyka\", upper: int=28):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"wyka\", upper=28):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_50",
    "sat": "def sat(rotations: List[int], target: str=\"bokem\", upper: int=32):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"bokem\", upper=32):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_51",
    "sat": "def sat(rotations: List[int], target: str=\"tasehycorulotilote\", upper: int=118):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"tasehycorulotilote\", upper=118):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_52",
    "sat": "def sat(rotations: List[int], target: str=\"mezybahuryw\", upper: int=62):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"mezybahuryw\", upper=62):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_53",
    "sat": "def sat(rotations: List[int], target: str=\"xofy\", upper: int=28):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"xofy\", upper=28):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_54",
    "sat": "def sat(rotations: List[int], target: str=\"lotuchawito\", upper: int=72):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"lotuchawito\", upper=72):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_55",
    "sat": "def sat(rotations: List[int], target: str=\"wijutethehechefapil\", upper: int=109):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"wijutethehechefapil\", upper=109):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_56",
    "sat": "def sat(rotations: List[int], target: str=\"kyquot\", upper: int=45):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"kyquot\", upper=45):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_57",
    "sat": "def sat(rotations: List[int], target: str=\"thaquohegochyb\", upper: int=95):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"thaquohegochyb\", upper=95):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_58",
    "sat": "def sat(rotations: List[int], target: str=\"zidesipakigo\", upper: int=78):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"zidesipakigo\", upper=78):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_59",
    "sat": "def sat(rotations: List[int], target: str=\"lafigequydox\", upper: int=79):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"lafigequydox\", upper=79):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_60",
    "sat": "def sat(rotations: List[int], target: str=\"chichi\", upper: int=20):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"chichi\", upper=20):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_61",
    "sat": "def sat(rotations: List[int], target: str=\"dytextyvi\", upper: int=56):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"dytextyvi\", upper=56):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_62",
    "sat": "def sat(rotations: List[int], target: str=\"bivuthajafimohohel\", upper: int=105):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"bivuthajafimohohel\", upper=105):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_63",
    "sat": "def sat(rotations: List[int], target: str=\"hetigasomecaw\", upper: int=70):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"hetigasomecaw\", upper=70):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_64",
    "sat": "def sat(rotations: List[int], target: str=\"cujepesahole\", upper: int=92):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"cujepesahole\", upper=92):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_65",
    "sat": "def sat(rotations: List[int], target: str=\"ritextily\", upper: int=78):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"ritextily\", upper=78):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_66",
    "sat": "def sat(rotations: List[int], target: str=\"coxojaquonika\", upper: int=84):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"coxojaquonika\", upper=84):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_67",
    "sat": "def sat(rotations: List[int], target: str=\"xucavasivyfotext\", upper: int=103):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"xucavasivyfotext\", upper=103):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_68",
    "sat": "def sat(rotations: List[int], target: str=\"g\", upper: int=6):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"g\", upper=6):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_69",
    "sat": "def sat(rotations: List[int], target: str=\"quiniserob\", upper: int=87):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"quiniserob\", upper=87):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_70",
    "sat": "def sat(rotations: List[int], target: str=\"bypemewaquechutext\", upper: int=119):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"bypemewaquechutext\", upper=119):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_71",
    "sat": "def sat(rotations: List[int], target: str=\"ruchyqu\", upper: int=46):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"ruchyqu\", upper=46):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_72",
    "sat": "def sat(rotations: List[int], target: str=\"chymoromygesygopi\", upper: int=102):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"chymoromygesygopi\", upper=102):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_73",
    "sat": "def sat(rotations: List[int], target: str=\"vecanesete\", upper: int=86):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"vecanesete\", upper=86):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_74",
    "sat": "def sat(rotations: List[int], target: str=\"suhanymafog\", upper: int=100):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"suhanymafog\", upper=100):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_75",
    "sat": "def sat(rotations: List[int], target: str=\"p\", upper: int=11):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"p\", upper=11):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_76",
    "sat": "def sat(rotations: List[int], target: str=\"bydowothawebyjagyn\", upper: int=123):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"bydowothawebyjagyn\", upper=123):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_77",
    "sat": "def sat(rotations: List[int], target: str=\"jiduchovatextede\", upper: int=98):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"jiduchovatextede\", upper=98):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_78",
    "sat": "def sat(rotations: List[int], target: str=\"cun\", upper: int=17):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"cun\", upper=17):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_79",
    "sat": "def sat(rotations: List[int], target: str=\"rikinuwodikiwojydumi\", upper: int=126):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"rikinuwodikiwojydumi\", upper=126):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_80",
    "sat": "def sat(rotations: List[int], target: str=\"tor\", upper: int=15):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"tor\", upper=15):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_81",
    "sat": "def sat(rotations: List[int], target: str=\"tejuf\", upper: int=45):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"tejuf\", upper=45):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_82",
    "sat": "def sat(rotations: List[int], target: str=\"qua\", upper: int=20):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"qua\", upper=20):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_83",
    "sat": "def sat(rotations: List[int], target: str=\"textechytolixezex\", upper: int=107):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"textechytolixezex\", upper=107):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_84",
    "sat": "def sat(rotations: List[int], target: str=\"sy\", upper: int=14):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"sy\", upper=14):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_85",
    "sat": "def sat(rotations: List[int], target: str=\"z\", upper: int=1):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"z\", upper=1):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_86",
    "sat": "def sat(rotations: List[int], target: str=\"xafequothede\", upper: int=56):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"xafequothede\", upper=56):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_87",
    "sat": "def sat(rotations: List[int], target: str=\"lethivoh\", upper: int=69):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"lethivoh\", upper=69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_88",
    "sat": "def sat(rotations: List[int], target: str=\"coseloxoryte\", upper: int=84):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"coseloxoryte\", upper=84):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_89",
    "sat": "def sat(rotations: List[int], target: str=\"valiz\", upper: int=33):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"valiz\", upper=33):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_90",
    "sat": "def sat(rotations: List[int], target: str=\"ze\", upper: int=6):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"ze\", upper=6):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_91",
    "sat": "def sat(rotations: List[int], target: str=\"sithasewychu\", upper: int=100):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"sithasewychu\", upper=100):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_92",
    "sat": "def sat(rotations: List[int], target: str=\"gozufemyguquy\", upper: int=94):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"gozufemyguquy\", upper=94):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_93",
    "sat": "def sat(rotations: List[int], target: str=\"werotequymygera\", upper: int=120):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"werotequymygera\", upper=120):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_94",
    "sat": "def sat(rotations: List[int], target: str=\"busuxo\", upper: int=24):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"busuxo\", upper=24):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_95",
    "sat": "def sat(rotations: List[int], target: str=\"fuquuxice\", upper: int=46):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fuquuxice\", upper=46):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_96",
    "sat": "def sat(rotations: List[int], target: str=\"birysodothiqu\", upper: int=86):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"birysodothiqu\", upper=86):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_97",
    "sat": "def sat(rotations: List[int], target: str=\"fedyzychyniquugath\", upper: int=97):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fedyzychyniquugath\", upper=97):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_98",
    "sat": "def sat(rotations: List[int], target: str=\"fyfycathizequ\", upper: int=82):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fyfycathizequ\", upper=82):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  },
  {
    "name": "MinRotations_99",
    "sat": "def sat(rotations: List[int], target: str=\"thetibuwisygynebo\", upper: int=140):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"thetibuwisygynebo\", upper=140):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ]
  }
]