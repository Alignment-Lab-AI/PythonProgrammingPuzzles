[
  {
    "name": "IsEven_0",
    "sat": "def sat(b: bool, n: int=10):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=10):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_1",
    "sat": "def sat(b: bool, n: int=0):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=0):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_2",
    "sat": "def sat(b: bool, n: int=1):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=1):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_3",
    "sat": "def sat(b: bool, n: int=2):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=2):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_4",
    "sat": "def sat(b: bool, n: int=3):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=3):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_5",
    "sat": "def sat(b: bool, n: int=4):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=4):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_6",
    "sat": "def sat(b: bool, n: int=5):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=5):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_7",
    "sat": "def sat(b: bool, n: int=6):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=6):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_8",
    "sat": "def sat(b: bool, n: int=7):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=7):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_9",
    "sat": "def sat(b: bool, n: int=8):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=8):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_10",
    "sat": "def sat(b: bool, n: int=9):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=9):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_11",
    "sat": "def sat(b: bool, n: int=11):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=11):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_12",
    "sat": "def sat(b: bool, n: int=12):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=12):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_13",
    "sat": "def sat(b: bool, n: int=13):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=13):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_14",
    "sat": "def sat(b: bool, n: int=14):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=14):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_15",
    "sat": "def sat(b: bool, n: int=15):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=15):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_16",
    "sat": "def sat(b: bool, n: int=16):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=16):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_17",
    "sat": "def sat(b: bool, n: int=17):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=17):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_18",
    "sat": "def sat(b: bool, n: int=18):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=18):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_19",
    "sat": "def sat(b: bool, n: int=19):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=19):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_20",
    "sat": "def sat(b: bool, n: int=20):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=20):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_21",
    "sat": "def sat(b: bool, n: int=21):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=21):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_22",
    "sat": "def sat(b: bool, n: int=22):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=22):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_23",
    "sat": "def sat(b: bool, n: int=23):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=23):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_24",
    "sat": "def sat(b: bool, n: int=24):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=24):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_25",
    "sat": "def sat(b: bool, n: int=25):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=25):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_26",
    "sat": "def sat(b: bool, n: int=26):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=26):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_27",
    "sat": "def sat(b: bool, n: int=27):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=27):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_28",
    "sat": "def sat(b: bool, n: int=28):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=28):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_29",
    "sat": "def sat(b: bool, n: int=29):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=29):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_30",
    "sat": "def sat(b: bool, n: int=30):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=30):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_31",
    "sat": "def sat(b: bool, n: int=31):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=31):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_32",
    "sat": "def sat(b: bool, n: int=32):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=32):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_33",
    "sat": "def sat(b: bool, n: int=33):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=33):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_34",
    "sat": "def sat(b: bool, n: int=34):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=34):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_35",
    "sat": "def sat(b: bool, n: int=35):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=35):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_36",
    "sat": "def sat(b: bool, n: int=36):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=36):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_37",
    "sat": "def sat(b: bool, n: int=37):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=37):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_38",
    "sat": "def sat(b: bool, n: int=38):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=38):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_39",
    "sat": "def sat(b: bool, n: int=39):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=39):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_40",
    "sat": "def sat(b: bool, n: int=40):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=40):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_41",
    "sat": "def sat(b: bool, n: int=41):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=41):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_42",
    "sat": "def sat(b: bool, n: int=42):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=42):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_43",
    "sat": "def sat(b: bool, n: int=43):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=43):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_44",
    "sat": "def sat(b: bool, n: int=44):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=44):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_45",
    "sat": "def sat(b: bool, n: int=45):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=45):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_46",
    "sat": "def sat(b: bool, n: int=46):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=46):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_47",
    "sat": "def sat(b: bool, n: int=47):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=47):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_48",
    "sat": "def sat(b: bool, n: int=48):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=48):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_49",
    "sat": "def sat(b: bool, n: int=49):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=49):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_50",
    "sat": "def sat(b: bool, n: int=50):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=50):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_51",
    "sat": "def sat(b: bool, n: int=51):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=51):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_52",
    "sat": "def sat(b: bool, n: int=52):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=52):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_53",
    "sat": "def sat(b: bool, n: int=53):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=53):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_54",
    "sat": "def sat(b: bool, n: int=54):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=54):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_55",
    "sat": "def sat(b: bool, n: int=55):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=55):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_56",
    "sat": "def sat(b: bool, n: int=56):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=56):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_57",
    "sat": "def sat(b: bool, n: int=57):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=57):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_58",
    "sat": "def sat(b: bool, n: int=58):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=58):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_59",
    "sat": "def sat(b: bool, n: int=59):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=59):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_60",
    "sat": "def sat(b: bool, n: int=60):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=60):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_61",
    "sat": "def sat(b: bool, n: int=61):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=61):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_62",
    "sat": "def sat(b: bool, n: int=62):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=62):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_63",
    "sat": "def sat(b: bool, n: int=63):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=63):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_64",
    "sat": "def sat(b: bool, n: int=64):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=64):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_65",
    "sat": "def sat(b: bool, n: int=65):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=65):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_66",
    "sat": "def sat(b: bool, n: int=66):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=66):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_67",
    "sat": "def sat(b: bool, n: int=67):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=67):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_68",
    "sat": "def sat(b: bool, n: int=68):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=68):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_69",
    "sat": "def sat(b: bool, n: int=69):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=69):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_70",
    "sat": "def sat(b: bool, n: int=70):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=70):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_71",
    "sat": "def sat(b: bool, n: int=71):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=71):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_72",
    "sat": "def sat(b: bool, n: int=72):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=72):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_73",
    "sat": "def sat(b: bool, n: int=73):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=73):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_74",
    "sat": "def sat(b: bool, n: int=74):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=74):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_75",
    "sat": "def sat(b: bool, n: int=75):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=75):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_76",
    "sat": "def sat(b: bool, n: int=76):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=76):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_77",
    "sat": "def sat(b: bool, n: int=77):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=77):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_78",
    "sat": "def sat(b: bool, n: int=78):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=78):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_79",
    "sat": "def sat(b: bool, n: int=79):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=79):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_80",
    "sat": "def sat(b: bool, n: int=80):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=80):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_81",
    "sat": "def sat(b: bool, n: int=81):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=81):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_82",
    "sat": "def sat(b: bool, n: int=82):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=82):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_83",
    "sat": "def sat(b: bool, n: int=83):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=83):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_84",
    "sat": "def sat(b: bool, n: int=84):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=84):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_85",
    "sat": "def sat(b: bool, n: int=85):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=85):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_86",
    "sat": "def sat(b: bool, n: int=86):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=86):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_87",
    "sat": "def sat(b: bool, n: int=87):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=87):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_88",
    "sat": "def sat(b: bool, n: int=88):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=88):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_89",
    "sat": "def sat(b: bool, n: int=89):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=89):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_90",
    "sat": "def sat(b: bool, n: int=90):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=90):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_91",
    "sat": "def sat(b: bool, n: int=91):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=91):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_92",
    "sat": "def sat(b: bool, n: int=92):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=92):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_93",
    "sat": "def sat(b: bool, n: int=93):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=93):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_94",
    "sat": "def sat(b: bool, n: int=94):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=94):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_95",
    "sat": "def sat(b: bool, n: int=95):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=95):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_96",
    "sat": "def sat(b: bool, n: int=96):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=96):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_97",
    "sat": "def sat(b: bool, n: int=97):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=97):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "IsEven_98",
    "sat": "def sat(b: bool, n: int=98):\n    assert type(b) is bool, 'b must be of type bool'\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=98):\n    return n % 2 == 0"
    ]
  },
  {
    "name": "Abbreviate_0",
    "sat": "def sat(s: str, word: str=\"antidisestablishmentarianism\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"antidisestablishmentarianism\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_1",
    "sat": "def sat(s: str, word: str=\"tuzesecirozuzyv\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tuzesecirozuzyv\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_2",
    "sat": "def sat(s: str, word: str=\"vyvyvoboquolivucycyny\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vyvyvoboquolivucycyny\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_3",
    "sat": "def sat(s: str, word: str=\"dafochexuceth\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"dafochexuceth\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_4",
    "sat": "def sat(s: str, word: str=\"non\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"non\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_5",
    "sat": "def sat(s: str, word: str=\"fabykuzorifura\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fabykuzorifura\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_6",
    "sat": "def sat(s: str, word: str=\"ravysequiquequefoh\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"ravysequiquequefoh\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_7",
    "sat": "def sat(s: str, word: str=\"dawelyfyjaruvelidocosesutextub\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"dawelyfyjaruvelidocosesutextub\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_8",
    "sat": "def sat(s: str, word: str=\"rechuthibubes\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"rechuthibubes\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_9",
    "sat": "def sat(s: str, word: str=\"zedoze\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zedoze\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_10",
    "sat": "def sat(s: str, word: str=\"sac\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"sac\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_11",
    "sat": "def sat(s: str, word: str=\"pyxuvaquinijewicexitextafifipi\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pyxuvaquinijewicexitextafifipi\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_12",
    "sat": "def sat(s: str, word: str=\"refomujeragyp\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"refomujeragyp\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_13",
    "sat": "def sat(s: str, word: str=\"juzazu\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"juzazu\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_14",
    "sat": "def sat(s: str, word: str=\"fyxolycurydi\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fyxolycurydi\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_15",
    "sat": "def sat(s: str, word: str=\"fakivyxywehikiribycywemexem\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fakivyxywehikiribycywemexem\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_16",
    "sat": "def sat(s: str, word: str=\"novocomu\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"novocomu\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_17",
    "sat": "def sat(s: str, word: str=\"modigitigy\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"modigitigy\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_18",
    "sat": "def sat(s: str, word: str=\"kuti\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kuti\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_19",
    "sat": "def sat(s: str, word: str=\"gitextobege\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gitextobege\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_20",
    "sat": "def sat(s: str, word: str=\"nogetygyquachuhovacaranath\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"nogetygyquachuhovacaranath\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_21",
    "sat": "def sat(s: str, word: str=\"textabichisachiw\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textabichisachiw\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_22",
    "sat": "def sat(s: str, word: str=\"xowynesupanebothi\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xowynesupanebothi\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_23",
    "sat": "def sat(s: str, word: str=\"cococharerihyxydawapekib\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cococharerihyxydawapekib\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_24",
    "sat": "def sat(s: str, word: str=\"quewufakoquejovesabebado\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quewufakoquejovesabebado\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_25",
    "sat": "def sat(s: str, word: str=\"gejozysikutha\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gejozysikutha\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_26",
    "sat": "def sat(s: str, word: str=\"kykygoketexte\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kykygoketexte\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_27",
    "sat": "def sat(s: str, word: str=\"lethoryzycubyxonyxo\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lethoryzycubyxonyxo\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_28",
    "sat": "def sat(s: str, word: str=\"textaquamuvyrepu\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textaquamuvyrepu\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_29",
    "sat": "def sat(s: str, word: str=\"fovasel\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fovasel\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_30",
    "sat": "def sat(s: str, word: str=\"gasilozitextinisanucaquachinur\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gasilozitextinisanucaquachinur\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_31",
    "sat": "def sat(s: str, word: str=\"civotextohyvulyhicefatavaluhy\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"civotextohyvulyhicefatavaluhy\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_32",
    "sat": "def sat(s: str, word: str=\"vybutex\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vybutex\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_33",
    "sat": "def sat(s: str, word: str=\"lovuthotufyrututony\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lovuthotufyrututony\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_34",
    "sat": "def sat(s: str, word: str=\"quudekaquytyfatextegahite\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quudekaquytyfatextegahite\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_35",
    "sat": "def sat(s: str, word: str=\"pevidecychukipudixopyguj\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pevidecychukipudixopyguj\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_36",
    "sat": "def sat(s: str, word: str=\"kotexta\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kotexta\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_37",
    "sat": "def sat(s: str, word: str=\"xehytherucuhafagizysosezovaq\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xehytherucuhafagizysosezovaq\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_38",
    "sat": "def sat(s: str, word: str=\"tharequupycyhitextobevokuq\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tharequupycyhitextobevokuq\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_39",
    "sat": "def sat(s: str, word: str=\"tubimelecocequ\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tubimelecocequ\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_40",
    "sat": "def sat(s: str, word: str=\"xothy\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xothy\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_41",
    "sat": "def sat(s: str, word: str=\"textitextov\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textitextov\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_42",
    "sat": "def sat(s: str, word: str=\"luthoxychybulaquakonypem\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"luthoxychybulaquakonypem\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_43",
    "sat": "def sat(s: str, word: str=\"tifozupuwulupodabowohoda\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tifozupuwulupodabowohoda\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_44",
    "sat": "def sat(s: str, word: str=\"bethihitextychuty\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"bethihitextychuty\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_45",
    "sat": "def sat(s: str, word: str=\"zybykuthebiquyxothelihixysugoj\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zybykuthebiquyxothelihixysugoj\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_46",
    "sat": "def sat(s: str, word: str=\"paxedymozosycufychujub\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"paxedymozosycufychujub\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_47",
    "sat": "def sat(s: str, word: str=\"wacotivychilepiluchubogapequac\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"wacotivychilepiluchubogapequac\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_48",
    "sat": "def sat(s: str, word: str=\"textabixikym\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"textabixikym\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_49",
    "sat": "def sat(s: str, word: str=\"kowopaquityquacataxizedilopu\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kowopaquityquacataxizedilopu\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_50",
    "sat": "def sat(s: str, word: str=\"cefovothyjitholokutex\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cefovothyjitholokutex\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_51",
    "sat": "def sat(s: str, word: str=\"pymicabyryzida\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pymicabyryzida\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_52",
    "sat": "def sat(s: str, word: str=\"tapulamuzochamanejojec\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"tapulamuzochamanejojec\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_53",
    "sat": "def sat(s: str, word: str=\"lychuchar\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lychuchar\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_54",
    "sat": "def sat(s: str, word: str=\"jothidelygobosubi\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"jothidelygobosubi\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_55",
    "sat": "def sat(s: str, word: str=\"juqu\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"juqu\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_56",
    "sat": "def sat(s: str, word: str=\"xitatextolevytextaj\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xitatextolevytextaj\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_57",
    "sat": "def sat(s: str, word: str=\"kegygubevepufasubiziquu\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kegygubevepufasubiziquu\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_58",
    "sat": "def sat(s: str, word: str=\"favic\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"favic\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_59",
    "sat": "def sat(s: str, word: str=\"fozinixyquehifyvinejatume\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fozinixyquehifyvinejatume\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_60",
    "sat": "def sat(s: str, word: str=\"rythobukity\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"rythobukity\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_61",
    "sat": "def sat(s: str, word: str=\"quejithicichuzaneque\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quejithicichuzaneque\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_62",
    "sat": "def sat(s: str, word: str=\"pugyhyzyxofyh\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pugyhyzyxofyh\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_63",
    "sat": "def sat(s: str, word: str=\"kodanathirizodasisus\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kodanathirizodasisus\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_64",
    "sat": "def sat(s: str, word: str=\"pavydyzyxatextinochu\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pavydyzyxatextinochu\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_65",
    "sat": "def sat(s: str, word: str=\"vyrudychatext\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vyrudychatext\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_66",
    "sat": "def sat(s: str, word: str=\"zefuxuquowojo\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zefuxuquowojo\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_67",
    "sat": "def sat(s: str, word: str=\"cylysegecuwosonezoveruxefopoc\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cylysegecuwosonezoveruxefopoc\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_68",
    "sat": "def sat(s: str, word: str=\"guwixudichisilys\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"guwixudichisilys\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_69",
    "sat": "def sat(s: str, word: str=\"sunibisalufusanotextydy\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"sunibisalufusanotextydy\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_70",
    "sat": "def sat(s: str, word: str=\"lyxisugasabyvafyzuvuvecigu\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"lyxisugasabyvafyzuvuvecigu\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_71",
    "sat": "def sat(s: str, word: str=\"bani\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"bani\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_72",
    "sat": "def sat(s: str, word: str=\"chyjyfuvochiquucymyfik\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"chyjyfuvochiquucymyfik\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_73",
    "sat": "def sat(s: str, word: str=\"xyfifuthef\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xyfifuthef\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_74",
    "sat": "def sat(s: str, word: str=\"queth\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"queth\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_75",
    "sat": "def sat(s: str, word: str=\"xunujavojukoviquyqu\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xunujavojukoviquyqu\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_76",
    "sat": "def sat(s: str, word: str=\"norymyjexylygyjoduza\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"norymyjexylygyjoduza\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_77",
    "sat": "def sat(s: str, word: str=\"kowiwymekithigequyzukod\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kowiwymekithigequyzukod\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_78",
    "sat": "def sat(s: str, word: str=\"kutext\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"kutext\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_79",
    "sat": "def sat(s: str, word: str=\"jurewubozynakiquathetage\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"jurewubozynakiquathetage\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_80",
    "sat": "def sat(s: str, word: str=\"vohelekeket\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"vohelekeket\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_81",
    "sat": "def sat(s: str, word: str=\"chysodarequaquixoqu\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"chysodarequaquixoqu\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_82",
    "sat": "def sat(s: str, word: str=\"hutypipesojikerizuquyjuwyro\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"hutypipesojikerizuquyjuwyro\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_83",
    "sat": "def sat(s: str, word: str=\"myt\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"myt\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_84",
    "sat": "def sat(s: str, word: str=\"migiwoxo\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"migiwoxo\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_85",
    "sat": "def sat(s: str, word: str=\"fupegyquurinusurewosagotext\", max_len: int=7):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"fupegyquurinusurewosagotext\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_86",
    "sat": "def sat(s: str, word: str=\"thyxiwucazusotigulote\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"thyxiwucazusotigulote\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_87",
    "sat": "def sat(s: str, word: str=\"pihisoxytextisa\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"pihisoxytextisa\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_88",
    "sat": "def sat(s: str, word: str=\"datheruxisuteruroby\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"datheruxisuteruroby\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_89",
    "sat": "def sat(s: str, word: str=\"girumidisixixufetholivejequat\", max_len: int=6):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"girumidisixixufetholivejequat\", max_len=6):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_90",
    "sat": "def sat(s: str, word: str=\"dehojelo\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"dehojelo\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_91",
    "sat": "def sat(s: str, word: str=\"liwomylukekitut\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"liwomylukekitut\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_92",
    "sat": "def sat(s: str, word: str=\"quifuke\", max_len: int=9):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quifuke\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_93",
    "sat": "def sat(s: str, word: str=\"nodylowagidolorirerygechoduvev\", max_len: int=12):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"nodylowagidolorirerygechoduvev\", max_len=12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_94",
    "sat": "def sat(s: str, word: str=\"zixuwunesyraxozudajojutekivat\", max_len: int=14):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"zixuwunesyraxozudajojutekivat\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_95",
    "sat": "def sat(s: str, word: str=\"gahuxoquicociwethukodecibixet\", max_len: int=5):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gahuxoquicociwethukodecibixet\", max_len=5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_96",
    "sat": "def sat(s: str, word: str=\"narilytextygapi\", max_len: int=11):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"narilytextygapi\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_97",
    "sat": "def sat(s: str, word: str=\"cykumagyxigachykihuchac\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"cykumagyxigachykihuchac\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_98",
    "sat": "def sat(s: str, word: str=\"chixonet\", max_len: int=13):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"chixonet\", max_len=13):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "Abbreviate_99",
    "sat": "def sat(s: str, word: str=\"quuxafozerebujityzem\", max_len: int=8):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quuxafozerebujityzem\", max_len=8):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ]
  },
  {
    "name": "SquareTiles_0",
    "sat": "def sat(corners: List[List[int]], m: int=10, n: int=9, a: int=5, target: int=4):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=10, n=9, a=5, target=4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_1",
    "sat": "def sat(corners: List[List[int]], m: int=57, n: int=6, a: int=7, target: int=9):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=57, n=6, a=7, target=9):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_2",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=66, a: int=6, target: int=15):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=66, a=6, target=15):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_3",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=7, a: int=6, target: int=6):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=7, a=6, target=6):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_4",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=8, a: int=1, target: int=34):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=8, a=1, target=34):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_5",
    "sat": "def sat(corners: List[List[int]], m: int=430, n: int=8, a: int=5, target: int=172):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=430, n=8, a=5, target=172):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_6",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=56, a: int=4, target: int=15):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=56, a=4, target=15):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_7",
    "sat": "def sat(corners: List[List[int]], m: int=58, n: int=2, a: int=3, target: int=20):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=58, n=2, a=3, target=20):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_8",
    "sat": "def sat(corners: List[List[int]], m: int=81, n: int=20, a: int=7, target: int=39):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=81, n=20, a=7, target=39):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_9",
    "sat": "def sat(corners: List[List[int]], m: int=80, n: int=6, a: int=7, target: int=12):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=80, n=6, a=7, target=12):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_10",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=925, a: int=1, target: int=8328):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=925, a=1, target=8328):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_11",
    "sat": "def sat(corners: List[List[int]], m: int=37, n: int=791, a: int=8, target: int=499):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=37, n=791, a=8, target=499):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_12",
    "sat": "def sat(corners: List[List[int]], m: int=25, n: int=42, a: int=7, target: int=25):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=25, n=42, a=7, target=25):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_13",
    "sat": "def sat(corners: List[List[int]], m: int=74, n: int=677, a: int=6, target: int=1471):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=74, n=677, a=6, target=1471):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_14",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=54, a: int=10, target: int=8):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=54, a=10, target=8):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_15",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=5, a: int=10, target: int=3):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=5, a=10, target=3):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_16",
    "sat": "def sat(corners: List[List[int]], m: int=614, n: int=360, a: int=3, target: int=24604):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=614, n=360, a=3, target=24604):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_17",
    "sat": "def sat(corners: List[List[int]], m: int=63, n: int=54, a: int=5, target: int=144):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=63, n=54, a=5, target=144):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_18",
    "sat": "def sat(corners: List[List[int]], m: int=26, n: int=5, a: int=3, target: int=18):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=26, n=5, a=3, target=18):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_19",
    "sat": "def sat(corners: List[List[int]], m: int=291, n: int=59, a: int=9, target: int=232):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=291, n=59, a=9, target=232):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_20",
    "sat": "def sat(corners: List[List[int]], m: int=12, n: int=796, a: int=7, target: int=231):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=12, n=796, a=7, target=231):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_21",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=834, a: int=10, target: int=87):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=834, a=10, target=87):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_22",
    "sat": "def sat(corners: List[List[int]], m: int=44, n: int=42, a: int=5, target: int=82):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=44, n=42, a=5, target=82):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_23",
    "sat": "def sat(corners: List[List[int]], m: int=93, n: int=19, a: int=7, target: int=42):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=93, n=19, a=7, target=42):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_24",
    "sat": "def sat(corners: List[List[int]], m: int=275, n: int=30, a: int=4, target: int=552):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=275, n=30, a=4, target=552):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_25",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=6, a: int=4, target: int=7):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=6, a=4, target=7):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_26",
    "sat": "def sat(corners: List[List[int]], m: int=61, n: int=619, a: int=5, target: int=1612):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=61, n=619, a=5, target=1612):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_27",
    "sat": "def sat(corners: List[List[int]], m: int=460, n: int=67, a: int=2, target: int=7824):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=460, n=67, a=2, target=7824):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_28",
    "sat": "def sat(corners: List[List[int]], m: int=843, n: int=463, a: int=7, target: int=8109):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=843, n=463, a=7, target=8109):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_29",
    "sat": "def sat(corners: List[List[int]], m: int=90, n: int=6, a: int=4, target: int=48):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=90, n=6, a=4, target=48):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_30",
    "sat": "def sat(corners: List[List[int]], m: int=53, n: int=58, a: int=5, target: int=136):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=53, n=58, a=5, target=136):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_31",
    "sat": "def sat(corners: List[List[int]], m: int=410, n: int=822, a: int=3, target: int=37540):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=410, n=822, a=3, target=37540):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_32",
    "sat": "def sat(corners: List[List[int]], m: int=56, n: int=32, a: int=5, target: int=87):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=56, n=32, a=5, target=87):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_33",
    "sat": "def sat(corners: List[List[int]], m: int=600, n: int=78, a: int=5, target: int=1920):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=600, n=78, a=5, target=1920):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_34",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=59, a: int=10, target: int=9):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=59, a=10, target=9):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_35",
    "sat": "def sat(corners: List[List[int]], m: int=172, n: int=46, a: int=7, target: int=175):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=172, n=46, a=7, target=175):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_36",
    "sat": "def sat(corners: List[List[int]], m: int=14, n: int=7, a: int=3, target: int=16):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=14, n=7, a=3, target=16):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_37",
    "sat": "def sat(corners: List[List[int]], m: int=3, n: int=5, a: int=8, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=5, a=8, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_38",
    "sat": "def sat(corners: List[List[int]], m: int=81, n: int=4, a: int=6, target: int=14):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=81, n=4, a=6, target=14):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_39",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=4, a: int=2, target: int=5):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=4, a=2, target=5):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_40",
    "sat": "def sat(corners: List[List[int]], m: int=924, n: int=4, a: int=9, target: int=103):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=924, n=4, a=9, target=103):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_41",
    "sat": "def sat(corners: List[List[int]], m: int=998, n: int=671, a: int=8, target: int=10503):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=998, n=671, a=8, target=10503):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_42",
    "sat": "def sat(corners: List[List[int]], m: int=470, n: int=45, a: int=1, target: int=21150):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=470, n=45, a=1, target=21150):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_43",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=47, a: int=3, target: int=51):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=47, a=3, target=51):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_44",
    "sat": "def sat(corners: List[List[int]], m: int=284, n: int=963, a: int=5, target: int=11003):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=284, n=963, a=5, target=11003):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_45",
    "sat": "def sat(corners: List[List[int]], m: int=33, n: int=217, a: int=4, target: int=496):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=33, n=217, a=4, target=496):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_46",
    "sat": "def sat(corners: List[List[int]], m: int=21, n: int=494, a: int=7, target: int=217):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=21, n=494, a=7, target=217):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_47",
    "sat": "def sat(corners: List[List[int]], m: int=25, n: int=247, a: int=6, target: int=210):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=25, n=247, a=6, target=210):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_48",
    "sat": "def sat(corners: List[List[int]], m: int=60, n: int=37, a: int=3, target: int=263):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=60, n=37, a=3, target=263):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_49",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=396, a: int=2, target: int=199):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=396, a=2, target=199):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_50",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=1, a: int=5, target: int=4):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=1, a=5, target=4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_51",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=38, a: int=2, target: int=58):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=38, a=2, target=58):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_52",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=38, a: int=9, target: int=7):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=38, a=9, target=7):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_53",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=61, a: int=7, target: int=9):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=61, a=7, target=9):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_54",
    "sat": "def sat(corners: List[List[int]], m: int=7, n: int=83, a: int=2, target: int=172):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=83, a=2, target=172):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_55",
    "sat": "def sat(corners: List[List[int]], m: int=22, n: int=8, a: int=9, target: int=4):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=22, n=8, a=9, target=4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_56",
    "sat": "def sat(corners: List[List[int]], m: int=776, n: int=5, a: int=9, target: int=91):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=776, n=5, a=9, target=91):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_57",
    "sat": "def sat(corners: List[List[int]], m: int=971, n: int=13, a: int=10, target: int=196):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=971, n=13, a=10, target=196):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_58",
    "sat": "def sat(corners: List[List[int]], m: int=69, n: int=775, a: int=7, target: int=1114):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=69, n=775, a=7, target=1114):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_59",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=420, a: int=6, target: int=72):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=420, a=6, target=72):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_60",
    "sat": "def sat(corners: List[List[int]], m: int=36, n: int=7, a: int=6, target: int=13):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=36, n=7, a=6, target=13):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_61",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=3, a: int=2, target: int=14):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=3, a=2, target=14):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_62",
    "sat": "def sat(corners: List[List[int]], m: int=3, n: int=867, a: int=9, target: int=101):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=867, a=9, target=101):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_63",
    "sat": "def sat(corners: List[List[int]], m: int=694, n: int=3, a: int=1, target: int=2085):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=694, n=3, a=1, target=2085):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_64",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=5, a: int=1, target: int=47):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=5, a=1, target=47):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_65",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=1, a: int=7, target: int=1):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=1, a=7, target=1):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_66",
    "sat": "def sat(corners: List[List[int]], m: int=9, n: int=5, a: int=6, target: int=2):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=9, n=5, a=6, target=2):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_67",
    "sat": "def sat(corners: List[List[int]], m: int=25, n: int=59, a: int=10, target: int=18):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=25, n=59, a=10, target=18):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_68",
    "sat": "def sat(corners: List[List[int]], m: int=408, n: int=1, a: int=8, target: int=53):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=408, n=1, a=8, target=53):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_69",
    "sat": "def sat(corners: List[List[int]], m: int=31, n: int=8, a: int=1, target: int=250):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=31, n=8, a=1, target=250):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_70",
    "sat": "def sat(corners: List[List[int]], m: int=975, n: int=42, a: int=1, target: int=40951):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=975, n=42, a=1, target=40951):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_71",
    "sat": "def sat(corners: List[List[int]], m: int=89, n: int=55, a: int=3, target: int=573):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=89, n=55, a=3, target=573):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_72",
    "sat": "def sat(corners: List[List[int]], m: int=2, n: int=837, a: int=1, target: int=1675):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=2, n=837, a=1, target=1675):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_73",
    "sat": "def sat(corners: List[List[int]], m: int=87, n: int=9, a: int=1, target: int=785):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=87, n=9, a=1, target=785):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_74",
    "sat": "def sat(corners: List[List[int]], m: int=77, n: int=4, a: int=4, target: int=20):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=77, n=4, a=4, target=20):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_75",
    "sat": "def sat(corners: List[List[int]], m: int=870, n: int=9, a: int=8, target: int=219):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=870, n=9, a=8, target=219):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_76",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=550, a: int=4, target: int=280):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=550, a=4, target=280):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_77",
    "sat": "def sat(corners: List[List[int]], m: int=28, n: int=974, a: int=9, target: int=438):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=28, n=974, a=9, target=438):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_78",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=78, a: int=8, target: int=10):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=78, a=8, target=10):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_79",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=2, a: int=3, target: int=2):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=2, a=3, target=2):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_80",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=68, a: int=10, target: int=9):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=68, a=10, target=9):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_81",
    "sat": "def sat(corners: List[List[int]], m: int=6, n: int=41, a: int=3, target: int=31):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=6, n=41, a=3, target=31):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_82",
    "sat": "def sat(corners: List[List[int]], m: int=5, n: int=86, a: int=3, target: int=58):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=5, n=86, a=3, target=58):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_83",
    "sat": "def sat(corners: List[List[int]], m: int=80, n: int=551, a: int=3, target: int=4970):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=80, n=551, a=3, target=4970):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_84",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=95, a: int=4, target: int=26):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=95, a=4, target=26):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_85",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=22, a: int=6, target: int=11):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=22, a=6, target=11):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_86",
    "sat": "def sat(corners: List[List[int]], m: int=533, n: int=5, a: int=3, target: int=356):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=533, n=5, a=3, target=356):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_87",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=293, a: int=4, target: int=76):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=293, a=4, target=76):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_88",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=828, a: int=9, target: int=94):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=828, a=9, target=94):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_89",
    "sat": "def sat(corners: List[List[int]], m: int=29, n: int=7, a: int=10, target: int=6):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=29, n=7, a=10, target=6):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_90",
    "sat": "def sat(corners: List[List[int]], m: int=27, n: int=73, a: int=6, target: int=68):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=27, n=73, a=6, target=68):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_91",
    "sat": "def sat(corners: List[List[int]], m: int=1, n: int=93, a: int=9, target: int=12):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=1, n=93, a=9, target=12):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_92",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=5, a: int=1, target: int=40):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=5, a=1, target=40):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_93",
    "sat": "def sat(corners: List[List[int]], m: int=48, n: int=15, a: int=1, target: int=722):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=48, n=15, a=1, target=722):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_94",
    "sat": "def sat(corners: List[List[int]], m: int=608, n: int=978, a: int=2, target: int=148656):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=608, n=978, a=2, target=148656):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_95",
    "sat": "def sat(corners: List[List[int]], m: int=4, n: int=2, a: int=4, target: int=2):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=2, a=4, target=2):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_96",
    "sat": "def sat(corners: List[List[int]], m: int=8, n: int=48, a: int=5, target: int=20):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=8, n=48, a=5, target=20):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_97",
    "sat": "def sat(corners: List[List[int]], m: int=56, n: int=984, a: int=3, target: int=6235):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=56, n=984, a=3, target=6235):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_98",
    "sat": "def sat(corners: List[List[int]], m: int=467, n: int=626, a: int=6, target: int=8192):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=467, n=626, a=6, target=8192):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "SquareTiles_99",
    "sat": "def sat(corners: List[List[int]], m: int=19, n: int=252, a: int=10, target: int=53):\n    assert type(corners) is list and all(type(a) is list and all(type(b) is int for b in a) for a in corners), 'corners must be of type List[List[int]]'\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=19, n=252, a=10, target=53):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ]
  },
  {
    "name": "EasyTwos_0",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_1",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 0], [0, 1, 1], [1, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 0], [0, 1, 1], [1, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_2",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_3",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_4",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_5",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_6",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_7",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_8",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_9",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_10",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_11",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_12",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_13",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_14",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_15",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_16",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_17",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_18",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_19",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_20",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_21",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_22",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_23",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_24",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_25",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 0], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 0], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_26",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_27",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_28",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_29",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [1, 0, 0], [1, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 0, 0], [1, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_30",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 1], [0, 1, 1], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 0], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 1, 0], [1, 1, 1], [1, 0, 1], [0, 1, 1], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 0], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_31",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_32",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_33",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 0, 0], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 0, 0], [1, 1, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_34",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_35",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 1, 1], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_36",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 0], [0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_37",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_38",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [0, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [1, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [0, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [1, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_39",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 0, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_40",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_41",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_42",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 0], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 0], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_43",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 1, 1], [1, 0, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_44",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_45",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_46",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 0], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 0], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_47",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 0, 1], [0, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 0, 1], [0, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_48",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0], [1, 1, 0], [1, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0], [1, 1, 0], [1, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_49",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_50",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_51",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_52",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 0, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 0], [0, 1, 1], [1, 1, 0], [0, 0, 1], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_53",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_54",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_55",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 1, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_56",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 1, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 0], [0, 0, 1], [1, 1, 1], [1, 1, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_57",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_58",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_59",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_60",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 1], [1, 1, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 1], [1, 1, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_61",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_62",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_63",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [0, 1, 1], [0, 1, 0], [0, 0, 0], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_64",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 1, 0], [1, 0, 1], [1, 1, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0], [0, 1, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 1, 0], [1, 0, 1], [1, 1, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0], [0, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_65",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_66",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 0, 1], [1, 0, 1], [0, 0, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_67",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_68",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 1], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_69",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_70",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_71",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_72",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_73",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 1, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_74",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 0, 0], [0, 0, 1], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 0, 1], [0, 1, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_75",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_76",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 0], [1, 0, 0], [1, 1, 1], [0, 0, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 1], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1], [0, 0, 0], [1, 0, 0], [1, 1, 1], [0, 0, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_77",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [1, 1, 0], [1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [1, 1, 0], [1, 1, 1], [0, 0, 1], [0, 1, 0], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_78",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [0, 0, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [0, 0, 1], [0, 0, 1], [1, 0, 0], [0, 1, 1], [0, 0, 1], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_79",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 1, 1], [1, 0, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_80",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 1, 0], [1, 1, 0], [1, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 1, 0], [1, 1, 0], [1, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_81",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1], [0, 0, 0], [1, 1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_82",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 0, 1], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_83",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 1], [0, 1, 0], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_84",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_85",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0], [0, 0, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_86",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0], [0, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_87",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 1, 1], [0, 0, 1], [0, 1, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_88",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_89",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_90",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [1, 0, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_91",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_92",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [1, 1, 1], [1, 1, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 1, 1], [1, 1, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_93",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_94",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 0], [1, 0, 0], [1, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_95",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_96",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 1], [0, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_97",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 1, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 1], [0, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_98",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[1, 0, 0], [0, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 0], [0, 0, 0], [0, 1, 1], [1, 1, 1], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "EasyTwos_99",
    "sat": "def sat(lb: List[bool], trips: List[List[int]]=[[0, 1, 0], [0, 0, 0], [1, 0, 1]]):\n    assert type(lb) is list and all(type(a) is bool for a in lb), 'lb must be of type List[bool]'\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 0, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ]
  },
  {
    "name": "DecreasingCountComparison_0",
    "sat": "def sat(n: int, scores: List[int]=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_1",
    "sat": "def sat(n: int, scores: List[int]=[6, 3], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[6, 3], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_2",
    "sat": "def sat(n: int, scores: List[int]=[15, 12, 7], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 12, 7], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_3",
    "sat": "def sat(n: int, scores: List[int]=[36, 13, 12, 3], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[36, 13, 12, 3], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_4",
    "sat": "def sat(n: int, scores: List[int]=[32, 32, 16, 16, 11], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 32, 16, 16, 11], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_5",
    "sat": "def sat(n: int, scores: List[int]=[22, 17, 10, 4, 3, 1], k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 17, 10, 4, 3, 1], k=3):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_6",
    "sat": "def sat(n: int, scores: List[int]=[4, 4, 4, 4, 4, 0, 0], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[4, 4, 4, 4, 4, 0, 0], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_7",
    "sat": "def sat(n: int, scores: List[int]=[0, 0, 0, 0, 0, 0, 0, 0], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0, 0, 0, 0, 0, 0, 0], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_8",
    "sat": "def sat(n: int, scores: List[int]=[34, 28, 20, 19, 19, 16, 13, 11, 9], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 28, 20, 19, 19, 16, 13, 11, 9], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_9",
    "sat": "def sat(n: int, scores: List[int]=[7, 7, 5, 4, 4, 3, 3, 3, 2, 0], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[7, 7, 5, 4, 4, 3, 3, 3, 2, 0], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_10",
    "sat": "def sat(n: int, scores: List[int]=[20, 20, 19, 19, 18, 18, 18, 13, 12, 12, 2], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[20, 20, 19, 19, 18, 18, 18, 13, 12, 12, 2], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_11",
    "sat": "def sat(n: int, scores: List[int]=[41, 32, 30, 28, 28, 24, 18, 13, 11, 8, 5, 1], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[41, 32, 30, 28, 28, 24, 18, 13, 11, 8, 5, 1], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_12",
    "sat": "def sat(n: int, scores: List[int]=[46, 41, 39, 39, 35, 33, 32, 29, 28, 20, 9, 3, 2], k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[46, 41, 39, 39, 35, 33, 32, 29, 28, 20, 9, 3, 2], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_13",
    "sat": "def sat(n: int, scores: List[int]=[38, 35, 33, 31, 31, 20, 20, 20, 13, 13, 10, 6, 6, 2], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[38, 35, 33, 31, 31, 20, 20, 20, 13, 13, 10, 6, 6, 2], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_14",
    "sat": "def sat(n: int, scores: List[int]=[48, 47, 46, 37, 35, 31, 27, 22, 16, 14, 6, 6, 5, 3, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[48, 47, 46, 37, 35, 31, 27, 22, 16, 14, 6, 6, 5, 3, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_15",
    "sat": "def sat(n: int, scores: List[int]=[32, 29, 26, 23, 19, 17, 16, 14, 12, 10, 9, 8, 7, 7, 1, 0], k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 29, 26, 23, 19, 17, 16, 14, 12, 10, 9, 8, 7, 7, 1, 0], k=1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_16",
    "sat": "def sat(n: int, scores: List[int]=[36, 35, 35, 34, 27, 24, 21, 19, 17, 17, 12, 11, 7, 5, 5, 3, 0], k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[36, 35, 35, 34, 27, 24, 21, 19, 17, 17, 12, 11, 7, 5, 5, 3, 0], k=10):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_17",
    "sat": "def sat(n: int, scores: List[int]=[20, 19, 19, 18, 17, 15, 11, 11, 10, 9, 9, 8, 8, 4, 3, 3, 2, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[20, 19, 19, 18, 17, 15, 11, 11, 10, 9, 9, 8, 8, 4, 3, 3, 2, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_18",
    "sat": "def sat(n: int, scores: List[int]=[28, 26, 25, 25, 24, 24, 22, 21, 21, 20, 20, 16, 13, 12, 8, 8, 8, 7, 1], k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[28, 26, 25, 25, 24, 24, 22, 21, 21, 20, 20, 16, 13, 12, 8, 8, 8, 7, 1], k=10):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_19",
    "sat": "def sat(n: int, scores: List[int]=[47, 43, 40, 38, 38, 35, 29, 25, 24, 24, 21, 14, 12, 12, 12, 11, 9, 8, 6, 5], k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 43, 40, 38, 38, 35, 29, 25, 24, 24, 21, 14, 12, 12, 12, 11, 9, 8, 6, 5], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_20",
    "sat": "def sat(n: int, scores: List[int]=[26, 23, 22, 21, 21, 20, 20, 20, 19, 18, 16, 15, 15, 12, 11, 8, 8, 7, 3, 3, 0], k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[26, 23, 22, 21, 21, 20, 20, 20, 19, 18, 16, 15, 15, 12, 11, 8, 8, 7, 3, 3, 0], k=14):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_21",
    "sat": "def sat(n: int, scores: List[int]=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=0):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_22",
    "sat": "def sat(n: int, scores: List[int]=[29, 28, 23, 23, 20, 19, 18, 18, 17, 17, 16, 16, 14, 11, 9, 5, 5, 4, 3, 3, 2, 0, 0], k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[29, 28, 23, 23, 20, 19, 18, 18, 17, 17, 16, 16, 14, 11, 9, 5, 5, 4, 3, 3, 2, 0, 0], k=8):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_23",
    "sat": "def sat(n: int, scores: List[int]=[44, 42, 37, 37, 37, 36, 36, 31, 29, 24, 23, 21, 17, 17, 12, 11, 9, 9, 7, 6, 6, 4, 2, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[44, 42, 37, 37, 37, 36, 36, 31, 29, 24, 23, 21, 17, 17, 12, 11, 9, 9, 7, 6, 6, 4, 2, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_24",
    "sat": "def sat(n: int, scores: List[int]=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_25",
    "sat": "def sat(n: int, scores: List[int]=[39, 36, 36, 36, 36, 34, 26, 22, 21, 19, 19, 18, 18, 17, 14, 12, 11, 7, 7, 7, 7, 7, 6, 6, 3, 0], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[39, 36, 36, 36, 36, 34, 26, 22, 21, 19, 19, 18, 18, 17, 14, 12, 11, 7, 7, 7, 7, 7, 6, 6, 3, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_26",
    "sat": "def sat(n: int, scores: List[int]=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=16):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_27",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 21, 21, 21, 21, 20, 19, 19, 18, 18, 17, 16, 16, 13, 12, 12, 11, 10, 7, 7, 5, 5, 3, 1, 1, 0, 0], k: int=24):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 21, 21, 21, 21, 20, 19, 19, 18, 18, 17, 16, 16, 13, 12, 12, 11, 10, 7, 7, 5, 5, 3, 1, 1, 0, 0], k=24):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_28",
    "sat": "def sat(n: int, scores: List[int]=[31, 29, 28, 28, 27, 27, 27, 26, 25, 21, 21, 21, 20, 20, 18, 18, 17, 15, 14, 13, 12, 11, 11, 10, 6, 4, 3, 2, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[31, 29, 28, 28, 27, 27, 27, 26, 25, 21, 21, 21, 20, 20, 18, 18, 17, 15, 14, 13, 12, 11, 11, 10, 6, 4, 3, 2, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_29",
    "sat": "def sat(n: int, scores: List[int]=[32, 31, 30, 30, 27, 27, 26, 25, 24, 22, 22, 22, 22, 19, 19, 17, 16, 15, 13, 12, 11, 11, 7, 6, 6, 5, 3, 3, 2, 1], k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 31, 30, 30, 27, 27, 26, 25, 24, 22, 22, 22, 22, 19, 19, 17, 16, 15, 13, 12, 11, 11, 7, 6, 6, 5, 3, 3, 2, 1], k=19):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_30",
    "sat": "def sat(n: int, scores: List[int]=[32, 32, 31, 28, 27, 27, 27, 25, 24, 23, 22, 21, 20, 18, 18, 16, 15, 13, 12, 9, 8, 6, 6, 5, 4, 4, 3, 2, 1, 1, 0], k: int=22):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 32, 31, 28, 27, 27, 27, 25, 24, 23, 22, 21, 20, 18, 18, 16, 15, 13, 12, 9, 8, 6, 6, 5, 4, 4, 3, 2, 1, 1, 0], k=22):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_31",
    "sat": "def sat(n: int, scores: List[int]=[36, 34, 33, 31, 31, 31, 30, 29, 29, 28, 28, 25, 25, 25, 24, 22, 21, 20, 19, 18, 15, 15, 12, 11, 11, 11, 9, 9, 6, 6, 4, 4], k: int=31):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[36, 34, 33, 31, 31, 31, 30, 29, 29, 28, 28, 25, 25, 25, 24, 22, 21, 20, 19, 18, 15, 15, 12, 11, 11, 11, 9, 9, 6, 6, 4, 4], k=31):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_32",
    "sat": "def sat(n: int, scores: List[int]=[18, 18, 17, 16, 16, 16, 15, 15, 15, 14, 13, 13, 12, 11, 11, 10, 10, 10, 10, 8, 7, 7, 6, 6, 5, 3, 3, 3, 1, 1, 0, 0, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[18, 18, 17, 16, 16, 16, 15, 15, 15, 14, 13, 13, 12, 11, 11, 10, 10, 10, 10, 8, 7, 7, 6, 6, 5, 3, 3, 3, 1, 1, 0, 0, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_33",
    "sat": "def sat(n: int, scores: List[int]=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_34",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=25):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=25):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_35",
    "sat": "def sat(n: int, scores: List[int]=[22, 22, 21, 20, 20, 20, 19, 18, 16, 15, 14, 14, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 8, 8, 6, 6, 4, 4, 3, 2, 2, 1, 1, 1, 1], k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 22, 21, 20, 20, 20, 19, 18, 16, 15, 14, 14, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 8, 8, 6, 6, 4, 4, 3, 2, 2, 1, 1, 1, 1], k=3):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_36",
    "sat": "def sat(n: int, scores: List[int]=[38, 37, 35, 33, 32, 31, 31, 30, 28, 28, 28, 27, 26, 25, 24, 24, 22, 21, 17, 16, 16, 14, 14, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 6, 5, 5, 5], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[38, 37, 35, 33, 32, 31, 31, 30, 28, 28, 28, 27, 26, 25, 24, 24, 22, 21, 17, 16, 16, 14, 14, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 6, 5, 5, 5], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_37",
    "sat": "def sat(n: int, scores: List[int]=[16, 15, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 7, 7, 7, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2, 1, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[16, 15, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 7, 7, 7, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2, 1, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_38",
    "sat": "def sat(n: int, scores: List[int]=[33, 32, 32, 32, 31, 31, 30, 30, 29, 29, 28, 24, 22, 22, 21, 20, 20, 20, 19, 17, 16, 15, 15, 14, 12, 12, 12, 9, 7, 7, 6, 5, 4, 4, 1, 1, 1, 1, 0], k: int=28):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[33, 32, 32, 32, 31, 31, 30, 30, 29, 29, 28, 24, 22, 22, 21, 20, 20, 20, 19, 17, 16, 15, 15, 14, 12, 12, 12, 9, 7, 7, 6, 5, 4, 4, 1, 1, 1, 1, 0], k=28):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_39",
    "sat": "def sat(n: int, scores: List[int]=[48, 47, 46, 45, 43, 42, 42, 41, 40, 38, 38, 37, 35, 35, 33, 32, 31, 29, 28, 26, 24, 24, 22, 22, 20, 19, 19, 16, 16, 15, 14, 9, 9, 9, 8, 6, 6, 6, 5, 0], k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[48, 47, 46, 45, 43, 42, 42, 41, 40, 38, 38, 37, 35, 35, 33, 32, 31, 29, 28, 26, 24, 24, 22, 22, 20, 19, 19, 16, 16, 15, 14, 9, 9, 9, 8, 6, 6, 6, 5, 0], k=7):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_40",
    "sat": "def sat(n: int, scores: List[int]=[46, 43, 42, 39, 37, 37, 36, 36, 35, 35, 32, 32, 30, 29, 28, 26, 26, 26, 25, 24, 23, 23, 22, 22, 21, 21, 21, 21, 20, 20, 19, 17, 16, 13, 11, 10, 9, 8, 2, 1, 0], k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[46, 43, 42, 39, 37, 37, 36, 36, 35, 35, 32, 32, 30, 29, 28, 26, 26, 26, 25, 24, 23, 23, 22, 22, 21, 21, 21, 21, 20, 20, 19, 17, 16, 13, 11, 10, 9, 8, 2, 1, 0], k=18):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_41",
    "sat": "def sat(n: int, scores: List[int]=[24, 23, 23, 22, 22, 21, 20, 18, 18, 18, 17, 16, 16, 15, 13, 12, 12, 12, 11, 11, 10, 10, 10, 9, 8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 4, 4, 2, 2, 2, 1, 1, 1], k: int=36):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[24, 23, 23, 22, 22, 21, 20, 18, 18, 18, 17, 16, 16, 15, 13, 12, 12, 12, 11, 11, 10, 10, 10, 9, 8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 4, 4, 2, 2, 2, 1, 1, 1], k=36):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_42",
    "sat": "def sat(n: int, scores: List[int]=[16, 16, 16, 15, 15, 15, 14, 14, 14, 13, 11, 11, 11, 10, 9, 9, 8, 8, 7, 6, 6, 6, 4, 4, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k: int=40):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[16, 16, 16, 15, 15, 15, 14, 14, 14, 13, 11, 11, 11, 10, 9, 9, 8, 8, 7, 6, 6, 6, 4, 4, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k=40):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_43",
    "sat": "def sat(n: int, scores: List[int]=[22, 22, 22, 21, 20, 20, 19, 19, 19, 19, 17, 15, 14, 14, 14, 13, 12, 11, 10, 10, 9, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 22, 22, 21, 20, 20, 19, 19, 19, 19, 17, 15, 14, 14, 14, 13, 12, 11, 10, 10, 9, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_44",
    "sat": "def sat(n: int, scores: List[int]=[15, 15, 15, 15, 15, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 6, 6, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 15, 15, 15, 15, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 6, 6, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=7):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_45",
    "sat": "def sat(n: int, scores: List[int]=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_46",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 18, 17, 17, 17, 17, 16, 15, 15, 14, 14, 14, 12, 12, 11, 11, 11, 11, 10, 9, 8, 7, 7, 6, 6, 4, 4, 4, 4, 4, 2, 2, 1, 1, 1, 0], k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 18, 17, 17, 17, 17, 16, 15, 15, 14, 14, 14, 12, 12, 11, 11, 11, 11, 10, 9, 8, 7, 7, 6, 6, 4, 4, 4, 4, 4, 2, 2, 1, 1, 1, 0], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_47",
    "sat": "def sat(n: int, scores: List[int]=[24, 22, 21, 20, 20, 20, 20, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 13, 13, 13, 13, 11, 8, 8, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k: int=29):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[24, 22, 21, 20, 20, 20, 20, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 13, 13, 13, 13, 11, 8, 8, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k=29):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_48",
    "sat": "def sat(n: int, scores: List[int]=[34, 34, 32, 31, 31, 31, 31, 30, 30, 30, 28, 27, 27, 27, 25, 24, 23, 21, 21, 20, 20, 20, 19, 16, 16, 16, 15, 14, 13, 13, 12, 12, 11, 11, 10, 10, 10, 9, 9, 9, 9, 7, 6, 6, 6, 5, 3, 2, 0], k: int=45):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 34, 32, 31, 31, 31, 31, 30, 30, 30, 28, 27, 27, 27, 25, 24, 23, 21, 21, 20, 20, 20, 19, 16, 16, 16, 15, 14, 13, 13, 12, 12, 11, 11, 10, 10, 10, 9, 9, 9, 9, 7, 6, 6, 6, 5, 3, 2, 0], k=45):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_49",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 20, 20, 19, 19, 19, 19, 17, 17, 17, 16, 16, 16, 16, 15, 14, 14, 14, 13, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 5, 5, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0], k: int=27):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 20, 20, 19, 19, 19, 19, 17, 17, 17, 16, 16, 16, 16, 15, 14, 14, 14, 13, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 5, 5, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0], k=27):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_50",
    "sat": "def sat(n: int, scores: List[int]=[13, 13, 13, 13, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k: int=41):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[13, 13, 13, 13, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k=41):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_51",
    "sat": "def sat(n: int, scores: List[int]=[29, 29, 29, 28, 28, 28, 28, 27, 26, 25, 25, 24, 22, 22, 20, 20, 19, 19, 18, 18, 18, 18, 17, 16, 16, 14, 14, 14, 14, 13, 13, 10, 10, 9, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 3, 2, 2, 2, 1, 1, 0, 0], k: int=21):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[29, 29, 29, 28, 28, 28, 28, 27, 26, 25, 25, 24, 22, 22, 20, 20, 19, 19, 18, 18, 18, 18, 17, 16, 16, 14, 14, 14, 14, 13, 13, 10, 10, 9, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 3, 2, 2, 2, 1, 1, 0, 0], k=21):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_52",
    "sat": "def sat(n: int, scores: List[int]=[25, 24, 24, 23, 23, 22, 22, 21, 21, 21, 20, 20, 18, 18, 18, 18, 15, 15, 15, 14, 14, 14, 14, 12, 12, 12, 12, 11, 10, 10, 9, 8, 8, 7, 7, 7, 7, 7, 7, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 0], k: int=26):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[25, 24, 24, 23, 23, 22, 22, 21, 21, 21, 20, 20, 18, 18, 18, 18, 15, 15, 15, 14, 14, 14, 14, 12, 12, 12, 12, 11, 10, 10, 9, 8, 8, 7, 7, 7, 7, 7, 7, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 0], k=26):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_53",
    "sat": "def sat(n: int, scores: List[int]=[26, 26, 26, 25, 24, 24, 24, 23, 23, 23, 22, 21, 21, 21, 20, 20, 20, 19, 18, 18, 17, 17, 17, 16, 16, 15, 14, 13, 12, 12, 10, 10, 10, 10, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 3, 2, 2, 1, 1, 0], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[26, 26, 26, 25, 24, 24, 24, 23, 23, 23, 22, 21, 21, 21, 20, 20, 20, 19, 18, 18, 17, 17, 17, 16, 16, 15, 14, 13, 12, 12, 10, 10, 10, 10, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 3, 2, 2, 1, 1, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_54",
    "sat": "def sat(n: int, scores: List[int]=[15, 15, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 15, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k=14):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_55",
    "sat": "def sat(n: int, scores: List[int]=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=34):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=34):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_56",
    "sat": "def sat(n: int, scores: List[int]=[37, 37, 35, 34, 34, 34, 33, 33, 32, 31, 31, 31, 30, 30, 29, 28, 28, 27, 26, 26, 25, 24, 23, 21, 21, 20, 20, 19, 18, 17, 16, 15, 15, 13, 12, 11, 10, 10, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 5, 3, 3, 2, 2, 1, 0], k: int=46):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[37, 37, 35, 34, 34, 34, 33, 33, 32, 31, 31, 31, 30, 30, 29, 28, 28, 27, 26, 26, 25, 24, 23, 21, 21, 20, 20, 19, 18, 17, 16, 15, 15, 13, 12, 11, 10, 10, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 5, 3, 3, 2, 2, 1, 0], k=46):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_57",
    "sat": "def sat(n: int, scores: List[int]=[15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 13, 13, 13, 13, 13, 12, 12, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 13, 13, 13, 13, 13, 12, 12, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=13):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_58",
    "sat": "def sat(n: int, scores: List[int]=[42, 41, 40, 40, 38, 38, 37, 37, 37, 36, 36, 36, 36, 36, 34, 33, 32, 32, 32, 32, 30, 29, 28, 27, 27, 26, 26, 24, 24, 23, 23, 22, 22, 21, 20, 19, 17, 17, 14, 14, 13, 13, 11, 10, 9, 9, 8, 8, 8, 7, 5, 4, 4, 3, 3, 2, 1, 1, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[42, 41, 40, 40, 38, 38, 37, 37, 37, 36, 36, 36, 36, 36, 34, 33, 32, 32, 32, 32, 30, 29, 28, 27, 27, 26, 26, 24, 24, 23, 23, 22, 22, 21, 20, 19, 17, 17, 14, 14, 13, 13, 11, 10, 9, 9, 8, 8, 8, 7, 5, 4, 4, 3, 3, 2, 1, 1, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_59",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=46):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=46):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_60",
    "sat": "def sat(n: int, scores: List[int]=[39, 38, 38, 37, 37, 36, 35, 35, 34, 33, 32, 32, 31, 28, 26, 25, 25, 24, 24, 24, 22, 21, 19, 19, 19, 19, 18, 18, 17, 16, 15, 15, 14, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 8, 7, 7, 7, 7, 6, 5, 5, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[39, 38, 38, 37, 37, 36, 35, 35, 34, 33, 32, 32, 31, 28, 26, 25, 25, 24, 24, 24, 22, 21, 19, 19, 19, 19, 18, 18, 17, 16, 15, 15, 14, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 8, 7, 7, 7, 7, 6, 5, 5, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0], k=10):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_61",
    "sat": "def sat(n: int, scores: List[int]=[9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=61):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=61):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_62",
    "sat": "def sat(n: int, scores: List[int]=[41, 40, 39, 38, 36, 34, 34, 34, 34, 33, 32, 29, 29, 27, 26, 25, 25, 23, 23, 22, 22, 20, 20, 19, 18, 17, 17, 17, 15, 15, 15, 14, 14, 12, 12, 12, 12, 11, 11, 10, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 7, 5, 5, 4, 4, 4, 4, 2, 2, 1, 1, 0, 0], k: int=57):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[41, 40, 39, 38, 36, 34, 34, 34, 34, 33, 32, 29, 29, 27, 26, 25, 25, 23, 23, 22, 22, 20, 20, 19, 18, 17, 17, 17, 15, 15, 15, 14, 14, 12, 12, 12, 12, 11, 11, 10, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 7, 5, 5, 4, 4, 4, 4, 2, 2, 1, 1, 0, 0], k=57):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_63",
    "sat": "def sat(n: int, scores: List[int]=[34, 33, 33, 33, 33, 32, 32, 31, 31, 31, 30, 30, 30, 30, 30, 30, 29, 29, 29, 28, 28, 28, 28, 25, 25, 25, 24, 24, 24, 22, 19, 18, 18, 18, 17, 17, 16, 15, 15, 14, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 9, 9, 8, 6, 6, 5, 5, 3, 3, 2, 2, 1, 1, 0], k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 33, 33, 33, 33, 32, 32, 31, 31, 31, 30, 30, 30, 30, 30, 30, 29, 29, 29, 28, 28, 28, 28, 25, 25, 25, 24, 24, 24, 22, 19, 18, 18, 18, 17, 17, 16, 15, 15, 14, 13, 13, 12, 12, 11, 10, 10, 10, 9, 9, 9, 9, 8, 6, 6, 5, 5, 3, 3, 2, 2, 1, 1, 0], k=15):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_64",
    "sat": "def sat(n: int, scores: List[int]=[10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=28):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=28):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_65",
    "sat": "def sat(n: int, scores: List[int]=[13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=55):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=55):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_66",
    "sat": "def sat(n: int, scores: List[int]=[47, 47, 46, 44, 43, 42, 42, 42, 41, 39, 39, 39, 38, 38, 38, 38, 37, 36, 36, 35, 34, 32, 30, 30, 30, 29, 28, 28, 27, 25, 25, 25, 25, 25, 25, 24, 23, 22, 22, 20, 19, 19, 18, 17, 17, 16, 16, 15, 15, 14, 13, 12, 11, 11, 11, 10, 10, 8, 7, 6, 5, 5, 4, 4, 3, 3, 2], k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 47, 46, 44, 43, 42, 42, 42, 41, 39, 39, 39, 38, 38, 38, 38, 37, 36, 36, 35, 34, 32, 30, 30, 30, 29, 28, 28, 27, 25, 25, 25, 25, 25, 25, 24, 23, 22, 22, 20, 19, 19, 18, 17, 17, 16, 16, 15, 15, 14, 13, 12, 11, 11, 11, 10, 10, 8, 7, 6, 5, 5, 4, 4, 3, 3, 2], k=12):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_67",
    "sat": "def sat(n: int, scores: List[int]=[12, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0], k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[12, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_68",
    "sat": "def sat(n: int, scores: List[int]=[11, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=29):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[11, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=29):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_69",
    "sat": "def sat(n: int, scores: List[int]=[20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1], k: int=47):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 11, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1], k=47):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_70",
    "sat": "def sat(n: int, scores: List[int]=[30, 30, 30, 29, 29, 29, 29, 27, 27, 26, 26, 26, 25, 24, 24, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 13, 12, 12, 12, 12, 11, 10, 9, 8, 8, 8, 8, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 4, 3, 3, 1, 1, 0], k: int=25):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[30, 30, 30, 29, 29, 29, 29, 27, 27, 26, 26, 26, 25, 24, 24, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 13, 12, 12, 12, 12, 11, 10, 9, 8, 8, 8, 8, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 4, 3, 3, 1, 1, 0], k=25):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_71",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_72",
    "sat": "def sat(n: int, scores: List[int]=[10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=41):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=41):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_73",
    "sat": "def sat(n: int, scores: List[int]=[48, 46, 45, 44, 43, 42, 42, 42, 42, 41, 41, 41, 39, 39, 37, 37, 36, 36, 35, 34, 34, 33, 33, 32, 32, 30, 28, 27, 27, 26, 25, 25, 24, 24, 24, 23, 22, 22, 21, 21, 20, 20, 19, 18, 17, 17, 17, 17, 17, 16, 16, 14, 14, 13, 12, 12, 10, 9, 9, 8, 7, 6, 6, 5, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0], k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[48, 46, 45, 44, 43, 42, 42, 42, 42, 41, 41, 41, 39, 39, 37, 37, 36, 36, 35, 34, 34, 33, 33, 32, 32, 30, 28, 27, 27, 26, 25, 25, 24, 24, 24, 23, 22, 22, 21, 21, 20, 20, 19, 18, 17, 17, 17, 17, 17, 16, 16, 14, 14, 13, 12, 12, 10, 9, 9, 8, 7, 6, 6, 5, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0], k=12):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_74",
    "sat": "def sat(n: int, scores: List[int]=[32, 31, 31, 30, 30, 30, 29, 29, 28, 28, 28, 28, 28, 27, 27, 27, 27, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 24, 23, 23, 23, 22, 21, 21, 20, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k: int=47):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[32, 31, 31, 30, 30, 30, 29, 29, 28, 28, 28, 28, 28, 27, 27, 27, 27, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 24, 23, 23, 23, 22, 21, 21, 20, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 3, 2, 1, 1, 1, 0, 0, 0], k=47):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_75",
    "sat": "def sat(n: int, scores: List[int]=[29, 29, 28, 27, 27, 27, 25, 25, 23, 22, 22, 21, 21, 21, 21, 20, 19, 19, 18, 18, 18, 17, 17, 16, 16, 16, 16, 15, 15, 15, 15, 14, 13, 13, 13, 13, 13, 12, 11, 11, 11, 11, 11, 10, 10, 10, 8, 8, 8, 8, 8, 7, 7, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0], k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[29, 29, 28, 27, 27, 27, 25, 25, 23, 22, 22, 21, 21, 21, 21, 20, 19, 19, 18, 18, 18, 17, 17, 16, 16, 16, 16, 15, 15, 15, 15, 14, 13, 13, 13, 13, 13, 12, 11, 11, 11, 11, 11, 10, 10, 10, 8, 8, 8, 8, 8, 7, 7, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0], k=13):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_76",
    "sat": "def sat(n: int, scores: List[int]=[44, 44, 43, 40, 38, 37, 37, 37, 37, 35, 35, 35, 34, 34, 33, 33, 31, 30, 30, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 24, 23, 23, 22, 22, 20, 20, 20, 19, 19, 18, 17, 17, 15, 15, 15, 15, 14, 14, 12, 11, 11, 11, 10, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0], k: int=39):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[44, 44, 43, 40, 38, 37, 37, 37, 37, 35, 35, 35, 34, 34, 33, 33, 31, 30, 30, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 24, 23, 23, 22, 22, 20, 20, 20, 19, 19, 18, 17, 17, 15, 15, 15, 15, 14, 14, 12, 11, 11, 11, 10, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0], k=39):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_77",
    "sat": "def sat(n: int, scores: List[int]=[43, 43, 43, 41, 41, 40, 39, 39, 39, 38, 38, 38, 37, 37, 36, 36, 36, 35, 35, 35, 35, 34, 34, 33, 33, 32, 32, 31, 28, 28, 28, 26, 25, 25, 24, 24, 23, 23, 22, 22, 22, 22, 22, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 15, 15, 14, 13, 13, 12, 11, 11, 11, 11, 10, 10, 10, 9, 8, 8, 7, 7, 5, 5, 5, 3, 2, 1, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[43, 43, 43, 41, 41, 40, 39, 39, 39, 38, 38, 38, 37, 37, 36, 36, 36, 35, 35, 35, 35, 34, 34, 33, 33, 32, 32, 31, 28, 28, 28, 26, 25, 25, 24, 24, 23, 23, 22, 22, 22, 22, 22, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 15, 15, 14, 13, 13, 12, 11, 11, 11, 11, 10, 10, 10, 9, 8, 8, 7, 7, 5, 5, 5, 3, 2, 1, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_78",
    "sat": "def sat(n: int, scores: List[int]=[47, 46, 44, 44, 44, 43, 43, 41, 41, 40, 39, 38, 38, 38, 38, 38, 37, 37, 37, 37, 37, 36, 36, 35, 33, 33, 33, 31, 29, 28, 26, 26, 26, 25, 25, 24, 23, 23, 23, 21, 20, 20, 20, 19, 19, 18, 18, 18, 16, 15, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 7, 7, 7, 6, 6, 6, 5, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k: int=69):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 46, 44, 44, 44, 43, 43, 41, 41, 40, 39, 38, 38, 38, 38, 38, 37, 37, 37, 37, 37, 36, 36, 35, 33, 33, 33, 31, 29, 28, 26, 26, 26, 25, 25, 24, 23, 23, 23, 21, 20, 20, 20, 19, 19, 18, 18, 18, 16, 15, 13, 12, 11, 11, 10, 10, 10, 9, 9, 8, 7, 7, 7, 6, 6, 6, 5, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], k=69):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_79",
    "sat": "def sat(n: int, scores: List[int]=[26, 26, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 17, 17, 16, 16, 16, 16, 14, 14, 13, 13, 12, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0, 0, 0], k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[26, 26, 26, 26, 26, 25, 25, 24, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 21, 21, 20, 20, 20, 19, 19, 19, 19, 19, 18, 17, 17, 16, 16, 16, 16, 14, 14, 13, 13, 12, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 1, 1, 1, 0, 0, 0], k=11):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_80",
    "sat": "def sat(n: int, scores: List[int]=[14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_81",
    "sat": "def sat(n: int, scores: List[int]=[31, 30, 30, 30, 30, 29, 29, 29, 29, 28, 28, 28, 27, 26, 26, 26, 25, 25, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 21, 20, 19, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 15, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 7, 7, 7, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0], k: int=33):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[31, 30, 30, 30, 30, 29, 29, 29, 29, 28, 28, 28, 27, 26, 26, 26, 25, 25, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 21, 20, 19, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 15, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 9, 8, 7, 7, 7, 7, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0], k=33):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_82",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=22):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=22):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_83",
    "sat": "def sat(n: int, scores: List[int]=[12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k: int=58):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], k=58):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_84",
    "sat": "def sat(n: int, scores: List[int]=[46, 46, 45, 45, 45, 44, 43, 43, 43, 43, 41, 40, 40, 38, 38, 38, 36, 36, 36, 35, 35, 35, 35, 35, 35, 34, 34, 33, 33, 33, 31, 31, 31, 30, 30, 30, 30, 29, 28, 27, 27, 27, 27, 25, 23, 23, 23, 22, 22, 22, 22, 21, 20, 20, 19, 18, 16, 15, 14, 14, 14, 14, 13, 12, 12, 11, 11, 9, 9, 9, 9, 7, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 1, 1, 1], k: int=37):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[46, 46, 45, 45, 45, 44, 43, 43, 43, 43, 41, 40, 40, 38, 38, 38, 36, 36, 36, 35, 35, 35, 35, 35, 35, 34, 34, 33, 33, 33, 31, 31, 31, 30, 30, 30, 30, 29, 28, 27, 27, 27, 27, 25, 23, 23, 23, 22, 22, 22, 22, 21, 20, 20, 19, 18, 16, 15, 14, 14, 14, 14, 13, 12, 12, 11, 11, 9, 9, 9, 9, 7, 6, 5, 5, 4, 4, 3, 3, 3, 3, 2, 1, 1, 1], k=37):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_85",
    "sat": "def sat(n: int, scores: List[int]=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_86",
    "sat": "def sat(n: int, scores: List[int]=[8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=79):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=79):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_87",
    "sat": "def sat(n: int, scores: List[int]=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=17):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_88",
    "sat": "def sat(n: int, scores: List[int]=[45, 43, 42, 42, 41, 39, 39, 38, 38, 37, 37, 36, 36, 36, 35, 34, 34, 33, 33, 33, 33, 32, 31, 31, 31, 31, 30, 30, 30, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 24, 24, 23, 22, 22, 21, 21, 20, 19, 19, 19, 19, 18, 18, 18, 17, 16, 16, 15, 15, 14, 13, 13, 13, 13, 11, 11, 11, 9, 9, 8, 7, 7, 6, 6, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0], k: int=50):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[45, 43, 42, 42, 41, 39, 39, 38, 38, 37, 37, 36, 36, 36, 35, 34, 34, 33, 33, 33, 33, 32, 31, 31, 31, 31, 30, 30, 30, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 24, 24, 23, 22, 22, 21, 21, 20, 19, 19, 19, 19, 18, 18, 18, 17, 16, 16, 15, 15, 14, 13, 13, 13, 13, 11, 11, 11, 9, 9, 8, 7, 7, 6, 6, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0], k=50):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_89",
    "sat": "def sat(n: int, scores: List[int]=[40, 39, 39, 39, 39, 38, 38, 38, 38, 37, 35, 35, 32, 32, 32, 31, 31, 31, 30, 30, 29, 29, 27, 27, 27, 27, 26, 26, 26, 26, 25, 24, 24, 23, 23, 23, 23, 22, 21, 20, 20, 19, 19, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 7, 6, 6, 6, 4, 4, 4, 4, 3, 2, 1, 1, 0, 0], k: int=65):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[40, 39, 39, 39, 39, 38, 38, 38, 38, 37, 35, 35, 32, 32, 32, 31, 31, 31, 30, 30, 29, 29, 27, 27, 27, 27, 26, 26, 26, 26, 25, 24, 24, 23, 23, 23, 23, 22, 21, 20, 20, 19, 19, 19, 18, 18, 18, 18, 18, 17, 17, 16, 16, 15, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 7, 6, 6, 6, 4, 4, 4, 4, 3, 2, 1, 1, 0, 0], k=65):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_90",
    "sat": "def sat(n: int, scores: List[int]=[40, 40, 40, 39, 39, 39, 38, 38, 36, 36, 36, 34, 32, 32, 32, 31, 31, 31, 30, 30, 30, 30, 29, 29, 27, 27, 26, 26, 26, 26, 26, 25, 25, 25, 25, 24, 23, 23, 23, 22, 22, 21, 20, 20, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 14, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 5, 5, 5, 5, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0], k: int=54):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[40, 40, 40, 39, 39, 39, 38, 38, 36, 36, 36, 34, 32, 32, 32, 31, 31, 31, 30, 30, 30, 30, 29, 29, 27, 27, 26, 26, 26, 26, 26, 25, 25, 25, 25, 24, 23, 23, 23, 22, 22, 21, 20, 20, 20, 19, 19, 17, 17, 17, 16, 15, 15, 15, 14, 13, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 5, 5, 5, 5, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0], k=54):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_91",
    "sat": "def sat(n: int, scores: List[int]=[23, 23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17, 16, 16, 16, 16, 16, 16, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 2, 2, 2, 2, 1, 1, 0], k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[23, 23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17, 16, 16, 16, 16, 16, 16, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 2, 2, 2, 2, 1, 1, 0], k=8):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_92",
    "sat": "def sat(n: int, scores: List[int]=[14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=46):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=46):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_93",
    "sat": "def sat(n: int, scores: List[int]=[22, 22, 22, 22, 22, 22, 22, 22, 22, 21, 20, 20, 20, 20, 20, 19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0], k: int=42):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[22, 22, 22, 22, 22, 22, 22, 22, 22, 21, 20, 20, 20, 20, 20, 19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0], k=42):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_94",
    "sat": "def sat(n: int, scores: List[int]=[47, 47, 46, 46, 44, 43, 43, 43, 42, 41, 41, 40, 40, 40, 39, 38, 36, 35, 35, 35, 34, 34, 33, 33, 33, 32, 32, 31, 31, 30, 29, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 23, 22, 22, 22, 22, 21, 20, 19, 19, 19, 19, 19, 19, 18, 17, 16, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 12, 10, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 4, 3, 2, 1, 1, 1, 1, 0], k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[47, 47, 46, 46, 44, 43, 43, 43, 42, 41, 41, 40, 40, 40, 39, 38, 36, 35, 35, 35, 34, 34, 33, 33, 33, 32, 32, 31, 31, 30, 29, 29, 29, 29, 28, 28, 27, 26, 26, 26, 25, 25, 25, 24, 24, 24, 23, 22, 22, 22, 22, 21, 20, 19, 19, 19, 19, 19, 19, 18, 17, 16, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 12, 10, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 4, 3, 2, 1, 1, 1, 1, 0], k=9):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_95",
    "sat": "def sat(n: int, scores: List[int]=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=85):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=85):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_96",
    "sat": "def sat(n: int, scores: List[int]=[12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k=4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_97",
    "sat": "def sat(n: int, scores: List[int]=[21, 21, 21, 21, 21, 20, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 17, 17, 17, 17, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 1, 1, 0, 0], k: int=67):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 21, 21, 21, 21, 20, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 17, 17, 17, 17, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 1, 1, 0, 0], k=67):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_98",
    "sat": "def sat(n: int, scores: List[int]=[23, 23, 23, 22, 21, 21, 21, 21, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 16, 16, 16, 15, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k: int=85):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[23, 23, 23, 22, 21, 21, 21, 21, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 16, 16, 16, 16, 16, 16, 15, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=85):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DecreasingCountComparison_99",
    "sat": "def sat(n: int, scores: List[int]=[10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k: int=91):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k=91):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ]
  },
  {
    "name": "DominoTile_0",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=5, target: int=50):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=5, target=50):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_1",
    "sat": "def sat(squares: List[List[int]], m: int=40, n: int=45, target: int=1800):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=40, n=45, target=1800):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_2",
    "sat": "def sat(squares: List[List[int]], m: int=22, n: int=14, target: int=308):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=22, n=14, target=308):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_3",
    "sat": "def sat(squares: List[List[int]], m: int=48, n: int=23, target: int=1104):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=48, n=23, target=1104):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_4",
    "sat": "def sat(squares: List[List[int]], m: int=25, n: int=45, target: int=1124):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=25, n=45, target=1124):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_5",
    "sat": "def sat(squares: List[List[int]], m: int=26, n: int=27, target: int=702):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=26, n=27, target=702):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_6",
    "sat": "def sat(squares: List[List[int]], m: int=49, n: int=35, target: int=1714):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=49, n=35, target=1714):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_7",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=18, target: int=108):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=18, target=108):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_8",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=3, target: int=98):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=3, target=98):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_9",
    "sat": "def sat(squares: List[List[int]], m: int=31, n: int=7, target: int=216):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=31, n=7, target=216):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_10",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=46, target: int=138):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=46, target=138):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_11",
    "sat": "def sat(squares: List[List[int]], m: int=41, n: int=30, target: int=1230):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=30, target=1230):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_12",
    "sat": "def sat(squares: List[List[int]], m: int=2, n: int=40, target: int=80):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=2, n=40, target=80):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_13",
    "sat": "def sat(squares: List[List[int]], m: int=42, n: int=5, target: int=210):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=42, n=5, target=210):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_14",
    "sat": "def sat(squares: List[List[int]], m: int=4, n: int=43, target: int=172):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=4, n=43, target=172):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_15",
    "sat": "def sat(squares: List[List[int]], m: int=2, n: int=27, target: int=54):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=2, n=27, target=54):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_16",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=5, target: int=14):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=5, target=14):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_17",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=44, target: int=132):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=44, target=132):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_18",
    "sat": "def sat(squares: List[List[int]], m: int=34, n: int=28, target: int=952):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=34, n=28, target=952):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_19",
    "sat": "def sat(squares: List[List[int]], m: int=19, n: int=2, target: int=38):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=19, n=2, target=38):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_20",
    "sat": "def sat(squares: List[List[int]], m: int=35, n: int=34, target: int=1190):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=35, n=34, target=1190):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_21",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=21, target: int=692):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=21, target=692):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_22",
    "sat": "def sat(squares: List[List[int]], m: int=41, n: int=22, target: int=902):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=22, target=902):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_23",
    "sat": "def sat(squares: List[List[int]], m: int=23, n: int=48, target: int=1104):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=23, n=48, target=1104):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_24",
    "sat": "def sat(squares: List[List[int]], m: int=24, n: int=1, target: int=24):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=24, n=1, target=24):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_25",
    "sat": "def sat(squares: List[List[int]], m: int=39, n: int=22, target: int=858):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=39, n=22, target=858):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_26",
    "sat": "def sat(squares: List[List[int]], m: int=8, n: int=2, target: int=16):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=8, n=2, target=16):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_27",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=28, target: int=448):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=28, target=448):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_28",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=36, target: int=1692):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=36, target=1692):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_29",
    "sat": "def sat(squares: List[List[int]], m: int=11, n: int=25, target: int=274):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=11, n=25, target=274):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_30",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=2, target: int=12):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=2, target=12):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_31",
    "sat": "def sat(squares: List[List[int]], m: int=1, n: int=35, target: int=34):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=1, n=35, target=34):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_32",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=18, target: int=180):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=18, target=180):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_33",
    "sat": "def sat(squares: List[List[int]], m: int=2, n: int=29, target: int=58):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=2, n=29, target=58):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_34",
    "sat": "def sat(squares: List[List[int]], m: int=28, n: int=39, target: int=1092):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=28, n=39, target=1092):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_35",
    "sat": "def sat(squares: List[List[int]], m: int=28, n: int=16, target: int=448):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=28, n=16, target=448):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_36",
    "sat": "def sat(squares: List[List[int]], m: int=11, n: int=27, target: int=296):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=11, n=27, target=296):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_37",
    "sat": "def sat(squares: List[List[int]], m: int=24, n: int=29, target: int=696):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=24, n=29, target=696):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_38",
    "sat": "def sat(squares: List[List[int]], m: int=48, n: int=38, target: int=1824):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=48, n=38, target=1824):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_39",
    "sat": "def sat(squares: List[List[int]], m: int=29, n: int=25, target: int=724):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=29, n=25, target=724):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_40",
    "sat": "def sat(squares: List[List[int]], m: int=14, n: int=13, target: int=182):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=14, n=13, target=182):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_41",
    "sat": "def sat(squares: List[List[int]], m: int=21, n: int=22, target: int=462):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=21, n=22, target=462):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_42",
    "sat": "def sat(squares: List[List[int]], m: int=27, n: int=1, target: int=26):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=27, n=1, target=26):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_43",
    "sat": "def sat(squares: List[List[int]], m: int=46, n: int=49, target: int=2254):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=46, n=49, target=2254):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_44",
    "sat": "def sat(squares: List[List[int]], m: int=37, n: int=28, target: int=1036):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=37, n=28, target=1036):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_45",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=6, target: int=54):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=6, target=54):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_46",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=42, target: int=378):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=42, target=378):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_47",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=24, target: int=1128):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=24, target=1128):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_48",
    "sat": "def sat(squares: List[List[int]], m: int=39, n: int=9, target: int=350):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=39, n=9, target=350):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_49",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=2, target: int=66):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=2, target=66):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_50",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=4, target: int=40):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=4, target=40):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_51",
    "sat": "def sat(squares: List[List[int]], m: int=8, n: int=6, target: int=48):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=8, n=6, target=48):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_52",
    "sat": "def sat(squares: List[List[int]], m: int=14, n: int=17, target: int=238):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=14, n=17, target=238):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_53",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=16, target: int=752):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=16, target=752):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_54",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=43, target: int=258):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=43, target=258):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_55",
    "sat": "def sat(squares: List[List[int]], m: int=10, n: int=2, target: int=20):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=2, target=20):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_56",
    "sat": "def sat(squares: List[List[int]], m: int=44, n: int=6, target: int=264):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=44, n=6, target=264):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_57",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=9, target: int=80):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=9, target=80):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_58",
    "sat": "def sat(squares: List[List[int]], m: int=27, n: int=31, target: int=836):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=27, n=31, target=836):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_59",
    "sat": "def sat(squares: List[List[int]], m: int=43, n: int=29, target: int=1246):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=43, n=29, target=1246):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_60",
    "sat": "def sat(squares: List[List[int]], m: int=32, n: int=15, target: int=480):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=32, n=15, target=480):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_61",
    "sat": "def sat(squares: List[List[int]], m: int=5, n: int=25, target: int=124):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=5, n=25, target=124):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_62",
    "sat": "def sat(squares: List[List[int]], m: int=40, n: int=47, target: int=1880):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=40, n=47, target=1880):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_63",
    "sat": "def sat(squares: List[List[int]], m: int=21, n: int=45, target: int=944):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=21, n=45, target=944):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_64",
    "sat": "def sat(squares: List[List[int]], m: int=18, n: int=31, target: int=558):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=18, n=31, target=558):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_65",
    "sat": "def sat(squares: List[List[int]], m: int=12, n: int=33, target: int=396):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=12, n=33, target=396):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_66",
    "sat": "def sat(squares: List[List[int]], m: int=43, n: int=32, target: int=1376):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=43, n=32, target=1376):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_67",
    "sat": "def sat(squares: List[List[int]], m: int=44, n: int=9, target: int=396):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=44, n=9, target=396):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_68",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=47, target: int=140):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=47, target=140):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_69",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=1, target: int=2):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=1, target=2):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_70",
    "sat": "def sat(squares: List[List[int]], m: int=41, n: int=20, target: int=820):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=20, target=820):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_71",
    "sat": "def sat(squares: List[List[int]], m: int=38, n: int=33, target: int=1254):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=38, n=33, target=1254):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_72",
    "sat": "def sat(squares: List[List[int]], m: int=47, n: int=2, target: int=94):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=47, n=2, target=94):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_73",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=42, target: int=1386):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=42, target=1386):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_74",
    "sat": "def sat(squares: List[List[int]], m: int=6, n: int=5, target: int=30):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=6, n=5, target=30):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_75",
    "sat": "def sat(squares: List[List[int]], m: int=45, n: int=20, target: int=900):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=45, n=20, target=900):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_76",
    "sat": "def sat(squares: List[List[int]], m: int=17, n: int=31, target: int=526):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=17, n=31, target=526):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_77",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=14, target: int=224):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=14, target=224):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_78",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=40, target: int=640):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=40, target=640):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_79",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=3, target: int=48):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=3, target=48):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_80",
    "sat": "def sat(squares: List[List[int]], m: int=28, n: int=37, target: int=1036):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=28, n=37, target=1036):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_81",
    "sat": "def sat(squares: List[List[int]], m: int=23, n: int=43, target: int=988):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=23, n=43, target=988):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_82",
    "sat": "def sat(squares: List[List[int]], m: int=46, n: int=15, target: int=690):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=46, n=15, target=690):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_83",
    "sat": "def sat(squares: List[List[int]], m: int=15, n: int=25, target: int=374):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=15, n=25, target=374):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_84",
    "sat": "def sat(squares: List[List[int]], m: int=49, n: int=34, target: int=1666):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=49, n=34, target=1666):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_85",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=19, target: int=170):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=19, target=170):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_86",
    "sat": "def sat(squares: List[List[int]], m: int=38, n: int=47, target: int=1786):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=38, n=47, target=1786):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_87",
    "sat": "def sat(squares: List[List[int]], m: int=8, n: int=24, target: int=192):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=8, n=24, target=192):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_88",
    "sat": "def sat(squares: List[List[int]], m: int=9, n: int=8, target: int=72):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=9, n=8, target=72):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_89",
    "sat": "def sat(squares: List[List[int]], m: int=31, n: int=34, target: int=1054):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=31, n=34, target=1054):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_90",
    "sat": "def sat(squares: List[List[int]], m: int=16, n: int=1, target: int=16):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=16, n=1, target=16):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_91",
    "sat": "def sat(squares: List[List[int]], m: int=33, n: int=33, target: int=1088):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=33, n=33, target=1088):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_92",
    "sat": "def sat(squares: List[List[int]], m: int=19, n: int=3, target: int=56):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=19, n=3, target=56):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_93",
    "sat": "def sat(squares: List[List[int]], m: int=44, n: int=24, target: int=1056):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=44, n=24, target=1056):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_94",
    "sat": "def sat(squares: List[List[int]], m: int=24, n: int=13, target: int=312):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=24, n=13, target=312):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_95",
    "sat": "def sat(squares: List[List[int]], m: int=4, n: int=3, target: int=12):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=4, n=3, target=12):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_96",
    "sat": "def sat(squares: List[List[int]], m: int=21, n: int=11, target: int=230):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=21, n=11, target=230):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_97",
    "sat": "def sat(squares: List[List[int]], m: int=1, n: int=23, target: int=22):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=1, n=23, target=22):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_98",
    "sat": "def sat(squares: List[List[int]], m: int=26, n: int=13, target: int=338):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=26, n=13, target=338):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "DominoTile_99",
    "sat": "def sat(squares: List[List[int]], m: int=3, n: int=37, target: int=110):\n    assert type(squares) is list and all(type(a) is list and all(type(b) is int for b in a) for a in squares), 'squares must be of type List[List[int]]'\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=3, n=37, target=110):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ]
  },
  {
    "name": "IncDec_0",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x'], target: int=12):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x'], target=12):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_1",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x'], target: int=7416):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x'], target=7416):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_2",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--'], target: int=77865):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--'], target=77865):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_3",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x', 'x++'], target: int=8281):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x', 'x++'], target=8281):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_4",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x--'], target: int=95928):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x--'], target=95928):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_5",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', '++x', 'x++'], target: int=94413):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', '++x', 'x++'], target=94413):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_6",
    "sat": "def sat(n: int, ops: List[str]=['x++'], target: int=53804):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++'], target=53804):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_7",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', 'x++', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', '--x'], target: int=25224):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', 'x++', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', '--x'], target=25224):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_8",
    "sat": "def sat(n: int, ops: List[str]=['x++'], target: int=85446):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++'], target=85446):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_9",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x--'], target: int=82806):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x--'], target=82806):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_10",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x'], target: int=14977):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x'], target=14977):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_11",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', '--x', '++x', '++x', '--x'], target: int=96441):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', '--x', '++x', '++x', '--x'], target=96441):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_12",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', '++x', 'x--'], target: int=17387):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', '++x', 'x--'], target=17387):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_13",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '++x'], target: int=22109):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '++x'], target=22109):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_14",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x--', '++x'], target: int=77271):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x--', '++x'], target=77271):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_15",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--'], target: int=52997):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--'], target=52997):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_16",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x'], target: int=76065):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x'], target=76065):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_17",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--'], target: int=40964):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--'], target=40964):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_18",
    "sat": "def sat(n: int, ops: List[str]=['++x'], target: int=97753):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x'], target=97753):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_19",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', 'x--'], target: int=75063):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', 'x--'], target=75063):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_20",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x'], target: int=61835):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x'], target=61835):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_21",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--'], target: int=43959):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--'], target=43959):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_22",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--'], target: int=3345):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--'], target=3345):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_23",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++'], target: int=20286):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++'], target=20286):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_24",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++'], target: int=84438):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x--', 'x++'], target=84438):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_25",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++'], target: int=41260):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++'], target=41260):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_26",
    "sat": "def sat(n: int, ops: List[str]=['--x'], target: int=52217):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x'], target=52217):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_27",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '--x', '--x', '++x', 'x--', '--x', '--x'], target: int=87904):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '--x', '--x', '++x', 'x--', '--x', '--x'], target=87904):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_28",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x'], target: int=37939):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x'], target=37939):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_29",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x--'], target: int=93512):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', '++x', '--x', '++x', '++x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x--'], target=93512):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_30",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x'], target: int=38343):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x++', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x'], target=38343):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_31",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x'], target: int=23531):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x'], target=23531):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_32",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=74003):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=74003):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_33",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x'], target: int=3324):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x'], target=3324):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_34",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++'], target: int=7824):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++'], target=7824):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_35",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++'], target: int=97791):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++'], target=97791):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_36",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '++x'], target: int=29930):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '++x'], target=29930):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_37",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x--'], target: int=58294):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x--'], target=58294):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_38",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++'], target: int=35414):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++'], target=35414):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_39",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', '++x', 'x--', '++x', '++x', '++x'], target: int=54587):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', '++x', 'x--', '++x', '++x', '++x'], target=54587):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_40",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '++x', '--x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--'], target: int=4263):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '++x', '--x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--'], target=4263):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_41",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++'], target: int=81876):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x--', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++'], target=81876):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_42",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '--x', '++x', '--x', '--x', '++x', '--x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++'], target: int=50138):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '++x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '++x', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '--x', '++x', '--x', '--x', '++x', '--x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++'], target=50138):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_43",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', 'x--', '++x', 'x--', '--x', 'x--'], target: int=99606):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', 'x--', '++x', 'x--', '--x', 'x--'], target=99606):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_44",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', '++x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--'], target: int=40167):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', '++x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', '--x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--'], target=40167):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_45",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', '--x', '++x'], target: int=82471):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', '--x', '++x'], target=82471):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_46",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x'], target: int=63915):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x'], target=63915):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_47",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x++', '--x', 'x++', '--x', '--x'], target: int=76690):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x++', '--x', 'x++', '--x', '--x'], target=76690):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_48",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=55603):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=55603):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_49",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x++', '--x'], target: int=9771):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x++', '--x'], target=9771):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_50",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x'], target: int=95079):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', 'x++', '++x', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', '--x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x'], target=95079):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_51",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=68839):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=68839):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_52",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x'], target: int=97948):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x'], target=97948):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_53",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x--'], target: int=26237):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x--'], target=26237):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_54",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x--'], target: int=14502):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '--x', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x--', 'x++', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', '--x', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', '--x', '++x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x--'], target=14502):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_55",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '++x', 'x++', 'x--', '--x'], target: int=28444):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '++x', 'x++', 'x--', '--x'], target=28444):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_56",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', 'x--', 'x--', '++x'], target: int=68328):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', 'x--', 'x--', '++x'], target=68328):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_57",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x', '--x'], target: int=46849):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x', '--x'], target=46849):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_58",
    "sat": "def sat(n: int, ops: List[str]=['++x'], target: int=85114):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x'], target=85114):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_59",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++'], target: int=85076):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++'], target=85076):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_60",
    "sat": "def sat(n: int, ops: List[str]=['x--', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--'], target: int=22581):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--'], target=22581):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_61",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x'], target: int=95564):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x'], target=95564):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_62",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x'], target: int=77175):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '--x', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '++x', '++x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', '++x'], target=77175):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_63",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--'], target: int=18398):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x--', '++x', '++x', '++x', '--x', '++x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x--', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', '++x', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--'], target=18398):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_64",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x'], target: int=28931):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', '--x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x'], target=28931):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_65",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x++'], target: int=65817):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', '++x', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', '--x', '++x', '--x', '--x', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x++'], target=65817):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_66",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++'], target: int=15349):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '++x', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '--x', '++x', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x++', 'x++', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', 'x++', 'x++'], target=15349):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_67",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', 'x++'], target: int=636):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', 'x++'], target=636):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_68",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x'], target: int=96574):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x'], target=96574):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_69",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', '++x', '--x', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++'], target: int=46004):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '--x', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', '++x', '--x', 'x--', '++x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x++'], target=46004):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_70",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x'], target: int=99410):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '++x', '--x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x--', '--x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x'], target=99410):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_71",
    "sat": "def sat(n: int, ops: List[str]=['x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', '--x'], target: int=81750):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', '--x', '--x', 'x++', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x++', '--x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', '--x', '--x', '++x', '++x', '++x', '--x', '++x', '++x', '--x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', '--x', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', '--x', '++x', 'x++', '++x', '--x'], target=81750):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_72",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x'], target: int=14265):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x'], target=14265):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_73",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', 'x++'], target: int=89669):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', '--x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', '--x', 'x--', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x--', '--x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', '++x', '--x', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', '--x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', '++x', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x++', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', '--x', '--x', '++x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x--', '--x', '++x', '--x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '++x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x++', '++x', 'x++'], target=89669):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_74",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++'], target: int=51499):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', '--x', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', 'x--', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x--', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x--', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '--x', 'x++'], target=51499):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_75",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '--x', 'x++', 'x--'], target: int=38877):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '--x', 'x++', 'x--'], target=38877):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_76",
    "sat": "def sat(n: int, ops: List[str]=['++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x'], target: int=73905):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '--x'], target=73905):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_77",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=32706):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=32706):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_78",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--'], target: int=36903):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x--', 'x++', '--x', '++x', '--x', '--x', '++x', 'x++', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', '--x', '++x', '--x', '--x', '--x', 'x--', '++x', '++x', 'x--', '++x', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', '--x', 'x++', '--x', '--x', 'x++', 'x--', '--x', '++x', '++x', '--x', '++x', 'x++', 'x++', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '++x', '++x', '++x', '--x', 'x++', '--x', '++x', '++x', 'x--', '--x', '++x', 'x--', 'x++', '++x', '--x', '++x', 'x++', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '++x', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '++x', '++x', '++x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '--x', '++x', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x++', '++x', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x++', '--x', '++x', 'x--', '++x', '++x', 'x--', '--x', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x--'], target=36903):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_79",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x'], target: int=21):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x--', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '--x', 'x++', 'x--', 'x++', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', '++x', '--x', '++x', '++x', '++x', '++x', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '--x', '++x', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', '--x', '++x', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '++x', '--x', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', '--x', 'x--', 'x--', '++x', '--x', '++x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x'], target=21):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_80",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--'], target: int=37479):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x++', 'x++', 'x--', 'x++', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', 'x--', '--x', '--x', 'x++', '--x', '++x', '--x', 'x++', '--x', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '++x', '--x', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '--x', 'x--', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', 'x++', '--x', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', 'x++', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', '--x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', 'x++', '--x', '++x', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', 'x--'], target=37479):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_81",
    "sat": "def sat(n: int, ops: List[str]=['++x', '--x', '++x', '--x'], target: int=26155):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '--x', '++x', '--x'], target=26155):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_82",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x'], target: int=68747):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '++x', '++x', '--x', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', '++x', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '++x'], target=68747):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_83",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x'], target: int=36031):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x++', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '++x', '++x', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', '++x', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', '--x', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', '--x', 'x++', '++x', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x++', '++x', '++x', 'x--', '++x', '++x', '--x', '--x', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', '++x', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '--x'], target=36031):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_84",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', 'x++', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', 'x++', '--x'], target: int=29267):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', 'x++', 'x--', '++x', '--x', 'x--', '++x', '--x', 'x++', 'x++', '++x', '++x', 'x++', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', '++x', '++x', '++x', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', 'x--', '++x', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '++x', '--x', '++x', 'x--', 'x++', '--x'], target=29267):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_85",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x'], target: int=78016):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '--x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '++x', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '--x', 'x++', 'x--', '++x', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', 'x++', '++x', '--x', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', '--x'], target=78016):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_86",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++'], target: int=48606):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', '--x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', '++x', 'x++', '--x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x--', '++x', 'x++', '++x', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x--', '++x', 'x--', '++x', '--x', '++x', 'x++', '++x', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', 'x++', '++x', '--x', '--x', 'x--', '++x', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', 'x--', '--x', '--x', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '--x', 'x--', 'x++', '--x', '--x', '--x', '--x', '--x', 'x--', '++x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x++', '--x', 'x++', 'x++', '++x', '--x', 'x++', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', 'x++', 'x++', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '--x', '--x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', '--x', '++x', '++x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '--x', '++x', '++x', '--x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', 'x++', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', '--x', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', '--x', 'x++', 'x--', '--x', '++x', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x--', 'x--', '--x', 'x++', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', '++x', '++x', '++x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', 'x--', 'x++', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', '--x', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', '--x', '--x', '--x', 'x--', '--x', 'x--', 'x--', '--x', 'x++', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', '++x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', '--x', '--x', 'x++', '++x', '++x', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', 'x++', '++x', 'x++', 'x--', '--x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x--', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', '++x', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x--', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', '--x', '++x', 'x++', 'x++', '--x', 'x--', '--x', '++x', '--x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '--x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '--x', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', 'x--', 'x++', '--x', '++x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '++x', '++x', '--x', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', 'x--', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x++', '--x', '--x', 'x++'], target=48606):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_87",
    "sat": "def sat(n: int, ops: List[str]=['x--'], target: int=69826):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--'], target=69826):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_88",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', 'x++', '--x', '--x', '++x'], target: int=39621):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', 'x++', '--x', '--x', '++x'], target=39621):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_89",
    "sat": "def sat(n: int, ops: List[str]=['--x', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '++x', 'x++', 'x--', '++x', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', 'x++'], target: int=35255):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', '--x', '--x', '++x', '++x', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '--x', '--x', '++x', '--x', 'x++', '++x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', '++x', 'x--', '--x', '--x', '++x', 'x++', 'x--', '++x', '++x', '--x', '++x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', '--x', '--x', '++x', '++x', '--x', '++x', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', '--x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', '--x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '++x', 'x--', '++x', 'x--', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x++', '--x', '--x', '--x', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x--', '++x', 'x++', '++x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '++x', 'x--', 'x--', '--x', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '++x', '--x', 'x--', '--x', '++x', '--x', '++x', 'x--', 'x--', '--x', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', 'x++', 'x++'], target=35255):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_90",
    "sat": "def sat(n: int, ops: List[str]=['x++', '++x'], target: int=45283):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '++x'], target=45283):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_91",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x--'], target: int=86386):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', '++x', 'x--', '--x', '++x', '++x', '++x', '++x', 'x--', '--x', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x--'], target=86386):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_92",
    "sat": "def sat(n: int, ops: List[str]=['++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', '--x'], target: int=82017):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x++', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x++', '--x', 'x++', 'x++', '--x', '--x', '--x', '++x', 'x--', '++x', '--x', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', '++x', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', '--x'], target=82017):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_93",
    "sat": "def sat(n: int, ops: List[str]=['x--', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x'], target: int=64476):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', '++x', '--x', 'x--', '++x', '--x', 'x++', '++x'], target=64476):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_94",
    "sat": "def sat(n: int, ops: List[str]=['--x', 'x--', '--x', 'x++', '++x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++'], target: int=78478):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '--x', 'x++', '++x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x++', 'x--', '++x', 'x++', '++x', '--x', '++x', '--x', '--x', 'x--', '--x', 'x++', '--x', '++x', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', '--x', '--x', '++x', '++x', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '--x', 'x++', 'x++', '--x', 'x++', 'x++', '++x', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '++x', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', 'x++'], target=78478):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_95",
    "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x'], target: int=6996):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x', '--x', 'x--', 'x--', 'x--', '--x'], target=6996):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_96",
    "sat": "def sat(n: int, ops: List[str]=['--x', '++x'], target: int=95952):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '++x'], target=95952):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_97",
    "sat": "def sat(n: int, ops: List[str]=[], target: int=15387):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=[], target=15387):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_98",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x++'], target: int=27383):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x++'], target=27383):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "IncDec_99",
    "sat": "def sat(n: int, ops: List[str]=['x++', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++'], target: int=28639):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', '--x', 'x++', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '--x', 'x--', '++x', '++x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', 'x++', '--x', '++x', '++x', 'x--', '--x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '++x', 'x++', '++x', 'x++', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', '--x', '--x', '--x', '--x', 'x++'], target=28639):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ]
  },
  {
    "name": "CompareInAnyCase_0",
    "sat": "def sat(n: int, s: str=\"aaAab\", t: str=\"aAaaB\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"aaAab\", t=\"aAaaB\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_1",
    "sat": "def sat(n: int, s: str=\"COXANIxyropY\", t: str=\"cOXANixYrOpYVoFOREcHiParuKEb\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"COXANIxyropY\", t=\"cOXANixYrOpYVoFOREcHiParuKEb\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_2",
    "sat": "def sat(n: int, s: str=\"HUtuQuOWelYHEToMUHob\", t: str=\"HutuquoquobaJiXuc\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"HUtuQuOWelYHEToMUHob\", t=\"HutuquoquobaJiXuc\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_3",
    "sat": "def sat(n: int, s: str=\"tEXtUtE\", t: str=\"TeXjeX\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"tEXtUtE\", t=\"TeXjeX\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_4",
    "sat": "def sat(n: int, s: str=\"C\", t: str=\"Suh\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"C\", t=\"Suh\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_5",
    "sat": "def sat(n: int, s: str=\"lakyLiBEsU\", t: str=\"HYhODYNUtHuCHUrOsU\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"lakyLiBEsU\", t=\"HYhODYNUtHuCHUrOsU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_6",
    "sat": "def sat(n: int, s: str=\"vYRopyXUReTIs\", t: str=\"VyropYxUrETIS\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"vYRopyXUReTIs\", t=\"VyropYxUrETIS\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_7",
    "sat": "def sat(n: int, s: str=\"JYsIG\", t: str=\"HepulokOL\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JYsIG\", t=\"HepulokOL\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_8",
    "sat": "def sat(n: int, s: str=\"PESOTeXTEVar\", t: str=\"PESOteXtEVar\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"PESOTeXTEVar\", t=\"PESOteXtEVar\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_9",
    "sat": "def sat(n: int, s: str=\"chIGEmYlAzULEquuGydI\", t: str=\"CneC\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"chIGEmYlAzULEquuGydI\", t=\"CneC\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_10",
    "sat": "def sat(n: int, s: str=\"XaCYgAXequY\", t: str=\"XaCyGaxnEFiru\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"XaCYgAXequY\", t=\"XaCyGaxnEFiru\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_11",
    "sat": "def sat(n: int, s: str=\"CuPIxAJihAsukyQue\", t: str=\"CUpIXnYCIjIhyLaLOKAm\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CuPIxAJihAsukyQue\", t=\"CUpIXnYCIjIhyLaLOKAm\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_12",
    "sat": "def sat(n: int, s: str=\"v\", t: str=\"HegaKECIvavuthAtyz\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"v\", t=\"HegaKECIvavuthAtyz\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_13",
    "sat": "def sat(n: int, s: str=\"TURecigAC\", t: str=\"TURRUChufy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TURecigAC\", t=\"TURRUChufy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_14",
    "sat": "def sat(n: int, s: str=\"sYkUMAmici\", t: str=\"SyKxiWoq\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"sYkUMAmici\", t=\"SyKxiWoq\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_15",
    "sat": "def sat(n: int, s: str=\"was\", t: str=\"WAs\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"was\", t=\"WAs\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_16",
    "sat": "def sat(n: int, s: str=\"Z\", t: str=\"wYvYTARIcafaNaxoxID\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Z\", t=\"wYvYTARIcafaNaxoxID\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_17",
    "sat": "def sat(n: int, s: str=\"TY\", t: str=\"TdisAtEXTYFaM\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TY\", t=\"TdisAtEXTYFaM\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_18",
    "sat": "def sat(n: int, s: str=\"Je\", t: str=\"JEDAfaTExTyPIp\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Je\", t=\"JEDAfaTExTyPIp\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_19",
    "sat": "def sat(n: int, s: str=\"mOSEzuLyTHIXa\", t: str=\"MosjYCadeXaKEfesuGISy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mOSEzuLyTHIXa\", t=\"MosjYCadeXaKEfesuGISy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_20",
    "sat": "def sat(n: int, s: str=\"DyKIMUVoLewuGeM\", t: str=\"DYkImuVolEjatExtiwuCADErEQu\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"DyKIMUVoLewuGeM\", t=\"DYkImuVolEjatExtiwuCADErEQu\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_21",
    "sat": "def sat(n: int, s: str=\"HAquU\", t: str=\"haQUuGuXIkEjYpaf\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"HAquU\", t=\"haQUuGuXIkEjYpaf\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_22",
    "sat": "def sat(n: int, s: str=\"pezaNIZyqueTypI\", t: str=\"pezANIZyquECHOtExTEFivaTHytiJIN\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"pezaNIZyqueTypI\", t=\"pezANIZyquECHOtExTEFivaTHytiJIN\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_23",
    "sat": "def sat(n: int, s: str=\"TeXtypicETUtHuNA\", t: str=\"TeXtxAtySYZod\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TeXtypicETUtHuNA\", t=\"TeXtxAtySYZod\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_24",
    "sat": "def sat(n: int, s: str=\"RUROq\", t: str=\"wyJetE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"RUROq\", t=\"wyJetE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_25",
    "sat": "def sat(n: int, s: str=\"zoWIKACHOteXTo\", t: str=\"zpeLEGAVE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"zoWIKACHOteXTo\", t=\"zpeLEGAVE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_26",
    "sat": "def sat(n: int, s: str=\"DOpakiKujiChyDYlUlyS\", t: str=\"DOPaKiKujIChyDYlUlYsXeteXtUsEBy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"DOpakiKujiChyDYlUlyS\", t=\"DOPaKiKujIChyDYlUlYsXeteXtUsEBy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_27",
    "sat": "def sat(n: int, s: str=\"rAfoCimUtywYKUGyTH\", t: str=\"rAFOCimutYWyKUGyTH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"rAfoCimUtywYKUGyTH\", t=\"rAFOCimutYWyKUGyTH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_28",
    "sat": "def sat(n: int, s: str=\"CEdEhEgORiQUeChy\", t: str=\"ceDwUcHIJOpyXUDe\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CEdEhEgORiQUeChy\", t=\"ceDwUcHIJOpyXUDe\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_29",
    "sat": "def sat(n: int, s: str=\"cH\", t: str=\"CfUrEjo\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"cH\", t=\"CfUrEjo\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_30",
    "sat": "def sat(n: int, s: str=\"WUGivITE\", t: str=\"WUgIViXukiC\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"WUGivITE\", t=\"WUgIViXukiC\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_31",
    "sat": "def sat(n: int, s: str=\"cigOTexT\", t: str=\"ciGOtext\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"cigOTexT\", t=\"ciGOtext\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_32",
    "sat": "def sat(n: int, s: str=\"ruDuPuCHIchi\", t: str=\"rudUPuCkecARy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"ruDuPuCHIchi\", t=\"rudUPuCkecARy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_33",
    "sat": "def sat(n: int, s: str=\"goDuFiCAxOga\", t: str=\"godUFKYGENaxOZOLoTex\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"goDuFiCAxOga\", t=\"godUFKYGENaxOZOLoTex\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_34",
    "sat": "def sat(n: int, s: str=\"bybyHIHybONesUBySIr\", t: str=\"BybyhIHYBoNesuTuCUqUOrIcHuvOnot\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"bybyHIHybONesUBySIr\", t=\"BybyhIHYBoNesuTuCUqUOrIcHuvOnot\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_35",
    "sat": "def sat(n: int, s: str=\"FUL\", t: str=\"fULtukIBYzidydifAVo\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"FUL\", t=\"fULtukIBYzidydifAVo\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_36",
    "sat": "def sat(n: int, s: str=\"kabOcANuweWolATIj\", t: str=\"KAtYQ\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"kabOcANuweWolATIj\", t=\"KAtYQ\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_37",
    "sat": "def sat(n: int, s: str=\"laTos\", t: str=\"law\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"laTos\", t=\"law\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_38",
    "sat": "def sat(n: int, s: str=\"hudoGIquUchA\", t: str=\"hUdOGIqUuchA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hudoGIquUchA\", t=\"hUdOGIqUuchA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_39",
    "sat": "def sat(n: int, s: str=\"JODExEDaNekECho\", t: str=\"JOdeXeDAnEkeCdyDAbUTIFychY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JODExEDaNekECho\", t=\"JOdeXeDAnEkeCdyDAbUTIFychY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_40",
    "sat": "def sat(n: int, s: str=\"GezATeN\", t: str=\"geZATeN\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"GezATeN\", t=\"geZATeN\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_41",
    "sat": "def sat(n: int, s: str=\"hEWymUsILIXO\", t: str=\"hewymcExIfOlOgOWePABEhU\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hEWymUsILIXO\", t=\"hewymcExIfOlOgOWePABEhU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_42",
    "sat": "def sat(n: int, s: str=\"FYsycE\", t: str=\"fYSYce\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"FYsycE\", t=\"fYSYce\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_43",
    "sat": "def sat(n: int, s: str=\"TeXTefyZatEx\", t: str=\"TDOchApYWIgOtextY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TeXTefyZatEx\", t=\"TDOchApYWIgOtextY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_44",
    "sat": "def sat(n: int, s: str=\"mYvETE\", t: str=\"MyVetE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mYvETE\", t=\"MyVetE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_45",
    "sat": "def sat(n: int, s: str=\"LefYw\", t: str=\"leFYWfanutHAcAb\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"LefYw\", t=\"leFYWfanutHAcAb\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_46",
    "sat": "def sat(n: int, s: str=\"Fo\", t: str=\"CiTulAPOsI\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Fo\", t=\"CiTulAPOsI\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_47",
    "sat": "def sat(n: int, s: str=\"tarInA\", t: str=\"taCIlyfyQuA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"tarInA\", t=\"taCIlyfyQuA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_48",
    "sat": "def sat(n: int, s: str=\"hyLuhacezYFEJUV\", t: str=\"HyLuHACEzYfEjuv\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hyLuhacezYFEJUV\", t=\"HyLuHACEzYfEjuv\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_49",
    "sat": "def sat(n: int, s: str=\"vYmIPEWIJi\", t: str=\"vYmkeRoZA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"vYmIPEWIJi\", t=\"vYmkeRoZA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_50",
    "sat": "def sat(n: int, s: str=\"SuchiGAChEKOGapoN\", t: str=\"SuChigje\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"SuchiGAChEKOGapoN\", t=\"SuChigje\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_51",
    "sat": "def sat(n: int, s: str=\"tOxeJoC\", t: str=\"la\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"tOxeJoC\", t=\"la\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_52",
    "sat": "def sat(n: int, s: str=\"zufoJArujyp\", t: str=\"ZMeramiMyd\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"zufoJArujyp\", t=\"ZMeramiMyd\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_53",
    "sat": "def sat(n: int, s: str=\"thIMuquIpaV\", t: str=\"tHiMUQUIPafaTHitHeSoRiWYtEXt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"thIMuquIpaV\", t=\"tHiMUQUIPafaTHitHeSoRiWYtEXt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_54",
    "sat": "def sat(n: int, s: str=\"PIgy\", t: str=\"deThErECuREFEQUARiXI\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"PIgy\", t=\"deThErECuREFEQUARiXI\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_55",
    "sat": "def sat(n: int, s: str=\"DOnAquYWYfACiG\", t: str=\"DOnAQuyWYFaCiG\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"DOnAquYWYfACiG\", t=\"DOnAQuyWYFaCiG\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_56",
    "sat": "def sat(n: int, s: str=\"W\", t: str=\"hEGy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"W\", t=\"hEGy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_57",
    "sat": "def sat(n: int, s: str=\"hi\", t: str=\"HbikuHawaL\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hi\", t=\"HbikuHawaL\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_58",
    "sat": "def sat(n: int, s: str=\"divELAtEXTo\", t: str=\"dwelitExtaVicac\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"divELAtEXTo\", t=\"dwelitExtaVicac\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_59",
    "sat": "def sat(n: int, s: str=\"JItiHI\", t: str=\"cYcalUcH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JItiHI\", t=\"cYcalUcH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_60",
    "sat": "def sat(n: int, s: str=\"lAzusALOriCU\", t: str=\"laZUsAlORiCwIVUtEXtY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"lAzusALOriCU\", t=\"laZUsAlORiCwIVUtEXtY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_61",
    "sat": "def sat(n: int, s: str=\"jichygOwYTeXtE\", t: str=\"jichYgowyTexTE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"jichygOwYTeXtE\", t=\"jichYgowyTexTE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_62",
    "sat": "def sat(n: int, s: str=\"JER\", t: str=\"RIChAdYWiT\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"JER\", t=\"RIChAdYWiT\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_63",
    "sat": "def sat(n: int, s: str=\"b\", t: str=\"hoTAzuCHYZUTH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"b\", t=\"hoTAzuCHYZUTH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_64",
    "sat": "def sat(n: int, s: str=\"SOgOQUEwykEX\", t: str=\"soGoQueWykeX\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"SOgOQUEwykEX\", t=\"soGoQueWykeX\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_65",
    "sat": "def sat(n: int, s: str=\"TEx\", t: str=\"TExmIte\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TEx\", t=\"TExmIte\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_66",
    "sat": "def sat(n: int, s: str=\"MUCAcHAMeMUwytUD\", t: str=\"MucacHaMeMUwYtula\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"MUCAcHAMeMUwytUD\", t=\"MucacHaMeMUwYtula\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_67",
    "sat": "def sat(n: int, s: str=\"moKASyRUSaWylaTHeT\", t: str=\"MOkASyrUSAWyLAThEt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"moKASyRUSaWylaTHeT\", t=\"MOkASyrUSAWyLAThEt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_68",
    "sat": "def sat(n: int, s: str=\"qUAJoTextyHogAQ\", t: str=\"quajOTeXTYKImOje\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"qUAJoTextyHogAQ\", t=\"quajOTeXTYKImOje\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_69",
    "sat": "def sat(n: int, s: str=\"jepyzul\", t: str=\"jepyZv\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"jepyzul\", t=\"jepyZv\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_70",
    "sat": "def sat(n: int, s: str=\"k\", t: str=\"QuasuMaSanahowy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"k\", t=\"QuasuMaSanahowy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_71",
    "sat": "def sat(n: int, s: str=\"RANiFYtHUTHONAmirOpO\", t: str=\"RAnifYtHuthTHYhAquiSeceTHEThu\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"RANiFYtHUTHONAmirOpO\", t=\"RAnifYtHuthTHYhAquiSeceTHEThu\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_72",
    "sat": "def sat(n: int, s: str=\"Jut\", t: str=\"JUt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"Jut\", t=\"JUt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_73",
    "sat": "def sat(n: int, s: str=\"MubuHADEL\", t: str=\"hEx\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"MubuHADEL\", t=\"hEx\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_74",
    "sat": "def sat(n: int, s: str=\"QuyQUETeXtociVEKulO\", t: str=\"QuYQUEtExtCHegExEtIpachoqUITE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"QuyQUETeXtociVEKulO\", t=\"QuYQUEtExtCHegExEtIpachoqUITE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_75",
    "sat": "def sat(n: int, s: str=\"MOLAnyrYtexTEjyM\", t: str=\"w\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"MOLAnyrYtexTEjyM\", t=\"w\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_76",
    "sat": "def sat(n: int, s: str=\"ChaSUvaRECHyBeNu\", t: str=\"chAsUvarechybeTEXtICHOwyjuJE\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"ChaSUvaRECHyBeNu\", t=\"chAsUvarechybeTEXtICHOwyjuJE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_77",
    "sat": "def sat(n: int, s: str=\"pEkITyXYH\", t: str=\"ToDyDoxIthavez\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"pEkITyXYH\", t=\"ToDyDoxIthavez\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_78",
    "sat": "def sat(n: int, s: str=\"mOM\", t: str=\"mtextYhIlaXInA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mOM\", t=\"mtextYhIlaXInA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_79",
    "sat": "def sat(n: int, s: str=\"RIvIjO\", t: str=\"rthirIvokaXoB\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"RIvIjO\", t=\"rthirIvokaXoB\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_80",
    "sat": "def sat(n: int, s: str=\"VydAkychiZyjEbekaL\", t: str=\"vyDAKychizYjEbeHERy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"VydAkychiZyjEbekaL\", t=\"vyDAKychizYjEbeHERy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_81",
    "sat": "def sat(n: int, s: str=\"xydav\", t: str=\"XyDAV\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"xydav\", t=\"XyDAV\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_82",
    "sat": "def sat(n: int, s: str=\"QU\", t: str=\"QJY\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"QU\", t=\"QJY\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_83",
    "sat": "def sat(n: int, s: str=\"CHApINYByzYtoGij\", t: str=\"cHAPINYByzYTOgIj\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CHApINYByzYtoGij\", t=\"cHAPINYByzYTOgIj\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_84",
    "sat": "def sat(n: int, s: str=\"LuTEX\", t: str=\"LuTENEzYVyteXtYfachErORa\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"LuTEX\", t=\"LuTENEzYVyteXtYfachErORa\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_85",
    "sat": "def sat(n: int, s: str=\"falyFUxodOcHachOfoCh\", t: str=\"falyfuxOdoCHAchofoCH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"falyFUxodOcHachOfoCh\", t=\"falyfuxOdoCHAchofoCH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_86",
    "sat": "def sat(n: int, s: str=\"cyxeKUThOTHIQuyBUT\", t: str=\"CYxEKUtHcyGUNUt\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"cyxeKUThOTHIQuyBUT\", t=\"CYxEKUtHcyGUNUt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_87",
    "sat": "def sat(n: int, s: str=\"vERisuGeCYZUsEcHEze\", t: str=\"verisuGEcyZuFeR\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"vERisuGeCYZUsEcHEze\", t=\"verisuGEcyZuFeR\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_88",
    "sat": "def sat(n: int, s: str=\"CIFekiGucHO\", t: str=\"gUg\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"CIFekiGucHO\", t=\"gUg\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_89",
    "sat": "def sat(n: int, s: str=\"hEvULEp\", t: str=\"HEvulWatex\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"hEvULEp\", t=\"HEvulWatex\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_90",
    "sat": "def sat(n: int, s: str=\"maGUMug\", t: str=\"manuchoZORyjUFYvyVoGU\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"maGUMug\", t=\"manuchoZORyjUFYvyVoGU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_91",
    "sat": "def sat(n: int, s: str=\"NelUhETh\", t: str=\"nELUHetTextOpOCH\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"NelUhETh\", t=\"nELUHetTextOpOCH\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_92",
    "sat": "def sat(n: int, s: str=\"KIrutYCheHyChijIT\", t: str=\"KiRuTycHeHyCHIJIZoSUtHYDirA\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"KIrutYCheHyChijIT\", t=\"KiRuTycHeHyCHIJIZoSUtHYDirA\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_93",
    "sat": "def sat(n: int, s: str=\"fawiKOMyT\", t: str=\"FaSiSyS\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"fawiKOMyT\", t=\"FaSiSyS\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_94",
    "sat": "def sat(n: int, s: str=\"TOmANYGYCAtHaRafIQU\", t: str=\"TomAN\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TOmANYGYCAtHaRafIQU\", t=\"TomAN\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_95",
    "sat": "def sat(n: int, s: str=\"LUtEX\", t: str=\"LuTEX\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"LUtEX\", t=\"LuTEX\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_96",
    "sat": "def sat(n: int, s: str=\"FEsepUTHUkePOdeNUFAg\", t: str=\"feSEhiCHOTHEdOz\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"FEsepUTHUkePOdeNUFAg\", t=\"feSEhiCHOTHEdOz\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_97",
    "sat": "def sat(n: int, s: str=\"N\", t: str=\"njaRaNYthyVeJuk\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"N\", t=\"njaRaNYthyVeJuk\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_98",
    "sat": "def sat(n: int, s: str=\"TUWYnen\", t: str=\"tuwynEn\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"TUWYnen\", t=\"tuwynEn\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "CompareInAnyCase_99",
    "sat": "def sat(n: int, s: str=\"mesy\", t: str=\"mesy\"):\n    assert type(n) is int, 'n must be of type int'\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"mesy\", t=\"mesy\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ]
  },
  {
    "name": "SlidingOne_0",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_1",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_2",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_3",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_4",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_5",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_6",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_7",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_8",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_9",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_10",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_11",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_12",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=0):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=0):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_13",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_14",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_15",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_16",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_17",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=1):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_18",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_19",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_20",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_21",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_22",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]], max_moves: int=2):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_23",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SlidingOne_24",
    "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]], max_moves: int=4):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ]
  },
  {
    "name": "SortPlusPlus_0",
    "sat": "def sat(s: str, inp: str=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_1",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+2+3+2+2+3+3+2+3+2+1+3+2+2+1+3+1+1+1+1+2+1+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+2+3+2+2+3+3+2+3+2+1+3+2+2+1+3+1+1+1+1+2+1+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_2",
    "sat": "def sat(s: str, inp: str=\"3+3+3+2+2+1+1+1+1+2+2+2+3+3+3+2+3+2+2+3+1+1+3+3+2+3+3+3+1+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+2+2+1+1+1+1+2+2+2+3+3+3+2+3+2+2+3+1+1+3+3+2+3+3+3+1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_3",
    "sat": "def sat(s: str, inp: str=\"2+3+2+3+2+2+1+3+3+3+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+2+3+2+2+1+3+3+3+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_4",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+2+2+2+3+2+2+3+1+1+3+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+2+2+2+3+2+2+3+1+1+3+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_5",
    "sat": "def sat(s: str, inp: str=\"3+3+2+3+2+3+2+2+3+3+3+3+1+3+3+2+2+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+3+2+3+2+2+3+3+3+3+1+3+3+2+2+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_6",
    "sat": "def sat(s: str, inp: str=\"2+3+3+2+3+1+1+3+3+2+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+3+2+3+1+1+3+3+2+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_7",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+1+1+1+1+2+3+2+1+3+1+1+3+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+1+1+1+1+2+3+2+1+3+1+1+3+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_8",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+3+2+1+3+3+3+2+1+2+1+1+2+1+3+1+2+3+1+1+1+2+1+2+3+2+1+1+3+1+2+2+1+2+3+2+2+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+3+2+1+3+3+3+2+1+2+1+1+2+1+3+1+2+3+1+1+1+2+1+2+3+2+1+1+3+1+2+2+1+2+3+2+2+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_9",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+3+3+1+2+1+3+2+3+1+3+3+2+2+2+1+3+3+2+2+2+2+1+2+3+3+3+2+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+3+3+1+2+1+3+2+3+1+3+3+2+2+2+1+3+3+2+2+2+2+1+2+3+3+3+2+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_10",
    "sat": "def sat(s: str, inp: str=\"3+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_11",
    "sat": "def sat(s: str, inp: str=\"1+2+2+3+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+3+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_12",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+1+2+2+2+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+1+2+2+2+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_13",
    "sat": "def sat(s: str, inp: str=\"3+1+2+1+1+1+2+1+3+2+1+3+1+2+3+2+2+2+3+1+2+3+2+1+2+1+2+1+3+2+3+2+3+1+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+1+1+1+2+1+3+2+1+3+1+2+3+2+2+2+3+1+2+3+2+1+2+1+2+1+3+2+3+2+3+1+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_14",
    "sat": "def sat(s: str, inp: str=\"3+3+3+1+2+1+2+3+2+2+1+3+1+2+2+3+2+3+3+2+1+2+3+3+1+2+3+1+2+1+1+1+3+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+1+2+1+2+3+2+2+1+3+1+2+2+3+2+3+3+2+1+2+3+3+1+2+3+1+2+1+1+1+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_15",
    "sat": "def sat(s: str, inp: str=\"1+3+2+1+3+1+1+3+2+1+2+2+1+1+2+2+1+2+3+3+1+2+3+3+2+3+2+1+2+2+2+3+1+2+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+1+3+1+1+3+2+1+2+2+1+1+2+2+1+2+3+3+1+2+3+3+2+3+2+1+2+2+2+3+1+2+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_16",
    "sat": "def sat(s: str, inp: str=\"1+3+1+1+3+3+3+3+2+2+2+3+1+1+2+1+2+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+1+1+3+3+3+3+2+2+2+3+1+1+2+1+2+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_17",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+1+2+1+3+3+2+1+1+1+2+2+2+2+3+3+3+3+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+1+2+1+3+3+2+1+1+1+2+2+2+2+3+3+3+3+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_18",
    "sat": "def sat(s: str, inp: str=\"2+3+3+1+3+1+2+2+1+2+1+2+3+2+3+2+1+2+3+2+2+1+2+3+3+2+1+1+2+2+3+2+3+3+3+3+1+3+3+2+1+2+1+2+1+2+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+3+1+3+1+2+2+1+2+1+2+3+2+3+2+1+2+3+2+2+1+2+3+3+2+1+1+2+2+3+2+3+3+3+3+1+3+3+2+1+2+1+2+1+2+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_19",
    "sat": "def sat(s: str, inp: str=\"3+2+1+1+1+2+1+1+1+1+1+1+3+1+2+1+1+3+1+2+2+3+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+1+1+2+1+1+1+1+1+1+3+1+2+1+1+3+1+2+2+3+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_20",
    "sat": "def sat(s: str, inp: str=\"2+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_21",
    "sat": "def sat(s: str, inp: str=\"3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_22",
    "sat": "def sat(s: str, inp: str=\"1+2+3+1+2+1+3+1+2+3+1+3+2+1+3+2+1+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3+1+2+1+3+1+2+3+1+3+2+1+3+2+1+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_23",
    "sat": "def sat(s: str, inp: str=\"1+1+3+2+3+3+3+1+2+1+1+2+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+2+3+3+3+1+2+1+1+2+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_24",
    "sat": "def sat(s: str, inp: str=\"2+2+3+1+3+2+2+3+3+3+1+3+3+1+1+2+1+3+1+2+1+3+1+1+1+3+1+2+1+2+1+2+3+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+1+3+2+2+3+3+3+1+3+3+1+1+2+1+3+1+2+1+3+1+1+1+3+1+2+1+2+1+2+3+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_25",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+3+2+2+3+3+1+2+3+3+2+1+3+1+2+2+3+2+1+1+2+2+2+3+2+3+2+3+1+1+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+3+2+2+3+3+1+2+3+3+2+1+3+1+2+2+3+2+1+1+2+2+2+3+2+3+2+3+1+1+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_26",
    "sat": "def sat(s: str, inp: str=\"1+3+1+3+2+1+3+3+1+3+3+1+1+2+2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+1+3+2+1+3+3+1+3+3+1+1+2+2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_27",
    "sat": "def sat(s: str, inp: str=\"2+1+3+1+2+1+1+1+2+1+1+2+2+2+1+3+3+1+1+2+3+3+2+3+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+3+1+2+1+1+1+2+1+1+2+2+2+1+3+3+1+1+2+3+3+2+3+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_28",
    "sat": "def sat(s: str, inp: str=\"2+3+2+2+2+2+3+3+3+3+2+3+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+2+2+2+2+3+3+3+3+2+3+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_29",
    "sat": "def sat(s: str, inp: str=\"2+2+3+2+1+1+2+1+3+1+3+1+3+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+2+1+1+2+1+3+1+3+1+3+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_30",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+3+1+2+1+2+2+1+1+3+3+1+1+1+2+2+1+3+2+2+1+1+1+1+1+1+3+1+3+3+3+3+3+2+3+1+3+1+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+3+1+2+1+2+2+1+1+3+3+1+1+1+2+2+1+3+2+2+1+1+1+1+1+1+3+1+3+3+3+3+3+2+3+1+3+1+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_31",
    "sat": "def sat(s: str, inp: str=\"3+3+2+2+3+1+2+3+3+1+3+1+1+1+1+2+2+2+1+2+2+2+3+3+3+3+3+3+1+3+1+1+2+2+1+3+3+2+1+1+3+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+2+3+1+2+3+3+1+3+1+1+1+1+2+2+2+1+2+2+2+3+3+3+3+3+3+1+3+1+1+2+2+1+3+3+2+1+1+3+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_32",
    "sat": "def sat(s: str, inp: str=\"2+1+3+2+1+3+1+2+3+1+1+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+3+2+1+3+1+2+3+1+1+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_33",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+2+3+3+3+2+1+1+3+3+2+2+2+3+3+2+1+3+1+1+2+1+3+3+1+2+2+2+2+2+2+3+3+3+2+3+1+2+2+3+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+2+3+3+3+2+1+1+3+3+2+2+2+3+3+2+1+3+1+1+2+1+3+3+1+2+2+2+2+2+2+3+3+3+2+3+1+2+2+3+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_34",
    "sat": "def sat(s: str, inp: str=\"3+3+2+1+3+2+2+2+2+1+2+3+1+1+3+1+2+3+2+1+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+1+3+2+2+2+2+1+2+3+1+1+3+1+2+3+2+1+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_35",
    "sat": "def sat(s: str, inp: str=\"2+3+1+2+2+3+3+2+1+3+1+1+2+2+1+3+2+1+3+3+2+1+3+3+2+3+1+1+3+1+2+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+2+3+3+2+1+3+1+1+2+2+1+3+2+1+3+3+2+1+3+3+2+3+1+1+3+1+2+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_36",
    "sat": "def sat(s: str, inp: str=\"1+1+3+2+3+1+2+1+1+3+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+2+3+1+2+1+1+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_37",
    "sat": "def sat(s: str, inp: str=\"\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_38",
    "sat": "def sat(s: str, inp: str=\"1+1+2+3+1+2+3+1+3+2+2+2+1+3+2+3+1+1+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+2+3+1+2+3+1+3+2+2+2+1+3+2+3+1+1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_39",
    "sat": "def sat(s: str, inp: str=\"3+2+2+2+2+3+3+1+1+1+1+2+3+2+2+2+2+2+1+3+1+3+2+1+2+2+2+2+3+2+1+1+3+2+2+3+1+3+2+3+1+2+1+3+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+2+2+2+3+3+1+1+1+1+2+3+2+2+2+2+2+1+3+1+3+2+1+2+2+2+2+3+2+1+1+3+2+2+3+1+3+2+3+1+2+1+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_40",
    "sat": "def sat(s: str, inp: str=\"1+3+3+3+2+3+2+2+3+2+2+1+2+2+1+1+1+2+2+1+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+3+2+3+2+2+3+2+2+1+2+2+1+1+1+2+2+1+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_41",
    "sat": "def sat(s: str, inp: str=\"3+1+1+3+3+3+2+1+1+1+1+2+2+2+2+2+1+3+2+3+1+1+2+2+3+3+2+1+1+3+3+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+1+3+3+3+2+1+1+1+1+2+2+2+2+2+1+3+2+3+1+1+2+2+3+3+2+1+1+3+3+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_42",
    "sat": "def sat(s: str, inp: str=\"2+3+1+1+3+2+3+2+2+2+3+3+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+1+3+2+3+2+2+2+3+3+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_43",
    "sat": "def sat(s: str, inp: str=\"3+1+2+1+1+3+3+2+3+3+3+2+3+3+1+1+2+2+2+1+1+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+1+1+3+3+2+3+3+3+2+3+3+1+1+2+2+2+1+1+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_44",
    "sat": "def sat(s: str, inp: str=\"2+2+3+3+3+2+2+3+2+3+1+1+1+2+1+3+2+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+3+3+2+2+3+2+3+1+1+1+2+1+3+2+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_45",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+2+1+1+2+2+1+2+2+3+2+1+3+1+2+2+1+2+2+3+1+3+2+2+2+2+2+2+3+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+2+1+1+2+2+1+2+2+3+2+1+3+1+2+2+1+2+2+3+1+3+2+2+2+2+2+2+3+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_46",
    "sat": "def sat(s: str, inp: str=\"3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_47",
    "sat": "def sat(s: str, inp: str=\"3+3+1+2+1+2+3+3+1+1+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+1+2+1+2+3+3+1+1+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_48",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+1+1+2+2+1+2+1+2+2+2+3+1+1+2+2+2+3+3+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+1+1+2+2+1+2+1+2+2+2+3+1+1+2+2+2+3+3+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_49",
    "sat": "def sat(s: str, inp: str=\"2+3+1+2+2+2+2+2+1+3+3+3+1+1+3+3+3+3+1+2+1+2+1+1+1+2+1+3+1+2+3+1+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+2+2+2+2+1+3+3+3+1+1+3+3+3+3+1+2+1+2+1+1+1+2+1+3+1+2+3+1+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_50",
    "sat": "def sat(s: str, inp: str=\"2+2+2+2+2+2+2+3+2+3+2+1+1+3+1+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+2+2+2+2+2+3+2+3+2+1+1+3+1+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_51",
    "sat": "def sat(s: str, inp: str=\"3+2+3+2+2+1+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+2+2+1+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_52",
    "sat": "def sat(s: str, inp: str=\"3+1+1+2+3+3+3+1+2+2+2+2+1+1+3+3+3+2+1+2+3+3+1+2+2+3+2+1+3+3+3+3+2+3+3+1+2+2+3+1+1+3+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+1+2+3+3+3+1+2+2+2+2+1+1+3+3+3+2+1+2+3+3+1+2+2+3+2+1+3+3+3+3+2+3+3+1+2+2+3+1+1+3+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_53",
    "sat": "def sat(s: str, inp: str=\"2+2+3+2+1+1+2+3+1+3+1+1+1+2+2+1+2+3+1+1+1+3+3+3+1+3+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+3+2+1+1+2+3+1+3+1+1+1+2+2+1+2+3+1+1+1+3+3+3+1+3+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_54",
    "sat": "def sat(s: str, inp: str=\"2+1+1+3+2+1+2+2+2+3+3+2+2+1+1+1+3+3+1+2+3+1+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1+3+2+1+2+2+2+3+3+2+2+1+1+1+3+3+1+2+3+1+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_55",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+2+2+3+3+2+2+2+1+2+2+1+1+2+2+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+2+2+3+3+2+2+2+1+2+2+1+1+2+2+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_56",
    "sat": "def sat(s: str, inp: str=\"2+1+2+1+3+2+3+2+3+2+1+3+2+2+3+1+3+2+1+1+2+3+2+2+1+2+2+1+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+2+3+2+3+2+1+3+2+2+3+1+3+2+1+1+2+3+2+2+1+2+2+1+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_57",
    "sat": "def sat(s: str, inp: str=\"3+2+3+3+3+1+2+3+3+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+3+3+1+2+3+3+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_58",
    "sat": "def sat(s: str, inp: str=\"3+3+2+2+1+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+2+1+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_59",
    "sat": "def sat(s: str, inp: str=\"2+2+2+3+1+2+1+1+1+2+3+3+2+2+2+3+1+1+2+3+3+3+3+3+1+3+1+2+2+1+2+2+1+2+2+1+2+1+3+1+1+3+2+2+3+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+2+3+1+2+1+1+1+2+3+3+2+2+2+3+1+1+2+3+3+3+3+3+1+3+1+2+2+1+2+2+1+2+2+1+2+1+3+1+1+3+2+2+3+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_60",
    "sat": "def sat(s: str, inp: str=\"3+3+2+1+3+2+1+3+1+1+3+3+3+2+2+2+1+3+2+3+2+3+2+3+3+3+3+2+2+3+2+3+2+3+2+2+3+3+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+1+3+2+1+3+1+1+3+3+3+2+2+2+1+3+2+3+2+3+2+3+3+3+3+2+2+3+2+3+2+3+2+2+3+3+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_61",
    "sat": "def sat(s: str, inp: str=\"3+1+2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_62",
    "sat": "def sat(s: str, inp: str=\"3+2+2+1+2+3+1+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+2+1+2+3+1+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_63",
    "sat": "def sat(s: str, inp: str=\"3+1+3+3+2+2+3+3+2+1+3+2+1+2+3+3+1+2+1+3+2+3+2+2+3+1+1+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+3+2+2+3+3+2+1+3+2+1+2+3+3+1+2+1+3+2+3+2+2+3+1+1+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_64",
    "sat": "def sat(s: str, inp: str=\"2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_65",
    "sat": "def sat(s: str, inp: str=\"3+2+3+2+2+3+1+3+1+1+3+3+2+1+2+2+1+1+3+2+2+2+1+3+1+1+3+2+3+3+2+1+1+2+3+3+1+2+1+1+1+1+3+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+2+2+3+1+3+1+1+3+3+2+1+2+2+1+1+3+2+2+2+1+3+1+1+3+2+3+3+2+1+1+2+3+3+1+2+1+1+1+1+3+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_66",
    "sat": "def sat(s: str, inp: str=\"1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_67",
    "sat": "def sat(s: str, inp: str=\"2+3+1+2+3+2+3+3+1+2+3+2+2+3+1+2+3+1+2+3+2+1+2+1+3+1+3+3+2+2+3+2+2+2+1+1+1+3+3+2+3+1+2+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+3+2+3+3+1+2+3+2+2+3+1+2+3+1+2+3+2+1+2+1+3+1+3+3+2+2+3+2+2+2+1+1+1+3+3+2+3+1+2+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_68",
    "sat": "def sat(s: str, inp: str=\"3+3+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_69",
    "sat": "def sat(s: str, inp: str=\"1+2+2+3+3+3+2+3+1+1+1+3+2+1+3+2+2+1+2+2+2+1+2+1+3+1+3+2+2+2+2+3+3+3+1+2+1+1+1+2+1+3+3+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+3+3+3+2+3+1+1+1+3+2+1+3+2+2+1+2+2+2+1+2+1+3+1+3+2+2+2+2+3+3+3+1+2+1+1+1+2+1+3+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_70",
    "sat": "def sat(s: str, inp: str=\"3+1+2+1+1+1+3+2+2+3+3+2+1+1+1+2+1+2+3+2+1+2+2+3+2+1+1+3+1+3+2+2+2+1+2+2+2+2+2+3+3+3+2+1+2+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+2+1+1+1+3+2+2+3+3+2+1+1+1+2+1+2+3+2+1+2+2+3+2+1+1+3+1+3+2+2+2+1+2+2+2+2+2+3+3+3+2+1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_71",
    "sat": "def sat(s: str, inp: str=\"1+3+3+2+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+2+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_72",
    "sat": "def sat(s: str, inp: str=\"3+3+3+2+3+3+3+2+3+1+2+2+1+2+3+3+1+1+1+1+1+3+3+3+2+2+2+2+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+2+3+3+3+2+3+1+2+2+1+2+3+3+1+1+1+1+1+3+3+3+2+2+2+2+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_73",
    "sat": "def sat(s: str, inp: str=\"3+2+3+1+1+3+1+2+1+2+2+1+3+1+2+2+3+2+2+2+1+3+1+1+2+2+3+3+3+1+3+3+1+3+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+1+1+3+1+2+1+2+2+1+3+1+2+2+3+2+2+2+1+3+1+1+2+2+3+3+3+1+3+3+1+3+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_74",
    "sat": "def sat(s: str, inp: str=\"3+3+3+1+2+2+1+2+1+3+3+2+3+2+2+1+3+1+3+1+1+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+1+2+2+1+2+1+3+3+2+3+2+2+1+3+1+3+1+1+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_75",
    "sat": "def sat(s: str, inp: str=\"1+3+3+3+3+2+2+2+1+2+3+3+2+2+1+1+1+3+3+2+2+1+2+1+2+3+2+2+1+1+1+1+3+2+1+1+2+3+3+2+3+1+1+3+3+1+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+3+3+2+2+2+1+2+3+3+2+2+1+1+1+3+3+2+2+1+2+1+2+3+2+2+1+1+1+1+3+2+1+1+2+3+3+2+3+1+1+3+3+1+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_76",
    "sat": "def sat(s: str, inp: str=\"1+2+3+1+1+3+1+2+2+2+1+2+1+2+1+1+3+2+1+3+3+3+3+3+1+3+3+3+1+2+2+2+1+3+2+1+3+1+2+3+1+1+1+3+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3+1+1+3+1+2+2+2+1+2+1+2+1+1+3+2+1+3+3+3+3+3+1+3+3+3+1+2+2+2+1+3+2+1+3+1+2+3+1+1+1+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_77",
    "sat": "def sat(s: str, inp: str=\"2+1+2+1+3+1+3+3+3+1+2+2+2+2+2+2+3+3+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+1+3+3+3+1+2+2+2+2+2+2+3+3+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_78",
    "sat": "def sat(s: str, inp: str=\"1+1+1+1+3+1+1+3+3+3+1+2+1+3+3+3+2+2+2+1+3+3+2+3+2+3+3+2+2+1+3+1+2+2+3+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+1+1+3+1+1+3+3+3+1+2+1+3+3+3+2+2+2+1+3+3+2+3+2+3+3+2+2+1+3+1+2+2+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_79",
    "sat": "def sat(s: str, inp: str=\"3+1+3+3+3+3+3+2+2+1+1+2+3+1+1+3+2+3+2+2+3+1+2+1+3+2+1+3+3+1+3+1+2+1+1+3+2+2+3+2+3+1+1+2+3+1+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+3+3+3+3+2+2+1+1+2+3+1+1+3+2+3+2+2+3+1+2+1+3+2+1+3+3+1+3+1+2+1+1+3+2+2+3+2+3+1+1+2+3+1+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_80",
    "sat": "def sat(s: str, inp: str=\"3+2+3+3+3+3+3+2+2+1+2+3+2+3+3+1+3+3+1+1+2+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+3+3+3+3+2+2+1+2+3+2+3+3+1+3+3+1+1+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_81",
    "sat": "def sat(s: str, inp: str=\"3+2+3+3+2+1+2+1+1+2+1+2+2+2+3+1+2+3+3+2+1+1+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+3+2+1+2+1+1+2+1+2+2+2+3+1+2+3+3+2+1+1+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_82",
    "sat": "def sat(s: str, inp: str=\"2+1+1+3+3+1+1+1+1+3+2+1+2+2+3+3+1+3+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1+3+3+1+1+1+1+3+2+1+2+2+3+3+1+3+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_83",
    "sat": "def sat(s: str, inp: str=\"1+3+2+3+2+3+2+1+3+2+1+3+1+1+2+2+3+3+2+2+3+3+2+3+2+3+1+2+3+3+1+3+3+1+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+3+2+3+2+1+3+2+1+3+1+1+2+2+3+3+2+2+3+3+2+3+2+3+1+2+3+3+1+3+3+1+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_84",
    "sat": "def sat(s: str, inp: str=\"3+3+1+1+1+1+2+3+3+1+1+3+1+3+2+1+3+2+1+2+3+3+1+2+3+3+2+3+2+2+1+1+1+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+1+1+1+1+2+3+3+1+1+3+1+3+2+1+3+2+1+2+3+3+1+2+3+3+2+3+2+2+1+1+1+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_85",
    "sat": "def sat(s: str, inp: str=\"1+2+2+1+3+2+2+1+3+3+3+3+3+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+2+1+3+2+2+1+3+3+3+3+3+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_86",
    "sat": "def sat(s: str, inp: str=\"2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_87",
    "sat": "def sat(s: str, inp: str=\"2+1+2+2+1+1+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+2+1+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_88",
    "sat": "def sat(s: str, inp: str=\"3+3+2+2+2+1+3+3+3+3+3+2+2+2+2+2+1+3+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+2+2+2+1+3+3+3+3+3+2+2+2+2+2+1+3+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_89",
    "sat": "def sat(s: str, inp: str=\"1+3+2+1+2+3+1+1+3+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+1+2+3+1+1+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_90",
    "sat": "def sat(s: str, inp: str=\"1+2+3+1+2+1+2+3+3+3+2+3+3+3+1+2+1+2+1+1+2+3+1+3+1+2+3+2+3+1+3+1+3+3+3+3+2+1+1+2+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3+1+2+1+2+3+3+3+2+3+3+3+1+2+1+2+1+1+2+3+1+3+1+2+3+2+3+1+3+1+3+3+3+3+2+1+1+2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_91",
    "sat": "def sat(s: str, inp: str=\"1+3+3+2+2+3+3+3+2+2+3+1+2+2+2+2+2+3+3+2+1+3+1+2+3+1+1+3+2+1+1+3+2+1+1+2+2+1+3+2+3+1+2+3+3+3+2+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+2+2+3+3+3+2+2+3+1+2+2+2+2+2+3+3+2+1+3+1+2+3+1+1+3+2+1+1+3+2+1+1+2+2+1+3+2+3+1+2+3+3+3+2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_92",
    "sat": "def sat(s: str, inp: str=\"3+3+3+3+1+2+1+1+1+1+1+3+1+2+3+3+3+2+1+3+2+1+2+3+2+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+3+3+3+1+2+1+1+1+1+1+3+1+2+3+3+3+2+1+3+2+1+2+3+2+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_93",
    "sat": "def sat(s: str, inp: str=\"3+2+1+1+1+1+3+1+3+1+1+2+3+2+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+1+1+1+3+1+3+1+1+2+3+2+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_94",
    "sat": "def sat(s: str, inp: str=\"1+2+1+1+1+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+1+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_95",
    "sat": "def sat(s: str, inp: str=\"1+3+2+3+3+1+3+1+3+1+3+2+2+1+3+3+1+1+2+2+2+2+3+1+2+1+2+2+2+2+3+1+2+1+2+3+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+2+3+3+1+3+1+3+1+3+2+2+1+3+3+1+1+2+2+2+2+3+1+2+1+2+2+2+2+3+1+2+1+2+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_96",
    "sat": "def sat(s: str, inp: str=\"2+1+2+1+3+3+2+2+3+2+3+3+3+3+2+3+2+3+1+2+1+1+1+3+3+1+1+2+2+3+3+1+2+1+2+3+2+2+2+2+1\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+3+2+2+3+2+3+3+3+3+2+3+2+3+1+2+1+1+1+3+3+1+1+2+2+3+3+1+2+1+2+3+2+2+2+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_97",
    "sat": "def sat(s: str, inp: str=\"1+1+1+2+1+3+1+2+2+1+1+1+1+2+3+1+3+1+1+2+1+3+2+3+3+3+3+3+3+2+1+3+2+1+3+2+1+1+3+3+2+3+3+3+2+1+2+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+1+2+1+3+1+2+2+1+1+1+1+2+3+1+3+1+1+2+1+3+2+3+3+3+3+3+3+2+1+3+2+1+3+2+1+1+3+3+2+3+3+3+2+1+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_98",
    "sat": "def sat(s: str, inp: str=\"2+3+1+1+2+3+3+1+1+2+1+3+2+3+2+1+1+3+1+3+1+3+1+2+3+3+3+1+2+3+2+3+1+2+3+3+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+1+2+3+3+1+1+2+1+3+2+3+2+1+1+3+1+3+1+3+1+2+3+3+3+1+2+3+2+3+1+2+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "SortPlusPlus_99",
    "sat": "def sat(s: str, inp: str=\"3+1+3+2+3+3+1+3\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+1+3+2+3+3+1+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_0",
    "sat": "def sat(s: str, word: str=\"konjac\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"konjac\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_1",
    "sat": "def sat(s: str, word: str=\"betivo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"betivo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_2",
    "sat": "def sat(s: str, word: str=\"habyfedomeb\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"habyfedomeb\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_3",
    "sat": "def sat(s: str, word: str=\"geziqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"geziqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_4",
    "sat": "def sat(s: str, word: str=\"zugethi\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zugethi\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_5",
    "sat": "def sat(s: str, word: str=\"ko\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ko\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_6",
    "sat": "def sat(s: str, word: str=\"fyjoc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fyjoc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_7",
    "sat": "def sat(s: str, word: str=\"gadoro\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"gadoro\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_8",
    "sat": "def sat(s: str, word: str=\"munadymubunidamu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"munadymubunidamu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_9",
    "sat": "def sat(s: str, word: str=\"h\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"h\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_10",
    "sat": "def sat(s: str, word: str=\"quahywyzarotexto\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"quahywyzarotexto\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_11",
    "sat": "def sat(s: str, word: str=\"ryvexuzychaf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ryvexuzychaf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_12",
    "sat": "def sat(s: str, word: str=\"xith\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xith\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_13",
    "sat": "def sat(s: str, word: str=\"guhe\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"guhe\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_14",
    "sat": "def sat(s: str, word: str=\"nypugychek\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nypugychek\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_15",
    "sat": "def sat(s: str, word: str=\"gotextefuthyrakahamo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"gotextefuthyrakahamo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_16",
    "sat": "def sat(s: str, word: str=\"litytextuxuxyg\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"litytextuxuxyg\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_17",
    "sat": "def sat(s: str, word: str=\"zitex\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zitex\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_18",
    "sat": "def sat(s: str, word: str=\"hovycegowubatahupyr\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"hovycegowubatahupyr\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_19",
    "sat": "def sat(s: str, word: str=\"kyhi\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"kyhi\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_20",
    "sat": "def sat(s: str, word: str=\"t\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"t\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_21",
    "sat": "def sat(s: str, word: str=\"puzewusochoc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"puzewusochoc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_22",
    "sat": "def sat(s: str, word: str=\"xipubefinegydethoto\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xipubefinegydethoto\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_23",
    "sat": "def sat(s: str, word: str=\"naquuletha\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"naquuletha\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_24",
    "sat": "def sat(s: str, word: str=\"fetalonolyqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fetalonolyqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_25",
    "sat": "def sat(s: str, word: str=\"thahidilo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thahidilo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_26",
    "sat": "def sat(s: str, word: str=\"ricibyhequoz\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ricibyhequoz\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_27",
    "sat": "def sat(s: str, word: str=\"tod\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"tod\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_28",
    "sat": "def sat(s: str, word: str=\"junopesavowurabemale\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"junopesavowurabemale\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_29",
    "sat": "def sat(s: str, word: str=\"vetyfapachivuwoka\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vetyfapachivuwoka\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_30",
    "sat": "def sat(s: str, word: str=\"va\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"va\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_31",
    "sat": "def sat(s: str, word: str=\"zunuchivuruh\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zunuchivuruh\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_32",
    "sat": "def sat(s: str, word: str=\"co\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"co\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_33",
    "sat": "def sat(s: str, word: str=\"lakapequiwach\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"lakapequiwach\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_34",
    "sat": "def sat(s: str, word: str=\"text\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"text\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_35",
    "sat": "def sat(s: str, word: str=\"xaputh\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xaputh\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_36",
    "sat": "def sat(s: str, word: str=\"suhohigohej\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"suhohigohej\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_37",
    "sat": "def sat(s: str, word: str=\"dykyfuquilymitigu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dykyfuquilymitigu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_38",
    "sat": "def sat(s: str, word: str=\"boj\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"boj\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_39",
    "sat": "def sat(s: str, word: str=\"chycitowegob\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"chycitowegob\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_40",
    "sat": "def sat(s: str, word: str=\"dunethechotynovuto\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dunethechotynovuto\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_41",
    "sat": "def sat(s: str, word: str=\"nyzafu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nyzafu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_42",
    "sat": "def sat(s: str, word: str=\"waho\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"waho\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_43",
    "sat": "def sat(s: str, word: str=\"zyd\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zyd\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_44",
    "sat": "def sat(s: str, word: str=\"pomimilochajutextuf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"pomimilochajutextuf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_45",
    "sat": "def sat(s: str, word: str=\"cetextagow\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cetextagow\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_46",
    "sat": "def sat(s: str, word: str=\"lorequehiquatithuwo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"lorequehiquatithuwo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_47",
    "sat": "def sat(s: str, word: str=\"nehufepaterup\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nehufepaterup\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_48",
    "sat": "def sat(s: str, word: str=\"vexepoc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vexepoc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_49",
    "sat": "def sat(s: str, word: str=\"vaxetextynaquomidasy\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vaxetextynaquomidasy\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_50",
    "sat": "def sat(s: str, word: str=\"woletextir\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"woletextir\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_51",
    "sat": "def sat(s: str, word: str=\"dechymegurynaby\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dechymegurynaby\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_52",
    "sat": "def sat(s: str, word: str=\"mithemegechytywinada\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"mithemegechytywinada\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_53",
    "sat": "def sat(s: str, word: str=\"fofukybuquo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fofukybuquo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_54",
    "sat": "def sat(s: str, word: str=\"rixiha\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"rixiha\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_55",
    "sat": "def sat(s: str, word: str=\"ximavilu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ximavilu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_56",
    "sat": "def sat(s: str, word: str=\"cyketyjuthinumisuf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cyketyjuthinumisuf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_57",
    "sat": "def sat(s: str, word: str=\"jynixajohothaq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jynixajohothaq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_58",
    "sat": "def sat(s: str, word: str=\"byf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"byf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_59",
    "sat": "def sat(s: str, word: str=\"diparukatyvaposyj\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"diparukatyvaposyj\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_60",
    "sat": "def sat(s: str, word: str=\"thybexadekypyc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thybexadekypyc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_61",
    "sat": "def sat(s: str, word: str=\"bov\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"bov\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_62",
    "sat": "def sat(s: str, word: str=\"mehyce\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"mehyce\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_63",
    "sat": "def sat(s: str, word: str=\"xexopycoro\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"xexopycoro\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_64",
    "sat": "def sat(s: str, word: str=\"vysusizubanyzykurole\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vysusizubanyzykurole\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_65",
    "sat": "def sat(s: str, word: str=\"fudinigahijuselipapa\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fudinigahijuselipapa\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_66",
    "sat": "def sat(s: str, word: str=\"hadofyte\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"hadofyte\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_67",
    "sat": "def sat(s: str, word: str=\"henykivudotitexty\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"henykivudotitexty\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_68",
    "sat": "def sat(s: str, word: str=\"rydilezilobogitiquos\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"rydilezilobogitiquos\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_69",
    "sat": "def sat(s: str, word: str=\"vymechuhekytextech\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vymechuhekytextech\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_70",
    "sat": "def sat(s: str, word: str=\"saxaquepig\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"saxaquepig\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_71",
    "sat": "def sat(s: str, word: str=\"jithyzelahylik\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jithyzelahylik\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_72",
    "sat": "def sat(s: str, word: str=\"wo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"wo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_73",
    "sat": "def sat(s: str, word: str=\"nachejysisamuwywo\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nachejysisamuwywo\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_74",
    "sat": "def sat(s: str, word: str=\"vomadohyg\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"vomadohyg\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_75",
    "sat": "def sat(s: str, word: str=\"nylylaq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"nylylaq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_76",
    "sat": "def sat(s: str, word: str=\"j\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"j\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_77",
    "sat": "def sat(s: str, word: str=\"jotextepoq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jotextepoq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_78",
    "sat": "def sat(s: str, word: str=\"byzohuchigiso\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"byzohuchigiso\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_79",
    "sat": "def sat(s: str, word: str=\"cagocuxytextolet\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cagocuxytextolet\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_80",
    "sat": "def sat(s: str, word: str=\"mojedufida\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"mojedufida\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_81",
    "sat": "def sat(s: str, word: str=\"jy\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"jy\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_82",
    "sat": "def sat(s: str, word: str=\"chaquocichobehy\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"chaquocichobehy\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_83",
    "sat": "def sat(s: str, word: str=\"myquuhacaby\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"myquuhacaby\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_84",
    "sat": "def sat(s: str, word: str=\"het\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"het\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_85",
    "sat": "def sat(s: str, word: str=\"chirikutextynoqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"chirikutextynoqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_86",
    "sat": "def sat(s: str, word: str=\"cylyxequefamuhuq\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cylyxequefamuhuq\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_87",
    "sat": "def sat(s: str, word: str=\"rijachinuz\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"rijachinuz\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_88",
    "sat": "def sat(s: str, word: str=\"tokinaxigi\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"tokinaxigi\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_89",
    "sat": "def sat(s: str, word: str=\"q\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"q\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_90",
    "sat": "def sat(s: str, word: str=\"quovuhagomiv\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"quovuhagomiv\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_91",
    "sat": "def sat(s: str, word: str=\"thucygyf\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thucygyf\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_92",
    "sat": "def sat(s: str, word: str=\"goc\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"goc\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_93",
    "sat": "def sat(s: str, word: str=\"wirucoch\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"wirucoch\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_94",
    "sat": "def sat(s: str, word: str=\"cyvykacubysarusyqu\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"cyvykacubysarusyqu\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_95",
    "sat": "def sat(s: str, word: str=\"k\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"k\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_96",
    "sat": "def sat(s: str, word: str=\"quum\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"quum\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_97",
    "sat": "def sat(s: str, word: str=\"furibixochifexuthipe\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"furibixochifexuthipe\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_98",
    "sat": "def sat(s: str, word: str=\"hykec\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"hykec\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "CapitalizeFirstLetter_99",
    "sat": "def sat(s: str, word: str=\"textoxucugis\"):\n    assert type(s) is str, 's must be of type str'\n    for i in range(len(s)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"textoxucugis\"):\n    return word[0].upper() + word[1:]"
    ]
  },
  {
    "name": "LongestSubsetString_0",
    "sat": "def sat(t: str, s: str=\"abbbcabbac\", target: int=7):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbbcabbac\", target=7): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_1",
    "sat": "def sat(t: str, s: str=\"ccac\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccac\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_2",
    "sat": "def sat(t: str, s: str=\"b\", target: int=1):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"b\", target=1): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_3",
    "sat": "def sat(t: str, s: str=\"cacc\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cacc\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_4",
    "sat": "def sat(t: str, s: str=\"cbcba\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcba\", target=5): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_5",
    "sat": "def sat(t: str, s: str=\"aacacccba\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aacacccba\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_6",
    "sat": "def sat(t: str, s: str=\"cbbba\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbba\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_7",
    "sat": "def sat(t: str, s: str=\"cbbaccacccacbacabaabacbccaaaaccababaabbccccbbbcbccbaaaccaacbacccbacbbcbacccbabbbab\", target: int=53):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbaccacccacbacabaabacbccaaaaccababaabbccccbbbcbccbaaaccaacbacccbacbbcbacccbabbbab\", target=53): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_8",
    "sat": "def sat(t: str, s: str=\"bcacaacccbcaacbbcbcabbcbbaaaabbbacabacbbaaa\", target: int=28):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcacaacccbcaacbbcbcabbcbbaaaabbbacabacbbaaa\", target=28): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_9",
    "sat": "def sat(t: str, s: str=\"ba\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ba\", target=2): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_10",
    "sat": "def sat(t: str, s: str=\"bcbacbcabaabacaacbbacbccabbaabcbbcbc\", target: int=29):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbacbcabaabacaacbbacbccabbaabcbbcbc\", target=29): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_11",
    "sat": "def sat(t: str, s: str=\"caacbbcabccacababababbbcbacbccccaabcbbcbbaccabaabccbabaaaacaacbbccbccaaabcacbbbbbacacacacbbacbbacbccbcabcbaacccabcbccbbcbacbbbbabcacccbccaacbaaaabbbacccbbbbabbbcabcbacbccbacbbcccbaccbbabbbaccacabbcbccaaabcabbccabcaccabcbaaccbbccaaacaccbccbbbbbbacbcccacaaacaacccacabbcababaabccacccbaaaabcabbbbaabcccbcbbcbababcbcccabcbcabacaaabbbcbababacacaababaaccabbcbbaacacbbaa\", target: int=243):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caacbbcabccacababababbbcbacbccccaabcbbcbbaccabaabccbabaaaacaacbbccbccaaabcacbbbbbacacacacbbacbbacbccbcabcbaacccabcbccbbcbacbbbbabcacccbccaacbaaaabbbacccbbbbabbbcabcbacbccbacbbcccbaccbbabbbaccacabbcbccaaabcabbccabcaccabcbaaccbbccaaacaccbccbbbbbbacbcccacaaacaacccacabbcababaabccacccbaaaabcabbbbaabcccbcbbcbababcbcccabcbcabacaaabbbcbababacacaababaaccabbcbbaacacbbaa\", target=243): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_12",
    "sat": "def sat(t: str, s: str=\"bcbbcccaaabbbbbaacbbcabbcabaccababacacaccbcbabbbbacabbbccabbabbbcbbaaaaaabcbccbbbbbcbacbcccacaaacabbbcacbbcbacbbbabbbbccbbabaabbbabaaaccabbcbcbababaaacaacacacaaaccaabbcaabccacccaabbcbaaacbbaaabcabbacccccaaabccacbacacbaaaabacbacbacbaacbcccaaabaabaccbcccaaacaaaaabbccbbbcacccbaacbbcbaccbabaacccaacbbbcaccbcbcacccacacbbcabbaaacabbccbacaacbbaacbccabababababbcaccacaabbaabcacbaacbcbbcacaaaabccbccaabbbaabcbbcbbccbbcacaccabacbcabbcbbaccbabacacbababcbccaabcbcabaabcbcaaabbbabaacabbbbbbcacaacabbacabccbabcbbccbcccacaabccbbccbcccbacabcbbcabbaaacbbcbcbbcbcabcbbbcaacccbccaacabccbcccacbaababbaaccbcabcbbbabbccbbbcaccabacaabbaaabccccbabcaccaababccaacaaabbaabcbacaccaaacbcbbbbbabaabbcccaabcbbacbbcaabbaccbcbbbcabaacbbcbbbbbaabaacaaabaccbccaccbaaacbbbbbcbbcccaaccabbacaccabbcccbccaacaabbaaccbcbcbcbccbaaabaabababacaccbabbbabcaac\", target: int=532):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbbcccaaabbbbbaacbbcabbcabaccababacacaccbcbabbbbacabbbccabbabbbcbbaaaaaabcbccbbbbbcbacbcccacaaacabbbcacbbcbacbbbabbbbccbbabaabbbabaaaccabbcbcbababaaacaacacacaaaccaabbcaabccacccaabbcbaaacbbaaabcabbacccccaaabccacbacacbaaaabacbacbacbaacbcccaaabaabaccbcccaaacaaaaabbccbbbcacccbaacbbcbaccbabaacccaacbbbcaccbcbcacccacacbbcabbaaacabbccbacaacbbaacbccabababababbcaccacaabbaabcacbaacbcbbcacaaaabccbccaabbbaabcbbcbbccbbcacaccabacbcabbcbbaccbabacacbababcbccaabcbcabaabcbcaaabbbabaacabbbbbbcacaacabbacabccbabcbbccbcccacaabccbbccbcccbacabcbbcabbaaacbbcbcbbcbcabcbbbcaacccbccaacabccbcccacbaababbaaccbcabcbbbabbccbbbcaccabacaabbaaabccccbabcaccaababccaacaaabbaabcbacaccaaacbcbbbbbabaabbcccaabcbbacbbcaabbaccbcbbbcabaacbbcbbbbbaabaacaaabaccbccaccbaaacbbbbbcbbcccaaccabbacaccabbcccbccaacaabbaaccbcbcbcbccbaaabaabababacaccbabbbabcaac\", target=532): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_13",
    "sat": "def sat(t: str, s: str=\"cbababc\", target: int=7):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbababc\", target=7): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_14",
    "sat": "def sat(t: str, s: str=\"abaabab\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abaabab\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_15",
    "sat": "def sat(t: str, s: str=\"ababcababcbacabbabaababaabaacaacbabacbacbbabacabbacaaaabccccbabbbabcabcaacbacbcbcbbbaaabbccbcabcacabbcbccbbabbbbccacccabacbabbaaabaaccbacaaabacaababcacbcbbacbcacabbaccccbaaabaaacaccccacabcababbacccacbaaacacbbbcabcbbaababcaacbccaabbbccbacccbbaacbcabacbcabaacabaccbaaacabcbcacabbacaaaabacbbabcaacbcabcacaaacbbccbacccbbbccababbccaaabccccccabbcbcccbabaccbbabcaabbacbcbcbaacbccabaaaabaabbcbccabacabccabacaacaaabbcbbccaccbbcaacbaabcaccccccbccccbcbaabbcaabaaccaaabaababbacabaababacbbcbbabaabaacaabaaaaabcccbcabacaaccccbacacabcbbbcbcaaacbbabbcaaacbaaacccaccccbbbbacabbcaaaaaccbbbabaccbbbaacbbcbbbccbabcccbccabbacbacbabbbaabbacbbbbaaacabcabbcccbbbaabcacaacaacccbbacaaabcbaacaaaccaaabcabbcccabbbcaccaaabbbcacbabbaccbcbbabccbcbbbbaccbbacabbccaacaacacaaaabaccccbacabbaacbcaaaacbbaaacccccbaabbabccabbbabcbcbaaacbabbbbaacbaaccbccabaabcbbaabacbbcbcbaabbbcaabcacaccabc\", target: int=565):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ababcababcbacabbabaababaabaacaacbabacbacbbabacabbacaaaabccccbabbbabcabcaacbacbcbcbbbaaabbccbcabcacabbcbccbbabbbbccacccabacbabbaaabaaccbacaaabacaababcacbcbbacbcacabbaccccbaaabaaacaccccacabcababbacccacbaaacacbbbcabcbbaababcaacbccaabbbccbacccbbaacbcabacbcabaacabaccbaaacabcbcacabbacaaaabacbbabcaacbcabcacaaacbbccbacccbbbccababbccaaabccccccabbcbcccbabaccbbabcaabbacbcbcbaacbccabaaaabaabbcbccabacabccabacaacaaabbcbbccaccbbcaacbaabcaccccccbccccbcbaabbcaabaaccaaabaababbacabaababacbbcbbabaabaacaabaaaaabcccbcabacaaccccbacacabcbbbcbcaaacbbabbcaaacbaaacccaccccbbbbacabbcaaaaaccbbbabaccbbbaacbbcbbbccbabcccbccabbacbacbabbbaabbacbbbbaaacabcabbcccbbbaabcacaacaacccbbacaaabcbaacaaaccaaabcabbcccabbbcaccaaabbbcacbabbaccbcbbabccbcbbbbaccbbacabbccaacaacacaaaabaccccbacabbaacbcaaaacbbaaacccccbaabbabccabbbabcbcbaaacbabbbbaacbaaccbccabaabcbbaabacbbcbcbaabbbcaabcacaccabc\", target=565): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_16",
    "sat": "def sat(t: str, s: str=\"bcbbcb\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbbcb\", target=5): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_17",
    "sat": "def sat(t: str, s: str=\"aba\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aba\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_18",
    "sat": "def sat(t: str, s: str=\"cacab\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cacab\", target=5): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_19",
    "sat": "def sat(t: str, s: str=\"bbaccbcacbaaaababccbbbcacabbaccbbbaccacbbccbabbcaccacbbbbccaccbbaabbabcaaccccba\", target: int=50):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbaccbcacbaaaababccbbbcacabbaccbbbaccacbbccbabbcaccacbbbbccaccbbaabbabcaaccccba\", target=50): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_20",
    "sat": "def sat(t: str, s: str=\"abacabbab\", target: int=8):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abacabbab\", target=8): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_21",
    "sat": "def sat(t: str, s: str=\"cccabbbcbaaaacacabcabbcbbbabbaaacbcaacbbcabcaaaaaaaabaaaacaaabcabcbabbcaabcbacaabacabaaccbbaabbcabcbbaacbccbaaabccbccacacbbaabcaaababaacaccaacbbcaabaaaccbbbaccaaccbbccabcbaaabcaaaacaccacbababbaaababacbcababbbbabcccacaaabcabbaabcaacbbbbcacbccccbaabbacabacaabbcaaabaccbcbbccbcabababbabbaccbbaaccbbaaccbcaccabcbbbacbbbbabbacbcaabcaabbccccacaababcacbcbbaccccabbabbbcbccacabbcabababaaacbabccbcaaaaccccccccbbbacababaacbcbcccbbcabcbbaabcbacabaaacabaccaabbabbcacbacaababbcbcbbcaccbcaacbbccbabbcabaabcaaaacabcaccaabbacacabccabcacbbbaabbaaaabbabbcbbaccccbcbbaaccacacbcaacbbcaacccbabaccccacbcbccbacacbcabbabbbcbacacbbaabaabbbcbabccabcbacbcacbbbaaacacacaabaaabcbaababbbbaccacccaccbabababaaaaabacbaccbabcbcaaccaabcbbccccaccbbcacababcabaabbabcccabaccbbcaaccbcacbacbbaabbbbcccccbbaabccacabbcccbcbabacbaabbbcbcccbacccccacacccccbcacbbcabcccbacccabcbccaabbcaabbcaacccbcaccccca\", target: int=572):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccabbbcbaaaacacabcabbcbbbabbaaacbcaacbbcabcaaaaaaaabaaaacaaabcabcbabbcaabcbacaabacabaaccbbaabbcabcbbaacbccbaaabccbccacacbbaabcaaababaacaccaacbbcaabaaaccbbbaccaaccbbccabcbaaabcaaaacaccacbababbaaababacbcababbbbabcccacaaabcabbaabcaacbbbbcacbccccbaabbacabacaabbcaaabaccbcbbccbcabababbabbaccbbaaccbbaaccbcaccabcbbbacbbbbabbacbcaabcaabbccccacaababcacbcbbaccccabbabbbcbccacabbcabababaaacbabccbcaaaaccccccccbbbacababaacbcbcccbbcabcbbaabcbacabaaacabaccaabbabbcacbacaababbcbcbbcaccbcaacbbccbabbcabaabcaaaacabcaccaabbacacabccabcacbbbaabbaaaabbabbcbbaccccbcbbaaccacacbcaacbbcaacccbabaccccacbcbccbacacbcabbabbbcbacacbbaabaabbbcbabccabcbacbcacbbbaaacacacaabaaabcbaababbbbaccacccaccbabababaaaaabacbaccbabcbcaaccaabcbbccccaccbbcacababcabaabbabcccabaccbbcaaccbcacbacbbaabbbbcccccbbaabccacabbcccbcbabacbaabbbcbcccbacccccacacccccbcacbbcabcccbacccabcbccaabbcaabbcaacccbcaccccca\", target=572): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_22",
    "sat": "def sat(t: str, s: str=\"abbac\", target: int=4):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbac\", target=4): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_23",
    "sat": "def sat(t: str, s: str=\"cbaabbcaabaabacbbbbabcacaabcaaaabcabcbbabbacbbcacccaccbbccbbabaabacababcaccabbabaacbbaaacacbcacaccaacbbcabcbabbccabcbcbabbbaacbacbbcbcbaabacbaccccbbcbaaacaccbbbbcbcabacabcbbbacccacaccccccbaabcaaababcbbcbabbcacbacaacbbccbcacbbabbbabacaccbbcbbcccaccbbbcaccbccaaaacababccaabbaaaabcbacacaacaababbbabbbabaacaacbcbabcaabbcccbabcbbbcbacbcaabcaaccaabbcbcbbbacccaacacaacaaaacbcacabcbcbabbcbbcacbacabacabaaacbbabcacbccabaccaabacabcaacbbbbcaaaabbacccacacbaaaaabbcaaabbcabacaaabcbabacbabcbcbbabbcbabcbcaccabcabcbccccbaccacacbcccaababaaaaabbbcabaacababcbacbccacbcccbabacbaaabacbbabaacccaaabbccabbbbbbaaabcbcaabccacbccbabcacacbbbaaccacacbacacbaaaaabbbbcbccbccbbcabccacccccbccacabbbbcbbbacaacbcaabcbbbccacbbaccabacaabacacaccacbbcbbcbcbcbcccccccaacccbaaabcbcbacaaacbccbabcbbbcacbccbbcbbbcbbacccbbcacbcaaccbaaccccababbbbabacbbaacaacabcaaacbacacacaabbcbaaabbccbabacbacbbcbccbaaacbccacbacabaabcbcbcbcaaacaabbaacbbccabccaabaaccabbbcacaabcacbcaabcacababbcabcccccbbaacabaaccaccaacc\", target: int=664):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbaabbcaabaabacbbbbabcacaabcaaaabcabcbbabbacbbcacccaccbbccbbabaabacababcaccabbabaacbbaaacacbcacaccaacbbcabcbabbccabcbcbabbbaacbacbbcbcbaabacbaccccbbcbaaacaccbbbbcbcabacabcbbbacccacaccccccbaabcaaababcbbcbabbcacbacaacbbccbcacbbabbbabacaccbbcbbcccaccbbbcaccbccaaaacababccaabbaaaabcbacacaacaababbbabbbabaacaacbcbabcaabbcccbabcbbbcbacbcaabcaaccaabbcbcbbbacccaacacaacaaaacbcacabcbcbabbcbbcacbacabacabaaacbbabcacbccabaccaabacabcaacbbbbcaaaabbacccacacbaaaaabbcaaabbcabacaaabcbabacbabcbcbbabbcbabcbcaccabcabcbccccbaccacacbcccaababaaaaabbbcabaacababcbacbccacbcccbabacbaaabacbbabaacccaaabbccabbbbbbaaabcbcaabccacbccbabcacacbbbaaccacacbacacbaaaaabbbbcbccbccbbcabccacccccbccacabbbbcbbbacaacbcaabcbbbccacbbaccabacaabacacaccacbbcbbcbcbcbcccccccaacccbaaabcbcbacaaacbccbabcbbbcacbccbbcbbbcbbacccbbcacbcaaccbaaccccababbbbabacbbaacaacabcaaacbacacacaabbcbaaabbccbabacbacbbcbccbaaacbccacbacabaabcbcbcbcaaacaabbaacbbccabccaabaaccabbbcacaabcacbcaabcacababbcabcccccbbaacabaaccaccaacc\", target=664): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_24",
    "sat": "def sat(t: str, s: str=\"bcaaabaacacababcaaaacbbbccbacabbbccbbaccbacbacbcbbcbabaaaabcabacacc\", target: int=48):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcaaabaacacababcaaaacbbbccbacabbbccbbaccbacbacbcbbcbabaaaabcabacacc\", target=48): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_25",
    "sat": "def sat(t: str, s: str=\"bacca\", target: int=4):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bacca\", target=4): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_26",
    "sat": "def sat(t: str, s: str=\"acbbabc\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acbbabc\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_27",
    "sat": "def sat(t: str, s: str=\"a\", target: int=1):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"a\", target=1): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_28",
    "sat": "def sat(t: str, s: str=\"aabcacb\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aabcacb\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_29",
    "sat": "def sat(t: str, s: str=\"bbbacccccacacbcbbbabbbcbbccbcccaabcccabcacbcbbbbabccacaabbbaccaacaabbbabbbabaaacccabccabaabbababccbcabbccaacabacccabbbcabccaccbcbcababaccbaacabccbbbcabcaaccabbcbcbbacbaabbccacacccaabacabccaacaaaaaccabbbaaaacccbcbcaacaacabcaabcacbbccbaacabcbabcaaccccaabaabbaccbcbabccabbbcabccbaccbaaacaaccccacbbacbabbbaacaccbaaacacccbabbbcbabccaaaaaababbbcbbacabaaccbaabcabbaccaabaacacbcabcacbcccaaaacacabbccbccbcccbccabbababcbabcbaababbabaccbcaaacacabcbaabccbaacababacbacbacaaaabacbccacbcacbcacabacccabaaabababcbccbabaaabbbabcacbaacbaccccbbcccaaaccaaacccbabaaaccbacbacabbccabaaaaabcbcabaabaccacccbcbcbbcbbabcabccccbaababbaabbaaaaacccaaacababacacaaaccccbbcccccbaacbaaaaaaaaccaccbcbbbaccaaaaccaacbacacaa\", target: int=450):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbacccccacacbcbbbabbbcbbccbcccaabcccabcacbcbbbbabccacaabbbaccaacaabbbabbbabaaacccabccabaabbababccbcabbccaacabacccabbbcabccaccbcbcababaccbaacabccbbbcabcaaccabbcbcbbacbaabbccacacccaabacabccaacaaaaaccabbbaaaacccbcbcaacaacabcaabcacbbccbaacabcbabcaaccccaabaabbaccbcbabccabbbcabccbaccbaaacaaccccacbbacbabbbaacaccbaaacacccbabbbcbabccaaaaaababbbcbbacabaaccbaabcabbaccaabaacacbcabcacbcccaaaacacabbccbccbcccbccabbababcbabcbaababbabaccbcaaacacabcbaabccbaacababacbacbacaaaabacbccacbcacbcacabacccabaaabababcbccbabaaabbbabcacbaacbaccccbbcccaaaccaaacccbabaaaccbacbacabbccabaaaaabcbcabaabaccacccbcbcbbcbbabcabccccbaababbaabbaaaaacccaaacababacacaaaccccbbcccccbaacbaaaaaaaaccaccbcbbbaccaaaaccaacbacacaa\", target=450): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_30",
    "sat": "def sat(t: str, s: str=\"ccbaacaacbbbacbaaccbccccacbbcbbcbbacaaacacacccbccbbbbacaaacbaaabcbbcbcbbcbbabbabaaabaccbbbaaaaaaabccbccbabbabaababbbaccbaacbabccbbaccbcacababaababaaacaacaccbbcaabcaacacccabacaaaaaccbccbccacbcbbabcbacbbccbcacbaacbacbbbccbacaacbaaaabbbbacaccaccaaaaaccaccabcbaccbcaabcabbccbabacbbbbacbbabbcbcbaccbcaaaacbabbcbbbcccbaaccbbacbbbaccaaacacabbcccbbbccaaabacabaababaaacaaaacbcbaabcabbacbbacacabaccbabaccabbabbababcbacbbcbcbacababcbbaccbccabbbccbcbbabaabbcabcbcbabaaacbcbccccaaaaccaaccbcbcbbbbccababcaa\", target: int=329):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccbaacaacbbbacbaaccbccccacbbcbbcbbacaaacacacccbccbbbbacaaacbaaabcbbcbcbbcbbabbabaaabaccbbbaaaaaaabccbccbabbabaababbbaccbaacbabccbbaccbcacababaababaaacaacaccbbcaabcaacacccabacaaaaaccbccbccacbcbbabcbacbbccbcacbaacbacbbbccbacaacbaaaabbbbacaccaccaaaaaccaccabcbaccbcaabcabbccbabacbbbbacbbabbcbcbaccbcaaaacbabbcbbbcccbaaccbbacbbbaccaaacacabbcccbbbccaaabacabaababaaacaaaacbcbaabcabbacbbacacabaccbabaccabbabbababcbacbbcbcbacababcbbaccbccabbbccbcbbabaabbcabcbcbabaaacbcbccccaaaaccaaccbcbcbbbbccababcaa\", target=329): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_31",
    "sat": "def sat(t: str, s: str=\"aac\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aac\", target=2): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_32",
    "sat": "def sat(t: str, s: str=\"abaccbcccaabaacccaacccca\", target: int=13):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abaccbcccaabaacccaacccca\", target=13): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_33",
    "sat": "def sat(t: str, s: str=\"acacbabcacabaaabbbacc\", target: int=16):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acacbabcacabaaabbbacc\", target=16): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_34",
    "sat": "def sat(t: str, s: str=\"abbabaacabcccccabcacacaaabbabcaccbbbbbccaabcbcbbabaccaacbcabacccbbaacbccacccabccacababbbcaaaccbcbbbacbbacbaaaaaaaaaacacaabaacccacaabbabbccbccbbcabcabccbabcbaacbcacacbabbcabbaaabaaaccbaaaccbbbcbbbaaccabacbacbccabbaabbcbacabcaccaacacaabccaabbaccbbcabcccabccbbcccbbacbcbbcbabbcbccbabbababcabbabbbacbcbcbcccaacbcbaccabaabcccccacabcbaccccacacaaaacabaabcacbabbccaaaacbccccababcbcbaabacbcbcbcabbbbbaabaaccbbbbaccccabbcbcbaccabcbcbacbcaabacbbbcbbccccabacabbacabccaaacaacbccbaaaabaaccbbbbcbcacaaabcbcaccabacbbaacacabcaaaababbacbcbbabcbbbaabbabccccbbcbcacaaccbcbbcaaaacaacbcacababaa\", target: int=387):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbabaacabcccccabcacacaaabbabcaccbbbbbccaabcbcbbabaccaacbcabacccbbaacbccacccabccacababbbcaaaccbcbbbacbbacbaaaaaaaaaacacaabaacccacaabbabbccbccbbcabcabccbabcbaacbcacacbabbcabbaaabaaaccbaaaccbbbcbbbaaccabacbacbccabbaabbcbacabcaccaacacaabccaabbaccbbcabcccabccbbcccbbacbcbbcbabbcbccbabbababcabbabbbacbcbcbcccaacbcbaccabaabcccccacabcbaccccacacaaaacabaabcacbabbccaaaacbccccababcbcbaabacbcbcbcabbbbbaabaaccbbbbaccccabbcbcbaccabcbcbacbcaabacbbbcbbccccabacabbacabccaaacaacbccbaaaabaaccbbbbcbcacaaabcbcaccabacbbaacacabcaaaababbacbcbbabcbbbaabbabccccbbcbcacaaccbcbbcaaaacaacbcacababaa\", target=387): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_35",
    "sat": "def sat(t: str, s: str=\"baabacccacbbaacba\", target: int=12):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"baabacccacbbaacba\", target=12): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_36",
    "sat": "def sat(t: str, s: str=\"acacbabbacabbbbbcccbcbaaacbbbacbbccbabbbacaaaaaabcccacbbcaabbabcaaaaacabacbaccaabbbcccabcbbccbbcbcacbbccccbbcbbbbabbbaccbbababbbbcaccbabbabcaacabbcbcacabcbbbacabccbbabccbacabccbcabacacbbaaabbab\", target: int=126):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acacbabbacabbbbbcccbcbaaacbbbacbbccbabbbacaaaaaabcccacbbcaabbabcaaaaacabacbaccaabbbcccabcbbccbbcbcacbbccccbbcbbbbabbbaccbbababbbbcaccbabbabcaacabbcbcacabcbbbacabccbbabccbacabccbcabacacbbaaabbab\", target=126): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_37",
    "sat": "def sat(t: str, s: str=\"caababaaacaacaababbcaaccccbcaaacabbcacbbacbcbababccaabcbcbabbbaccbcbcbaaabcccabbababbbcaaacaaababbbbbacbcbcccbabaaacacccaaccbabcabbcacccaabbcbbcaacaacbaccaacacbabaabbbccacbccacaabcaacabbbaacabbabcbccbccaaccabccacabaabbbbcccccbbbcaccbbbabbabbcbccbcbcaccbbccacaacabbabccbccbbaccaabababbaabcacacbbcccabbbbabbbabbcabbcbababbacbbbaaccbaabcbcabaccaabcbb\", target: int=232):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caababaaacaacaababbcaaccccbcaaacabbcacbbacbcbababccaabcbcbabbbaccbcbcbaaabcccabbababbbcaaacaaababbbbbacbcbcccbabaaacacccaaccbabcabbcacccaabbcbbcaacaacbaccaacacbabaabbbccacbccacaabcaacabbbaacabbabcbccbccaaccabccacabaabbbbcccccbbbcaccbbbabbabbcbccbcbcaccbbccacaacabbabccbccbbaccaabababbaabcacacbbcccabbbbabbbabbcabbcbababbacbbbaaccbaabcbcabaccaabcbb\", target=232): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_38",
    "sat": "def sat(t: str, s: str=\"cccbbcbcbcbcbcabcbcccabacbccabaaacbcaccccaba\", target: int=33):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccbbcbcbcbcbcabcbcccabacbccabaaacbcaccccaba\", target=33): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_39",
    "sat": "def sat(t: str, s: str=\"aabcabaaccbbacbcaccbaaaaaacaabcbcbbabcbaaaaacccaabbbbcbcbbcbcbcccabccaccaacacaccccacabcc\", target: int=56):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aabcabaaccbbacbcaccbaaaaaacaabcbcbbabcbaaaaacccaabbbbcbcbbcbcbcccabccaccaacacaccccacabcc\", target=56): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_40",
    "sat": "def sat(t: str, s: str=\"ccaabbccacaacccbcaccbccccbaaababcbacbbbbaabbbbbaccbbbaabaaacbaaccbcbaaacabacbbcccabababcaccbabaacccaaabaaaaccabbacacbccaabccccacbbaaaaabbbaaaaccbaacbcbbbaaaaabbbaaabcbccbbabcabaccbcacaacbcbbacabbacacababbcaacbaccaabbccbbbbacbaaccacbabbbbaacbcacbacbcbbccabbbaaaababcccababacaaaaabbbccaacacbbbcacabcbbcbcaacccacccbaaabbcbabbcaaaabbbbaabcbacbaacaabbcccbbacaccacbbaaccacaccaccbaaaacccabccbaacaccbcbcaababcaacacbbbbbacbcaabaacaccbbcbcababcbabbccbcaaccacaabbcacbbbbaacbaaababbaabcacbbabbbabaaacaacbaacacccbabccaababbcbbaabaacbaacababbcaaaabccbccaaaaaacacaaabcaababaaccbacaaccabccbcacbbbbacbacbabbccbbbbabbacabcaccabbccabcabbcbacacabababaaccccccaabcabcaabaaaaacccbcbbabbabcabaccaabcbbbbccbacbcacabbbaccbcccabaabbaaabcababbacbbbaaaccacbbbccacabbabccbbbacbcbc\", target: int=485):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccaabbccacaacccbcaccbccccbaaababcbacbbbbaabbbbbaccbbbaabaaacbaaccbcbaaacabacbbcccabababcaccbabaacccaaabaaaaccabbacacbccaabccccacbbaaaaabbbaaaaccbaacbcbbbaaaaabbbaaabcbccbbabcabaccbcacaacbcbbacabbacacababbcaacbaccaabbccbbbbacbaaccacbabbbbaacbcacbacbcbbccabbbaaaababcccababacaaaaabbbccaacacbbbcacabcbbcbcaacccacccbaaabbcbabbcaaaabbbbaabcbacbaacaabbcccbbacaccacbbaaccacaccaccbaaaacccabccbaacaccbcbcaababcaacacbbbbbacbcaabaacaccbbcbcababcbabbccbcaaccacaabbcacbbbbaacbaaababbaabcacbbabbbabaaacaacbaacacccbabccaababbcbbaabaacbaacababbcaaaabccbccaaaaaacacaaabcaababaaccbacaaccabccbcacbbbbacbacbabbccbbbbabbacabcaccabbccabcabbcbacacabababaaccccccaabcabcaabaaaaacccbcbbabbabcabaccaabcbbbbccbacbcacabbbaccbcccabaabbaaabcababbacbbbaaaccacbbbccacabbabccbbbacbcbc\", target=485): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_41",
    "sat": "def sat(t: str, s: str=\"bccb\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bccb\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_42",
    "sat": "def sat(t: str, s: str=\"abacabbcabbbcaccccbaccbccabccbcbbcaccaaabbbacabbabbbcabbacacbccbcabbccaabbcbcbabaacaabbabcbaaabcaacacaccbbbcbbbccbacabcbabaabcbcaccabccbbccbcbccacacbabcaabcbabbababbabacaaaacabcbbaabcbbacbccaabaabaabcbaccbacbbccacabbbcccbc\", target: int=160):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abacabbcabbbcaccccbaccbccabccbcbbcaccaaabbbacabbabbbcabbacacbccbcabbccaabbcbcbabaacaabbabcbaaabcaacacaccbbbcbbbccbacabcbabaabcbcaccabccbbccbcbccacacbabcaabcbabbababbabacaaaacabcbbaabcbbacbccaabaabaabcbaccbacbbccacabbbcccbc\", target=160): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_43",
    "sat": "def sat(t: str, s: str=\"ccbbcbcabbbbbcaaaccaabbabacbcbabbbbcaaabcbcaaacbccaccbccabcabbcaccaacabccaabbcbcccccaaacbbccbacccacaacbbaa\", target: int=66):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccbbcbcabbbbbcaaaccaabbabacbcbabbbbcaaabcbcaaacbccaccbccabcabbcaccaacabccaabbcbcccccaaacbbccbacccacaacbbaa\", target=66): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_44",
    "sat": "def sat(t: str, s: str=\"aacbcbacbcacacbbbbcacccbcccbcbcbcccacbcacbabbaccabcbaacabacaccbabaccbbaaaabcbabacaaacbaabacbccbabacbbcaabbbbaabcacbaaacccbccaccaacacaccbbcbccabaccaabaaabacabcacaccaccbcbbb\", target: int=124):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aacbcbacbcacacbbbbcacccbcccbcbcbcccacbcacbabbaccabcbaacabacaccbabaccbbaaaabcbabacaaacbaabacbccbabacbbcaabbbbaabcacbaaacccbccaccaacacaccbbcbccabaccaabaaabacabcacaccaccbcbbb\", target=124): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_45",
    "sat": "def sat(t: str, s: str=\"cbcccbabc\", target: int=7):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcccbabc\", target=7): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_46",
    "sat": "def sat(t: str, s: str=\"cbbbcbaccbaaaccbaaccacbcaaaaacbcbacccabbbc\", target: int=26):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbbcbaccbaaaccbaaccacbcaaaaacbcbacccabbbc\", target=26): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_47",
    "sat": "def sat(t: str, s: str=\"bbaccbacbcaccccbcbacbcbcbabcbcbcbacabaaabbaaacbaa\", target: int=38):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbaccbacbcaccccbcbacbcbcbabcbcbcbacabaaabbaaacbaa\", target=38): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_48",
    "sat": "def sat(t: str, s: str=\"ccbccabbaacacacbccbbbabbccacccbbccbbaabaababbaabaaacbabccccbaccbbbcacccabcbbcaccbacaacabacabcbbcaacbbcbccccccacbacaabbbabaabcabaacbbacacabbcbacababacbbbbcabbcbcbacbbcaacacacabbabbbccacaccbbcbcaabbcabcbcabccccbaacccbacabcaaacacbaabcccacbbcbaaabaabbacaccccaacbbbcacbabbabaabcbcabbbacbabcaacbabaacabcaaccbaacabbaabaacccbbbcccacacbabbcabbaaaaabbaaccbbacbcbbccacbabbabccbacacbaabbaccaacabcaacbbababbaccaabbbbacabaccbabbccbbccabacacbaaabacbaccbcabcabccbccccbacbbaabaaabcbaccccaacabaacccbabcbbaabacbabbaaccacaccabcbbbcccbcaabcabaabaccabbcccacacbcbabbbaaabaabbbcababacbbabaaabcaccbbcbbcbacacccabaaccbcbbaacccabaababcabcabaacbaabbaabaacaabbbccaacbbaabaaacbcccaacacacabaacbaaaabbbabbcaacabcbcccccccbacabbababbaacbbbaacabbcababbacbacbcccacaabcbccbabacacbccaaccbbacacaacbaccabcaaacaccbbcacabcacaaacbaaaaabbbaaacaacababacaccaababacaacabbabbacbcabbaabcaaaaaacbbbbaacccccaacbcabcaaaacbbaaaabaabaabacbaccbbcabaacbbacabbaabcaaabbcbcbaaaaccacccbcaccbbcc\", target: int=636):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"ccbccabbaacacacbccbbbabbccacccbbccbbaabaababbaabaaacbabccccbaccbbbcacccabcbbcaccbacaacabacabcbbcaacbbcbccccccacbacaabbbabaabcabaacbbacacabbcbacababacbbbbcabbcbcbacbbcaacacacabbabbbccacaccbbcbcaabbcabcbcabccccbaacccbacabcaaacacbaabcccacbbcbaaabaabbacaccccaacbbbcacbabbabaabcbcabbbacbabcaacbabaacabcaaccbaacabbaabaacccbbbcccacacbabbcabbaaaaabbaaccbbacbcbbccacbabbabccbacacbaabbaccaacabcaacbbababbaccaabbbbacabaccbabbccbbccabacacbaaabacbaccbcabcabccbccccbacbbaabaaabcbaccccaacabaacccbabcbbaabacbabbaaccacaccabcbbbcccbcaabcabaabaccabbcccacacbcbabbbaaabaabbbcababacbbabaaabcaccbbcbbcbacacccabaaccbcbbaacccabaababcabcabaacbaabbaabaacaabbbccaacbbaabaaacbcccaacacacabaacbaaaabbbabbcaacabcbcccccccbacabbababbaacbbbaacabbcababbacbacbcccacaabcbccbabacacbccaaccbbacacaacbaccabcaaacaccbbcacabcacaaacbaaaaabbbaaacaacababacaccaababacaacabbabbacbcabbaabcaaaaaacbbbbaacccccaacbcabcaaaacbbaaaabaabaabacbaccbbcabaacbbacabbaabcaaabbcbcbaaaaccacccbcaccbbcc\", target=636): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_49",
    "sat": "def sat(t: str, s: str=\"bcbabcabbbcbbbaaaccbcbcacabacbbcbbcaacacaacbccaacacaaaccbaacbbbaacaacacccabcabbcabbbabcacbbcacaacaabbacabccbbbbcccacabaaababababcbccaabcabbabcbabbbacaaabcacbccabcaacbbbbcaccbaabacacaabaaabacccaacbcbbcaccbabbbbcabccabbaacaaaaaabbaabcbbbcabacbbbbabbcbabbcacbcabaccbaacacbbacbbabcbaacbabbacbaacab\", target: int=206):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbabcabbbcbbbaaaccbcbcacabacbbcbbcaacacaacbccaacacaaaccbaacbbbaacaacacccabcabbcabbbabcacbbcacaacaabbacabccbbbbcccacabaaababababcbccaabcabbabcbabbbacaaabcacbccabcaacbbbbcaccbaabacacaabaaabacccaacbcbbcaccbabbbbcabccabbaacaaaaaabbaabcbbbcabacbbbbabbcbabbcacbcabaccbaacacbbacbbabcbaacbabbacbaacab\", target=206): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_50",
    "sat": "def sat(t: str, s: str=\"abbccacbcccbccccbbccabcabacaaabbabb\", target: int=22):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abbccacbcccbccccbbccabcabacaaabbabb\", target=22): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_51",
    "sat": "def sat(t: str, s: str=\"abcabcbababcccbaabbcaccacbacbccbabacbbc\", target: int=32):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abcabcbababcccbaabbcaccacbacbccbabacbbc\", target=32): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_52",
    "sat": "def sat(t: str, s: str=\"\", target: int=0):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"\", target=0): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_53",
    "sat": "def sat(t: str, s: str=\"cccbbbaababacbbccabcaccbb\", target: int=16):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccbbbaababacbbccabcaccbb\", target=16): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_54",
    "sat": "def sat(t: str, s: str=\"cbcbbbaabbbbaaaccccbccbccbcbbabaaccbaaaabcaccacaaaabaabbcbacbbbcbcbbbbacccaacccbaacbbbbbbabcb\", target: int=52):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcbbbaabbbbaaaccccbccbccbcbbabaaccbaaaabcaccacaaaabaabbcbacbbbcbcbbbbacccaacccbaacbbbbbbabcb\", target=52): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_55",
    "sat": "def sat(t: str, s: str=\"babaaacb\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babaaacb\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_56",
    "sat": "def sat(t: str, s: str=\"acccbbcbccaabcbcccaacaccccbaaaabcaabcacacbcbcaccaabaccacbacccacbcc\", target: int=45):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acccbbcbccaabcbcccaacaccccbaaaabcaabcacacbcbcaccaabaccacbacccacbcc\", target=45): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_57",
    "sat": "def sat(t: str, s: str=\"caaaccacabbbabbacccabbbcacabbbabccccbabaaccba\", target: int=28):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caaaccacabbbabbacccabbbcacabbbabccccbabaaccba\", target=28): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_58",
    "sat": "def sat(t: str, s: str=\"abccbacbbccccabbbccbaccacbcca\", target: int=19):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abccbacbbccccabbbccbaccacbcca\", target=19): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_59",
    "sat": "def sat(t: str, s: str=\"bbbcaabba\", target: int=5):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbcaabba\", target=5): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_60",
    "sat": "def sat(t: str, s: str=\"caccaaacacccaabcabcaabbccbcbcbabaabbcbacaababcbccbabacababcbaaaabbacacabbcbbbbccbbbcabacbaaacabccacacaacabbacacabaabcbccbcbbcacaaaaaabcbabaacccbccacaabaacaabaabbaaabbbbcacacbbccaaccaaacbbcbcabcaaabcbccabbcbcabbbaaaaabacbcbbbccbcbcbcbccbbcbaabcababaccabccbcacabacaabaaabacaabbcabbccbabaccbbcbcbbcabbabcbacbababaccbbccbbcccbabbcbaccbbbacccbccbccbbbbbccbacbbaabcabbcbabbbccccbccacabababcbaababbccbbaccbbccacbbcbcabacbbaababbccbccbabcabcaabbabcaaabbbabbcccbbccccccbcbcaacacacacbaaaaccaabaccaaacbcbaaabbccbcabccbaaccacacbacccabcbbabbabcbccabbaabaacbbccbabccaaaccaaacab\", target: int=388):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caccaaacacccaabcabcaabbccbcbcbabaabbcbacaababcbccbabacababcbaaaabbacacabbcbbbbccbbbcabacbaaacabccacacaacabbacacabaabcbccbcbbcacaaaaaabcbabaacccbccacaabaacaabaabbaaabbbbcacacbbccaaccaaacbbcbcabcaaabcbccabbcbcabbbaaaaabacbcbbbccbcbcbcbccbbcbaabcababaccabccbcacabacaabaaabacaabbcabbccbabaccbbcbcbbcabbabcbacbababaccbbccbbcccbabbcbaccbbbacccbccbccbbbbbccbacbbaabcabbcbabbbccccbccacabababcbaababbccbbaccbbccacbbcbcabacbbaababbccbccbabcabcaabbabcaaabbbabbcccbbccccccbcbcaacacacacbaaaaccaabaccaaacbcbaaabbccbcabccbaaccacacbacccabcbbabbabcbccabbaabaacbbccbabccaaaccaaacab\", target=388): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_61",
    "sat": "def sat(t: str, s: str=\"caaab\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caaab\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_62",
    "sat": "def sat(t: str, s: str=\"abcbaaac\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abcbaaac\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_63",
    "sat": "def sat(t: str, s: str=\"bbcabbaabbabaccbcbccbcbbbaaaccbcbaaacaacacacccbccaaaccabbaccacccabbcaabbccbaacacababaaabcabccabcbcccbbaabbbaacbaacbacaabcabcbcaacbcababbbbabccaacacaaabaaaabaccbbbbbcbcbcababbaabcacaacbaccaccbcbbbbccbcabbbaacacbaaccccbabaacbbabcaaaababccaacbcccccacccbcbcaabacbcabccccaabcaaacbccaaacaaacbbccbcacbbbaacbccbaacccbccbaabbbcbcbcacacabccbbabcbccccabaaacbbbaabacbacaccbbcbccaaccabccbbacacaacbccbccaacccabbbabbcbabaccaabcbacbcbcbaaccbaaabbacabbcbbcbcaccccbacacbcbcbbbbccbbbbacbbcaacbacbcacbabacaaacaabbabbcabbbaaccabcaaacccbbbababcabaacbaccabacacbaaccbbccabacbccbbcbaaabacaccbacaabbbcabacabbcabbaabcaacbccbbabbcbbacacabcbbcbbacbbaacabba\", target: int=427):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbcabbaabbabaccbcbccbcbbbaaaccbcbaaacaacacacccbccaaaccabbaccacccabbcaabbccbaacacababaaabcabccabcbcccbbaabbbaacbaacbacaabcabcbcaacbcababbbbabccaacacaaabaaaabaccbbbbbcbcbcababbaabcacaacbaccaccbcbbbbccbcabbbaacacbaaccccbabaacbbabcaaaababccaacbcccccacccbcbcaabacbcabccccaabcaaacbccaaacaaacbbccbcacbbbaacbccbaacccbccbaabbbcbcbcacacabccbbabcbccccabaaacbbbaabacbacaccbbcbccaaccabccbbacacaacbccbccaacccabbbabbcbabaccaabcbacbcbcbaaccbaaabbacabbcbbcbcaccccbacacbcbcbbbbccbbbbacbbcaacbacbcacbabacaaacaabbabbcabbbaaccabcaaacccbbbababcabaacbaccabacacbaaccbbccabacbccbbcbaaabacaccbacaabbbcabacabbcabbaabcaacbccbbabbcbbacacabcbbcbbacbbaacabba\", target=427): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_64",
    "sat": "def sat(t: str, s: str=\"aacbcabbccbcbbcacabccccacabbbaaacacaabbaabcbccacbacaccccbcaabcbaabaabbaccbcacabacabaabcabcbaccbcbbbbbccabbabbbcaaabbbbaaabacababcaccacbcbcbcbacbbccabcaccaacccaabbcbacacaacacabbbababbabacccabcbbbacbbabbcaababbcbbacbacbbbbccccbcbbaacaccaaccababccabcbcbaabbaaabcbaaccaaaabacccbbababcabcabaccccccacacccaabbaaaccbaaccbacabbacaacbbaabbbbbaaaaaccabbaacbcbcccbbbbcabaabccabcabccbccaacacbbaaaaacaccbccbbcaccaaaabcbccaaabcabccaaaaababaccabaaabbcc\", target: int=286):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aacbcabbccbcbbcacabccccacabbbaaacacaabbaabcbccacbacaccccbcaabcbaabaabbaccbcacabacabaabcabcbaccbcbbbbbccabbabbbcaaabbbbaaabacababcaccacbcbcbcbacbbccabcaccaacccaabbcbacacaacacabbbababbabacccabcbbbacbbabbcaababbcbbacbacbbbbccccbcbbaacaccaaccababccabcbcbaabbaaabcbaaccaaaabacccbbababcabcabaccccccacacccaabbaaaccbaaccbacabbacaacbbaabbbbbaaaaaccabbaacbcbcccbbbbcabaabccabcabccbccaacacbbaaaaacaccbccbbcaccaaaabcbccaaabcabccaaaaababaccabaaabbcc\", target=286): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_65",
    "sat": "def sat(t: str, s: str=\"bbbbacbcccbacbaacccbbbbbabbbaaccaaacbbacaccbccaaccccccacab\", target: int=31):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbbacbcccbacbaacccbbbbbabbbaaccaaacbbacaccbccaaccccccacab\", target=31): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_66",
    "sat": "def sat(t: str, s: str=\"abacaaaabbbabaaaaccabcaacccbacccbccbbbabcabbabccabccababacaccbcabbabaacccacbcababccbaacbbccbcccbbccabbbaaaabbacaaaaccacaaabbbcbcbbbbbccaabcaaacacbaaababacababcabbbcaacbccaccaababaaccaccccabbabbaacbcccabccbaccbaaabcbacbccacabbbcbcbccabcaacaaaaabbacaaacbacbcbccacaacabcbaaaccaacbcaaaccbbaaaacbccbbcaaacabcbcbbcacaacabcbacccccccccabaaacacabbaabbcbcabbcbcacbcbbcabaaabbcabccbacbbabbaaaaccbcccbbabaaacaaaaababacbcacbbbcbacaabbcabaaabababbcabaaacacabbaacbacccabaccbabbbbccccbbacacbbcabcabccaaccccaccbcabcbbaabbbacccaccacababbbbcabbaaacaccccacbccbaccacabcabbbabbaaaccacabcbaaacbccaabbcacbaabaaccabcabbbabcccacbacaccaacacabcbaaccbaaacaaacacbaacabcbcabbabaaaabcaaccaaaabccacaacba\", target: int=444):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abacaaaabbbabaaaaccabcaacccbacccbccbbbabcabbabccabccababacaccbcabbabaacccacbcababccbaacbbccbcccbbccabbbaaaabbacaaaaccacaaabbbcbcbbbbbccaabcaaacacbaaababacababcabbbcaacbccaccaababaaccaccccabbabbaacbcccabccbaccbaaabcbacbccacabbbcbcbccabcaacaaaaabbacaaacbacbcbccacaacabcbaaaccaacbcaaaccbbaaaacbccbbcaaacabcbcbbcacaacabcbacccccccccabaaacacabbaabbcbcabbcbcacbcbbcabaaabbcabccbacbbabbaaaaccbcccbbabaaacaaaaababacbcacbbbcbacaabbcabaaabababbcabaaacacabbaacbacccabaccbabbbbccccbbacacbbcabcabccaaccccaccbcabcbbaabbbacccaccacababbbbcabbaaacaccccacbccbaccacabcabbbabbaaaccacabcbaaacbccaabbcacbaabaaccabcabbbabcccacbacaccaacacabcbaaccbaaacaaacacbaacabcbcabbabaaaabcaaccaaaabccacaacba\", target=444): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_67",
    "sat": "def sat(t: str, s: str=\"caabbbbacbaabcccaacaaabbaccbaacabcababcbaaabbcbbbabacabcbcbccacacbbccbabbcaaabcbaccbbbaccaacbbcaccbbccabbabcbbccaacbbbcaaacbbcabccbabbaacbacccbabaaabbcabcaaabccbbaabbbaaccbbbbcabbcbbbabaabcbcbcaacacbbabccacccbbacaacbaccabb\", target: int=147):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caabbbbacbaabcccaacaaabbaccbaacabcababcbaaabbcbbbabacabcbcbccacacbbccbabbcaaabcbaccbbbaccaacbbcaccbbccabbabcbbccaacbbbcaaacbbcabccbabbaacbacccbabaaabbcabcaaabccbbaabbbaaccbbbbcabbcbbbabaabcbcbcaacacbbabccacccbbacaacbaccabb\", target=147): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_68",
    "sat": "def sat(t: str, s: str=\"cbbabababccaaccabccaaaccbbaaaabcaacbbabcbbbcaa\", target: int=29):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbabababccaaccabccaaaccbbaaaabcaacbbabcbbbcaa\", target=29): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_69",
    "sat": "def sat(t: str, s: str=\"abcccbaabcaacababbaccacbbbcbbbccbacabcacacbbcbcbabbccbbacbcaccacbcacbabbbcaacaacbabcccaaaccacbaaaaabbbbcbcccbcbcaccaabcbaaaaaccabaaabacacbcabbbababbccbccabaabaaacacaccacababbcacccbaabbaabcbbbbcbcbccccaaaacacacbabacbcaacbbbcacbaaccacbbabbcbacbbbabbbbbacccaaaaccabbaacaaacaacccbccccacbaacababbabcabbacaacccbcbacbbbbbcbccacbbaabbaccbcabbccbcbacacbabbacbacbabcacbaabcbcccababccbccacbacbabcabaabcaaacbbcbbbbaccabacccbcacccaccabbcbcbccbaaabaccbcbaaaabbbccabbcbababccbaabcabcaaacbbbbbbacccabccbcbacbcaacbbaabacacaccabccabbbcbaacaacaabcbacacaabbccbbababcbccaccacbcaccbbcacacaaabcbbcbabcabccbabaaabacabaaaccaaaabccbacabbbccbbaabbabbbacabaaacbbaacacabbcacbbaaaabbbbbbacbcccbacbbbbbaccaabbbbababcaababbaabcacaccbccbcacaaacbbbbaabbbcbaaccbbaccabacbbbabbccbcbbbbcccbabccbababbbcbabcbcbbcbaabbbccabaaabacaaccaaababbbccccbabcbaabbbacaaccabbbaababca\", target: int=560):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abcccbaabcaacababbaccacbbbcbbbccbacabcacacbbcbcbabbccbbacbcaccacbcacbabbbcaacaacbabcccaaaccacbaaaaabbbbcbcccbcbcaccaabcbaaaaaccabaaabacacbcabbbababbccbccabaabaaacacaccacababbcacccbaabbaabcbbbbcbcbccccaaaacacacbabacbcaacbbbcacbaaccacbbabbcbacbbbabbbbbacccaaaaccabbaacaaacaacccbccccacbaacababbabcabbacaacccbcbacbbbbbcbccacbbaabbaccbcabbccbcbacacbabbacbacbabcacbaabcbcccababccbccacbacbabcabaabcaaacbbcbbbbaccabacccbcacccaccabbcbcbccbaaabaccbcbaaaabbbccabbcbababccbaabcabcaaacbbbbbbacccabccbcbacbcaacbbaabacacaccabccabbbcbaacaacaabcbacacaabbccbbababcbccaccacbcaccbbcacacaaabcbbcbabcabccbabaaabacabaaaccaaaabccbacabbbccbbaabbabbbacabaaacbbaacacabbcacbbaaaabbbbbbacbcccbacbbbbbaccaabbbbababcaababbaabcacaccbccbcacaaacbbbbaabbbcbaaccbbaccabacbbbabbccbcbbbbcccbabccbababbbcbabcbcbbcbaabbbccabaaabacaaccaaababbbccccbabcbaabbbacaaccabbbaababca\", target=560): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_70",
    "sat": "def sat(t: str, s: str=\"babcccccccbcacbabaccccabccaacbbbcbcbbbacbcaabbbcbbcbcabcbccbcaacbbcbabbcabcabbbacb\", target: int=57):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babcccccccbcacbabaccccabccaacbbbcbcbbbacbcaabbbcbbcbcabcbccbcaacbbcbabbcabcabbbacb\", target=57): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_71",
    "sat": "def sat(t: str, s: str=\"abccabbcbabaaccccbbbcccabcaaaacabacbcaaaabacaaacbaacbaccacbacacaacccbbcacbbabaaccabbbaaa\", target: int=57):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abccabbcbabaaccccbbbcccabcaaaacabacbcaaaabacaaacbaacbaccacbacacaacccbbcacbbabaaccabbbaaa\", target=57): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_72",
    "sat": "def sat(t: str, s: str=\"acabcca\", target: int=6):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acabcca\", target=6): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_73",
    "sat": "def sat(t: str, s: str=\"cabccbcccacbbabcbcbcabbcbabbcccaabccaaccaccbcbccbabaabacaacabbbbbcbaabcbbbac\", target: int=53):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cabccbcccacbbabcbcbcabbcbabbcccaabccaaccaccbcbccbabaabacaacabbbbbcbaabcbbbac\", target=53): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_74",
    "sat": "def sat(t: str, s: str=\"cababbbcccacaaabbcbbabbacacbcababccabbcccbabbabcbaccabbacbbbbacbabbaaacaaabaaabbaaacacabbcbacbbcaacbbaaaaccabccacabbcbaaacabbacaacbbacbcabbccbccabbcabcccbcacbcbabbbbabccbccbcbccabcbccbbbaaabaccbcccabbcaabbaabcababcbcbbbbbaacacaacbcabacbbcabcccbbbbabbbbbcccbacaabbaabaacbcbcabababcbbbaacaaaccccbcbbaaabcccbcbbabacabbbbcababbbacababaccccababbcabbacbcaacaaaabbcaaaabcbcbbbaaaaccbbcbcaaccbcaabccacbcbaaccaaaaacb\", target: int=268):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cababbbcccacaaabbcbbabbacacbcababccabbcccbabbabcbaccabbacbbbbacbabbaaacaaabaaabbaaacacabbcbacbbcaacbbaaaaccabccacabbcbaaacabbacaacbbacbcabbccbccabbcabcccbcacbcbabbbbabccbccbcbccabcbccbbbaaabaccbcccabbcaabbaabcababcbcbbbbbaacacaacbcabacbbcabcccbbbbabbbbbcccbacaabbaabaacbcbcabababcbbbaacaaaccccbcbbaaabcccbcbbabacabbbbcababbbacababaccccababbcabbacbcaacaaaabbcaaaabcbcbbbaaaaccbbcbcaaccbcaabccacbcbaaccaaaaacb\", target=268): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_75",
    "sat": "def sat(t: str, s: str=\"babcbbaacbcabcccbaabbbccbbbabcbaaaabcacabababaacccbabccbcbaacbacbbaacaabbbbcbacacbcccbacaccbcabbbcbbccbababbbcbcbbcbbabbccacccacccccabcabcbbbccacabccccacbccbbacacbbbbbbbcbaacbcbaabcccbbbacbbaccbacbbbbcacacbababbabcbcababbcaaaccccacbbbacbaabccacbbcbcbbcabcbbcbcaaabacaabbabacbabcaaaaaaacbcabbbacbcbbcbaabcbbacabababccaaabccaabccbcccabaccbacbaaabaaaccbbabcbbabcccacbacacacccbacccccbcacaaaacaaccbabbcbcabaababaababbacacaaabaabcbbccabacbcaccaacccaababcaacbaccccbbcccbcabacaaccbababcabbbaaccbabcbbabcbcbababacbbabbaabbbaacabcbaabcaabccaccbaacccbcccbaccbcbcacabababababbbaabaaacbbcabcbbaaacbabbcacbacccaaabcbbaaaccbacabbaacbbcbcabcabaabacccaabbccbabbcbacbcaacabbbbccbbabcbcabcbbbbcaccbbcaacaaabaacabbaaccabcaccbcaaaccacabacb\", target: int=498):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babcbbaacbcabcccbaabbbccbbbabcbaaaabcacabababaacccbabccbcbaacbacbbaacaabbbbcbacacbcccbacaccbcabbbcbbccbababbbcbcbbcbbabbccacccacccccabcabcbbbccacabccccacbccbbacacbbbbbbbcbaacbcbaabcccbbbacbbaccbacbbbbcacacbababbabcbcababbcaaaccccacbbbacbaabccacbbcbcbbcabcbbcbcaaabacaabbabacbabcaaaaaaacbcabbbacbcbbcbaabcbbacabababccaaabccaabccbcccabaccbacbaaabaaaccbbabcbbabcccacbacacacccbacccccbcacaaaacaaccbabbcbcabaababaababbacacaaabaabcbbccabacbcaccaacccaababcaacbaccccbbcccbcabacaaccbababcabbbaaccbabcbbabcbcbababacbbabbaabbbaacabcbaabcaabccaccbaacccbcccbaccbcbcacabababababbbaabaaacbbcabcbbaaacbabbcacbacccaaabcbbaaaccbacabbaacbbcbcabcabaabacccaabbccbabbcbacbcaacabbbbccbbabcbcabcbbbbcaccbbcaacaaabaacabbaaccabcaccbcaaaccacabacb\", target=498): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_76",
    "sat": "def sat(t: str, s: str=\"bbbcbb\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbbcbb\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_77",
    "sat": "def sat(t: str, s: str=\"cbbcbaabbabbbabcbcacaaaacaaaccbbcbbbccbaacccccbbbabbcbbbbbccaccaccabcbcaccbbbacaabacbcbacacbbaabbcaaaabcaaaacbacbcaaaccaabcbbbbaabcacccabcccacaaabbbccabbbaabbbccaacbbcbcaccccbacabbbbbcbccbbcbaabaaabaaabcccbabbbcabcaabcabcabccbaaaaaaabcaaabbbccabbccacbaccaabaabcaabbcbabaccabaabbcabbccabcbbcbacaaaacbcbacabcabaaaacabbbbccacbcbcbcbacabbbabcabacbbcbcabcbbbcaccbbcbbccbbcbcabacabccabccaacbcbbcabbbbacacbabcaaccabcaccabacacabcbaacabbacacbaabcbbcabbaabaaacbacccbacbcaccabaaacbbbbaaacabaaabbabccababaccbcbcacaacbaabbbccbbbcacabcbaacababcabcbbbbabbaaaacccabbacbcacacacaaaaabbbacaabacbbcccbabbbcbbacacaaabcbcababaacabbacbcabbccbcbccababbaabaccbbaabbacb\", target: int=434):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbcbaabbabbbabcbcacaaaacaaaccbbcbbbccbaacccccbbbabbcbbbbbccaccaccabcbcaccbbbacaabacbcbacacbbaabbcaaaabcaaaacbacbcaaaccaabcbbbbaabcacccabcccacaaabbbccabbbaabbbccaacbbcbcaccccbacabbbbbcbccbbcbaabaaabaaabcccbabbbcabcaabcabcabccbaaaaaaabcaaabbbccabbccacbaccaabaabcaabbcbabaccabaabbcabbccabcbbcbacaaaacbcbacabcabaaaacabbbbccacbcbcbcbacabbbabcabacbbcbcabcbbbcaccbbcbbccbbcbcabacabccabccaacbcbbcabbbbacacbabcaaccabcaccabacacabcbaacabbacacbaabcbbcabbaabaaacbacccbacbcaccabaaacbbbbaaacabaaabbabccababaccbcbcacaacbaabbbccbbbcacabcbaacababcabcbbbbabbaaaacccabbacbcacacacaaaaabbbacaabacbbcccbabbbcbbacacaaabcbcababaacabbacbcabbccbcbccababbaabaccbbaabbacb\", target=434): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_78",
    "sat": "def sat(t: str, s: str=\"cacccbbbbacccaaacbbaabbccbaaccbaccbcccaac\", target: int=22):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cacccbbbbacccaaacbbaabbccbaaccbaccbcccaac\", target=22): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_79",
    "sat": "def sat(t: str, s: str=\"bcbbbcbbbbaaccccabbacabababccacaacbcaacbcacccabcabcabcabbabbccccbcbbcaababccacabaacbccacccbabccbacabcbbbacacbcabacccaccbcacbbbcbcbbaacabbbbabcbbcacaccccaabaabcaccabcbcccaaabccbaabbcbbcbbaacbcaaaaaacaaccaaaaaacacccbcabbbbbbaccccaaabbcabcacaaaaccacaaababcbacbbabcaabbcaacaabccaabbacabbccababbaacaabacaccacccccabcbcabcacabbbacacababbbabacbccbbabccacabcbcaccaccbabbaaccbabbabcaaccccccbcbaaabcccabcabccbbabbccbbccbbcacbbaaabbaabacaaaaaacbcbaaccbbabbbccbcbcccabbcbbcccccaabcbccbbccccbccbcaccbbbbabbaabcaabcbccaaaccbabacbcbbaaabbccbaccaababbacaccccabbcaacabaacbcabaaaacbaacacbcbccbabbccbaacabbbbbacabaabaaabbbacaaabaacbbabacbcbbacabcacabcabccbacbabaccbbababcbccbcbbccbbacbacabccaacaaabaaacbbcbcabcbbccabcbbcbcbaaaaabaccbbabaccccbcbabbabbbaabccaaaacbababbbaababbcbbaaaabccaaabcbbaaaacccccccbabaccabcbcbcacaaaaaaacababbcaaabbcbbbaaabbbbbbbacabaaaabccabcccaccaccacbaaacaccbccbbbcbacbcbbacabcaabcbabcbabbb\", target: int=586):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bcbbbcbbbbaaccccabbacabababccacaacbcaacbcacccabcabcabcabbabbccccbcbbcaababccacabaacbccacccbabccbacabcbbbacacbcabacccaccbcacbbbcbcbbaacabbbbabcbbcacaccccaabaabcaccabcbcccaaabccbaabbcbbcbbaacbcaaaaaacaaccaaaaaacacccbcabbbbbbaccccaaabbcabcacaaaaccacaaababcbacbbabcaabbcaacaabccaabbacabbccababbaacaabacaccacccccabcbcabcacabbbacacababbbabacbccbbabccacabcbcaccaccbabbaaccbabbabcaaccccccbcbaaabcccabcabccbbabbccbbccbbcacbbaaabbaabacaaaaaacbcbaaccbbabbbccbcbcccabbcbbcccccaabcbccbbccccbccbcaccbbbbabbaabcaabcbccaaaccbabacbcbbaaabbccbaccaababbacaccccabbcaacabaacbcabaaaacbaacacbcbccbabbccbaacabbbbbacabaabaaabbbacaaabaacbbabacbcbbacabcacabcabccbacbabaccbbababcbccbcbbccbbacbacabccaacaaabaaacbbcbcabcbbccabcbbcbcbaaaaabaccbbabaccccbcbabbabbbaabccaaaacbababbbaababbcbbaaaabccaaabcbbaaaacccccccbabaccabcbcbcacaaaaaaacababbcaaabbcbbbaaabbbbbbbacabaaaabccabcccaccaccacbaaacaccbccbbbcbacbcbbacabcaabcbabcbabbb\", target=586): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_80",
    "sat": "def sat(t: str, s: str=\"bbabbaaaccbabbcbaaccbbbccaabbb\", target: int=16):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbabbaaaccbabbcbaaccbbbccaabbb\", target=16): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_81",
    "sat": "def sat(t: str, s: str=\"cbbcaacbcbaaccabcaacaccabbabaacaaacccbaabaccbccacbbbaccbbccbbcaabaccacaacbbababccbcbbbbbcabbbbcbaaaccbabcababbacacbbacbbbabbbababaaacacbacaaabacbbcabacbccacbcccaacaaaacababcccabcbacbaacccccbbabcbaaccccabcaaaacacaaaaacaaccacacbaccabbcccbcbbaabbacbabccacbaabbccaaabbbcababbaaaaccaabcbaabcbabccabcaabcccbacabcabbbcccaaacccaabbacabbcbbaaabbbbbcbaccabaaaabaabccccaccbbcabacbabcaabbaacabcbccaaabcabaacabcabbaccbcbbcbccccaccabbcbacbabacbbcbbabaaacbacbbcacacccaababaaaaabcaccbbaabbcaacacabccccccccbcbaaaababaabbcbccabbababbccccaaabacbbaaabbbacbaaaccbabccabc\", target: int=359):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbbcaacbcbaaccabcaacaccabbabaacaaacccbaabaccbccacbbbaccbbccbbcaabaccacaacbbababccbcbbbbbcabbbbcbaaaccbabcababbacacbbacbbbabbbababaaacacbacaaabacbbcabacbccacbcccaacaaaacababcccabcbacbaacccccbbabcbaaccccabcaaaacacaaaaacaaccacacbaccabbcccbcbbaabbacbabccacbaabbccaaabbbcababbaaaaccaabcbaabcbabccabcaabcccbacabcabbbcccaaacccaabbacabbcbbaaabbbbbcbaccabaaaabaabccccaccbbcabacbabcaabbaacabcbccaaabcabaacabcabbaccbcbbcbccccaccabbcbacbabacbbcbbabaaacbacbbcacacccaababaaaaabcaccbbaabbcaacacabccccccccbcbaaaababaabbcbccabbababbccccaaabacbbaaabbbacbaaaccbabccabc\", target=359): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_82",
    "sat": "def sat(t: str, s: str=\"caa\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caa\", target=2): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_83",
    "sat": "def sat(t: str, s: str=\"cbcbcacbaabacab\", target: int=14):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcbcacbaabacab\", target=14): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_84",
    "sat": "def sat(t: str, s: str=\"cccbcbcabbacbabbcaccaaabccccbcbcbbacabbbbbcaacaaabaabbcbaacaaacaaacbbaabbcbcbbcccccaccccbbccaabbcabbccccaccbccbabcaacbbbbbbacaacbbbbcaccabcbcabcccacbbcaaabcbccbcabcabcbbbcbabcacaacccacabccbcbcbbbabbbaabccccabacccbaacbcaaabcbcacbabcaabbcacbbbcbcbccccccbbbbabacccbcaaaaaabcaaccbabcaabcbcacbabcbcabcabacbaaaaaaaabbabbabaabbbcccbbaccbbaacacacabcaababaabcbcacaaaaccaaccaabbcabaccacaaacbbbccaaaabaaabaabacbabcccaaaaccccccabcbccacaabcacaccaabaababccbbbcbbccccbbbbcccaaaaaaacaacacaacaccbcabcaacabbacaacbacbbbababaacaacbcabcababccbbabaacbaabaccaccaccabcacccbaccaabbccbbcababacaabbaccaababccccaccaaabbbccabb\", target: int=382):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cccbcbcabbacbabbcaccaaabccccbcbcbbacabbbbbcaacaaabaabbcbaacaaacaaacbbaabbcbcbbcccccaccccbbccaabbcabbccccaccbccbabcaacbbbbbbacaacbbbbcaccabcbcabcccacbbcaaabcbccbcabcabcbbbcbabcacaacccacabccbcbcbbbabbbaabccccabacccbaacbcaaabcbcacbabcaabbcacbbbcbcbccccccbbbbabacccbcaaaaaabcaaccbabcaabcbcacbabcbcabcabacbaaaaaaaabbabbabaabbbcccbbaccbbaacacacabcaababaabcbcacaaaaccaaccaabbcabaccacaaacbbbccaaaabaaabaabacbabcccaaaaccccccabcbccacaabcacaccaabaababccbbbcbbccccbbbbcccaaaaaaacaacacaacaccbcabcaacabbacaacbacbbbababaacaacbcabcababccbbabaacbaabaccaccaccabcacccbaccaabbccbbcababacaabbaccaababccccaccaaabbbccabb\", target=382): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_85",
    "sat": "def sat(t: str, s: str=\"bbaabbcbcaaabcbaabbbcacaccabaaacababacbbaababbbbcbabaabcbabaacaaabaccbbaacacabacccaccacbcaaabbccbcaabcacbccbccaaccbbababcaabbcccaacbbcbccbcabbcbabaaacababaaccbbccbcacbccacccbcaaacbaabcaaabbcbcacbaccacaabbbcbbccabaabacac\", target: int=153):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bbaabbcbcaaabcbaabbbcacaccabaaacababacbbaababbbbcbabaabcbabaacaaabaccbbaacacabacccaccacbcaaabbccbcaabcacbccbccaaccbbababcaabbcccaacbbcbccbcabbcbabaaacababaaccbbccbcacbccacccbcaaacbaabcaaabbcbcacbaccacaabbbcbbccabaabacac\", target=153): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_86",
    "sat": "def sat(t: str, s: str=\"acacbacbbaabbcbcaccacbccbbbaccbaaaabacaabaacabcabaabccbabbaaabacacabacacbabcaaccabcaabcabcacbabaaccccbccbbcaacbcbaaaaaacabaacaababcaaccbbbcbacbababcababbcacbccbcbbcc\", target: int=122):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acacbacbbaabbcbcaccacbccbbbaccbaaaabacaabaacabcabaabccbabbaaabacacabacacbabcaaccabcaabcabcacbabaaccccbccbbcaacbcbaaaaaacabaacaababcaaccbbbcbacbababcababbcacbccbcbbcc\", target=122): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_87",
    "sat": "def sat(t: str, s: str=\"babcbabccabbbcaabbaacaaacbbccbccabaabacaacaacaaabcabcbacbcbcaccaabbaaabcbcaccbbbbccbcccccbbabbaaabacabcbcacabaababbacabaacabcaaacbaccbaaccabaccbbabacabccababccbabcbcacbcacbcbbacbababcacbbabbabccbabbcabcabccabcaacbcbbaaacbbbbacbcbbbbcbccbaaaaaabcbcbcbaccabacababaabcbbbccabacbbcbbbaabbacaccabaaaaccbbabbcaaabcbbbbcaaabacbaacacaabbbbccaccabbcbabacccbcaacacbcacbabcbabbacacabaaaababaabbaccbbcbbbbcccccccabababbabcabbaaaabbccacbabcca\", target: int=301):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"babcbabccabbbcaabbaacaaacbbccbccabaabacaacaacaaabcabcbacbcbcaccaabbaaabcbcaccbbbbccbcccccbbabbaaabacabcbcacabaababbacabaacabcaaacbaccbaaccabaccbbabacabccababccbabcbcacbcacbcbbacbababcacbbabbabccbabbcabcabccabcaacbcbbaaacbbbbacbcbbbbcbccbaaaaaabcbcbcbaccabacababaabcbbbccabacbbcbbbaabbacaccabaaaaccbbabbcaaabcbbbbcaaabacbaacacaabbbbccaccabbcbabacccbcaacacbcacbabcbabbacacabaaaababaabbaccbbcbbbbcccccccabababbabcabbaaaabbccacbabcca\", target=301): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_88",
    "sat": "def sat(t: str, s: str=\"acbbabbbaabbcabbbccaaaacbbbbbcab\", target: int=17):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acbbabbbaabbcabbbccaaaacbbbbbcab\", target=17): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_89",
    "sat": "def sat(t: str, s: str=\"abccaabacabcc\", target: int=10):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"abccaabacabcc\", target=10): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_90",
    "sat": "def sat(t: str, s: str=\"aaccacacbacabcabbaaaccaccacbaaabbbcbaaccbcacabbabcbaabcaacbbcbbabbbaababbababbaacacbaaccacabbcaabccccbbcbabcbccbbbbbaacbbccccbbbcacaacbbabcaacccacbabbbcbacbbcababbcbababacabbbcccbccbacacaabacccaccabcccbbcbbbacccccccbbccbaccbccbcbabaacbcabcabbbabacccbbcccbbcbbcacbbaaccbabbaccccabaabbaaccacbbabbbbaacaacaabcabacccbbbaccbbbaacaaccaacabcbbabaaaaacbbcbcbbbccbaabacbaabaccbbabacabaababaaabccaabccabbbababbbaccccacbccccaaaccbbcbaaccaacbccbabacaccbbbaaccbacbcccbccbccabaccaacaaacaababcaabcccacacabbcbcccabcbcaaabcacccbabcbbbcbccccabcbcaaaaacacbbacabacacbccacababaaaaaaacaccbbabbbaabcaaccacbaccbbaccaccbaabababaabacabbcacbacbabcaacbccbabcbbabcbbccbcaccaabccbabbbccbbaccbacaaaabbbbbbcabaaabacbaababcabcbaaaabbbaacccaabaccbbaabcbaacbcbcaabbbbabaaabcaaabbaccccbabcbbbccbcccbbabcbccbaaabbbccbaaabacacaaccaabbacacbabcbcabacabbbabcbbcaaccaaacbaaccbbbaaccacbcbaaacabcccaaacbbaaaaacbabaacbbabccaacbcaaaccaaacaaacbbcaaacabcbccabccabbcacabacaacbbbccbabc\", target: int=615):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aaccacacbacabcabbaaaccaccacbaaabbbcbaaccbcacabbabcbaabcaacbbcbbabbbaababbababbaacacbaaccacabbcaabccccbbcbabcbccbbbbbaacbbccccbbbcacaacbbabcaacccacbabbbcbacbbcababbcbababacabbbcccbccbacacaabacccaccabcccbbcbbbacccccccbbccbaccbccbcbabaacbcabcabbbabacccbbcccbbcbbcacbbaaccbabbaccccabaabbaaccacbbabbbbaacaacaabcabacccbbbaccbbbaacaaccaacabcbbabaaaaacbbcbcbbbccbaabacbaabaccbbabacabaababaaabccaabccabbbababbbaccccacbccccaaaccbbcbaaccaacbccbabacaccbbbaaccbacbcccbccbccabaccaacaaacaababcaabcccacacabbcbcccabcbcaaabcacccbabcbbbcbccccabcbcaaaaacacbbacabacacbccacababaaaaaaacaccbbabbbaabcaaccacbaccbbaccaccbaabababaabacabbcacbacbabcaacbccbabcbbabcbbccbcaccaabccbabbbccbbaccbacaaaabbbbbbcabaaabacbaababcabcbaaaabbbaacccaabaccbbaabcbaacbcbcaabbbbabaaabcaaabbaccccbabcbbbccbcccbbabcbccbaaabbbccbaaabacacaaccaabbacacbabcbcabacabbbabcbbcaaccaaacbaaccbbbaaccacbcbaaacabcccaaacbbaaaaacbabaacbbabccaacbcaaaccaaacaaacbbcaaacabcbccabccabbcacabacaacbbbccbabc\", target=615): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_91",
    "sat": "def sat(t: str, s: str=\"caaaabaaacbcaccbbabacababcacccabbacaaacbcbcbcaacabaaacabbcacbabcbbcbbbabbabbaaacccbaaccacaabbbbacabcabaacbcacbabbcbbcbcbacabbaabbbacbbcabccabbbacbaaaccbaacaabacccaabbaabccaaccacbbccbbabcabcccacaaacaaccccacbccbabbcaaccbaccbcbaacabcaababcbccbcabcbbccaaaaccccacababbacbcbcbbcbaaabaccbcccbacaaabccbbabaaaacacaacbbcbaabaabaacabacbccbbcbacaaacbbacbaacccacbbcaccacbcacccaaacbbbabbbbcacabacbaaccaaaaccaccccaaaacbbbcbbbcaccacaabaaacabbcbcbacababababbcabbcabccbbaacbcacbababcabbbcbcbbacbbaabbabbbcbccaabccbccabcaccbbbbcbccccaccbbbcbccbbababcbbbacbcbbbbbababacbaccabccacababcbbbacacbcabbbacacaacbbaaccbbbabaaaacacacbacabbbabaccbacbaccabcccbababbaaacbcbbcbbcabaacbcbacacbbbbcbabccaaaabccbbbbacabccaabbacbbbbcbbbababcabaabcaabacbccbcccbbcaabaaaccacbcabcacbccbbccabcbbacaabbcabcbaccababbabbacbacbcbaabcaaccbabbbcbcacbbbcccbaababbcaacababbaccbaccbbaacbccbabbabbcccaacbcacabcbcbcaaabaccaaabbbccaacaaccaacbccabacbcbb\", target: int=621):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"caaaabaaacbcaccbbabacababcacccabbacaaacbcbcbcaacabaaacabbcacbabcbbcbbbabbabbaaacccbaaccacaabbbbacabcabaacbcacbabbcbbcbcbacabbaabbbacbbcabccabbbacbaaaccbaacaabacccaabbaabccaaccacbbccbbabcabcccacaaacaaccccacbccbabbcaaccbaccbcbaacabcaababcbccbcabcbbccaaaaccccacababbacbcbcbbcbaaabaccbcccbacaaabccbbabaaaacacaacbbcbaabaabaacabacbccbbcbacaaacbbacbaacccacbbcaccacbcacccaaacbbbabbbbcacabacbaaccaaaaccaccccaaaacbbbcbbbcaccacaabaaacabbcbcbacababababbcabbcabccbbaacbcacbababcabbbcbcbbacbbaabbabbbcbccaabccbccabcaccbbbbcbccccaccbbbcbccbbababcbbbacbcbbbbbababacbaccabccacababcbbbacacbcabbbacacaacbbaaccbbbabaaaacacacbacabbbabaccbacbaccabcccbababbaaacbcbbcbbcabaacbcbacacbbbbcbabccaaaabccbbbbacabccaabbacbbbbcbbbababcabaabcaabacbccbcccbbcaabaaaccacbcabcacbccbbccabcbbacaabbcabcbaccababbabbacbacbcbaabcaaccbabbbcbcacbbbcccbaababbcaacababbaccbaccbbaacbccbabbabbcccaacbcacabcbcbcaaabaccaaabbbccaacaaccaacbccabacbcbb\", target=621): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_92",
    "sat": "def sat(t: str, s: str=\"cbcccacbacccbccaaccaabcbabbacacbaacacbacbcccacbcacacbaaacbaaaaabaabababcacaccb\", target: int=58):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcccacbacccbccaaccaabcbabbacacbaacacbacbcccacbcacacbaaacbaaaaabaabababcacaccb\", target=58): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_93",
    "sat": "def sat(t: str, s: str=\"aabccc\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"aabccc\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_94",
    "sat": "def sat(t: str, s: str=\"c\", target: int=1):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"c\", target=1): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_95",
    "sat": "def sat(t: str, s: str=\"baa\", target: int=2):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"baa\", target=2): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_96",
    "sat": "def sat(t: str, s: str=\"acbaabcbabcacacacaccaccbbbaaababacaccbacaacacbccbababbaacbacccacbcababaabacccaacaacbacbbbbcca\", target: int=70):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"acbaabcbabcacacacaccaccbbbaaababacaccbacaacacbccbababbaacbacccacbcababaabacccaacaacbacbbbbcca\", target=70): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_97",
    "sat": "def sat(t: str, s: str=\"cbcbbbccabbbcacbccbcccccacccccbaabaaabaabcaaacbbaaaacaccbcbacabacbcabacabbccbccbbbcbccbabaacbaaacabbacbcbbacbbcbcaccccbbacacbaabcbbcbaaabcbbaaabbaaabcababaccbbbabbbaacbacbabcaaabaabbaaacbbcbbbbacbcbbcacbbacbcccaacaacabaccaaaacbcbcbaacbbcabccccabacbaabacbbabbabbcbcabbccabbbbacaaaacaccccbccbbacbaabaabbbbaaabcccababcbbaaaacccaacbabcccabacbabbbaabcbccacbabbccabbcabcbccacacbabccbabcbaaabbbbcccbbbbcbacbcaacccacbacabaaacababbacacacbbccaaacacbacbbbbaccbaacacacbbbacccbbcaabcacbbcaaaabcccabacaabaaacbcccccccbccbbacaccbccbbbbccabbaaaccabcbbabbcababccaccbcbacbcabacbbacbbcaabcaabcaaccaacccbacabbbbabccacbacbbbaaccababcabcbbcaacccabbcbcbbbbcbccacbacaccaabaacaabcacaaaccbbbcccabbabcaacacaababaaacaabacbcbaccaacaccbcaaacbcccabbbbaccbabbaaaaaaaaabbcababcacabcbcaccbb\", target: int=501):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcbbbccabbbcacbccbcccccacccccbaabaaabaabcaaacbbaaaacaccbcbacabacbcabacabbccbccbbbcbccbabaacbaaacabbacbcbbacbbcbcaccccbbacacbaabcbbcbaaabcbbaaabbaaabcababaccbbbabbbaacbacbabcaaabaabbaaacbbcbbbbacbcbbcacbbacbcccaacaacabaccaaaacbcbcbaacbbcabccccabacbaabacbbabbabbcbcabbccabbbbacaaaacaccccbccbbacbaabaabbbbaaabcccababcbbaaaacccaacbabcccabacbabbbaabcbccacbabbccabbcabcbccacacbabccbabcbaaabbbbcccbbbbcbacbcaacccacbacabaaacababbacacacbbccaaacacbacbbbbaccbaacacacbbbacccbbcaabcacbbcaaaabcccabacaabaaacbcccccccbccbbacaccbccbbbbccabbaaaccabcbbabbcababccaccbcbacbcabacbbacbbcaabcaabcaaccaacccbacabbbbabccacbacbbbaaccababcabcbbcaacccabbcbcbbbbcbccacbacaccaabaacaabcacaaaccbbbcccabbabcaacacaababaaacaabacbcbaccaacaccbcaaacbcccabbbbaccbabbaaaaaaaaabbcababcacabcbcaccbb\", target=501): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_98",
    "sat": "def sat(t: str, s: str=\"bac\", target: int=3):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"bac\", target=3): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "LongestSubsetString_99",
    "sat": "def sat(t: str, s: str=\"cbcabcbcbaacabcaccaaaccbcbccacbbababcbaccbacbabbbaabcbbbc\", target: int=44):\n    assert type(t) is str, 't must be of type str'\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target",
    "sols": [
      "def sol(s=\"cbcabcbcbaacabcaccaaaccbcbccacbbababcbaccbacbabbbaabcbbbc\", target=44): # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_0",
    "sat": "def sat(n: int, s: str=\"0000111111100000\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000111111100000\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000111111100000\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000111111100000\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000111111100000\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_1",
    "sat": "def sat(n: int, s: str=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011101110000001100111010000000101010000010001101110101100000100010011000111110101011001110001100000100100011110110000011001111000000010010000100110001000111101101011011100111010111100101010011110010000111010000110000010101100101111100101001000000010110001110001001010110100010101001000010001101111111010111010111011110000010101000000000000011001110010100110000101101110110011111011110110011011011111001011100010111101111011011100101101011010010100100111011000100010111111110011001100011000001001010110010110110010110001101001111100001001001100010101011010001001101010010100011110011110100000011111111100001100000000001100111101011101001011000011101111001001111011111011100100000001101011110010011100000010011111010011001110010100100001111001100100100011011110100101011111011001011101110011000110110011011111010100000011000110000011010110111\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_2",
    "sat": "def sat(n: int, s: str=\"0001\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_3",
    "sat": "def sat(n: int, s: str=\"1111111111111011\", k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1111111111111011\", k=11):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1111111111111011\", k=11):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1111111111111011\", k=11):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1111111111111011\", k=11):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_4",
    "sat": "def sat(n: int, s: str=\"111111111111111111100000\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111111111111111111100000\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111111111111111111100000\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111111111111111111100000\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111111111111111111100000\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_5",
    "sat": "def sat(n: int, s: str=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1011011111010100110010100101111101110001000001011111110011110110000000000000111110\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_6",
    "sat": "def sat(n: int, s: str=\"0011111111111001011100110011011110111111\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0011111111111001011100110011011110111111\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_7",
    "sat": "def sat(n: int, s: str=\"100000100110\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000100110\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000100110\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000100110\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000100110\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_8",
    "sat": "def sat(n: int, s: str=\"10000000001\", k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10000000001\", k=8):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10000000001\", k=8):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10000000001\", k=8):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10000000001\", k=8):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_9",
    "sat": "def sat(n: int, s: str=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"001101011110000101110101011101111100110001110100101100111111000001100111110001000001101001001111110001011001010010011101111110101110000110110000000101100110101011010001011000010101011101100011010000011010101000000011100111010000011011001100000001101100001111110111011101111101110111110111111111000110001100\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_10",
    "sat": "def sat(n: int, s: str=\"1000010\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000010\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000010\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000010\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000010\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_11",
    "sat": "def sat(n: int, s: str=\"01111111110\", k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01111111110\", k=9):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01111111110\", k=9):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01111111110\", k=9):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01111111110\", k=9):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_12",
    "sat": "def sat(n: int, s: str=\"110111101111000000010110110010010111000011111111111111001101110010\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111101111000000010110110010010111000011111111111111001101110010\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_13",
    "sat": "def sat(n: int, s: str=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01101100000110110111001110000111100100000000100000111000111111110000100101001100010011100010011011\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_14",
    "sat": "def sat(n: int, s: str=\"1000000\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000000\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000000\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000000\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000000\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_15",
    "sat": "def sat(n: int, s: str=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10100100001111011000110100011111110011000111101110001010001001100000011011101101010110100101101101110101100011001101100000100110101111101111011010101111110010001101100101110000111011110101101001101111101000111001111001011001111110010011101110110010010101111111100010110111010010011111101001011100010100110101100010100101011000111010010111100111111110001101101100000011111010000001011101011000011011100001011110001001111110000010111000110111011100100101001001010111110001000100\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_16",
    "sat": "def sat(n: int, s: str=\"01\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_17",
    "sat": "def sat(n: int, s: str=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010010111110100101011001010001011100010001101001000001101111001110001100101111000111010100100110100011100010110111100001000110000001111011001101110111001010001000011111000111100111110100110100100111100101010110110100001100000111111011000000011111000111010000111001101111010110001001001111111010111111110000100100100000110110110001001010101111101000100011110111000010010101001101100010100101111111011000011110111110001011010111010000000000000000100100111101010010001011101101111000001001000111101010011010001010010100011010011011111001011100001000100111000111110100111101011100100111111110000010010001011101001101101011001111110111101011111000110011111000111011110001110100101000100111100101110110110011100010100111111010010011101111101010111110001001100011100000111101111010110100000101001011101001011001011001101001110010000010010101110100000001001011100000011100010010110100101000111101\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_18",
    "sat": "def sat(n: int, s: str=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111100110000111101101100000001111100110000111101111100100100101001101000011101000110010101000111010110101110011010010100110110110100011011000011010101101001110111010011001000100001001110011110010011001010010010000000110011000000100111110010001111010000110101000001101110101110110010010100001100011010010101011100001110011011111110001011101000100011010110000010000010011001101110000011010101001010011111101011011110101111011010000001010001011001010101000111010111011001010101111010010000100011000011000010111110011001111011000100010111110110111100010101100011011001110010011110101111111011111111100111110011000100001111100101111100011011000001100100111110101111110010100011011011110110011101110011110111000101101010100100001010001101110001110010010100101000101110111100111110001110101110110001010011001101111100011101111011101111111001101010001100011011000100010001101\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_19",
    "sat": "def sat(n: int, s: str=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000001010001001001001111000110111011000111101010001001000100000010111110001001001100011110001100101111000111111111000111010001011010110110000100011011010100001000010000111011010100011100101101101000110101010001101110101010001101010111101101011011110001001001110100011100001011100100110010011000001011100100001110001011111011110\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_20",
    "sat": "def sat(n: int, s: str=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111010100011101000100110010111010001100000000100010011010101100010101101101011111011111001100111100011001100101110000110011100010011011000110000001101100000000011000010100101111001001111001000001011110011100000101100100101011111011001100101111011001101011011110011100110110001101100010111100010010011011000100001010010011001011011110010010110001101010100000010100111001000000011010\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_21",
    "sat": "def sat(n: int, s: str=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010100001001001001111001001101110010111001001101011010101000111001001011101011000000010110100110011010111000100100101000001101111101011000100010010100010010101111011101000101001011001110100101000110101011000011111001010011110011110110010001110101110100010011010011001001010110000011100000111110101011110010000010001000111011110001001010101101101100011011101010010111011111011100110101110011101100101011101100000000010101100011011100000110101011110110101101011110100011110010100100011000101001110010011101110101101110000001010101010001011011001100101010110001011100111101100101100011001010110001000000101101001111011001111000010000111111010101110100011100101101110100101000001011110011111010010101010101011100011000101100101110000111101001100110000011111000010011101100000111010001010110000000000000000011000010101010100011101001011000001110101011001101101001101010011011110010110010101110001011110100010111100101110\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_22",
    "sat": "def sat(n: int, s: str=\"01011110110110100011001011101100011111111111111100\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01011110110110100011001011101100011111111111111100\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_23",
    "sat": "def sat(n: int, s: str=\"1000000000\", k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000000000\", k=9):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000000000\", k=9):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000000000\", k=9):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000000000\", k=9):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_24",
    "sat": "def sat(n: int, s: str=\"100001010101011100111111111010101\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100001010101011100111111111010101\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_25",
    "sat": "def sat(n: int, s: str=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1110111110110100000110100110100011000110001110001101100110000011101110000011011100010111110100001011000001010001010001000111000111110000100111100010010111011010101010001100101001011001000001010011100001101001010010000000100010101001011111001111100001000011000000110010010011000001101001111010000100101011100011001110000101011001111111110111011000011111010101011110110110011111111000010111110110100001001011011110110010000111001000110000011110110110010010100111101100100010001111001010000110011010111110001000011010011010010110110001111010110100100010000001111101001000110011010101100101000000000000000000000111101100010011101110001010110011010100011001011111011010111001011111100111101110001111101011110101010111100111110000110001110010100001110011100111011001001100001001010001101100001011011000010000101111001001111000111011101111101\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_26",
    "sat": "def sat(n: int, s: str=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"11101010100101010010001100111100111100100101110111111101101000101100101110001000111111111100000\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_27",
    "sat": "def sat(n: int, s: str=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010011011111111101010010011111001110011000100010011100101111101110101010101000011010110110011100001000111010101001000000000000000011100011010000100000101100111110100100001101010100101101101100001000010101101011000001010011010010111101101001001101000100011110100100010001001000100000110100010000100101000001011010010110100001110001101010101001000110011010001011111011100001000110110111110111000100110111011011101011010101000000011101000000010100011001111001101100100001101001001101010110011101110111001100100011010111111100001100101\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_28",
    "sat": "def sat(n: int, s: str=\"111000000000\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111000000000\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111000000000\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111000000000\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111000000000\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_29",
    "sat": "def sat(n: int, s: str=\"0111010101110001101100111010010011001000111110000110011100\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0111010101110001101100111010010011001000111110000110011100\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_30",
    "sat": "def sat(n: int, s: str=\"111000000000000010\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111000000000000010\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111000000000000010\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111000000000000010\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111000000000000010\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_31",
    "sat": "def sat(n: int, s: str=\"000010011100100101011\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000010011100100101011\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000010011100100101011\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000010011100100101011\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000010011100100101011\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_32",
    "sat": "def sat(n: int, s: str=\"01111111111110\", k: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01111111111110\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01111111111110\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01111111111110\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01111111111110\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_33",
    "sat": "def sat(n: int, s: str=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01111000011011000010111111000010010100011000011001000100001111110111110100101000001010110000010101100011111001101000010001011011101101111000001000000110110100111011111101111110101100111001000000100001010000111011111100010010001011101111010000101010000001010000101001001101100101100000000001001101111010011010100001001110101110011111010010110010110010001110101001000100000100100100100101111101110000110001011111111100110001100001111101100000011011110100110100011111100101011110100000010000010001010010110010111100100000101000110111011011000100001111011100001110001100010100000101100110011011001000001111110011000110101000100011111000111101011100001000100110000001100010100011010011110100110000011001110010010111000111001010010001101111101010010011111011011010010000000101010110110000000111011110010101010001001101101111100100011\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_34",
    "sat": "def sat(n: int, s: str=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00000001000010100011000001010000011100111101011101001001110111100010001101111011000110110110100100010001101101000100011010111000000111001101000010001000101100111100110001110001000011110101010001101011111011000010000101111001111100111001001111100011001011111100110101110010001000111110001011111111000000001011000110001101001111011110101100010001111101110001011000001101110000000000011111011110100110001110001001110111000011000011111000010000100000100100101111100001101000000100110010111101010010000101110101100000110110100110001101110000100010111110100011011011011101110100101000000101000010110101010100001110101110110001101100000001010010110011110111011010101000000101101011101010101100000100101011011110010010011101110000110010000100100101101101100010101010110110011110110010101101011011011\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_35",
    "sat": "def sat(n: int, s: str=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00100010110111010001100100010000001111011010101010010011111111010000000110010\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_36",
    "sat": "def sat(n: int, s: str=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k: int=9):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111111101111000111000010010000110000011100111011010010101010110010000011001101011000001001111111110011010010101100110\", k=9):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_37",
    "sat": "def sat(n: int, s: str=\"1100\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1100\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1100\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1100\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1100\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_38",
    "sat": "def sat(n: int, s: str=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110000111000111001100100010010011000101011011101110110111001010110000000\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_39",
    "sat": "def sat(n: int, s: str=\"0101111111111111110\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0101111111111111110\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0101111111111111110\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0101111111111111110\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0101111111111111110\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_40",
    "sat": "def sat(n: int, s: str=\"1111111111111\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1111111111111\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1111111111111\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1111111111111\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1111111111111\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_41",
    "sat": "def sat(n: int, s: str=\"00010\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00010\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00010\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00010\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00010\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_42",
    "sat": "def sat(n: int, s: str=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010101011101110010100000011011001010010100001001101001011001100111101101011001111101011011100011011000101101011001010100111101100000011011110000101011111000110011011100111101000001100100010011011011000011101010111000111111101111110100110101000000110100011110010000111010000111011000001110101101110001011100000100101011010101100001001011111111100010110000111110101100001000010111101001100011101011100011111010111010010110100001011001110000001000101000110000010011010001000111111100101100110011001100010010100110101011101010000000000000000000000110000001000100100001100001100110100101010101001101110101110110000010110010011000110110011001101110110000001011111000000100001000111010000110111\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_43",
    "sat": "def sat(n: int, s: str=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"101100100010100011011101000110101100010111101000001111011011001001101111100100110110\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_44",
    "sat": "def sat(n: int, s: str=\"1011010\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1011010\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1011010\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1011010\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1011010\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_45",
    "sat": "def sat(n: int, s: str=\"0111111111111111100\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0111111111111111100\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0111111111111111100\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0111111111111111100\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0111111111111111100\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_46",
    "sat": "def sat(n: int, s: str=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0111010011101100000101111110110000000110001010111011100000101011010100110111101001101110110001010100011010111101011110000100001001110000011010111000000011000101101000101010001011101101010100110011001000110100111010010111101100000011010110110100100111110111011101110010001100010111110101110110011000000111100000111110000010011110111110111100010000000001101010111010110010101001111000010001001000000010101011000000011110100110000010110100110101000001010111000111010110011010101111001100011010110101010010110110111100110111000110011100011000011000\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_47",
    "sat": "def sat(n: int, s: str=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1101000011101111101101111111101111011011001011101000010010111010001000000001110001101110011000110111000011110101000100110110101000010110010011011100011011011001111111111111111111000111001001000110101010111011000011101011100111000000010100010000010101101101110101011000101010000011000110010100101001010101001110100000010000001000000101010100100001001100001001011110111111111000100010100110001101010110000001010110010000010101110100111111001011100011011010010101010000000111111110001011010110110100001110111011100111101011001000111000000111011100100011100010011000000101011010010111100110001001011000100100101100000010010111110000001000010110101001001001010000100101100110110111000100101000000110100000100010010101001000101001101110110101001000110101111110110101110100100\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_48",
    "sat": "def sat(n: int, s: str=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0010100110111001000110101000011001011010001010001010000111011011000001111100100101001111110011111010101\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_49",
    "sat": "def sat(n: int, s: str=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011011010100110000100010110001010101000001110111010010100101011011011100101010010100001010000000000000000000000111\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_50",
    "sat": "def sat(n: int, s: str=\"01010000000000000000100100111101100110011001\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01010000000000000000100100111101100110011001\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_51",
    "sat": "def sat(n: int, s: str=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011000101100011010111010100000000000000000000000111000000011010010110111000000111001001001000010\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_52",
    "sat": "def sat(n: int, s: str=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010011001101101111101101110101111001010011110100101100001000011000001110011101011100011010000001111100000001100001011111111101101100110101011111011111100001100111000111110111100010010100000101010001100010100000100011001111110010111101110001101111100001001101111101001001010010010010000101000101011000101011110001111111001110111110100000100111111111100011011111011001110000101000001001001001001011110101100001110110100\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_53",
    "sat": "def sat(n: int, s: str=\"100000\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_54",
    "sat": "def sat(n: int, s: str=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10000011111101010100000101100101010101100111011110010111111101111011111011101000111000000000010011010100\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_55",
    "sat": "def sat(n: int, s: str=\"10111111111111111111\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10111111111111111111\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10111111111111111111\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10111111111111111111\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10111111111111111111\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_56",
    "sat": "def sat(n: int, s: str=\"0100111111111111111110111\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0100111111111111111110111\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0100111111111111111110111\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0100111111111111111110111\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0100111111111111111110111\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_57",
    "sat": "def sat(n: int, s: str=\"01110010111100100101110000011010010\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01110010111100100101110000011010010\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_58",
    "sat": "def sat(n: int, s: str=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01101100010111111101111011001100111011110001101100000011101101001001110001100010011000111000110111110110000100010111010001101111011111010011000011111111000000110110010000011101011011110100000100011001111000010101111111001011101010010100100100010001001000010110110110111011110001100110100111011111000010011001111101101100100111111001101001110111011001100110010011010101001010001101001010001101001000101110110100101000101011110111110001010011000010100101010101101110110110010111110000001101110001111011010011000110011010000000101001011011100010011100111111011100100100111100110000100011100001000111010110110100100100100010101100110110111001010010100010010000110001011101010101110001000000011000110101111100111000010101011101110110011010100000100111001101011100111110101000100101010101101011110101000110000000001101010110000110111010111100111011101110011101111001111001110111000101100111110000000010001101101111101011001101000010100\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_59",
    "sat": "def sat(n: int, s: str=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k: int=8):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110011011010000000011101010001010010100001011001000001100001101010100110001010\", k=8):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_60",
    "sat": "def sat(n: int, s: str=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1011011101000010101101110011111011001111111111100011111111111100010010111100111001110001101111001001010100010010111111011101001011011000110110011001110010000000101111101100000000110010000011001101101110110011000111111101110110110010011010001111010011011111100000110001010010001010111001101100100100101001110110101010010001010001011101111111111111110001011110111001000101110110001011011001000101100011010\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_61",
    "sat": "def sat(n: int, s: str=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010101100000110011100011011111010110000000000000001100010001000111111110001101001011001101011100110010000111100101110110110110111010001001100000000010000011110011001101011111001101000100100010110001111000000110110111110011110111100001001010101110101000001110000000100000011010\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_62",
    "sat": "def sat(n: int, s: str=\"10000000000000000000\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10000000000000000000\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10000000000000000000\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10000000000000000000\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10000000000000000000\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_63",
    "sat": "def sat(n: int, s: str=\"110111111111111111\", k: int=15):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111111111111111\", k=15):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111111111111111\", k=15):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111111111111111\", k=15):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111111111111111\", k=15):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_64",
    "sat": "def sat(n: int, s: str=\"100000000000000000010\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000000000000000010\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000000000000000010\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000000000000000010\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000000000000000010\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_65",
    "sat": "def sat(n: int, s: str=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k: int=11):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000101010110111001001100000001111000011011011111010011101001101100000101000111100011001101011101101001001111010111100101110011110101100000100010101101011100011110110100001111001101111111101100011100101010110100001110111110111000111100011011010111011100011010110110110101010000110111010111101110011000010010100010100110111100001000011110110101011101110010001100001011001010001101111000101001111111111110000011010011100101110110010110010010000100101101001011000100011000110011100110010101011110100001000010000001100101001010110000110000001010000011111110100111111011010110101111011110010100100100111100001001001101\", k=11):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_66",
    "sat": "def sat(n: int, s: str=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1110010000011011111111000000011000110000101100101010110001111010101100011011101001010100111101000000010010110000010111001000011101000100101000001011110100011101011101000000101100111110000110011100010100111111110100110100001000101001001111011101110110011100111000110000001001101011110010001011011011010111100100001100100010001010111010001010010100010110101010110001100111011000011111001011000100000010110001110100101110001101110100000001100101110101001011010110100101101000110100010010010101000001011011100000101011010110010010011010110010000100100101001101100000000111011101111010111110000101001111111111111111100011010100100010\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_67",
    "sat": "def sat(n: int, s: str=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"010000111101010010011010111001011101111111000011011111001011011011100111111010001001001110001010011101111001100100101001110011100100000111100110011111110010111110010111111000100001100110011100110000100111111011010100100110011101110110011011010100001010111111100100000000000000000000101001100100101100100011000100001001101101010101010110000000111011110101111010111100111010010101101101100011000111001001011001001001000101111101000101110000100000100001101100100111011000110101010101101100000001011111011000111111001001001101100110100011101100001100010001101001001010001011111101110110000011000100111101011101100110000101001000100010011011011001011000101011101010110100011101101110001111110011110100100101010011110\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_68",
    "sat": "def sat(n: int, s: str=\"10101000000000000000000000\", k: int=17):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10101000000000000000000000\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10101000000000000000000000\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10101000000000000000000000\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10101000000000000000000000\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_69",
    "sat": "def sat(n: int, s: str=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000110010001111111100001100010000010000111100001011001010110010101111110101100101010111000000101011000001101010100100001000111000001100100011100000100101000110100110101011100100001010000101101111100010110001010000010011111001001100100111000001000011000001100011100111110111011010001100010011110010100010101100000010110101101100\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_70",
    "sat": "def sat(n: int, s: str=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00111111011110111101011011110000010011011111110011010001011110000110000100111010000011111100110110101111111000011100100011101110011111010111011001101011110000111000101100110001110000000101100011000011000000111001101001000101000001010001111001101011110111111011011101011100101101111100111100011010101111000111010111101011101110000000110000111\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_71",
    "sat": "def sat(n: int, s: str=\"100111111111111111100\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100111111111111111100\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100111111111111111100\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100111111111111111100\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100111111111111111100\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_72",
    "sat": "def sat(n: int, s: str=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010001110001100001101100100111000101001111011001111010110010001100000000000000001010010\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_73",
    "sat": "def sat(n: int, s: str=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01101010110100000000011111101100001110111000100001001011111011001010110000010010110010011010000110110101010000011110010101111110100110010001011101111101110101110110110111100010101011101001011000100101011010000100100010000101100101001011000110010011000010101010001101110101010111000110001110101110001011011000001110000010110001011000101000100001010111001011101011011110011000010100101100010001101110101100101100000110101111011111011110101000000000101101110110110100101100010111010000110110101010001001011100111110001001010001000101110100101011110100100010110110001101100110000101000100100000100000111101001111011000111001100101111100000101101011110011101000001100011110000000110000010000111111001001000010110001001100110010110011010110110101111001111011111100011\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_74",
    "sat": "def sat(n: int, s: str=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01100110011010110111111111111001010000110001011000011100111011001001110011110101011000101000000000101111000100100001001000011011111110010011011011011001000110100011001110000100111101000011011100100001101011011000000001010011011011001101101001011110000000011111100100000110110111000010010000111110010100100101111101111100111111100011110111100111100001110001100000110000111111100000000001000000110010100101110010000110001010000101000010111010111001111010010101011110011101001101011010001000011110111010100100010010011011000010000001011111010001001011000110101001111110000000011010110010111010111110110100101010000111101100110011011101101010100110100111111101000101001010110001110101100101001000000101011111000001011110001001111010010110111100010111001011100100100111100101\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_75",
    "sat": "def sat(n: int, s: str=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10100001010101000100110110111111111111111111111111001101110000000010111111011101\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_76",
    "sat": "def sat(n: int, s: str=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1101010100101001111101110101001100011110011000110111011001000000010111001101100111011010111011110111011010000010111111001111101110010011100001111001111001101100001110011010011011100110001110111010110010000100001001010110110110100010101111111100101000011011101100010001110010010011010001011001110010010000111100100110111000011100100100000110110001001110011001011001101011010110010100110011000000001001010001000111011101100001100000000011111011001111000000000101110110001011101111001110111001110111101101110010111010110110010010110011111100001101111110010100100001001011001011000000101110111010010111011001011111101100011110100001000100010101100101011001001111101001101101101101111111100000001101110001011100101001001011111100100011111111111110110100110001111110111100011011100011111101010000011111100001101010011000010001011010110101010101001011010011001001011110001001011101001101011001011010110010\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_77",
    "sat": "def sat(n: int, s: str=\"011011001111011100111011011000000000011\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011011001111011100111011011000000000011\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_78",
    "sat": "def sat(n: int, s: str=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01000100001001000110110111111100101101101010101110000000011011101100110011000010111000111000101010011010000011011010\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_79",
    "sat": "def sat(n: int, s: str=\"00000000000000\", k: int=13):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00000000000000\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00000000000000\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00000000000000\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00000000000000\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_80",
    "sat": "def sat(n: int, s: str=\"1111011001000\", k: int=4):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1111011001000\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1111011001000\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1111011001000\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1111011001000\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_81",
    "sat": "def sat(n: int, s: str=\"000000000000000001\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000000000000000001\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000000000000000001\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000000000000000001\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000000000000000001\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_82",
    "sat": "def sat(n: int, s: str=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k: int=16):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10110111110100000000000000000100011011111011111100100111000101100100001010001000001101101110011\", k=16):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_83",
    "sat": "def sat(n: int, s: str=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001111110100111100111010001010111100100010000101101100100111101111010111011011111110010100010001110000011101011001111010001110001110001010110010111011110010001000011\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_84",
    "sat": "def sat(n: int, s: str=\"0001001110111111001101011001101001111111111111111111111\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001001110111111001101011001101001111111111111111111111\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_85",
    "sat": "def sat(n: int, s: str=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100000110011101100010001100111001110000110100101100110110001111010110000000111101110111011011101010000111001001110100100001100011000110001011001111101011010111011110100010110010011010011100101001111101001110101111011011001011011111110100101100100101111000101000000001000100001101010111111011100100011011110011111101011001001110000010100111111000010101010001001011110101101101001000100111010100110100101000101001000110101101001101000111011010101\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_86",
    "sat": "def sat(n: int, s: str=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000000000000001100001100101011001111001011000101001110010010001100010111101110000111110000000111001101111110010011011011110011101000000101101100101001100010011101011010010110011110100011110100100000110100101100101000111111111110111011100100001010010110000100010000000110011011101100011010010000110011111000001101000100110000101110111100011011011011010101111101001101101100101001111010000110011011100010001100110110000100101010100100101000110001011100011011011\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_87",
    "sat": "def sat(n: int, s: str=\"000000001101\", k: int=7):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000000001101\", k=7):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000000001101\", k=7):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000000001101\", k=7):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000000001101\", k=7):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_88",
    "sat": "def sat(n: int, s: str=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01100001101010100110010000101100010001111000111110000001100010101111101101101110011011111110100111101110101111111110001111001110001001011100001110000101001001100100001111010000100010011010011110000110101110101011111110011010010101011101100010101011101000010100100000100001100001110101101000011101101010000010100111101000101110010011100010000000010101111011000011111011100100010001010000111000010010000011011010100111001101101001101000011100111011011011000100110111011110011011011110111001001011100011100111000111010110110101110000110111100001101100001000010010000101000001111010111110001111000000100101101110100100100000001111111100010100001010100011001010001110001010001000\", k=6):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_89",
    "sat": "def sat(n: int, s: str=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"11001101001011111000100111101110011101100011100111010010011000100000000000000100101011001000100001010\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_90",
    "sat": "def sat(n: int, s: str=\"1100000000000000000001\", k: int=19):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1100000000000000000001\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1100000000000000000001\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1100000000000000000001\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1100000000000000000001\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_91",
    "sat": "def sat(n: int, s: str=\"111111111111111101111\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"111111111111111101111\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"111111111111111101111\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"111111111111111101111\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"111111111111111101111\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_92",
    "sat": "def sat(n: int, s: str=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0010111111011111100000110101001100100101110001011000010000000000000000001001001\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_93",
    "sat": "def sat(n: int, s: str=\"11100011000100111\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"11100011000100111\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"11100011000100111\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"11100011000100111\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"11100011000100111\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_94",
    "sat": "def sat(n: int, s: str=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0001011100110100001110000000110101111001100011101100010011101100000111100010011001110010100010100110001110001110110010011001010111100110101110011100101000011010110110000111101110010000110011100001110100100111011011011011110000010100000000111010001000100011010110111011111111110110100110111111000100100000001101110110011000110101\", k=2):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_95",
    "sat": "def sat(n: int, s: str=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k: int=18):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1000111100011111010001111000100111110100011000101111010111111111111111111111000010000110010100000011010\", k=18):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_96",
    "sat": "def sat(n: int, s: str=\"100010011\", k: int=1):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100010011\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100010011\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100010011\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100010011\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_97",
    "sat": "def sat(n: int, s: str=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k: int=12):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01011100000000000100110001110111001111101111000011010101111010000011010001101010110001100011100100000001000010101110110010001100001010011111111111110110100000111010001111011010001110111010000100110111001010100000011010110011000110011001011110101010000110001010100100110001101110101110011001100010101111010000000000011100011100001101100011000000011101110010110100000010000111011101100010000111001001010111001101100101110111110110100111100111100000100101000101010000110\", k=12):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_98",
    "sat": "def sat(n: int, s: str=\"001001111011000101101111001000110011011001111111111111100110110001\", k: int=14):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"001001111011000101101111001000110011011001111111111111100110110001\", k=14):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FindHomogeneousSubstring_99",
    "sat": "def sat(n: int, s: str=\"000\", k: int=3):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"000\", k=3):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"000\", k=3):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"000\", k=3):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"000\", k=3):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ]
  },
  {
    "name": "FivePowers_0",
    "sat": "def sat(s: str, n: int=7):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=7):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_1",
    "sat": "def sat(s: str, n: int=0):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=0):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_2",
    "sat": "def sat(s: str, n: int=1):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=1):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_3",
    "sat": "def sat(s: str, n: int=2):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_4",
    "sat": "def sat(s: str, n: int=3):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=3):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_5",
    "sat": "def sat(s: str, n: int=4):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=4):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_6",
    "sat": "def sat(s: str, n: int=5):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=5):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_7",
    "sat": "def sat(s: str, n: int=6):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=6):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_8",
    "sat": "def sat(s: str, n: int=8):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=8):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_9",
    "sat": "def sat(s: str, n: int=9):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=9):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_10",
    "sat": "def sat(s: str, n: int=10):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=10):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_11",
    "sat": "def sat(s: str, n: int=11):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=11):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_12",
    "sat": "def sat(s: str, n: int=12):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=12):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_13",
    "sat": "def sat(s: str, n: int=13):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=13):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_14",
    "sat": "def sat(s: str, n: int=14):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=14):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_15",
    "sat": "def sat(s: str, n: int=15):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=15):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_16",
    "sat": "def sat(s: str, n: int=16):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=16):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_17",
    "sat": "def sat(s: str, n: int=17):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=17):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_18",
    "sat": "def sat(s: str, n: int=18):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=18):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_19",
    "sat": "def sat(s: str, n: int=19):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=19):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_20",
    "sat": "def sat(s: str, n: int=20):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=20):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_21",
    "sat": "def sat(s: str, n: int=21):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=21):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_22",
    "sat": "def sat(s: str, n: int=22):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=22):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_23",
    "sat": "def sat(s: str, n: int=23):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=23):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_24",
    "sat": "def sat(s: str, n: int=24):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=24):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_25",
    "sat": "def sat(s: str, n: int=25):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=25):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_26",
    "sat": "def sat(s: str, n: int=26):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=26):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_27",
    "sat": "def sat(s: str, n: int=27):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=27):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_28",
    "sat": "def sat(s: str, n: int=28):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=28):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_29",
    "sat": "def sat(s: str, n: int=29):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=29):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_30",
    "sat": "def sat(s: str, n: int=30):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=30):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_31",
    "sat": "def sat(s: str, n: int=31):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=31):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_32",
    "sat": "def sat(s: str, n: int=32):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=32):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_33",
    "sat": "def sat(s: str, n: int=33):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=33):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_34",
    "sat": "def sat(s: str, n: int=34):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=34):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_35",
    "sat": "def sat(s: str, n: int=35):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=35):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_36",
    "sat": "def sat(s: str, n: int=36):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=36):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_37",
    "sat": "def sat(s: str, n: int=37):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=37):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_38",
    "sat": "def sat(s: str, n: int=38):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=38):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_39",
    "sat": "def sat(s: str, n: int=39):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=39):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_40",
    "sat": "def sat(s: str, n: int=40):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=40):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_41",
    "sat": "def sat(s: str, n: int=41):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=41):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_42",
    "sat": "def sat(s: str, n: int=42):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=42):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_43",
    "sat": "def sat(s: str, n: int=43):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=43):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_44",
    "sat": "def sat(s: str, n: int=44):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=44):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_45",
    "sat": "def sat(s: str, n: int=45):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=45):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_46",
    "sat": "def sat(s: str, n: int=46):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=46):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_47",
    "sat": "def sat(s: str, n: int=47):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=47):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_48",
    "sat": "def sat(s: str, n: int=48):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=48):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_49",
    "sat": "def sat(s: str, n: int=49):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=49):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_50",
    "sat": "def sat(s: str, n: int=50):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=50):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_51",
    "sat": "def sat(s: str, n: int=51):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=51):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_52",
    "sat": "def sat(s: str, n: int=52):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=52):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_53",
    "sat": "def sat(s: str, n: int=53):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=53):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_54",
    "sat": "def sat(s: str, n: int=54):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=54):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_55",
    "sat": "def sat(s: str, n: int=55):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=55):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_56",
    "sat": "def sat(s: str, n: int=56):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=56):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_57",
    "sat": "def sat(s: str, n: int=57):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=57):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_58",
    "sat": "def sat(s: str, n: int=58):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=58):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_59",
    "sat": "def sat(s: str, n: int=59):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=59):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_60",
    "sat": "def sat(s: str, n: int=60):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=60):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_61",
    "sat": "def sat(s: str, n: int=61):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=61):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_62",
    "sat": "def sat(s: str, n: int=62):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=62):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_63",
    "sat": "def sat(s: str, n: int=63):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=63):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_64",
    "sat": "def sat(s: str, n: int=64):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=64):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_65",
    "sat": "def sat(s: str, n: int=65):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=65):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_66",
    "sat": "def sat(s: str, n: int=66):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=66):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_67",
    "sat": "def sat(s: str, n: int=67):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=67):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_68",
    "sat": "def sat(s: str, n: int=68):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=68):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_69",
    "sat": "def sat(s: str, n: int=69):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=69):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_70",
    "sat": "def sat(s: str, n: int=70):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=70):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_71",
    "sat": "def sat(s: str, n: int=71):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=71):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_72",
    "sat": "def sat(s: str, n: int=72):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=72):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_73",
    "sat": "def sat(s: str, n: int=73):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=73):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_74",
    "sat": "def sat(s: str, n: int=74):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=74):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_75",
    "sat": "def sat(s: str, n: int=75):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=75):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_76",
    "sat": "def sat(s: str, n: int=76):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=76):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_77",
    "sat": "def sat(s: str, n: int=77):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=77):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_78",
    "sat": "def sat(s: str, n: int=78):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=78):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_79",
    "sat": "def sat(s: str, n: int=79):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=79):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_80",
    "sat": "def sat(s: str, n: int=80):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=80):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_81",
    "sat": "def sat(s: str, n: int=81):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=81):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_82",
    "sat": "def sat(s: str, n: int=82):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=82):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_83",
    "sat": "def sat(s: str, n: int=83):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=83):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_84",
    "sat": "def sat(s: str, n: int=84):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=84):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_85",
    "sat": "def sat(s: str, n: int=85):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=85):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_86",
    "sat": "def sat(s: str, n: int=86):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=86):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_87",
    "sat": "def sat(s: str, n: int=87):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=87):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_88",
    "sat": "def sat(s: str, n: int=88):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=88):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_89",
    "sat": "def sat(s: str, n: int=89):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=89):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_90",
    "sat": "def sat(s: str, n: int=90):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=90):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_91",
    "sat": "def sat(s: str, n: int=91):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=91):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_92",
    "sat": "def sat(s: str, n: int=92):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=92):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_93",
    "sat": "def sat(s: str, n: int=93):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=93):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_94",
    "sat": "def sat(s: str, n: int=94):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=94):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_95",
    "sat": "def sat(s: str, n: int=95):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=95):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_96",
    "sat": "def sat(s: str, n: int=96):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=96):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_97",
    "sat": "def sat(s: str, n: int=97):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=97):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "FivePowers_98",
    "sat": "def sat(s: str, n: int=98):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=98):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ]
  },
  {
    "name": "CombinationLock_0",
    "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"012\", combo=\"329\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_1",
    "sat": "def sat(states: List[str], start: str=\"216\", combo: str=\"998\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"216\", combo=\"998\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_2",
    "sat": "def sat(states: List[str], start: str=\"37\", combo: str=\"08\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"37\", combo=\"08\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_3",
    "sat": "def sat(states: List[str], start: str=\"1491511143\", combo: str=\"2425877025\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1491511143\", combo=\"2425877025\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_4",
    "sat": "def sat(states: List[str], start: str=\"04076\", combo: str=\"32441\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"04076\", combo=\"32441\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_5",
    "sat": "def sat(states: List[str], start: str=\"5375\", combo: str=\"9044\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5375\", combo=\"9044\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_6",
    "sat": "def sat(states: List[str], start: str=\"1112\", combo: str=\"0714\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1112\", combo=\"0714\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_7",
    "sat": "def sat(states: List[str], start: str=\"09357420\", combo: str=\"20829960\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"09357420\", combo=\"20829960\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_8",
    "sat": "def sat(states: List[str], start: str=\"9316710580\", combo: str=\"8447131092\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9316710580\", combo=\"8447131092\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_9",
    "sat": "def sat(states: List[str], start: str=\"96066072\", combo: str=\"35671171\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"96066072\", combo=\"35671171\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_10",
    "sat": "def sat(states: List[str], start: str=\"493\", combo: str=\"276\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"493\", combo=\"276\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_11",
    "sat": "def sat(states: List[str], start: str=\"7007346005\", combo: str=\"8653227796\", target_len: int=22):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7007346005\", combo=\"8653227796\", target_len=22):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_12",
    "sat": "def sat(states: List[str], start: str=\"4146\", combo: str=\"6764\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4146\", combo=\"6764\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_13",
    "sat": "def sat(states: List[str], start: str=\"069169\", combo: str=\"408609\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"069169\", combo=\"408609\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_14",
    "sat": "def sat(states: List[str], start: str=\"894\", combo: str=\"907\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"894\", combo=\"907\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_15",
    "sat": "def sat(states: List[str], start: str=\"3648\", combo: str=\"1449\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3648\", combo=\"1449\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_16",
    "sat": "def sat(states: List[str], start: str=\"03645240\", combo: str=\"09680593\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"03645240\", combo=\"09680593\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_17",
    "sat": "def sat(states: List[str], start: str=\"916\", combo: str=\"924\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"916\", combo=\"924\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_18",
    "sat": "def sat(states: List[str], start: str=\"98750140\", combo: str=\"75374849\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"98750140\", combo=\"75374849\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_19",
    "sat": "def sat(states: List[str], start: str=\"1720920724\", combo: str=\"8105118833\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1720920724\", combo=\"8105118833\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_20",
    "sat": "def sat(states: List[str], start: str=\"62908558\", combo: str=\"89905057\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"62908558\", combo=\"89905057\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_21",
    "sat": "def sat(states: List[str], start: str=\"975\", combo: str=\"797\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"975\", combo=\"797\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_22",
    "sat": "def sat(states: List[str], start: str=\"36302\", combo: str=\"79078\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"36302\", combo=\"79078\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_23",
    "sat": "def sat(states: List[str], start: str=\"18\", combo: str=\"57\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"18\", combo=\"57\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_24",
    "sat": "def sat(states: List[str], start: str=\"6\", combo: str=\"8\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6\", combo=\"8\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_25",
    "sat": "def sat(states: List[str], start: str=\"5629\", combo: str=\"9395\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5629\", combo=\"9395\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_26",
    "sat": "def sat(states: List[str], start: str=\"4320824\", combo: str=\"3484304\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4320824\", combo=\"3484304\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_27",
    "sat": "def sat(states: List[str], start: str=\"3648749541\", combo: str=\"1503240792\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3648749541\", combo=\"1503240792\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_28",
    "sat": "def sat(states: List[str], start: str=\"577212\", combo: str=\"608839\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"577212\", combo=\"608839\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_29",
    "sat": "def sat(states: List[str], start: str=\"65636527\", combo: str=\"99800171\", target_len: int=28):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"65636527\", combo=\"99800171\", target_len=28):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_30",
    "sat": "def sat(states: List[str], start: str=\"92\", combo: str=\"16\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"92\", combo=\"16\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_31",
    "sat": "def sat(states: List[str], start: str=\"42\", combo: str=\"06\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"42\", combo=\"06\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_32",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"0\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8\", combo=\"0\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_33",
    "sat": "def sat(states: List[str], start: str=\"683965052\", combo: str=\"287206495\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"683965052\", combo=\"287206495\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_34",
    "sat": "def sat(states: List[str], start: str=\"9769687746\", combo: str=\"8653683898\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9769687746\", combo=\"8653683898\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_35",
    "sat": "def sat(states: List[str], start: str=\"22217169\", combo: str=\"40818016\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"22217169\", combo=\"40818016\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_36",
    "sat": "def sat(states: List[str], start: str=\"5267\", combo: str=\"3674\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5267\", combo=\"3674\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_37",
    "sat": "def sat(states: List[str], start: str=\"59239\", combo: str=\"67535\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"59239\", combo=\"67535\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_38",
    "sat": "def sat(states: List[str], start: str=\"3412\", combo: str=\"3511\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3412\", combo=\"3511\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_39",
    "sat": "def sat(states: List[str], start: str=\"644606526\", combo: str=\"133531000\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"644606526\", combo=\"133531000\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_40",
    "sat": "def sat(states: List[str], start: str=\"470\", combo: str=\"625\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"470\", combo=\"625\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_41",
    "sat": "def sat(states: List[str], start: str=\"9043741279\", combo: str=\"8673043124\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9043741279\", combo=\"8673043124\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_42",
    "sat": "def sat(states: List[str], start: str=\"68663\", combo: str=\"60353\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"68663\", combo=\"60353\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_43",
    "sat": "def sat(states: List[str], start: str=\"9563799\", combo: str=\"3500475\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9563799\", combo=\"3500475\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_44",
    "sat": "def sat(states: List[str], start: str=\"4\", combo: str=\"5\", target_len: int=0):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4\", combo=\"5\", target_len=0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_45",
    "sat": "def sat(states: List[str], start: str=\"1512\", combo: str=\"4886\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"1512\", combo=\"4886\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_46",
    "sat": "def sat(states: List[str], start: str=\"7484\", combo: str=\"3579\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7484\", combo=\"3579\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_47",
    "sat": "def sat(states: List[str], start: str=\"153389\", combo: str=\"735261\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"153389\", combo=\"735261\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_48",
    "sat": "def sat(states: List[str], start: str=\"9\", combo: str=\"4\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9\", combo=\"4\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_49",
    "sat": "def sat(states: List[str], start: str=\"6\", combo: str=\"7\", target_len: int=0):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6\", combo=\"7\", target_len=0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_50",
    "sat": "def sat(states: List[str], start: str=\"83670\", combo: str=\"35210\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"83670\", combo=\"35210\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_51",
    "sat": "def sat(states: List[str], start: str=\"8839776\", combo: str=\"0917530\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8839776\", combo=\"0917530\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_52",
    "sat": "def sat(states: List[str], start: str=\"95\", combo: str=\"56\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"95\", combo=\"56\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_53",
    "sat": "def sat(states: List[str], start: str=\"6227\", combo: str=\"4780\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6227\", combo=\"4780\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_54",
    "sat": "def sat(states: List[str], start: str=\"03\", combo: str=\"98\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"03\", combo=\"98\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_55",
    "sat": "def sat(states: List[str], start: str=\"95444\", combo: str=\"30829\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"95444\", combo=\"30829\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_56",
    "sat": "def sat(states: List[str], start: str=\"030050\", combo: str=\"818991\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"030050\", combo=\"818991\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_57",
    "sat": "def sat(states: List[str], start: str=\"2714090\", combo: str=\"4601893\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"2714090\", combo=\"4601893\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_58",
    "sat": "def sat(states: List[str], start: str=\"3174952329\", combo: str=\"0772404224\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"3174952329\", combo=\"0772404224\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_59",
    "sat": "def sat(states: List[str], start: str=\"58994627\", combo: str=\"99616023\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"58994627\", combo=\"99616023\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_60",
    "sat": "def sat(states: List[str], start: str=\"82936\", combo: str=\"80547\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"82936\", combo=\"80547\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_61",
    "sat": "def sat(states: List[str], start: str=\"63844371\", combo: str=\"93680744\", target_len: int=22):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"63844371\", combo=\"93680744\", target_len=22):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_62",
    "sat": "def sat(states: List[str], start: str=\"5\", combo: str=\"8\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5\", combo=\"8\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_63",
    "sat": "def sat(states: List[str], start: str=\"486896318\", combo: str=\"110364497\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"486896318\", combo=\"110364497\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_64",
    "sat": "def sat(states: List[str], start: str=\"657\", combo: str=\"938\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"657\", combo=\"938\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_65",
    "sat": "def sat(states: List[str], start: str=\"8942458130\", combo: str=\"4743589796\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8942458130\", combo=\"4743589796\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_66",
    "sat": "def sat(states: List[str], start: str=\"76214771\", combo: str=\"11507983\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"76214771\", combo=\"11507983\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_67",
    "sat": "def sat(states: List[str], start: str=\"40784\", combo: str=\"30833\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"40784\", combo=\"30833\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_68",
    "sat": "def sat(states: List[str], start: str=\"05925\", combo: str=\"07029\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"05925\", combo=\"07029\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_69",
    "sat": "def sat(states: List[str], start: str=\"04308669\", combo: str=\"16075906\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"04308669\", combo=\"16075906\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_70",
    "sat": "def sat(states: List[str], start: str=\"9096105291\", combo: str=\"8381334790\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9096105291\", combo=\"8381334790\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_71",
    "sat": "def sat(states: List[str], start: str=\"26609261\", combo: str=\"21907313\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"26609261\", combo=\"21907313\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_72",
    "sat": "def sat(states: List[str], start: str=\"246155\", combo: str=\"744567\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"246155\", combo=\"744567\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_73",
    "sat": "def sat(states: List[str], start: str=\"61929254\", combo: str=\"10970807\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"61929254\", combo=\"10970807\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_74",
    "sat": "def sat(states: List[str], start: str=\"01\", combo: str=\"38\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"01\", combo=\"38\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_75",
    "sat": "def sat(states: List[str], start: str=\"12850100\", combo: str=\"52835573\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"12850100\", combo=\"52835573\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_76",
    "sat": "def sat(states: List[str], start: str=\"182403\", combo: str=\"660233\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"182403\", combo=\"660233\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_77",
    "sat": "def sat(states: List[str], start: str=\"67888845\", combo: str=\"31906953\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"67888845\", combo=\"31906953\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_78",
    "sat": "def sat(states: List[str], start: str=\"464088\", combo: str=\"766326\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"464088\", combo=\"766326\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_79",
    "sat": "def sat(states: List[str], start: str=\"940176\", combo: str=\"280564\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"940176\", combo=\"280564\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_80",
    "sat": "def sat(states: List[str], start: str=\"6942\", combo: str=\"0915\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6942\", combo=\"0915\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_81",
    "sat": "def sat(states: List[str], start: str=\"284009399\", combo: str=\"256258667\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"284009399\", combo=\"256258667\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_82",
    "sat": "def sat(states: List[str], start: str=\"121688\", combo: str=\"690944\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"121688\", combo=\"690944\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_83",
    "sat": "def sat(states: List[str], start: str=\"204816201\", combo: str=\"620523894\", target_len: int=24):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"204816201\", combo=\"620523894\", target_len=24):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_84",
    "sat": "def sat(states: List[str], start: str=\"8949\", combo: str=\"9502\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8949\", combo=\"9502\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_85",
    "sat": "def sat(states: List[str], start: str=\"09\", combo: str=\"35\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"09\", combo=\"35\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_86",
    "sat": "def sat(states: List[str], start: str=\"4820\", combo: str=\"1904\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"4820\", combo=\"1904\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_87",
    "sat": "def sat(states: List[str], start: str=\"614872257\", combo: str=\"221198895\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"614872257\", combo=\"221198895\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_88",
    "sat": "def sat(states: List[str], start: str=\"70865467\", combo: str=\"10637573\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"70865467\", combo=\"10637573\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_89",
    "sat": "def sat(states: List[str], start: str=\"396\", combo: str=\"707\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"396\", combo=\"707\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_90",
    "sat": "def sat(states: List[str], start: str=\"905484084\", combo: str=\"738628515\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"905484084\", combo=\"738628515\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_91",
    "sat": "def sat(states: List[str], start: str=\"16372\", combo: str=\"88839\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"16372\", combo=\"88839\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_92",
    "sat": "def sat(states: List[str], start: str=\"7910442\", combo: str=\"2612321\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7910442\", combo=\"2612321\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_93",
    "sat": "def sat(states: List[str], start: str=\"30\", combo: str=\"73\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"30\", combo=\"73\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_94",
    "sat": "def sat(states: List[str], start: str=\"5010331\", combo: str=\"6851290\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"5010331\", combo=\"6851290\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_95",
    "sat": "def sat(states: List[str], start: str=\"8525\", combo: str=\"4132\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8525\", combo=\"4132\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_96",
    "sat": "def sat(states: List[str], start: str=\"422\", combo: str=\"160\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"422\", combo=\"160\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_97",
    "sat": "def sat(states: List[str], start: str=\"551216090\", combo: str=\"504637022\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"551216090\", combo=\"504637022\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_98",
    "sat": "def sat(states: List[str], start: str=\"8315482\", combo: str=\"8888343\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"8315482\", combo=\"8888343\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLock_99",
    "sat": "def sat(states: List[str], start: str=\"917770726\", combo: str=\"247138502\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"917770726\", combo=\"247138502\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_0",
    "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"012\", combo=\"329\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_1",
    "sat": "def sat(states: List[str], start: str=\"56300340\", combo: str=\"46697465\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"56300340\", combo=\"46697465\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_2",
    "sat": "def sat(states: List[str], start: str=\"2164222519\", combo: str=\"5256679468\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2164222519\", combo=\"5256679468\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_3",
    "sat": "def sat(states: List[str], start: str=\"3069977\", combo: str=\"1891210\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3069977\", combo=\"1891210\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_4",
    "sat": "def sat(states: List[str], start: str=\"3\", combo: str=\"2\", target_len: int=0):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3\", combo=\"2\", target_len=0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_5",
    "sat": "def sat(states: List[str], start: str=\"55161\", combo: str=\"08362\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"55161\", combo=\"08362\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_6",
    "sat": "def sat(states: List[str], start: str=\"7572\", combo: str=\"5907\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7572\", combo=\"5907\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_7",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"5\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8\", combo=\"5\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_8",
    "sat": "def sat(states: List[str], start: str=\"90\", combo: str=\"88\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"90\", combo=\"88\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_9",
    "sat": "def sat(states: List[str], start: str=\"4678029421\", combo: str=\"7281867890\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"4678029421\", combo=\"7281867890\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_10",
    "sat": "def sat(states: List[str], start: str=\"79014\", combo: str=\"00653\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"79014\", combo=\"00653\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_11",
    "sat": "def sat(states: List[str], start: str=\"378382\", combo: str=\"668860\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"378382\", combo=\"668860\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_12",
    "sat": "def sat(states: List[str], start: str=\"6941\", combo: str=\"0486\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6941\", combo=\"0486\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_13",
    "sat": "def sat(states: List[str], start: str=\"0387219\", combo: str=\"0466903\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"0387219\", combo=\"0466903\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_14",
    "sat": "def sat(states: List[str], start: str=\"032\", combo: str=\"431\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"032\", combo=\"431\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_15",
    "sat": "def sat(states: List[str], start: str=\"36489\", combo: str=\"39221\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"36489\", combo=\"39221\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_16",
    "sat": "def sat(states: List[str], start: str=\"14\", combo: str=\"45\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"14\", combo=\"45\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_17",
    "sat": "def sat(states: List[str], start: str=\"55079\", combo: str=\"06853\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"55079\", combo=\"06853\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_18",
    "sat": "def sat(states: List[str], start: str=\"921808733\", combo: str=\"490815978\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"921808733\", combo=\"490815978\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_19",
    "sat": "def sat(states: List[str], start: str=\"1\", combo: str=\"4\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"1\", combo=\"4\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_20",
    "sat": "def sat(states: List[str], start: str=\"203673141\", combo: str=\"064239312\", target_len: int=24):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"203673141\", combo=\"064239312\", target_len=24):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_21",
    "sat": "def sat(states: List[str], start: str=\"8876943\", combo: str=\"6216563\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8876943\", combo=\"6216563\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_22",
    "sat": "def sat(states: List[str], start: str=\"7644602\", combo: str=\"1745883\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7644602\", combo=\"1745883\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_23",
    "sat": "def sat(states: List[str], start: str=\"9939826561\", combo: str=\"2177042233\", target_len: int=26):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"9939826561\", combo=\"2177042233\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_24",
    "sat": "def sat(states: List[str], start: str=\"0275398698\", combo: str=\"3863797961\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"0275398698\", combo=\"3863797961\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_25",
    "sat": "def sat(states: List[str], start: str=\"97820\", combo: str=\"39977\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"97820\", combo=\"39977\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_26",
    "sat": "def sat(states: List[str], start: str=\"55\", combo: str=\"42\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"55\", combo=\"42\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_27",
    "sat": "def sat(states: List[str], start: str=\"05678\", combo: str=\"47195\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"05678\", combo=\"47195\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_28",
    "sat": "def sat(states: List[str], start: str=\"732370981\", combo: str=\"846288075\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"732370981\", combo=\"846288075\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_29",
    "sat": "def sat(states: List[str], start: str=\"255831\", combo: str=\"095922\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"255831\", combo=\"095922\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_30",
    "sat": "def sat(states: List[str], start: str=\"621415884\", combo: str=\"682654575\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"621415884\", combo=\"682654575\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_31",
    "sat": "def sat(states: List[str], start: str=\"122130627\", combo: str=\"686000101\", target_len: int=27):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"122130627\", combo=\"686000101\", target_len=27):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_32",
    "sat": "def sat(states: List[str], start: str=\"099799323\", combo: str=\"772590431\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"099799323\", combo=\"772590431\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_33",
    "sat": "def sat(states: List[str], start: str=\"95761055\", combo: str=\"38390044\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"95761055\", combo=\"38390044\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_34",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"0\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8\", combo=\"0\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_35",
    "sat": "def sat(states: List[str], start: str=\"24221\", combo: str=\"96788\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"24221\", combo=\"96788\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_36",
    "sat": "def sat(states: List[str], start: str=\"467\", combo: str=\"954\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"467\", combo=\"954\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_37",
    "sat": "def sat(states: List[str], start: str=\"622392172\", combo: str=\"685300142\", target_len: int=12):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"622392172\", combo=\"685300142\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_38",
    "sat": "def sat(states: List[str], start: str=\"5735058\", combo: str=\"0804152\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5735058\", combo=\"0804152\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_39",
    "sat": "def sat(states: List[str], start: str=\"51\", combo: str=\"09\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"51\", combo=\"09\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_40",
    "sat": "def sat(states: List[str], start: str=\"14\", combo: str=\"52\", target_len: int=5):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"14\", combo=\"52\", target_len=5):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_41",
    "sat": "def sat(states: List[str], start: str=\"3\", combo: str=\"1\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3\", combo=\"1\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_42",
    "sat": "def sat(states: List[str], start: str=\"5964\", combo: str=\"9583\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5964\", combo=\"9583\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_43",
    "sat": "def sat(states: List[str], start: str=\"8\", combo: str=\"1\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8\", combo=\"1\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_44",
    "sat": "def sat(states: List[str], start: str=\"8398\", combo: str=\"4096\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8398\", combo=\"4096\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_45",
    "sat": "def sat(states: List[str], start: str=\"61269\", combo: str=\"54357\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"61269\", combo=\"54357\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_46",
    "sat": "def sat(states: List[str], start: str=\"61\", combo: str=\"24\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"61\", combo=\"24\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_47",
    "sat": "def sat(states: List[str], start: str=\"8030\", combo: str=\"3885\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8030\", combo=\"3885\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_48",
    "sat": "def sat(states: List[str], start: str=\"594752\", combo: str=\"334954\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"594752\", combo=\"334954\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_49",
    "sat": "def sat(states: List[str], start: str=\"4930447\", combo: str=\"4030188\", target_len: int=8):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"4930447\", combo=\"4030188\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_50",
    "sat": "def sat(states: List[str], start: str=\"88853874\", combo: str=\"85111832\", target_len: int=17):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"88853874\", combo=\"85111832\", target_len=17):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_51",
    "sat": "def sat(states: List[str], start: str=\"75\", combo: str=\"70\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"75\", combo=\"70\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_52",
    "sat": "def sat(states: List[str], start: str=\"365123\", combo: str=\"713146\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"365123\", combo=\"713146\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_53",
    "sat": "def sat(states: List[str], start: str=\"944210580\", combo: str=\"600879196\", target_len: int=28):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"944210580\", combo=\"600879196\", target_len=28):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_54",
    "sat": "def sat(states: List[str], start: str=\"0147304168\", combo: str=\"6231030133\", target_len: int=27):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"0147304168\", combo=\"6231030133\", target_len=27):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_55",
    "sat": "def sat(states: List[str], start: str=\"90\", combo: str=\"79\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"90\", combo=\"79\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_56",
    "sat": "def sat(states: List[str], start: str=\"392226\", combo: str=\"172861\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"392226\", combo=\"172861\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_57",
    "sat": "def sat(states: List[str], start: str=\"52976\", combo: str=\"01223\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"52976\", combo=\"01223\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_58",
    "sat": "def sat(states: List[str], start: str=\"7379\", combo: str=\"3062\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7379\", combo=\"3062\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_59",
    "sat": "def sat(states: List[str], start: str=\"93576482\", combo: str=\"17298023\", target_len: int=21):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"93576482\", combo=\"17298023\", target_len=21):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_60",
    "sat": "def sat(states: List[str], start: str=\"8816263359\", combo: str=\"4914849140\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"8816263359\", combo=\"4914849140\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_61",
    "sat": "def sat(states: List[str], start: str=\"83168\", combo: str=\"06405\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"83168\", combo=\"06405\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_62",
    "sat": "def sat(states: List[str], start: str=\"7709789710\", combo: str=\"2858456193\", target_len: int=29):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7709789710\", combo=\"2858456193\", target_len=29):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_63",
    "sat": "def sat(states: List[str], start: str=\"81251322\", combo: str=\"34504312\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"81251322\", combo=\"34504312\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_64",
    "sat": "def sat(states: List[str], start: str=\"304497\", combo: str=\"647525\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"304497\", combo=\"647525\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_65",
    "sat": "def sat(states: List[str], start: str=\"2\", combo: str=\"8\", target_len: int=3):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2\", combo=\"8\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_66",
    "sat": "def sat(states: List[str], start: str=\"7578573725\", combo: str=\"0245224184\", target_len: int=29):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7578573725\", combo=\"0245224184\", target_len=29):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_67",
    "sat": "def sat(states: List[str], start: str=\"56480\", combo: str=\"29327\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"56480\", combo=\"29327\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_68",
    "sat": "def sat(states: List[str], start: str=\"1\", combo: str=\"9\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"1\", combo=\"9\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_69",
    "sat": "def sat(states: List[str], start: str=\"81088\", combo: str=\"89148\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"81088\", combo=\"89148\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_70",
    "sat": "def sat(states: List[str], start: str=\"19801078\", combo: str=\"58243505\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"19801078\", combo=\"58243505\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_71",
    "sat": "def sat(states: List[str], start: str=\"6456\", combo: str=\"9419\", target_len: int=9):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6456\", combo=\"9419\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_72",
    "sat": "def sat(states: List[str], start: str=\"3192688\", combo: str=\"0283336\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3192688\", combo=\"0283336\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_73",
    "sat": "def sat(states: List[str], start: str=\"5\", combo: str=\"7\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5\", combo=\"7\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_74",
    "sat": "def sat(states: List[str], start: str=\"293128\", combo: str=\"451407\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"293128\", combo=\"451407\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_75",
    "sat": "def sat(states: List[str], start: str=\"878\", combo: str=\"969\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"878\", combo=\"969\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_76",
    "sat": "def sat(states: List[str], start: str=\"526114\", combo: str=\"312729\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"526114\", combo=\"312729\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_77",
    "sat": "def sat(states: List[str], start: str=\"2941753473\", combo: str=\"3237597846\", target_len: int=28):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2941753473\", combo=\"3237597846\", target_len=28):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_78",
    "sat": "def sat(states: List[str], start: str=\"19684412\", combo: str=\"76259103\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"19684412\", combo=\"76259103\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_79",
    "sat": "def sat(states: List[str], start: str=\"20\", combo: str=\"38\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"20\", combo=\"38\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_80",
    "sat": "def sat(states: List[str], start: str=\"7929\", combo: str=\"1644\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"7929\", combo=\"1644\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_81",
    "sat": "def sat(states: List[str], start: str=\"5434094109\", combo: str=\"0473933550\", target_len: int=25):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5434094109\", combo=\"0473933550\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_82",
    "sat": "def sat(states: List[str], start: str=\"46706\", combo: str=\"01542\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"46706\", combo=\"01542\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_83",
    "sat": "def sat(states: List[str], start: str=\"3504804\", combo: str=\"4727097\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"3504804\", combo=\"4727097\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_84",
    "sat": "def sat(states: List[str], start: str=\"5287082107\", combo: str=\"5418795951\", target_len: int=23):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5287082107\", combo=\"5418795951\", target_len=23):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_85",
    "sat": "def sat(states: List[str], start: str=\"050\", combo: str=\"990\", target_len: int=4):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"050\", combo=\"990\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_86",
    "sat": "def sat(states: List[str], start: str=\"98283623\", combo: str=\"89030615\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"98283623\", combo=\"89030615\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_87",
    "sat": "def sat(states: List[str], start: str=\"5402\", combo: str=\"2036\", target_len: int=13):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5402\", combo=\"2036\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_88",
    "sat": "def sat(states: List[str], start: str=\"196\", combo: str=\"986\", target_len: int=2):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"196\", combo=\"986\", target_len=2):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_89",
    "sat": "def sat(states: List[str], start: str=\"936269908\", combo: str=\"845879488\", target_len: int=14):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"936269908\", combo=\"845879488\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_90",
    "sat": "def sat(states: List[str], start: str=\"6721231\", combo: str=\"7110857\", target_len: int=16):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6721231\", combo=\"7110857\", target_len=16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_91",
    "sat": "def sat(states: List[str], start: str=\"470678\", combo: str=\"413609\", target_len: int=10):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"470678\", combo=\"413609\", target_len=10):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_92",
    "sat": "def sat(states: List[str], start: str=\"6001656\", combo: str=\"2027128\", target_len: int=19):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"6001656\", combo=\"2027128\", target_len=19):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_93",
    "sat": "def sat(states: List[str], start: str=\"71708\", combo: str=\"84283\", target_len: int=15):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"71708\", combo=\"84283\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_94",
    "sat": "def sat(states: List[str], start: str=\"9\", combo: str=\"7\", target_len: int=1):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"9\", combo=\"7\", target_len=1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_95",
    "sat": "def sat(states: List[str], start: str=\"98\", combo: str=\"23\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"98\", combo=\"23\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_96",
    "sat": "def sat(states: List[str], start: str=\"780\", combo: str=\"278\", target_len: int=7):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"780\", combo=\"278\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_97",
    "sat": "def sat(states: List[str], start: str=\"466004\", combo: str=\"164623\", target_len: int=11):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"466004\", combo=\"164623\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_98",
    "sat": "def sat(states: List[str], start: str=\"2387379\", combo: str=\"8746063\", target_len: int=20):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"2387379\", combo=\"8746063\", target_len=20):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "CombinationLockObfuscated_99",
    "sat": "def sat(states: List[str], start: str=\"298869\", combo: str=\"566402\", target_len: int=18):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"298869\", combo=\"566402\", target_len=18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ]
  },
  {
    "name": "InvertPermutation_0",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hello are you there?\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hello are you there?\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_1",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vulunolyhinesada xorasisovof rytenada bylofyhothasyjosoc w chumaqueletexteth bugicovozu vorapeky hochydoroxososehe\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vulunolyhinesada xorasisovof rytenada bylofyhothasyjosoc w chumaqueletexteth bugicovozu vorapeky hochydoroxososehe\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_2",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quir chodytufiwefes zazibohonych\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quir chodytufiwefes zazibohonych\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_3",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gotosutextes kehipik z nocut delybiwogevefy xagumykovemabezezir guwolakopigitextac laduwowivecobikorura\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gotosutextes kehipik z nocut delybiwogevefy xagumykovemabezezir guwolakopigitextac laduwowivecobikorura\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_4",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xichugutachonanokot mu syruvugolebovazy h wyth labovamabuw lytextokatextukidom mydyfocysozonet\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xichugutachonanokot mu syruvugolebovazy h wyth labovamabuw lytextokatextukidom mydyfocysozonet\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_5",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"mogalyth gyquuzuban paz tehehujinych bedanijibathasibowop textolav robuhutextylu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mogalyth gyquuzuban paz tehehujinych bedanijibathasibowop textolav robuhutextylu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_6",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xo ryhunawehikuzum thifynavaguvug mucetetacoxiv gachuw du sivizef\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xo ryhunawehikuzum thifynavaguvug mucetetacoxiv gachuw du sivizef\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_7",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xabiwoxe lup lexofatemuxaberevu fa zilutext l paxamagonac cewydyrodisizu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xabiwoxe lup lexofatemuxaberevu fa zilutext l paxamagonac cewydyrodisizu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_8",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fyrochunu pikokevogi wychacaf\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fyrochunu pikokevogi wychacaf\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_9",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"suthoruxa quimizafidyvejite gycawaquinolufe xefote dobapihobytexto motip dogiwytex\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"suthoruxa quimizafidyvejite gycawaquinolufe xefote dobapihobytexto motip dogiwytex\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_10",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fygobotozenefoxi pylat\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fygobotozenefoxi pylat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_11",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hegejinibepogafix thisoxig rilomo\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hegejinibepogafix thisoxig rilomo\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_12",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jubof gydokariq kukawefohuthopex deth\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jubof gydokariq kukawefohuthopex deth\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_13",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"mah sitiqu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mah sitiqu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_14",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thivig biquudowonim\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thivig biquudowonim\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_15",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tot dexomica chenupythuhazaxoxy vyminykerahitak halis choquyciquapu wumexijesosatextace\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tot dexomica chenupythuhazaxoxy vyminykerahitak halis choquyciquapu wumexijesosatextace\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_16",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"b t ch que wa tyronejadadu p xubovyvitextoqu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"b t ch que wa tyronejadadu p xubovyvitextoqu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_17",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jasecemitaw muthawoce\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jasecemitaw muthawoce\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_18",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hipatexterawojas vawucagisy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hipatexterawojas vawucagisy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_19",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fapobumozywe co quirymypisuci gequocasuhotextoquyg ret xogoquotextudecepuc thachytiquijus wacimexur\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fapobumozywe co quirymypisuci gequocasuhotextoquyg ret xogoquotextudecepuc thachytiquijus wacimexur\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_20",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pabykusigy xoboroko kigi thiwibowosefapazax textibuxewelubowy totan topejyziwoquux ma\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pabykusigy xoboroko kigi thiwibowosefapazax textibuxewelubowy totan topejyziwoquux ma\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_21",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gazujuwyzawih bubitextetex bometextupy zuretyvukyquaque pegidychuseh nelowazytexticutuze jat fyverivak\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gazujuwyzawih bubitextetex bometextupy zuretyvukyquaque pegidychuseh nelowazytexticutuze jat fyverivak\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_22",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quovi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quovi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_23",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"chanakorozydexizot juhaquizyrynydi wodypitextyxodadeth textoviquoraki thetagalyzyme\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chanakorozydexizot juhaquizyrynydi wodypitextyxodadeth textoviquoraki thetagalyzyme\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_24",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vuquytextytextujojyw thechocudyxire mynakazugybydu sizozirotextuvum kalih chivisovibudufoziqu delisocut dovixynatexta\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vuquytextytextujojyw thechocudyxire mynakazugybydu sizozirotextuvum kalih chivisovibudufoziqu delisocut dovixynatexta\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_25",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"balosylafic cesigomozichotahuky rothuwiw f chinithaku\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"balosylafic cesigomozichotahuky rothuwiw f chinithaku\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_26",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"f th\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"f th\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_27",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"najimadulenuwosuzeri lachifilaxanatar vyjythuthixytextoth jagygiseritextuxuhyk\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"najimadulenuwosuzeri lachifilaxanatar vyjythuthixytextoth jagygiseritextuxuhyk\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_28",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thyz fopipisy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thyz fopipisy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_29",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zokisemy thebydu xypityxopav thythajach sodicu xycho nichuzolithojybytex nypu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zokisemy thebydu xypityxopav thythajach sodicu xycho nichuzolithojybytex nypu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_30",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thybathog sonumujethyjugoqu ri zachady thec sunehudochyrakihu textasiwoquycaxecub joquigyzowohu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thybathog sonumujethyjugoqu ri zachady thec sunehudochyrakihu textasiwoquycaxecub joquigyzowohu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_31",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"viwafyte g\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"viwafyte g\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_32",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"dumequugiwicucym naryg hefamathithor betujodyl lotalafevysopefyne sonohichitheba\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"dumequugiwicucym naryg hefamathithor betujodyl lotalafevysopefyne sonohichitheba\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_33",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"chisyvoquejururomu woraputexto lojyfechalyc rurudofyquoth gycapokelasomu cytexturetextoguwech\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chisyvoquejururomu woraputexto lojyfechalyc rurudofyquoth gycapokelasomu cytexturetextoguwech\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_34",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jathocathytyxo gemivyquugix galozexucebapudesica c lolobob\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jathocathytyxo gemivyquugix galozexucebapudesica c lolobob\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_35",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wethevepehogocape\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wethevepehogocape\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_36",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"chyquethe jesepolysy mopijigocebygumiro coquajilyw\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chyquethe jesepolysy mopijigocebygumiro coquajilyw\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_37",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"nasyhahohys xythechyquy kudojowenutigi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"nasyhahohys xythechyquy kudojowenutigi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_38",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xetextyquo puch hytextugimit rijaxa m cuxirethugirywoho lelasitorix\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xetextyquo puch hytextugimit rijaxa m cuxirethugirywoho lelasitorix\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_39",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wogitextitocyli lisaxygulemec bykyge zygopusebywachyg ralij dumywibethe bejedew fesoj\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wogitextitocyli lisaxygulemec bykyge zygopusebywachyg ralij dumywibethe bejedew fesoj\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_40",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"verogerythichi lachonaxacucutyb\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"verogerythichi lachonaxacucutyb\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_41",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"xovamojewib\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"xovamojewib\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_42",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pomuchunybovolum chatextugi bamiquevyniwomuxuxu gar tydatuxanogegat fa\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pomuchunybovolum chatextugi bamiquevyniwomuxuxu gar tydatuxanogegat fa\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_43",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hehechyliliruna dokote sojithihymuquadate cusaz rekosufethugipifu jo bas chocesycozuxigycyryp\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hehechyliliruna dokote sojithihymuquadate cusaz rekosufethugipifu jo bas chocesycozuxigycyryp\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_44",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"rah mujotomuques jycochopevich\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"rah mujotomuques jycochopevich\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_45",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"dypigybasatexti xeq\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"dypigybasatexti xeq\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_46",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pytextufik hy nuwymuzuchanuquomafi nawuchumed kyhi xuw\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pytextufik hy nuwymuzuchanuquomafi nawuchumed kyhi xuw\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_47",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tudemytijymy nythoquigaquiryd dexu vagecenethaj\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tudemytijymy nythoquigaquiryd dexu vagecenethaj\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_48",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"haxefulyhamomequ\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"haxefulyhamomequ\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_49",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"kegody dehekagozy tesyvocyginochykib purisav chythythatext\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kegody dehekagozy tesyvocyginochykib purisav chythythatext\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_50",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quutym quethevat catibyvopepynohesy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quutym quethevat catibyvopepynohesy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_51",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"losyquytextothoc jimitex symihosujezowiv hecuchyr topivomudechepamad byq jykajukunimaxuky\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"losyquytextothoc jimitex symihosujezowiv hecuchyr topivomudechepamad byq jykajukunimaxuky\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_52",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"sabynatextocic\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"sabynatextocic\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_53",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"rykuroderetextoxyd pamykysax tex jarumatextuza pyjeluthe quakichokov quuquysekatyq\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"rykuroderetextoxyd pamykysax tex jarumatextuza pyjeluthe quakichokov quuquysekatyq\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_54",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"nuchemev zaqu mynexunumecocewitivi dytextycocupadequo mikuduchyfecihika fupotavepysofaj d\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"nuchemev zaqu mynexunumecocewitivi dytextycocupadequo mikuduchyfecihika fupotavepysofaj d\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_55",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vapuchuthymyrofiqu doth pylyxymacozitextychi vithom\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vapuchuthymyrofiqu doth pylyxymacozitextychi vithom\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_56",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zohufax jakanemidanatufut kanethycyk\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zohufax jakanemidanatufut kanethycyk\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_57",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ropozasat\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ropozasat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_58",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ritunycoxulyjihut hotho fow\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ritunycoxulyjihut hotho fow\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_59",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zik\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zik\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_60",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"mapyheniropu vawatextohihi fudukubetowapucocyjy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mapyheniropu vawatextohihi fudukubetowapucocyjy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_61",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"kitextaxutheno bihob dolethequ zethogotext wy vivokaxusywatagi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kitextaxutheno bihob dolethequ zethogotext wy vivokaxusywatagi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_62",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"texticumiqu nahajodajuwuzahuhyfy podajyfotextekutextu busesowevatext textuchexavyfivu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"texticumiqu nahajodajuwuzahuhyfy podajyfotextekutextu busesowevatext textuchexavyfivu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_63",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wabihuzachy z textikebeth jypykohezodaf textoza pudy thacyquirufocuthypis textet\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wabihuzachy z textikebeth jypykohezodaf textoza pudy thacyquirufocuthypis textet\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_64",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"j soxyja kovowechirysyro ximepakebehizofa dybutext gelythegilygadymuth tazyjelicic sihuquufa tohathojyhutextat\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"j soxyja kovowechirysyro ximepakebehizofa dybutext gelythegilygadymuth tazyjelicic sihuquufa tohathojyhutextat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_65",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gechochify sythepony ca jechyt pinirasethythaxazy quujechothiwupa nyfykimutyr zu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gechochify sythepony ca jechyt pinirasethythaxazy quujechothiwupa nyfykimutyr zu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_66",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"het vajithyhaci\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"het vajithyhaci\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_67",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gewecutufifozethach chyzoqu tokuquitextawu quohubomaf totoj logytocaluxat lech zac giwohorowaquanimy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gewecutufifozethach chyzoqu tokuquitextawu quohubomaf totoj logytocaluxat lech zac giwohorowaquanimy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_68",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jetholuropechysumexo keguloquykythywasy textix radelego quezo budirecysic sonuchotextute\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jetholuropechysumexo keguloquykythywasy textix radelego quezo budirecysic sonuchotextute\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_69",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tychumi sif gipyvesag seguz gihi totykilohykasithyth\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tychumi sif gipyvesag seguz gihi totykilohykasithyth\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_70",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"sybivocohefudezaruj giwesyt togy vo\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"sybivocohefudezaruj giwesyt togy vo\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_71",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ko hufixyjuxicygydul jebythozec buquetahupalerirot\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ko hufixyjuxicygydul jebythozec buquetahupalerirot\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_72",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"nutextuchopuzyte chatextihopuhux chofache gorichy juthefygolevom negichyzubot difuqui xajudythuquanucura fuchadygokugu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"nutextuchopuzyte chatextihopuhux chofache gorichy juthefygolevom negichyzubot difuqui xajudythuquanucura fuchadygokugu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_73",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fuxeput mysitubiqu zypasa wylikiqu gothohykyfakal pocethithibaregozo thona bubuwivyror hajidynotypoz\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fuxeput mysitubiqu zypasa wylikiqu gothohykyfakal pocethithibaregozo thona bubuwivyror hajidynotypoz\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_74",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"sunizyzofufohyn va nuroratufokohudomon fexiparo fybevujin nirinojelecul\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"sunizyzofufohyn va nuroratufokohudomon fexiparo fybevujin nirinojelecul\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_75",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"gilukifaratexticylan vynagocatyfiquogujig\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"gilukifaratexticylan vynagocatyfiquogujig\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_76",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"cemyxugax maboniq chethogytextetuxed gabuthofuthewukequ xikyli\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"cemyxugax maboniq chethogytextetuxed gabuthofuthewukequ xikyli\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_77",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"thogocovapodat cafyjuhijama fycithuj piraquupatewigebythi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"thogocovapodat cafyjuhijama fycithuj piraquupatewigebythi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_78",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tagimodyryjowotexty nuthurased\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tagimodyryjowotexty nuthurased\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_79",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"textufuque kykacozed chethachuzizotextafa kewab cudax jo pifosylodiletex textejetextetextaka\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"textufuque kykacozed chethachuzizotextafa kewab cudax jo pifosylodiletex textejetextetextaka\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_80",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ryzugacheq darudy guquecojitextuxumef\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ryzugacheq darudy guquecojitextuxumef\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_81",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"jenilasoquyq depusufavokiquo pijob kerudatozyfasochu\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"jenilasoquyq depusufavokiquo pijob kerudatozyfasochu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_82",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tiquukag vufijijery textec surathu cebazopajani mequoveremyp pikicycutopemuhukoni cowugotexte\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tiquukag vufijijery textec surathu cebazopajani mequoveremyp pikicycutopemuhukoni cowugotexte\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_83",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quetygach chus textytextovydytex cugapahyku d zuwoladujudacutex dovucoxotextomazot qua ty\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quetygach chus textytextovydytex cugapahyku d zuwoladujudacutex dovucoxotextomazot qua ty\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_84",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"tochuchevexelavuteda ce hach fuf rafazichokojothiz dytenurojihethi chaji dasig pot\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"tochuchevexelavuteda ce hach fuf rafazichokojothiz dytenurojihethi chaji dasig pot\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_85",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hoseq sopuc fibafiladym bapuhavysi na fyfuxiwokowyvi zypyx henithythaxi sejethequahithyc\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hoseq sopuc fibafiladym bapuhavysi na fyfuxiwokowyvi zypyx henithythaxi sejethequahithyc\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_86",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ha kefywag fepel rewekutha gucosew noroz quavutexta\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ha kefywag fepel rewekutha gucosew noroz quavutexta\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_87",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"le ze go murawulachochitext quygymevethulyzazo\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"le ze go murawulachochitext quygymevethulyzazo\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_88",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"dycypuz textasuthathe thahythetha quonychew libaruteth cufomyquyxefewe netextyth thyc je\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"dycypuz textasuthathe thahythetha quonychew libaruteth cufomyquyxefewe netextyth thyc je\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_89",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"ris fabaxy gugyquachetext fixejozebofute t kusosutedykily quaquytextychajugy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"ris fabaxy gugyquachetext fixejozebofute t kusosutedykily quaquytextychajugy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_90",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"textohipu tuwatextihejajes thich vi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"textohipu tuwatextihejajes thich vi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_91",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"wohul chan bohuhovomykacu puryzejajetextarop hocutextegifeque mequojuxowivychusich papamutextitiherito fykuhemywynichetexti\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"wohul chan bohuhovomykacu puryzejajetextarop hocutextegifeque mequojuxowivychusich papamutextitiherito fykuhemywynichetexti\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_92",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"potextixyqu jochonyh fipywitextyxukelavom ma zothymesu quylygaxe tuzuxehufu wyfyvatext mokuvycotoco\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"potextixyqu jochonyh fipywitextyxukelavom ma zothymesu quylygaxe tuzuxehufu wyfyvatext mokuvycotoco\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_93",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"vil mequofe tubachyminekumuv quacy kyb novirudozy thafitarywiratono\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"vil mequofe tubachyminekumuv quacy kyb novirudozy thafitarywiratono\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_94",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"kifagebunedothete jaxajirelugut gyme quamibyji hokarazodetezafyquu lulechuthichukopif\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kifagebunedothete jaxajirelugut gyme quamibyji hokarazodetezafyquu lulechuthichukopif\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_95",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"pelyvi\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"pelyvi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_96",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"zusitikit cechewiquov texto\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"zusitikit cechewiquov texto\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_97",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"judu wutad\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"judu wutad\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_98",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"fehaquiwoxocih thuquasyquedapuquequ cuzichubak sazugyditext sodufahotextitex x dyvirira cuchivygelasafiwy\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fehaquiwoxocih thuquasyquedapuquequ cuzichubak sazugyditext sodufahotextitex x dyvirira cuchivygelasafiwy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  },
  {
    "name": "InvertPermutation_99",
    "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"quu cirufup cymevudyloxirujivac\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c)+1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"quu cirufup cymevudyloxirujivac\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ]
  }
]