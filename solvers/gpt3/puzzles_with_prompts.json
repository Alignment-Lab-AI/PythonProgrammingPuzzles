[
    {
        "name": "Nash_0",
        "sat": "def sat(strategies: List[List[float]], A: List[List[float]]=[[-1.0, -3.0], [0.0, -2.0]], B: List[List[float]]=[[-1.0, 0.0], [-3.0, -2.0]], eps: float=0.01):\n    assert type(strategies) is list and all(type(a) is list and all(type(b) is float for b in a) for a in strategies), 'strategies must be of type List[List[float]]'  # error tolerance\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
        "desc": "Compute a [Nash equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium) for a given\n[bimatrix game](https://en.wikipedia.org/wiki/Bimatrix_game). While this problem was known to be\nPPAD-hard in general. In fact the challenge is be much easier for an approximate\n[eps-equilibrium](https://en.wikipedia.org/wiki/Epsilon-equilibrium) and of course for small games.",
        "prompts": {
            "short": "def f(strategies: List[List[float]], A=[[-1.0, -3.0], [0.0, -2.0]], B=[[-1.0, 0.0], [-3.0, -2.0]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(strategies: List[List[float]], A=[[-1.0, -3.0], [0.0, -2.0]], B=[[-1.0, 0.0], [-3.0, -2.0]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(strategies: List[List[float]], A=[[-1.0, -3.0], [0.0, -2.0]], B=[[-1.0, 0.0], [-3.0, -2.0]], eps=0.01):\n    \"\"\"Compute a [Nash equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium) for a given\n    [bimatrix game](https://en.wikipedia.org/wiki/Bimatrix_game). While this problem was known to be\n    PPAD-hard in general. In fact the challenge is be much easier for an approximate\n    [eps-equilibrium](https://en.wikipedia.org/wiki/Epsilon-equilibrium) and of course for small games.\"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\nassert True == f6("
        }
    },
    {
        "name": "ZeroSum_0",
        "sat": "def sat(strategies: List[List[float]], A: List[List[float]]=[[0.0, -1.0, 1.0], [1.0, 0.0, -1.0], [-1.0, 1.0, 0.0]], eps: float=0.1):\n    assert type(strategies) is list and all(type(a) is list and all(type(b) is float for b in a) for a in strategies), 'strategies must be of type List[List[float]]'  # error tolerance\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
        "desc": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming.",
        "prompts": {
            "short": "def f(strategies: List[List[float]], A=[[0.0, -1.0, 1.0], [1.0, 0.0, -1.0], [-1.0, 1.0, 0.0]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(strategies: List[List[float]], A=[[0.0, -1.0, 1.0], [1.0, 0.0, -1.0], [-1.0, 1.0, 0.0]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(strategies: List[List[float]], A=[[0.0, -1.0, 1.0], [1.0, 0.0, -1.0], [-1.0, 1.0, 0.0]], eps=0.1):\n    \"\"\"Compute minimax optimal strategies for a given\n    [zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\n    Linear Programming.\"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))\n\nassert True == f6("
        }
    },
    {
        "name": "BirthdayParadox_0",
        "sat": "def sat(n: int, year_len: int=365):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
        "desc": "Find `n` such that the probability of two people having the same birthday in a group of `n` is near `1/2`.\nThe year length is year_len (365 is earth, while Neptune year is 60,182)\nSee [Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category))",
        "prompts": {
            "short": "def f(n: int, year_len=365):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, year_len=365):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, year_len=365):\n    \"\"\"Find `n` such that the probability of two people having the same birthday in a group of `n` is near `1/2`.\n    The year length is year_len (365 is earth, while Neptune year is 60,182)\n    See [Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category))\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len\n\nassert True == f6("
        }
    },
    {
        "name": "ExponentialProbability_0",
        "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.5):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
        "desc": "Find stopping probability, so that the probability of stopping in `steps` or fewer time steps\nis the given `target_prob`.\nSee [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)",
        "prompts": {
            "short": "def f(p_stop: float, steps=10, target_prob=0.5):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(p_stop: float, steps=10, target_prob=0.5):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(p_stop: float, steps=10, target_prob=0.5):\n    \"\"\"Find stopping probability, so that the probability of stopping in `steps` or fewer time steps\n    is the given `target_prob`.\n    See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)\"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6\n\nassert True == f6("
        }
    },
    {
        "name": "LZW_0",
        "sat": "def sat(seq: List[int], compressed_len: int=17, text: str=\"Hellooooooooooooooooooooo world!\"):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
        "desc": "Find a (short) compression that decompresses to the given string.\nWe have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.",
        "prompts": {
            "short": "def f(seq: List[int], compressed_len=17, text='Hellooooooooooooooooooooo world!'):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(seq: List[int], compressed_len=17, text='Hellooooooooooooooooooooo world!'):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(seq: List[int], compressed_len=17, text='Hellooooooooooooooooooooo world!'):\n    \"\"\"Find a (short) compression that decompresses to the given string.\n    We have provided a simple version of the *decompression* algorithm of\n    [Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\n    so the solution is the *compression* algorithm.\"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len\n\nassert True == f6("
        }
    },
    {
        "name": "PackingHam_0",
        "sat": "def sat(words: List[str], num: int=100, bits: int=100, dist: int=34):\n    assert type(words) is list and all(type(a) is str for a in words), 'words must be of type List[str]'\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
        "desc": "Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\n\nThis is a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces) in coding theory.",
        "prompts": {
            "short": "def f(words: List[str], num=100, bits=100, dist=34):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(words: List[str], num=100, bits=100, dist=34):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(words: List[str], num=100, bits=100, dist=34):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\n    \n    This is a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces) in coding theory.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))\n\nassert True == f6("
        }
    },
    {
        "name": "FindRepeats_0",
        "sat": "def sat(indices: List[int], a0: int=123):\n    assert type(indices) is list and all(type(a) is int for a in indices), 'indices must be of type List[int]'\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
        "desc": "Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\noccurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\na_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\nFor a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\nSample input:\n9\n\nSample output:\n[0, 3, 6, ..., 2997]\n\nThe sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\nall equal in this case.\n\nNote: This problem is much easier than the IMO problem which also required a proof that it is impossible\nfor a_0 not divisible by 3.\n\nInspired by [IMO 2017 Problem 1](https://www.imo-official.org/problems.aspx)",
        "prompts": {
            "short": "def f(indices: List[int], a0=123):\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(indices: List[int], a0=123):\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(indices: List[int], a0=123):\n    \"\"\"Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n    \n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n    \n    Sample input:\n    9\n    \n    Sample output:\n    [0, 3, 6, ..., 2997]\n    \n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \n    Note: This problem is much easier than the IMO problem which also required a proof that it is impossible\n    for a_0 not divisible by 3.\n    \n    Inspired by [IMO 2017 Problem 1](https://www.imo-official.org/problems.aspx)\"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1\n\nassert True == f6("
        }
    },
    {
        "name": "FindProductiveList_0",
        "sat": "def sat(li: List[int], n: int=6):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
        "desc": "Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\nwhere indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\nthat are multiples of 3 (as proven in the IMO problem).\n\nSample input:\n6\n\nSample output:\n[_, _, _, _, _, _]\n\n(Sample output hidden because showing sample output would give away too much information.)\n\nNote: This problem is easier than the IMO problem because the hard part is proving that sequences do not\nexists for non-multiples of 3.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)",
        "prompts": {
            "short": "def f(li: List[int], n=6):\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], n=6):\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], n=6):\n    \"\"\"Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n    \n    Sample input:\n    6\n    \n    Sample output:\n    [_, _, _, _, _, _]\n    \n    (Sample output hidden because showing sample output would give away too much information.)\n    \n    Note: This problem is easier than the IMO problem because the hard part is proving that sequences do not\n    exists for non-multiples of 3.\n    \n    Inspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)\"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))\n\nassert True == f6("
        }
    },
    {
        "name": "HalfTag_0",
        "sat": "def sat(li: List[int], n: int=3, tags: List[int]=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
        "desc": "The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\nThe goal is to find a subset (list) li of half the indices such that:\n* The sum of the indices equals the sum of the sum of the missing indices.\n* The tags of the chosen indices contains exactly each number in range(n) twice.\n\nSample input:\nn = 3\ntags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\nSample output:\n[0, 3, 5, 6, 8, 11]\n\nNote the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n\nInspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)",
        "prompts": {
            "short": "def f(li: List[int], n=3, tags=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], n=3, tags=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], n=3, tags=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    \"\"\"The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n    \n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n    \n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n    \n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \n    Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)\"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]\n\nassert True == f6("
        }
    },
    {
        "name": "AllQuadraticRoots_0",
        "sat": "def sat(roots: List[float], coeffs: List[float]=[1.3, -0.5]):\n    assert type(roots) is list and all(type(a) is float for a in roots), 'roots must be of type List[float]'\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
        "desc": "Find all (real) solutions for a [quadratic equation](https://en.wikipedia.org/wiki/Quadratic_formula)\nx^2 + b x + c (i.e., factor into roots)",
        "prompts": {
            "short": "def f(roots: List[float], coeffs=[1.3, -0.5]):\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(roots: List[float], coeffs=[1.3, -0.5]):\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(roots: List[float], coeffs=[1.3, -0.5]):\n    \"\"\"Find all (real) solutions for a [quadratic equation](https://en.wikipedia.org/wiki/Quadratic_formula)\n    x^2 + b x + c (i.e., factor into roots)\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6\n\nassert True == f6("
        }
    },
    {
        "name": "SumOfDigits_0",
        "sat": "def sat(x: str, s: int=679):\n    assert type(x) is str, 'x must be of type str'\n    return s == sum([int(d) for d in x])",
        "desc": "Find a number that its digits sum to a specific value.",
        "prompts": {
            "short": "def f(x: str, s=679):\n    return s == sum([int(d) for d in x])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: str, s=679):\n    return s == sum([int(d) for d in x])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: str, s=679):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])\n\nassert True == f6("
        }
    },
    {
        "name": "FloatWithDecimalValue_0",
        "sat": "def sat(z: float, v: int=9, d: float=0.0001):\n    assert type(z) is float, 'z must be of type float'\n    return int(z * 1/d % 10) == v",
        "desc": "Create a float with a specific decimal.",
        "prompts": {
            "short": "def f(z: float, v=9, d=0.0001):\n    return int(z * 1/d % 10) == v\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(z: float, v=9, d=0.0001):\n    return int(z * 1/d % 10) == v\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(z: float, v=9, d=0.0001):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1/d % 10) == v\n\nassert True == f6("
        }
    },
    {
        "name": "ArithmeticSequence_0",
        "sat": "def sat(x: List[int], a: int=7, s: int=5, e: int=200):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i+1] for i in range(len(x)-1)])",
        "desc": "Create a list that is a subrange of an arithmetic sequence.",
        "prompts": {
            "short": "def f(x: List[int], a=7, s=5, e=200):\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i+1] for i in range(len(x)-1)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], a=7, s=5, e=200):\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i+1] for i in range(len(x)-1)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], a=7, s=5, e=200):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i+1] for i in range(len(x)-1)])\n\nassert True == f6("
        }
    },
    {
        "name": "GeometricSequence_0",
        "sat": "def sat(x: List[int], a: int=8, r: int=2, l: int=50):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i+1] for i in range(len(x)-1)])",
        "desc": "Create a list that is a subrange of an gemoetric sequence.",
        "prompts": {
            "short": "def f(x: List[int], a=8, r=2, l=50):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i+1] for i in range(len(x)-1)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], a=8, r=2, l=50):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i+1] for i in range(len(x)-1)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], a=8, r=2, l=50):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i+1] for i in range(len(x)-1)])\n\nassert True == f6("
        }
    },
    {
        "name": "LineIntersection_0",
        "sat": "def sat(e: List[int], a: int=2, b: int=-1, c: int=1, d: int=2021):\n    assert type(e) is list and all(type(a) is int for a in e), 'e must be of type List[int]'\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
        "desc": "Find the intersection of two lines.\nSolution should be a list of the (x,y) coordinates.\nAccuracy of fifth decimal digit is required.",
        "prompts": {
            "short": "def f(e: List[int], a=2, b=-1, c=1, d=2021):\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(e: List[int], a=2, b=-1, c=1, d=2021):\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(e: List[int], a=2, b=-1, c=1, d=2021):\n    \"\"\"Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5\n\nassert True == f6("
        }
    },
    {
        "name": "IfProblem_0",
        "sat": "def sat(x: int, a: int=324554, b: int=1345345):\n    assert type(x) is int, 'x must be of type int'\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
        "desc": "Simple if statement",
        "prompts": {
            "short": "def f(x: int, a=324554, b=1345345):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=324554, b=1345345):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=324554, b=1345345):\n    \"\"\"Simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b\n\nassert True == f6("
        }
    },
    {
        "name": "IfProblemWithAnd_0",
        "sat": "def sat(x: int, a: int=9384594, b: int=1343663):\n    assert type(x) is int, 'x must be of type int'\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
        "desc": "Simple if statement with and clause",
        "prompts": {
            "short": "def f(x: int, a=9384594, b=1343663):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=9384594, b=1343663):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=9384594, b=1343663):\n    \"\"\"Simple if statement with and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b\n\nassert True == f6("
        }
    },
    {
        "name": "IfProblemWithOr_0",
        "sat": "def sat(x: int, a: int=253532, b: int=1230200):\n    assert type(x) is int, 'x must be of type int'\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
        "desc": "Simple if statement with or clause",
        "prompts": {
            "short": "def f(x: int, a=253532, b=1230200):\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=253532, b=1230200):\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=253532, b=1230200):\n    \"\"\"Simple if statement with or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\n\nassert True == f6("
        }
    },
    {
        "name": "IfCases_0",
        "sat": "def sat(x: int, a: int=4, b: int=54368639):\n    assert type(x) is int, 'x must be of type int'\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
        "desc": "Simple if statement with multiple cases",
        "prompts": {
            "short": "def f(x: int, a=4, b=54368639):\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=4, b=54368639):\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=4, b=54368639):\n    \"\"\"Simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\n\nassert True == f6("
        }
    },
    {
        "name": "ListPosSum_0",
        "sat": "def sat(x: List[int], n: int=5, s: int=19):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
        "desc": "Construct a list of non-negative integers that sum up to some value",
        "prompts": {
            "short": "def f(x: List[int], n=5, s=19):\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], n=5, s=19):\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], n=5, s=19):\n    \"\"\"Construct a list of non-negative integers that sum up to some value\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\n\nassert True == f6("
        }
    },
    {
        "name": "ListDistinctSum_0",
        "sat": "def sat(x: List[int], n: int=4, s: int=2021):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
        "desc": "Construct a list of distinct integers that sum up to some value",
        "prompts": {
            "short": "def f(x: List[int], n=4, s=2021):\n    return len(x) == n and sum(x) == s and len(set(x)) == n\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], n=4, s=2021):\n    return len(x) == n and sum(x) == s and len(set(x)) == n\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], n=4, s=2021):\n    \"\"\"Construct a list of distinct integers that sum up to some value\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n\n\nassert True == f6("
        }
    },
    {
        "name": "ConcatStrings_0",
        "sat": "def sat(x: str, s: List[str]=['a', 'b', 'c', 'd', 'e', 'f'], n: int=4):\n    assert type(x) is str, 'x must be of type str'\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
        "desc": "Concatenate list of characters",
        "prompts": {
            "short": "def f(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):\n    \"\"\"Concatenate list of characters\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\n\nassert True == f6("
        }
    },
    {
        "name": "SublistSum_0",
        "sat": "def sat(x: List[int], t: int=677, a: int=43, e: int=125, s: int=10):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
        "desc": "Sum values of sublist by range specifications",
        "prompts": {
            "short": "def f(x: List[int], t=677, a=43, e=125, s=10):\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], t=677, a=43, e=125, s=10):\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], t=677, a=43, e=125, s=10):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])\n\nassert True == f6("
        }
    },
    {
        "name": "CumulativeSum_0",
        "sat": "def sat(x: List[int], t: int=50, n: int=10):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
        "desc": "Number of values with cumulative sum less than target",
        "prompts": {
            "short": "def f(x: List[int], t=50, n=10):\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], t=50, n=10):\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], t=50, n=10):\n    \"\"\"Number of values with cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\n\nassert True == f6("
        }
    },
    {
        "name": "BasicStrCounts_0",
        "sat": "def sat(s: str, s1: str=\"a\", s2: str=\"b\", count1: int=50, count2: int=30):\n    assert type(s) is str, 's must be of type str'\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
        "desc": "Find a string that has `count1` occurrences of `s1` and `count1` occurrences of `s1` and starts and ends with\nthe same 10 characters",
        "prompts": {
            "short": "def f(s: str, s1='a', s2='b', count1=50, count2=30):\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, s1='a', s2='b', count1=50, count2=30):\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, s1='a', s2='b', count1=50, count2=30):\n    \"\"\"Find a string that has `count1` occurrences of `s1` and `count1` occurrences of `s1` and starts and ends with\n    the same 10 characters\"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]\n\nassert True == f6("
        }
    },
    {
        "name": "ReverseCat_0",
        "sat": "def sat(s: str, substrings: List[str]=['foo', 'bar', 'baz']):\n    assert type(s) is str, 's must be of type str'\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
        "desc": "Find a string that contains all the `substrings` reversed and forward",
        "prompts": {
            "short": "def f(s: str, substrings=['foo', 'bar', 'baz']):\n    return all(sub in s and sub[::-1] in s for sub in substrings)\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, substrings=['foo', 'bar', 'baz']):\n    return all(sub in s and sub[::-1] in s for sub in substrings)\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, substrings=['foo', 'bar', 'baz']):\n    \"\"\"Find a string that contains all the `substrings` reversed and forward\"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)\n\nassert True == f6("
        }
    },
    {
        "name": "EngineerNumbers_0",
        "sat": "def sat(ls: List[str], n: int=100, a: str=\"bar\", b: str=\"foo\"):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
        "desc": "Find a list of `n` strings starting with `a` and ending with `b`",
        "prompts": {
            "short": "def f(ls: List[str], n=100, a='bar', b='foo'):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str], n=100, a='bar', b='foo'):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str], n=100, a='bar', b='foo'):\n    \"\"\"Find a list of `n` strings starting with `a` and ending with `b`\"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)\n\nassert True == f6("
        }
    },
    {
        "name": "PenultimateString_0",
        "sat": "def sat(s: str, strings: List[str]=['cat', 'dog', 'bird', 'fly', 'moose']):\n    assert type(s) is str, 's must be of type str'\n    return s in strings and sum(t > s for t in strings) == 1",
        "desc": "Find the alphabetically second to last last string in a list.",
        "prompts": {
            "short": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s in strings and sum(t > s for t in strings) == 1\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s in strings and sum(t > s for t in strings) == 1\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1\n\nassert True == f6("
        }
    },
    {
        "name": "PenultimateRevString_0",
        "sat": "def sat(s: str, strings: List[str]=['cat', 'dog', 'bird', 'fly', 'moose']):\n    assert type(s) is str, 's must be of type str'\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
        "desc": "Find the reversed version of the alphabetically second string in a list.",
        "prompts": {
            "short": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1\n\nassert True == f6("
        }
    },
    {
        "name": "CenteredString_0",
        "sat": "def sat(s: str, target: str=\"foobarbazwow\", length: int=6):\n    assert type(s) is str, 's must be of type str'\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
        "desc": "Find a substring of length `length` centered within `target`.",
        "prompts": {
            "short": "def f(s: str, target='foobarbazwow', length=6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, target='foobarbazwow', length=6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, target='foobarbazwow', length=6):\n    \"\"\"Find a substring of length `length` centered within `target`.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\n\nassert True == f6("
        }
    },
    {
        "name": "Abbreviate_0",
        "sat": "def sat(s: str, word: str=\"antidisestablishmentarianism\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
        "desc": "Abbreviate strings longer than a given length by replacing everything but the first and last characters by\nan integer indicating how many characters there were in between them.\n\nInspired by [Codeforces Problem 71 A](https://codeforces.com/problemset/problem/71/A)",
        "prompts": {
            "short": "def f(s: str, word='antidisestablishmentarianism', max_len=10):\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, word='antidisestablishmentarianism', max_len=10):\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, word='antidisestablishmentarianism', max_len=10):\n    \"\"\"Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \n    Inspired by [Codeforces Problem 71 A](https://codeforces.com/problemset/problem/71/A)\"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]\n\nassert True == f6("
        }
    },
    {
        "name": "DecreasingCountComparison_0",
        "sat": "def sat(n: int, scores: List[int]=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
        "desc": "Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\nare at least as large as the kth.\n\nInspired by [Codeforces Problem 158 A](https://codeforces.com/problemset/problem/158/A)",
        "prompts": {
            "short": "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    \"\"\"Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \n    Inspired by [Codeforces Problem 158 A](https://codeforces.com/problemset/problem/158/A)\"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])\n\nassert True == f6("
        }
    },
    {
        "name": "IncDec_0",
        "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x'], target: int=19143212):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
        "desc": "This straightforward problem is a little harder than the Codeforces one.\nGiven a sequence of operations \"++x\",\n\"x++\", \"--x\", \"x--\", and a target value, find initial value so that the final value is the target value.\n\nSample Input:\nops = [\"x++\", \"--x\", \"--x\"]\ntarget = 12\n\nSample Output:\n13\n\nInspired by [Codeforces Problem 282 A](https://codeforces.com/problemset/problem/282/A)",
        "prompts": {
            "short": "def f(n: int, ops=['x++', '--x', '--x'], target=19143212):\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, ops=['x++', '--x', '--x'], target=19143212):\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, ops=['x++', '--x', '--x'], target=19143212):\n    \"\"\"This straightforward problem is a little harder than the Codeforces one.\n    Given a sequence of operations \"++x\",\n    \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the final value is the target value.\n    \n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n    \n    Sample Output:\n    13\n    \n    Inspired by [Codeforces Problem 282 A](https://codeforces.com/problemset/problem/282/A)\"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target\n\nassert True == f6("
        }
    },
    {
        "name": "SlidingOne_0",
        "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
        "desc": "We are given a 5x5 bimatrix with a single 1 like:\n0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n\nFind a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\nin \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n\nInspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)",
        "prompts": {
            "short": "def f(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    \"\"\"We are given a 5x5 bimatrix with a single 1 like:\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n    \n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \n    Inspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)\"\"\"\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1\n\nassert True == f6("
        }
    },
    {
        "name": "SortPlusPlus_0",
        "sat": "def sat(s: str, inp: str=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
        "desc": "Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\n\nInspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)",
        "prompts": {
            "short": "def f(s: str, inp='1+1+3+1+3+2+2+1+3+1+2'):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, inp='1+1+3+1+3+2+2+1+3+1+2'):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, inp='1+1+3+1+3+2+2+1+3+1+2'):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\n    \n    Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))\n\nassert True == f6("
        }
    },
    {
        "name": "FindHomogeneousSubstring_0",
        "sat": "def sat(n: int, s: str=\"0000111111100000\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k",
        "desc": "You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\nall 0's or all 1's.\n\nSample Input:\ns = 01010000111111100000, k = 5\n\nSample Output:\n8\n(or 9 or 10 or 15)\n\nInspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)",
        "prompts": {
            "short": "def f(n: int, s='0000111111100000', k=5):\n    return s[n:n + k] == s[n] * k\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, s='0000111111100000', k=5):\n    return s[n:n + k] == s[n] * k\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, s='0000111111100000', k=5):\n    \"\"\"You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n    \n    Sample Input:\n    s = 01010000111111100000, k = 5\n    \n    Sample Output:\n    8\n    (or 9 or 10 or 15)\n    \n    Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)\"\"\"\n    return s[n:n + k] == s[n] * k\n\nassert True == f6("
        }
    },
    {
        "name": "FivePowers_0",
        "sat": "def sat(s: str, n: int=7):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
        "desc": "What are the last two digits of 5^n?\n\nInspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/630/A)",
        "prompts": {
            "short": "def f(s: str, n=7):\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, n=7):\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, n=7):\n    \"\"\"What are the last two digits of 5^n?\n    \n    Inspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/630/A)\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\n\nassert True == f6("
        }
    },
    {
        "name": "CombinationLock_0",
        "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
        "desc": "Shortest Combination Lock Path\n\nGiven a starting a final lock position, find the (minimal) intermediate states, where each transition\ninvolves increasing or decreasing a single digit (mod 10)\ne.g.\nstart = \"120\"\ncombo = \"293\"\n\noutput: ['220', '210', '200', '290', '291', '292']\n\nInspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)",
        "prompts": {
            "short": "def f(states: List[str], start='012', combo='329', target_len=6):\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(states: List[str], start='012', combo='329', target_len=6):\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(states: List[str], start='012', combo='329', target_len=6):\n    \"\"\"Shortest Combination Lock Path\n    \n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10)\n    e.g.\n    start = \"120\"\n    combo = \"293\"\n    \n    output: ['220', '210', '200', '290', '291', '292']\n    \n    Inspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)\"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len\n\nassert True == f6("
        }
    },
    {
        "name": "CombinationLockObfuscated_0",
        "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
        "desc": "An obfuscated version of CombinationLock above",
        "prompts": {
            "short": "def f(states: List[str], start='012', combo='329', target_len=6):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(states: List[str], start='012', combo='329', target_len=6):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(states: List[str], start='012', combo='329', target_len=6):\n    \"\"\"An obfuscated version of CombinationLock above\"\"\"\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))\n\nassert True == f6("
        }
    },
    {
        "name": "InvertPermutation_0",
        "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hello are you there?\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
        "desc": "Find a string that, when a given permutation of characters is applied, has a given result.\n\nInspired by [Codeforces Problem 474 A](https://codeforces.com/problemset/problem/474/A)",
        "prompts": {
            "short": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='hello are you there?'):\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='hello are you there?'):\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='hello are you there?'):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\n    \n    Inspired by [Codeforces Problem 474 A](https://codeforces.com/problemset/problem/474/A)\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target\n\nassert True == f6("
        }
    },
    {
        "name": "OnesAndTwos_0",
        "sat": "def sat(seq: List[int], n: int=10000, length: int=5017):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length",
        "desc": "Find a sequence of 1's and 2's of a given length that that adds up to n\n\nInspired by [Codeforces Problem 476 A](https://codeforces.com/problemset/problem/476/A)",
        "prompts": {
            "short": "def f(seq: List[int], n=10000, length=5017):\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(seq: List[int], n=10000, length=5017):\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(seq: List[int], n=10000, length=5017):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\n    \n    Inspired by [Codeforces Problem 476 A](https://codeforces.com/problemset/problem/476/A)\"\"\"\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length\n\nassert True == f6("
        }
    },
    {
        "name": "MinConsecutiveSum_0",
        "sat": "def sat(start: int, k: int=3, upper: int=6, seq: List[int]=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
        "desc": "Find a sequence of k consecutive indices whose sum is minimal\n\nInspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)",
        "prompts": {
            "short": "def f(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\n    \n    Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\n\nassert True == f6("
        }
    },
    {
        "name": "MaxConsecutiveSum_0",
        "sat": "def sat(start: int, k: int=3, lower: int=150, seq: List[int]=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
        "desc": "Find a sequence of k consecutive indices whose sum is maximal\n\nInspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)",
        "prompts": {
            "short": "def f(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\n    \n    Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\n\nassert True == f6("
        }
    },
    {
        "name": "MaxConsecutiveProduct_0",
        "sat": "def sat(start: int, k: int=3, lower: int=100000, seq: List[int]=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
        "desc": "Find a sequence of k consecutive indices whose product is maximal, possibly looping around\n\nInspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)",
        "prompts": {
            "short": "def f(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\n    \n    Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\n\nassert True == f6("
        }
    },
    {
        "name": "MinRotations_0",
        "sat": "def sat(rotations: List[int], target: str=\"dad\", upper: int=9):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
        "desc": "We begin with the string `\"a...z\"`\n\nAn `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\ncycling around. Given a target string of length n, find the n rotations that put the consecutive characters\nof that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\nFor example if the string was `'fab'`, the minimal rotations would be `[5, -5, 1]` with a total of `11`.\n\nInspired by [Codeforces Problem 731 A](https://codeforces.com/problemset/problem/731/A)",
        "prompts": {
            "short": "def f(rotations: List[int], target='dad', upper=9):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(rotations: List[int], target='dad', upper=9):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(rotations: List[int], target='dad', upper=9):\n    \"\"\"We begin with the string `\"a...z\"`\n    \n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n    \n    For example if the string was `'fab'`, the minimal rotations would be `[5, -5, 1]` with a total of `11`.\n    \n    Inspired by [Codeforces Problem 731 A](https://codeforces.com/problemset/problem/731/A)\"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper\n\nassert True == f6("
        }
    },
    {
        "name": "KnightsTour_0",
        "sat": "def sat(tour: List[List[int]], m: int=8, n: int=8):\n    assert type(tour) is list and all(type(a) is list and all(type(b) is int for b in a) for a in tour), 'tour must be of type List[List[int]]'\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
        "desc": "Knights Tour\n\nFind an (open) tour of knight moves on an m x n chess-board that visits each square once.\n\nSee Wikipedia entry on [Knight's tour](https://en.wikipedia.org/w/index.php?title=Knight%27s_tour)",
        "prompts": {
            "short": "def f(tour: List[List[int]], m=8, n=8):\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(tour: List[List[int]], m=8, n=8):\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(tour: List[List[int]], m=8, n=8):\n    \"\"\"Knights Tour\n    \n    Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\n    \n    See Wikipedia entry on [Knight's tour](https://en.wikipedia.org/w/index.php?title=Knight%27s_tour)\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once\n\nassert True == f6("
        }
    },
    {
        "name": "GCD_0",
        "sat": "def sat(n: int, a: int=15482, b: int=23223, lower_bound: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
        "desc": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nFind the greatest common divisor of two integers.\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
        "prompts": {
            "short": "def f(n: int, a=15482, b=23223, lower_bound=5):\n    return a % n == 0 and b % n == 0 and n >= lower_bound\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=15482, b=23223, lower_bound=5):\n    return a % n == 0 and b % n == 0 and n >= lower_bound\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=15482, b=23223, lower_bound=5):\n    \"\"\"[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n    (GCD)\n    \n    Find the greatest common divisor of two integers.\n    \n    See also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\"\"\"\n    return a % n == 0 and b % n == 0 and n >= lower_bound\n\nassert True == f6("
        }
    },
    {
        "name": "GCD_multi_0",
        "sat": "def sat(n: int, nums: List[int]=[77410, 23223, 54187], lower_bound: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
        "desc": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nFind the greatest common divisor of a *list* of integers.\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
        "prompts": {
            "short": "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2):\n    return all(i % n == 0 for i in nums) and n >= lower_bound\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, nums=[77410, 23223, 54187], lower_bound=2):\n    return all(i % n == 0 for i in nums) and n >= lower_bound\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, nums=[77410, 23223, 54187], lower_bound=2):\n    \"\"\"[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n    (GCD)\n    \n    Find the greatest common divisor of a *list* of integers.\n    \n    See also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\"\"\"\n    return all(i % n == 0 for i in nums) and n >= lower_bound\n\nassert True == f6("
        }
    },
    {
        "name": "LCM_multi_0",
        "sat": "def sat(n: int, nums: List[int]=[15, 27, 102], upper_bound: int=5000):\n    assert type(n) is int, 'n must be of type int'\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
        "desc": "[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n(LCM)\n\nFind the least common multiple of a list of integers.\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
        "prompts": {
            "short": "def f(n: int, nums=[15, 27, 102], upper_bound=5000):\n    return all(n % i == 0 for i in nums) and n <= upper_bound\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, nums=[15, 27, 102], upper_bound=5000):\n    return all(n % i == 0 for i in nums) and n <= upper_bound\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, nums=[15, 27, 102], upper_bound=5000):\n    \"\"\"[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n    (LCM)\n    \n    Find the least common multiple of a list of integers.\n    \n    See also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\"\"\"\n    return all(n % i == 0 for i in nums) and n <= upper_bound\n\nassert True == f6("
        }
    },
    {
        "name": "SmallExponentBigSolution_0",
        "sat": "def sat(n: int, b: int=2, target: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return (b ** n) % n == target",
        "desc": "Small exponent, big solution\n\nSolve for n: b^n = target (mod n)\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)",
        "prompts": {
            "short": "def f(n: int, b=2, target=5):\n    return (b ** n) % n == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, b=2, target=5):\n    return (b ** n) % n == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, b=2, target=5):\n    \"\"\"Small exponent, big solution\n    \n    Solve for n: b^n = target (mod n)\n    \n    Problems have small b and target but solution is typically a large n.\n    Some of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n    \n    See [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)\"\"\"\n    return (b ** n) % n == target\n\nassert True == f6("
        }
    },
    {
        "name": "ThreeCubes_0",
        "sat": "def sat(nums: List[int], target: int=10):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
        "desc": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)",
        "prompts": {
            "short": "def f(nums: List[int], target=10):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(nums: List[int], target=10):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(nums: List[int], target=10):\n    \"\"\"Sum of three cubes\n    \n    Given `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\n    Conjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n    `a`, `b`, `c` may be positive or negative\n    \n    See [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n    [Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)\"\"\"\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target\n\nassert True == f6("
        }
    },
    {
        "name": "FourSquares_0",
        "sat": "def sat(nums: List[int], n: int=12345):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
        "desc": "Sum of four squares\n\n[Lagrange's Four Square Theorem](https://en.wikipedia.org/w/index.php?title=Lagrange%27s_four-square_theorem)\n\nGiven a non-negative integer `n`, a classic theorem of Lagrange says that `n` can be written as the sum of four\nintegers. The problem here is to find them. This is a nice problem and we give an elementary solution\nthat runs in time \tilde{O}(n),\nwhich is not \"polynomial time\" because it is not polynomial in log(n), the length of n. A poly-log(n)\nalgorithm using quaternions is described in the book:\n[\"Randomized algorithms in number theory\" by Michael O. Rabin and Jeffery O. Shallit (1986)](https://doi.org/10.1002/cpa.3160390713)\n\nThe first half of the problems involve small numbers and the second half involve some numbers up to 50 digits.",
        "prompts": {
            "short": "def f(nums: List[int], n=12345):\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(nums: List[int], n=12345):\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(nums: List[int], n=12345):\n    \"\"\"Sum of four squares\n    \n    [Lagrange's Four Square Theorem](https://en.wikipedia.org/w/index.php?title=Lagrange%27s_four-square_theorem)\n    \n    Given a non-negative integer `n`, a classic theorem of Lagrange says that `n` can be written as the sum of four\n    integers. The problem here is to find them. This is a nice problem and we give an elementary solution\n    that runs in time \tilde{O}(n),\n    which is not \"polynomial time\" because it is not polynomial in log(n), the length of n. A poly-log(n)\n    algorithm using quaternions is described in the book:\n    [\"Randomized algorithms in number theory\" by Michael O. Rabin and Jeffery O. Shallit (1986)](https://doi.org/10.1002/cpa.3160390713)\n    \n    The first half of the problems involve small numbers and the second half involve some numbers up to 50 digits.\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n\n\nassert True == f6("
        }
    },
    {
        "name": "Factoring_0",
        "sat": "def sat(i: int, n: int=62710561):\n    assert type(i) is int, 'i must be of type int'\n    return 1 < i < n and n % i == 0",
        "desc": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.",
        "prompts": {
            "short": "def f(i: int, n=62710561):\n    return 1 < i < n and n % i == 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, n=62710561):\n    return 1 < i < n and n % i == 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, n=62710561):\n    \"\"\"[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n    [RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n    \n    The factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\n    simple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\n    which include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\n    with hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\n    continue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n    \n    From Wikipedia:\n    \n    RSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\n    cash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\n    unless considerable advances are made in integer factorization or computational power in the near future.\"\"\"\n    return 1 < i < n and n % i == 0\n\nassert True == f6("
        }
    },
    {
        "name": "CollatzDelay_0",
        "sat": "def sat(n: int, t: int=100, upper: int=10):\n    assert type(n) is int, 'n must be of type int'\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
        "desc": "Collatz Delay\n\nFind `0 < n < upper` so that it takes exactly `t` steps to reach 1 in the Collatz process. For instance,\nthe number `n=9780657630` takes 1,132 steps and the number `n=93,571,393,692,802,302` takes\n2,091 steps, according to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)\n\nNow, this problem can be solved trivially by taking exponentially large `n = 2 ** t` so we also bound the\nnumber of bits of the solution to be upper.\n\nSee [this webpage](http://www.ericr.nl/wondrous/delrecs.html) for up-to-date records.",
        "prompts": {
            "short": "def f(n: int, t=100, upper=10):\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, t=100, upper=10):\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, t=100, upper=10):\n    \"\"\"Collatz Delay\n    \n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1 in the Collatz process. For instance,\n    the number `n=9780657630` takes 1,132 steps and the number `n=93,571,393,692,802,302` takes\n    2,091 steps, according to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)\n    \n    Now, this problem can be solved trivially by taking exponentially large `n = 2 ** t` so we also bound the\n    number of bits of the solution to be upper.\n    \n    See [this webpage](http://www.ericr.nl/wondrous/delrecs.html) for up-to-date records.\"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper\n\nassert True == f6("
        }
    },
    {
        "name": "Tutorial1_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return \"Hello \" + s == \"Hello world\"",
        "desc": "Find a string that when concatenated onto 'Hello ' gives 'Hello world'.",
        "prompts": {
            "short": "def f(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f6("
        }
    },
    {
        "name": "Tutorial2_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return \"Hello \" + s[::-1] == \"Hello world\"",
        "desc": "Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.",
        "prompts": {
            "short": "def f(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f6("
        }
    },
    {
        "name": "Tutorial3_0",
        "sat": "def sat(x: List[int]):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return len(x) == 2 and sum(x) == 3",
        "desc": "Find a list of two integers whose sum is 3.",
        "prompts": {
            "short": "def f(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f6("
        }
    },
    {
        "name": "Tutorial4_0",
        "sat": "def sat(s: List[str]):\n    assert type(s) is list and all(type(a) is str for a in s), 's must be of type List[str]'\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)",
        "desc": "Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.",
        "prompts": {
            "short": "def f(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f6("
        }
    },
    {
        "name": "Tutorial5_0",
        "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    return str(n * n).startswith(\"123456789\")",
        "desc": "Find an integer whose perfect square begins with 123456789 in its decimal representation.",
        "prompts": {
            "short": "def f(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f6("
        }
    },
    {
        "name": "HelloWorld_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s + 'world' == 'Hello world'",
        "desc": "Trivial example, no solutions provided",
        "prompts": {
            "short": "def f(s: str):\n    return s + 'world' == 'Hello world'\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return s + 'world' == 'Hello world'\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Trivial example, no solutions provided\"\"\"\n    return s + 'world' == 'Hello world'\n\nassert True == f6("
        }
    },
    {
        "name": "BackWorlds_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s[::-1] + 'world' == 'Hello world'",
        "desc": "Two solutions, no inputs",
        "prompts": {
            "short": "def f(s: str):\n    return s[::-1] + 'world' == 'Hello world'\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return s[::-1] + 'world' == 'Hello world'\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Two solutions, no inputs\"\"\"\n    return s[::-1] + 'world' == 'Hello world'\n\nassert True == f6("
        }
    },
    {
        "name": "StrAdd_0",
        "sat": "def sat(st: str, a: str=\"world\", b: str=\"Hello world\"):\n    assert type(st) is str, 'st must be of type str'\n    return st + a == b",
        "desc": "Solve simple string addition problem.",
        "prompts": {
            "short": "def f(st: str, a='world', b='Hello world'):\n    return st + a == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(st: str, a='world', b='Hello world'):\n    return st + a == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(st: str, a='world', b='Hello world'):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b\n\nassert True == f6("
        }
    },
    {
        "name": "StrSetLen_0",
        "sat": "def sat(s: str, dups: int=2021):\n    assert type(s) is str, 's must be of type str'\n    return len(set(s)) == len(s) - dups",
        "desc": "Find a string with `dups` duplicate chars",
        "prompts": {
            "short": "def f(s: str, dups=2021):\n    return len(set(s)) == len(s) - dups\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, dups=2021):\n    return len(set(s)) == len(s) - dups\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, dups=2021):\n    \"\"\"Find a string with `dups` duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups\n\nassert True == f6("
        }
    },
    {
        "name": "StrMul_0",
        "sat": "def sat(s: str, target: str=\"foofoofoofoo\", n: int=2):\n    assert type(s) is str, 's must be of type str'\n    return s * n == target",
        "desc": "Find a string which when repeated `n` times gives `target`",
        "prompts": {
            "short": "def f(s: str, target='foofoofoofoo', n=2):\n    return s * n == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, target='foofoofoofoo', n=2):\n    return s * n == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, target='foofoofoofoo', n=2):\n    \"\"\"Find a string which when repeated `n` times gives `target`\"\"\"\n    return s * n == target\n\nassert True == f6("
        }
    },
    {
        "name": "StrMul2_0",
        "sat": "def sat(n: int, target: str=\"foofoofoofoo\", s: str=\"foofoo\"):\n    assert type(n) is int, 'n must be of type int'\n    return s * n == target",
        "desc": "Find `n` such that `s` repeated `n` times gives `target`",
        "prompts": {
            "short": "def f(n: int, target='foofoofoofoo', s='foofoo'):\n    return s * n == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, target='foofoofoofoo', s='foofoo'):\n    return s * n == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, target='foofoofoofoo', s='foofoo'):\n    \"\"\"Find `n` such that `s` repeated `n` times gives `target`\"\"\"\n    return s * n == target\n\nassert True == f6("
        }
    },
    {
        "name": "StrLen_0",
        "sat": "def sat(s: str, n: int=1000):\n    assert type(s) is str, 's must be of type str'\n    return len(s) == n",
        "desc": "Find a string of length `n`",
        "prompts": {
            "short": "def f(s: str, n=1000):\n    return len(s) == n\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, n=1000):\n    return len(s) == n\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, n=1000):\n    \"\"\"Find a string of length `n`\"\"\"\n    return len(s) == n\n\nassert True == f6("
        }
    },
    {
        "name": "StrAt_0",
        "sat": "def sat(i: int, s: str=\"cat\", target: str=\"a\"):\n    assert type(i) is int, 'i must be of type int'\n    return s[i] == target",
        "desc": "Find the index of `target` in string `s`",
        "prompts": {
            "short": "def f(i: int, s='cat', target='a'):\n    return s[i] == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, s='cat', target='a'):\n    return s[i] == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, s='cat', target='a'):\n    \"\"\"Find the index of `target` in string `s`\"\"\"\n    return s[i] == target\n\nassert True == f6("
        }
    },
    {
        "name": "StrNegAt_0",
        "sat": "def sat(i: int, s: str=\"cat\", target: str=\"a\"):\n    assert type(i) is int, 'i must be of type int'\n    return s[i] == target and i < 0",
        "desc": "Find the index of `target` in `s` using a negative index.",
        "prompts": {
            "short": "def f(i: int, s='cat', target='a'):\n    return s[i] == target and i < 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, s='cat', target='a'):\n    return s[i] == target and i < 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, s='cat', target='a'):\n    \"\"\"Find the index of `target` in `s` using a negative index.\"\"\"\n    return s[i] == target and i < 0\n\nassert True == f6("
        }
    },
    {
        "name": "StrSlice_0",
        "sat": "def sat(inds: List[int], s: str=\"hello world\", target: str=\"do\"):\n    assert type(inds) is list and all(type(a) is int for a in inds), 'inds must be of type List[int]'\n    i, j, k = inds\n    return s[i:j:k] == target",
        "desc": "Find the three slice indices that give the specific `target` in string `s`",
        "prompts": {
            "short": "def f(inds: List[int], s='hello world', target='do'):\n    i, j, k = inds\n    return s[i:j:k] == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(inds: List[int], s='hello world', target='do'):\n    i, j, k = inds\n    return s[i:j:k] == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(inds: List[int], s='hello world', target='do'):\n    \"\"\"Find the three slice indices that give the specific `target` in string `s`\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target\n\nassert True == f6("
        }
    },
    {
        "name": "StrIndex_0",
        "sat": "def sat(s: str, big_str: str=\"foobar\", index: int=2):\n    assert type(s) is str, 's must be of type str'\n    return big_str.index(s) == index",
        "desc": "Find a string whose *first* index in `big_str` is `index`",
        "prompts": {
            "short": "def f(s: str, big_str='foobar', index=2):\n    return big_str.index(s) == index\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, big_str='foobar', index=2):\n    return big_str.index(s) == index\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, big_str='foobar', index=2):\n    \"\"\"Find a string whose *first* index in `big_str` is `index`\"\"\"\n    return big_str.index(s) == index\n\nassert True == f6("
        }
    },
    {
        "name": "StrIndex2_0",
        "sat": "def sat(big_str: str, sub_str: str=\"foobar\", index: int=2):\n    assert type(big_str) is str, 'big_str must be of type str'\n    return big_str.index(sub_str) == index",
        "desc": "Find a string whose *first* index of `sub_str` is `index`",
        "prompts": {
            "short": "def f(big_str: str, sub_str='foobar', index=2):\n    return big_str.index(sub_str) == index\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(big_str: str, sub_str='foobar', index=2):\n    return big_str.index(sub_str) == index\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(big_str: str, sub_str='foobar', index=2):\n    \"\"\"Find a string whose *first* index of `sub_str` is `index`\"\"\"\n    return big_str.index(sub_str) == index\n\nassert True == f6("
        }
    },
    {
        "name": "StrIn_0",
        "sat": "def sat(s: str, a: str=\"hello\", b: str=\"yellow\", length: int=4):\n    assert type(s) is str, 's must be of type str'\n    return len(s) == length and s in a and s in b",
        "desc": "Find a string of length `length` that is in both strings `a` and `b`",
        "prompts": {
            "short": "def f(s: str, a='hello', b='yellow', length=4):\n    return len(s) == length and s in a and s in b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, a='hello', b='yellow', length=4):\n    return len(s) == length and s in a and s in b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, a='hello', b='yellow', length=4):\n    \"\"\"Find a string of length `length` that is in both strings `a` and `b`\"\"\"\n    return len(s) == length and s in a and s in b\n\nassert True == f6("
        }
    },
    {
        "name": "ListSetLen_0",
        "sat": "def sat(li: List[int], dups: int=42155):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return len(set(li)) == len(li) - dups",
        "desc": "Find a list with a certain number of duplicate items",
        "prompts": {
            "short": "def f(li: List[int], dups=42155):\n    return len(set(li)) == len(li) - dups\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], dups=42155):\n    return len(set(li)) == len(li) - dups\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], dups=42155):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups\n\nassert True == f6("
        }
    },
    {
        "name": "ListMul_0",
        "sat": "def sat(li: List[int], target: List[int]=[17, 9, -1, 17, 9, -1], n: int=2):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li * n == target",
        "desc": "Find a list that when multiplied n times gives the target list",
        "prompts": {
            "short": "def f(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):\n    return li * n == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):\n    return li * n == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target\n\nassert True == f6("
        }
    },
    {
        "name": "ListLen_0",
        "sat": "def sat(li: List[int], n: int=85012):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return len(li) == n",
        "desc": "Find a list of a given length n",
        "prompts": {
            "short": "def f(li: List[int], n=85012):\n    return len(li) == n\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], n=85012):\n    return len(li) == n\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], n=85012):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n\n\nassert True == f6("
        }
    },
    {
        "name": "ListAt_0",
        "sat": "def sat(i: int, li: List[int]=[17, 31, 91, 18, 42, 1, 9], target: int=18):\n    assert type(i) is int, 'i must be of type int'\n    return li[i] == target",
        "desc": "Find the index of an item in a list. Any such index is fine.",
        "prompts": {
            "short": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    return li[i] == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    return li[i] == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target\n\nassert True == f6("
        }
    },
    {
        "name": "ListNegAt_0",
        "sat": "def sat(i: int, li: List[int]=[17, 31, 91, 18, 42, 1, 9], target: int=91):\n    assert type(i) is int, 'i must be of type int'\n    return li[i] == target and i < 0",
        "desc": "Find the index of an item in a list using negative indexing.",
        "prompts": {
            "short": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):\n    return li[i] == target and i < 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):\n    return li[i] == target and i < 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0\n\nassert True == f6("
        }
    },
    {
        "name": "ListSlice_0",
        "sat": "def sat(inds: List[int], li: List[int]=[42, 18, 21, 103, -2, 11], target: List[int]=[-2, 21, 42]):\n    assert type(inds) is list and all(type(a) is int for a in inds), 'inds must be of type List[int]'\n    i, j, k = inds\n    return li[i:j:k] == target",
        "desc": "Find three slice indices to achieve a given list slice",
        "prompts": {
            "short": "def f(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):\n    i, j, k = inds\n    return li[i:j:k] == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):\n    i, j, k = inds\n    return li[i:j:k] == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target\n\nassert True == f6("
        }
    },
    {
        "name": "ListIndex_0",
        "sat": "def sat(item: int, li: List[int]=[17, 2, 3, 9, 11, 11], index: int=4):\n    assert type(item) is int, 'item must be of type int'\n    return li.index(item) == index",
        "desc": "Find the item whose first index in `li` is `index`",
        "prompts": {
            "short": "def f(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    return li.index(item) == index\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    return li.index(item) == index\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    \"\"\"Find the item whose first index in `li` is `index`\"\"\"\n    return li.index(item) == index\n\nassert True == f6("
        }
    },
    {
        "name": "ListIndex2_0",
        "sat": "def sat(li: List[int], i: int=29, index: int=10412):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li.index(i) == index",
        "desc": "Find a list that contains `i` first at index `index`",
        "prompts": {
            "short": "def f(li: List[int], i=29, index=10412):\n    return li.index(i) == index\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], i=29, index=10412):\n    return li.index(i) == index\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], i=29, index=10412):\n    \"\"\"Find a list that contains `i` first at index `index`\"\"\"\n    return li.index(i) == index\n\nassert True == f6("
        }
    },
    {
        "name": "ListIn_0",
        "sat": "def sat(s: str, a: List[str]=['cat', 'dot', 'bird'], b: List[str]=['tree', 'fly', 'dot']):\n    assert type(s) is str, 's must be of type str'\n    return s in a and s in b",
        "desc": "Find an item that is in both lists `a` and `b`",
        "prompts": {
            "short": "def f(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):\n    return s in a and s in b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):\n    return s in a and s in b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):\n    \"\"\"Find an item that is in both lists `a` and `b`\"\"\"\n    return s in a and s in b\n\nassert True == f6("
        }
    },
    {
        "name": "IntNeg_0",
        "sat": "def sat(x: int, a: int=93252338):\n    assert type(x) is int, 'x must be of type int'\n    return -x == a",
        "desc": "Solve unary negation problem",
        "prompts": {
            "short": "def f(x: int, a=93252338):\n    return -x == a\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=93252338):\n    return -x == a\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=93252338):\n    \"\"\"Solve unary negation problem\"\"\"\n    return -x == a\n\nassert True == f6("
        }
    },
    {
        "name": "IntSum_0",
        "sat": "def sat(x: int, a: int=1073258, b: int=72352549):\n    assert type(x) is int, 'x must be of type int'\n    return a + x == b",
        "desc": "Solve sum problem",
        "prompts": {
            "short": "def f(x: int, a=1073258, b=72352549):\n    return a + x == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=1073258, b=72352549):\n    return a + x == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=1073258, b=72352549):\n    \"\"\"Solve sum problem\"\"\"\n    return a + x == b\n\nassert True == f6("
        }
    },
    {
        "name": "IntSub_0",
        "sat": "def sat(x: int, a: int=-382, b: int=14546310):\n    assert type(x) is int, 'x must be of type int'\n    return x - a == b",
        "desc": "Solve subtraction problem",
        "prompts": {
            "short": "def f(x: int, a=-382, b=14546310):\n    return x - a == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=-382, b=14546310):\n    return x - a == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=-382, b=14546310):\n    \"\"\"Solve subtraction problem\"\"\"\n    return x - a == b\n\nassert True == f6("
        }
    },
    {
        "name": "IntSub2_0",
        "sat": "def sat(x: int, a: int=8665464, b: int=-93206):\n    assert type(x) is int, 'x must be of type int'\n    return a - x == b",
        "desc": "Solve subtraction problem",
        "prompts": {
            "short": "def f(x: int, a=8665464, b=-93206):\n    return a - x == b\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=8665464, b=-93206):\n    return a - x == b\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=8665464, b=-93206):\n    \"\"\"Solve subtraction problem\"\"\"\n    return a - x == b\n\nassert True == f6("
        }
    },
    {
        "name": "IntMul_0",
        "sat": "def sat(n: int, a: int=14302, b: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return b * n + (a % b) == a",
        "desc": "Solve multiplication problem",
        "prompts": {
            "short": "def f(n: int, a=14302, b=5):\n    return b * n + (a % b) == a\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=14302, b=5):\n    return b * n + (a % b) == a\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=14302, b=5):\n    \"\"\"Solve multiplication problem\"\"\"\n    return b * n + (a % b) == a\n\nassert True == f6("
        }
    },
    {
        "name": "IntDiv_0",
        "sat": "def sat(n: int, a: int=3, b: int=23463462):\n    assert type(n) is int, 'n must be of type int'\n    return b // n == a",
        "desc": "Solve division problem",
        "prompts": {
            "short": "def f(n: int, a=3, b=23463462):\n    return b // n == a\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=3, b=23463462):\n    return b // n == a\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=3, b=23463462):\n    \"\"\"Solve division problem\"\"\"\n    return b // n == a\n\nassert True == f6("
        }
    },
    {
        "name": "IntDiv2_0",
        "sat": "def sat(n: int, a: int=345346363, b: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return n // b == a",
        "desc": "Find `n` that when divided by `b` is `a`",
        "prompts": {
            "short": "def f(n: int, a=345346363, b=10):\n    return n // b == a\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=345346363, b=10):\n    return n // b == a\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=345346363, b=10):\n    \"\"\"Find `n` that when divided by `b` is `a`\"\"\"\n    return n // b == a\n\nassert True == f6("
        }
    },
    {
        "name": "IntSquareRoot_0",
        "sat": "def sat(x: int, a: int=10201202001):\n    assert type(x) is int, 'x must be of type int'\n    return x ** 2 == a",
        "desc": "Compute square root of number.\nThe target has a round (integer) square root.",
        "prompts": {
            "short": "def f(x: int, a=10201202001):\n    return x ** 2 == a\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=10201202001):\n    return x ** 2 == a\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: int, a=10201202001):\n    \"\"\"Compute square root of number.\n    The target has a round (integer) square root.\"\"\"\n    return x ** 2 == a\n\nassert True == f6("
        }
    },
    {
        "name": "IntNegSquareRoot_0",
        "sat": "def sat(n: int, a: int=10000200001):\n    assert type(n) is int, 'n must be of type int'\n    return a == n * n and n < 0",
        "desc": "Compute negative square root of number.\nThe target has a round (integer) square root.",
        "prompts": {
            "short": "def f(n: int, a=10000200001):\n    return a == n * n and n < 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=10000200001):\n    return a == n * n and n < 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, a=10000200001):\n    \"\"\"Compute negative square root of number.\n    The target has a round (integer) square root.\"\"\"\n    return a == n * n and n < 0\n\nassert True == f6("
        }
    },
    {
        "name": "FloatSquareRoot_0",
        "sat": "def sat(x: float, a: int=1020):\n    assert type(x) is float, 'x must be of type float'\n    return abs(x ** 2 - a) < 10 ** -3",
        "desc": "Compute square root of number.\nThe target might not have a round solution.\nAccuracy of third decimal digit is required.",
        "prompts": {
            "short": "def f(x: float, a=1020):\n    return abs(x ** 2 - a) < 10 ** -3\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: float, a=1020):\n    return abs(x ** 2 - a) < 10 ** -3\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: float, a=1020):\n    \"\"\"Compute square root of number.\n    The target might not have a round solution.\n    Accuracy of third decimal digit is required.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3\n\nassert True == f6("
        }
    },
    {
        "name": "FloatNegSquareRoot_0",
        "sat": "def sat(x: float, a: int=1020):\n    assert type(x) is float, 'x must be of type float'\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
        "desc": "Compute (negative) square root of number.\nThe target might not have a round solution.\nAccuracy of third decimal digit is required.",
        "prompts": {
            "short": "def f(x: float, a=1020):\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: float, a=1020):\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: float, a=1020):\n    \"\"\"Compute (negative) square root of number.\n    The target might not have a round solution.\n    Accuracy of third decimal digit is required.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0\n\nassert True == f6("
        }
    },
    {
        "name": "LongestMonotonicSubstringTricky_0",
        "sat": "def sat(x: List[int], length: int=20, s: str=\"Dynamic programming solves this puzzle!!!\"):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
        "desc": "Find the indices of the longest substring with characters in sorted order, with a twist!",
        "prompts": {
            "short": "def f(x: List[int], length=20, s='Dynamic programming solves this puzzle!!!'):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], length=20, s='Dynamic programming solves this puzzle!!!'):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: List[int], length=20, s='Dynamic programming solves this puzzle!!!'):\n    \"\"\"Find the indices of the longest substring with characters in sorted order, with a twist!\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))\n\nassert True == f6("
        }
    },
    {
        "name": "ClockAngle_0",
        "sat": "def sat(hands: List[int], target_angle: int=45):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
        "desc": "[Clock Angle Problem](https://en.wikipedia.org/wiki/Clock_angle_problem)\n\nEasy variant checks if angle at li = [hour, min] is a given number of degrees.",
        "prompts": {
            "short": "def f(hands: List[int], target_angle=45):\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(hands: List[int], target_angle=45):\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(hands: List[int], target_angle=45):\n    \"\"\"[Clock Angle Problem](https://en.wikipedia.org/wiki/Clock_angle_problem)\n    \n    Easy variant checks if angle at li = [hour, min] is a given number of degrees.\"\"\"\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle\n\nassert True == f6("
        }
    },
    {
        "name": "MonkeyAndCoconuts_0",
        "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1",
        "desc": "[The Monkey and the Coconuts](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts)\n\nFind the number of coconuts to solve the following riddle quoted from\n[Wikipedia article](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts):\n    There is a pile of coconuts, owned by five men.\n    One man divides the pile into five equal piles, giving the one left over coconut to a passing monkey,\n    and takes away his own share. The second man then repeats the procedure, dividing the remaining pile\n    into five and taking away his share, as do the third, fourth, and fifth, each of them finding one\n    coconut left over when dividing the pile by five, and giving it to a monkey. Finally, the group\n     divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n    How many coconuts were there in the original pile?",
        "prompts": {
            "short": "def f(n: int):\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int):\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int):\n    \"\"\"[The Monkey and the Coconuts](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts)\n    \n    Find the number of coconuts to solve the following riddle quoted from\n    [Wikipedia article](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts):\n        There is a pile of coconuts, owned by five men.\n        One man divides the pile into five equal piles, giving the one left over coconut to a passing monkey,\n        and takes away his own share. The second man then repeats the procedure, dividing the remaining pile\n        into five and taking away his share, as do the third, fourth, and fifth, each of them finding one\n        coconut left over when dividing the pile by five, and giving it to a monkey. Finally, the group\n         divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n        How many coconuts were there in the original pile?\"\"\"\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\n\nassert True == f6("
        }
    },
    {
        "name": "PostageStamp_0",
        "sat": "def sat(stamps: List[int], target: int=80, max_stamps: int=4, options: List[int]=[10, 32, 8]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
        "desc": "[Postage stamp problem](https://en.wikipedia.org/wiki/Postage_stamp_problem)\n\nIn this problem version, one must find a selection of stamps to achieve a given value.",
        "prompts": {
            "short": "def f(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):\n    \"\"\"[Postage stamp problem](https://en.wikipedia.org/wiki/Postage_stamp_problem)\n    \n    In this problem version, one must find a selection of stamps to achieve a given value.\"\"\"\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target\n\nassert True == f6("
        }
    },
    {
        "name": "NecklaceSplit_0",
        "sat": "def sat(n: int, lace: str=\"bbbbrrbrbrbbrrrr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
        "desc": "[Necklace Splitting Problem](https://en.wikipedia.org/wiki/Necklace_splitting_problem)\n\nSplit a specific red/blue necklace in half at n so that each piece has an equal number of reds and blues.",
        "prompts": {
            "short": "def f(n: int, lace='bbbbrrbrbrbbrrrr'):\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, lace='bbbbrrbrbrbbrrrr'):\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int, lace='bbbbrrbrbrbbrrrr'):\n    \"\"\"[Necklace Splitting Problem](https://en.wikipedia.org/wiki/Necklace_splitting_problem)\n    \n    Split a specific red/blue necklace in half at n so that each piece has an equal number of reds and blues.\"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")\n\nassert True == f6("
        }
    },
    {
        "name": "PandigitalSquare_0",
        "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    return sorted([int(s) for s in str(n * n)]) == list(range(10))",
        "desc": "[Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Square\n\nFind an integer whose square has all digits 0-9 once.",
        "prompts": {
            "short": "def f(n: int):\n    return sorted([int(s) for s in str(n * n)]) == list(range(10))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int):\n    return sorted([int(s) for s in str(n * n)]) == list(range(10))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(n: int):\n    \"\"\"[Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Square\n    \n    Find an integer whose square has all digits 0-9 once.\"\"\"\n    return sorted([int(s) for s in str(n * n)]) == list(range(10))\n\nassert True == f6("
        }
    },
    {
        "name": "AllPandigitalSquares_0",
        "sat": "def sat(nums: List[int]):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174",
        "desc": "All [Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Squares\n\nFind all 174 integers whose 10-digit square has all digits 0-9",
        "prompts": {
            "short": "def f(nums: List[int]):\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(nums: List[int]):\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(nums: List[int]):\n    \"\"\"All [Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Squares\n    \n    Find all 174 integers whose 10-digit square has all digits 0-9\"\"\"\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174\n\nassert True == f6("
        }
    },
    {
        "name": "VerbalArithmetic_0",
        "sat": "def sat(li: List[int], words: List[str]=['SEND', 'MORE', 'MONEY']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
        "desc": "Find a substitution of digits for characters to make the numbers add up, like this:\nSEND + MORE = MONEY\n\nThe first digit in any cannot be 0.\nSee [Wikipedia article](https://en.wikipedia.org/wiki/Verbal_arithmetic)",
        "prompts": {
            "short": "def f(li: List[int], words=['SEND', 'MORE', 'MONEY']):\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], words=['SEND', 'MORE', 'MONEY']):\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int], words=['SEND', 'MORE', 'MONEY']):\n    \"\"\"Find a substitution of digits for characters to make the numbers add up, like this:\n    SEND + MORE = MONEY\n    \n    The first digit in any cannot be 0.\n    See [Wikipedia article](https://en.wikipedia.org/wiki/Verbal_arithmetic)\"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]\n\nassert True == f6("
        }
    },
    {
        "name": "AnyEdge_0",
        "sat": "def sat(e: List[int], edges: List[List[int]]=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    assert type(e) is list and all(type(a) is int for a in e), 'e must be of type List[int]'\n    return e in edges",
        "desc": "Find any edge in a given [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)).",
        "prompts": {
            "short": "def f(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    return e in edges\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    return e in edges\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    \"\"\"Find any edge in a given [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)).\"\"\"\n    return e in edges\n\nassert True == f6("
        }
    },
    {
        "name": "UnweightedShortestPath_0",
        "sat": "def sat(path: List[int], edges: List[List[int]]=[[0, 11], [0, 22], [11, 22], [11, 33], [22, 33]], u: int=0, v: int=33, bound: int=3):\n    assert type(path) is list and all(type(a) is int for a in path), 'path must be of type List[int]'\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
        "desc": "Unweighted Shortest Path\n\nFind a path from node u to node v, of a bounded length, in a given digraph on vertices 0, 1,..., n.\n\nSee (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]",
        "prompts": {
            "short": "def f(path: List[int], edges=[[0, 11], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(path: List[int], edges=[[0, 11], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(path: List[int], edges=[[0, 11], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):\n    \"\"\"Unweighted Shortest Path\n    \n    Find a path from node u to node v, of a bounded length, in a given digraph on vertices 0, 1,..., n.\n    \n    See (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound\n\nassert True == f6("
        }
    },
    {
        "name": "AnyPath_0",
        "sat": "def sat(path: List[int], edges: List[List[int]]=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    assert type(path) is list and all(type(a) is int for a in path), 'path must be of type List[int]'\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
        "desc": "Any Path\n\nFind any path from node 0 to node n in a given graph on vertices 0, 1,..., n.",
        "prompts": {
            "short": "def f(path: List[int], edges=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(path: List[int], edges=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(path: List[int], edges=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    \"\"\"Any Path\n    \n    Find any path from node 0 to node n in a given graph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True\n\nassert True == f6("
        }
    },
    {
        "name": "EvenPath_0",
        "sat": "def sat(path: List[int], edges: List[List[int]]=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    assert type(path) is list and all(type(a) is int for a in path), 'path must be of type List[int]'\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
        "desc": "Even Path\n\nFind any path with an even number of nodes from node 0 to node n in a given graph on vertices 0, 1,..., n.",
        "prompts": {
            "short": "def f(path: List[int], edges=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(path: List[int], edges=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(path: List[int], edges=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    \"\"\"Even Path\n    \n    Find any path with an even number of nodes from node 0 to node n in a given graph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0\n\nassert True == f6("
        }
    },
    {
        "name": "OddPath_0",
        "sat": "def sat(p: List[int], edges: List[List[int]]=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    assert type(p) is list and all(type(a) is int for a in p), 'p must be of type List[int]'\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
        "desc": "Odd Path\n\n*** Note the change to go from node 0 to node 1 ***\n\nFind any path with an odd number of nodes from node 0 to node 1 in a given graph on vertices 0, 1,..., n.",
        "prompts": {
            "short": "def f(p: List[int], edges=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(p: List[int], edges=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(p: List[int], edges=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    \"\"\"Odd Path\n    \n    *** Note the change to go from node 0 to node 1 ***\n    \n    Find any path with an odd number of nodes from node 0 to node 1 in a given graph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])\n\nassert True == f6("
        }
    },
    {
        "name": "Zarankiewicz_0",
        "sat": "def sat(edges: List[List[int]]):\n    assert type(edges) is list and all(type(a) is list and all(type(b) is int for b in a) for a in edges), 'edges must be of type List[List[int]]'\n    assert len(edges) == len({(a, b) for a, b in edges}) == 13  # weights\n    assert all(i in range(4) for li in edges for i in li)  # 4 nodes on each side\n    for i in range(4):\n        v = [m for m in range(4) if m != i]\n        for j in range(4):\n            u = [m for m in range(4) if m != j]\n            if all([m, n] in edges for m in v for n in u):\n                return False\n    return True",
        "desc": "[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)\n\nFind a bipartite graph with 4 vertices on each side, 13 edges, and no K_3,3 subgraph.",
        "prompts": {
            "short": "def f(edges: List[List[int]]):\n    assert len(edges) == len({(a, b) for a, b in edges}) == 13  # weights\n    assert all(i in range(4) for li in edges for i in li)  # 4 nodes on each side\n    for i in range(4):\n        v = [m for m in range(4) if m != i]\n        for j in range(4):\n            u = [m for m in range(4) if m != j]\n            if all([m, n] in edges for m in v for n in u):\n                return False\n    return True\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(edges: List[List[int]]):\n    assert len(edges) == len({(a, b) for a, b in edges}) == 13  # weights\n    assert all(i in range(4) for li in edges for i in li)  # 4 nodes on each side\n    for i in range(4):\n        v = [m for m in range(4) if m != i]\n        for j in range(4):\n            u = [m for m in range(4) if m != j]\n            if all([m, n] in edges for m in v for n in u):\n                return False\n    return True\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(edges: List[List[int]]):\n    \"\"\"[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)\n    \n    Find a bipartite graph with 4 vertices on each side, 13 edges, and no K_3,3 subgraph.\"\"\"\n    assert len(edges) == len({(a, b) for a, b in edges}) == 13  # weights\n    assert all(i in range(4) for li in edges for i in li)  # 4 nodes on each side\n    for i in range(4):\n        v = [m for m in range(4) if m != i]\n        for j in range(4):\n            u = [m for m in range(4) if m != j]\n            if all([m, n] in edges for m in v for n in u):\n                return False\n    return True\n\nassert True == f6("
        }
    },
    {
        "name": "GraphIsomorphism_0",
        "sat": "def sat(bi: List[int], g1: List[List[int]]=[[0, 1], [1, 2], [2, 3], [3, 4]], g2: List[List[int]]=[[0, 4], [4, 1], [1, 2], [2, 3]]):\n    assert type(bi) is list and all(type(a) is int for a in bi), 'bi must be of type List[int]'\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
        "desc": "In the classic [Graph Isomorphism](https://en.wikipedia.org/wiki/Graph_isomorphism) problem,\none is given two graphs which are permutations of one another and\nthe goal is to find the permutation. It is unknown wheter or not there exists a polynomial-time algorithm\nfor this problem, though an unpublished quasi-polynomial-time algorithm has been announced by Babai.\n\nEach graph is specified by a list of edges where each edge is a pair of integer vertex numbers.",
        "prompts": {
            "short": "def f(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4]], g2=[[0, 4], [4, 1], [1, 2], [2, 3]]):\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4]], g2=[[0, 4], [4, 1], [1, 2], [2, 3]]):\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4]], g2=[[0, 4], [4, 1], [1, 2], [2, 3]]):\n    \"\"\"In the classic [Graph Isomorphism](https://en.wikipedia.org/wiki/Graph_isomorphism) problem,\n    one is given two graphs which are permutations of one another and\n    the goal is to find the permutation. It is unknown wheter or not there exists a polynomial-time algorithm\n    for this problem, though an unpublished quasi-polynomial-time algorithm has been announced by Babai.\n    \n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}\n\nassert True == f6("
        }
    },
    {
        "name": "Study_1_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s.count('o') == 1000 and s.count('oo') == 0",
        "desc": "Find a string with 1000 'o's but no two adjacent 'o's.",
        "prompts": {
            "short": "def f(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 0\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 0\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a string with 1000 'o's but no two adjacent 'o's.\"\"\"\n    return s.count('o') == 1000 and s.count('oo') == 0\n\nassert True == f6("
        }
    },
    {
        "name": "Study_2_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801",
        "desc": "Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'.",
        "prompts": {
            "short": "def f(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'.\"\"\"\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801\n\nassert True == f6("
        }
    },
    {
        "name": "Study_3_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))",
        "desc": "Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998.\"\"\"\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))\n\nassert True == f6("
        }
    },
    {
        "name": "Study_4_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return len(li) == 10 and li.count(li[3]) == 2",
        "desc": "Find a list of length 10 where the fourth element occurs exactly twice.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return len(li) == 10 and li.count(li[3]) == 2\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return len(li) == 10 and li.count(li[3]) == 2\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list of length 10 where the fourth element occurs exactly twice.\"\"\"\n    return len(li) == 10 and li.count(li[3]) == 2\n\nassert True == f6("
        }
    },
    {
        "name": "Study_5_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([li.count(i) == i for i in range(10)])",
        "desc": "Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all([li.count(i) == i for i in range(10)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all([li.count(i) == i for i in range(10)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9.\"\"\"\n    return all([li.count(i) == i for i in range(10)])\n\nassert True == f6("
        }
    },
    {
        "name": "Study_6_0",
        "sat": "def sat(i: int):\n    assert type(i) is int, 'i must be of type int'\n    return i % 123 == 4 and i > 10 ** 10",
        "desc": "Find an integer greater than 10^10 which is 4 mod 123.",
        "prompts": {
            "short": "def f(i: int):\n    return i % 123 == 4 and i > 10 ** 10\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int):\n    return i % 123 == 4 and i > 10 ** 10\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int):\n    \"\"\"Find an integer greater than 10^10 which is 4 mod 123.\"\"\"\n    return i % 123 == 4 and i > 10 ** 10\n\nassert True == f6("
        }
    },
    {
        "name": "Study_7_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3",
        "desc": "Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888.",
        "prompts": {
            "short": "def f(s: str):\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888.\"\"\"\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3\n\nassert True == f6("
        }
    },
    {
        "name": "Study_8_0",
        "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]",
        "desc": "Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th.",
        "prompts": {
            "short": "def f(ls: List[str]):\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    \"\"\"Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th.\"\"\"\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]\n\nassert True == f6("
        }
    },
    {
        "name": "Study_9_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")",
        "desc": "Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to\nget the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\nmappings.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to\n    get the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\n    mappings.\"\"\"\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")\n\nassert True == f6("
        }
    },
    {
        "name": "Study_10_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11",
        "desc": "Find a palindrome of length greater than 11 in the decimal representation of 8^1818.",
        "prompts": {
            "short": "def f(s: str):\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a palindrome of length greater than 11 in the decimal representation of 8^1818.\"\"\"\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11\n\nassert True == f6("
        }
    },
    {
        "name": "Study_11_0",
        "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return min(ls) == max(ls) == str(len(ls))",
        "desc": "Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\nand is equal to the lexicographically smallest element.",
        "prompts": {
            "short": "def f(ls: List[str]):\n    return min(ls) == max(ls) == str(len(ls))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    return min(ls) == max(ls) == str(len(ls))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    \"\"\"Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\n    and is equal to the lexicographically smallest element.\"\"\"\n    return min(ls) == max(ls) == str(len(ls))\n\nassert True == f6("
        }
    },
    {
        "name": "Study_12_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000",
        "desc": "Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first\ninteger plus 4 is 9.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first\n    integer plus 4 is 9.\"\"\"\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000\n\nassert True == f6("
        }
    },
    {
        "name": "Study_13_0",
        "sat": "def sat(x: float):\n    assert type(x) is float, 'x must be of type float'\n    return str(x - 3.1415).startswith(\"123.456\")",
        "desc": "Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456.",
        "prompts": {
            "short": "def f(x: float):\n    return str(x - 3.1415).startswith(\"123.456\")\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: float):\n    return str(x - 3.1415).startswith(\"123.456\")\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(x: float):\n    \"\"\"Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456.\"\"\"\n    return str(x - 3.1415).startswith(\"123.456\")\n\nassert True == f6("
        }
    },
    {
        "name": "Study_14_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([sum(li[:i]) == i for i in range(20)])",
        "desc": "Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all([sum(li[:i]) == i for i in range(20)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all([sum(li[:i]) == i for i in range(20)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19.\"\"\"\n    return all([sum(li[:i]) == i for i in range(20)])\n\nassert True == f6("
        }
    },
    {
        "name": "Study_15_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))",
        "desc": "Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19.\"\"\"\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))\n\nassert True == f6("
        }
    },
    {
        "name": "Study_16_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return float(s) + len(s) == 4.5",
        "desc": "Find a real number such that when you add the length of its decimal representation to it, you get 4.5.\nYour answer should be the string form of the number in its decimal representation.",
        "prompts": {
            "short": "def f(s: str):\n    return float(s) + len(s) == 4.5\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return float(s) + len(s) == 4.5\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a real number such that when you add the length of its decimal representation to it, you get 4.5.\n    Your answer should be the string form of the number in its decimal representation.\"\"\"\n    return float(s) + len(s) == 4.5\n\nassert True == f6("
        }
    },
    {
        "name": "Study_17_0",
        "sat": "def sat(i: int):\n    assert type(i) is int, 'i must be of type int'\n    return len(str(i + 1000)) > len(str(i + 1001))",
        "desc": "Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001.",
        "prompts": {
            "short": "def f(i: int):\n    return len(str(i + 1000)) > len(str(i + 1001))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int):\n    return len(str(i + 1000)) > len(str(i + 1001))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(i: int):\n    \"\"\"Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001.\"\"\"\n    return len(str(i + 1000)) > len(str(i + 1001))\n\nassert True == f6("
        }
    },
    {
        "name": "Study_18_0",
        "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()",
        "desc": "Find a list of strings that when you combine them in all pairwise combinations gives the six strings:\n'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'",
        "prompts": {
            "short": "def f(ls: List[str]):\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    \"\"\"Find a list of strings that when you combine them in all pairwise combinations gives the six strings:\n    'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'\"\"\"\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()\n\nassert True == f6("
        }
    },
    {
        "name": "Study_19_0",
        "sat": "def sat(si: Set[int]):\n    assert type(si) is set and all(type(a) is int for a in si), 'si must be of type Set[int]'\n    return {i + j for i in si for j in si} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}",
        "desc": "Find a set of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\nThat is find set S such that, { i + j | i, j in S } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.",
        "prompts": {
            "short": "def f(si: Set[int]):\n    return {i + j for i in si for j in si} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(si: Set[int]):\n    return {i + j for i in si for j in si} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(si: Set[int]):\n    \"\"\"Find a set of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    That is find set S such that, { i + j | i, j in S } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\"\"\"\n    return {i + j for i in si for j in si} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\n\nassert True == f6("
        }
    },
    {
        "name": "Study_20_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))",
        "desc": "Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from\nthe previous one by one or is thrice the previous one.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\"\"\"\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))\n\nassert True == f6("
        }
    },
    {
        "name": "Study_21_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3",
        "desc": "Find a list integers containing exactly three distinct values, such that no integer repeats\ntwice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list integers containing exactly three distinct values, such that no integer repeats\n    twice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)\"\"\"\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3\n\nassert True == f6("
        }
    },
    {
        "name": "Study_22_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s[::2] in s and len(set(s)) == 5",
        "desc": "Find a string s containing exactly five distinct characters which also contains as a substring every other\ncharacter of s (e.g., if the string s were 'parrotfish' every other character would be 'profs').",
        "prompts": {
            "short": "def f(s: str):\n    return s[::2] in s and len(set(s)) == 5\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return s[::2] in s and len(set(s)) == 5\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a string s containing exactly five distinct characters which also contains as a substring every other\n    character of s (e.g., if the string s were 'parrotfish' every other character would be 'profs').\"\"\"\n    return s[::2] in s and len(set(s)) == 5\n\nassert True == f6("
        }
    },
    {
        "name": "Study_23_0",
        "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return tuple(ls) in zip('dee', 'doo', 'dah!')",
        "desc": "Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.",
        "prompts": {
            "short": "def f(ls: List[str]):\n    return tuple(ls) in zip('dee', 'doo', 'dah!')\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    return tuple(ls) in zip('dee', 'doo', 'dah!')\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    \"\"\"Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.\"\"\"\n    return tuple(ls) in zip('dee', 'doo', 'dah!')\n\nassert True == f6("
        }
    },
    {
        "name": "Study_24_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li.count(17) == 3 and li.count(3) >= 2",
        "desc": "Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return li.count(17) == 3 and li.count(3) >= 2\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return li.count(17) == 3 and li.count(3) >= 2\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three.\"\"\"\n    return li.count(17) == 3 and li.count(3) >= 2\n\nassert True == f6("
        }
    },
    {
        "name": "Study_25_0",
        "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]",
        "desc": "Find a permutation of the string 'Permute me true' which is a palindrome.",
        "prompts": {
            "short": "def f(s: str):\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(s: str):\n    \"\"\"Find a permutation of the string 'Permute me true' which is a palindrome.\"\"\"\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]\n\nassert True == f6("
        }
    },
    {
        "name": "Study_26_0",
        "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)",
        "desc": "Divide the decimal representation of 8^88 up into strings of length eight.",
        "prompts": {
            "short": "def f(ls: List[str]):\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(ls: List[str]):\n    \"\"\"Divide the decimal representation of 8^88 up into strings of length eight.\"\"\"\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)\n\nassert True == f6("
        }
    },
    {
        "name": "Study_27_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]",
        "desc": "Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\nv the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\nshare the same great-grandchildren. Represented this digraph by the list of children indices.",
        "prompts": {
            "short": "def f(li: List[int]):\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\n    v the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\n    share the same great-grandchildren. Represented this digraph by the list of children indices.\"\"\"\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]\n\nassert True == f6("
        }
    },
    {
        "name": "Study_28_0",
        "sat": "def sat(si: Set[int]):\n    assert type(si) is set and all(type(a) is int for a in si), 'si must be of type Set[int]'\n    return all(i in range(1000) and abs(i - j) >= 10 for i in si for j in si if i != j) and len(si) == 100",
        "desc": "Find a set of one hundred integers between 0 and 999 which all differ by at least ten from one another.",
        "prompts": {
            "short": "def f(si: Set[int]):\n    return all(i in range(1000) and abs(i - j) >= 10 for i in si for j in si if i != j) and len(si) == 100\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(si: Set[int]):\n    return all(i in range(1000) and abs(i - j) >= 10 for i in si for j in si if i != j) and len(si) == 100\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(si: Set[int]):\n    \"\"\"Find a set of one hundred integers between 0 and 999 which all differ by at least ten from one another.\"\"\"\n    return all(i in range(1000) and abs(i - j) >= 10 for i in si for j in si if i != j) and len(si) == 100\n\nassert True == f6("
        }
    },
    {
        "name": "Study_29_0",
        "sat": "def sat(si: Set[int]):\n    assert type(si) is set and all(type(a) is int for a in si), 'si must be of type Set[int]'\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in si for j in si if i != j) and len(si) > 995",
        "desc": "Find a set of more than 995 integers between 0 and 999, inclusive, such that each pair of integers have\nsquares that differ by at least 10.",
        "prompts": {
            "short": "def f(si: Set[int]):\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in si for j in si if i != j) and len(si) > 995\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(si: Set[int]):\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in si for j in si if i != j) and len(si) > 995\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(si: Set[int]):\n    \"\"\"Find a set of more than 995 integers between 0 and 999, inclusive, such that each pair of integers have\n    squares that differ by at least 10.\"\"\"\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in si for j in si if i != j) and len(si) > 995\n\nassert True == f6("
        }
    },
    {
        "name": "Study_30_0",
        "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])",
        "desc": "Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one\nare between 0 and 999, inclusive, and are strictly increasing in terms of f(n).",
        "prompts": {
            "short": "def f(li: List[int]):\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(li: List[int]):\n    \"\"\"Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one\n    are between 0 and 999, inclusive, and are strictly increasing in terms of f(n).\"\"\"\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])\n\nassert True == f6("
        }
    },
    {
        "name": "RockPaperScissors_0",
        "sat": "def sat(probs: List[float]):\n    assert type(probs) is list and all(type(a) is float for a in probs), 'probs must be of type List[float]'  # rock prob, paper prob, scissors prob\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6",
        "desc": "Find optimal strategy for Rock-Paper-Scissors zero-sum game\n\nCan the computer figure out that 1/3, 1/3, 1/3 achieves the maximal expected value of 0",
        "prompts": {
            "short": "def f(probs: List[float]):\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6\n\nassert True == f(",
            "medium": "def f1(s: str):\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(probs: List[float]):\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6\n\nassert True == f6(",
            "long": "def f1(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"\n\nassert True == f1(\"world\")\n\n---\n\ndef f2(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"\n\nassert True == f2(\"world\"[::-1])\n\n---\n\ndef f3(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\n\nassert True == f3([1, 2])\n\n---\n\ndef f4(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)\n\nassert True == f4([\"a\"*(i+2)+\"b\" for i in range(1000)])\n\n---\n\ndef f5(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")\n\nassert True == f5(int(int(\"123456789\" + \"0\"*9) ** 0.5) + 1)\n\n---\n\ndef f6(probs: List[float]):\n    \"\"\"Find optimal strategy for Rock-Paper-Scissors zero-sum game\n    \n    Can the computer figure out that 1/3, 1/3, 1/3 achieves the maximal expected value of 0\"\"\"\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6\n\nassert True == f6("
        }
    }
]