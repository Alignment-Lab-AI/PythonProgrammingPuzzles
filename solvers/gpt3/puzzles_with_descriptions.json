[{"name": "Nash_0", "sat": "def sat(strategies: List[List[float]], A: List[List[float]]=[[-1.0, -3.0], [0.0, -2.0]], B: List[List[float]]=[[-1.0, 0.0], [-3.0, -2.0]], eps: float=0.01):\n    assert type(strategies) is list and all(type(a) is list and all(type(b) is float for b in a) for a in strategies), 'strategies must be of type List[List[float]]'  # error tolerance\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))", "desc": "Compute a [Nash equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium) for a given\n[bimatrix game](https://en.wikipedia.org/wiki/Bimatrix_game). While this problem was known to be\nPPAD-hard in general. In fact the challenge is be much easier for an approximate\n[eps-equilibrium](https://en.wikipedia.org/wiki/Epsilon-equilibrium) and of course for small games."}, {"name": "ZeroSum_0", "sat": "def sat(strategies: List[List[float]], A: List[List[float]]=[[0.0, -1.0, 1.0], [1.0, 0.0, -1.0], [-1.0, 1.0, 0.0]], eps: float=0.1):\n    assert type(strategies) is list and all(type(a) is list and all(type(b) is float for b in a) for a in strategies), 'strategies must be of type List[List[float]]'  # error tolerance\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "desc": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming."}, {"name": "BirthdayParadox_0", "sat": "def sat(n: int, year_len: int=365):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "desc": "Find `n` such that the probability of two people having the same birthday in a group of `n` is near `1/2`.\nThe year length is year_len (365 is earth, while Neptune year is 60,182)\nSee [Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category))"}, {"name": "ExponentialProbability_0", "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.5):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "desc": "Find stopping probability, so that the probability of stopping in `steps` or fewer time steps\nis the given `target_prob`.\nSee [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)"}, {"name": "LZW_0", "sat": "def sat(seq: List[int], compressed_len: int=17, text: str=\"Hellooooooooooooooooooooo world!\"):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "desc": "Find a (short) compression that decompresses to the given string.\nWe have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm."}, {"name": "PackingHam_0", "sat": "def sat(words: List[str], num: int=100, bits: int=100, dist: int=34):\n    assert type(words) is list and all(type(a) is str for a in words), 'words must be of type List[str]'\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "desc": "Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\n\nThis is a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces) in coding theory."}, {"name": "FindRepeats_0", "sat": "def sat(indices: List[int], a0: int=123):\n    assert type(indices) is list and all(type(a) is int for a in indices), 'indices must be of type List[int]'\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1", "desc": "Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\noccurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\na_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\nFor a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\nSample input:\n9\n\nSample output:\n[0, 3, 6, ..., 2997]\n\nThe sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\nall equal in this case.\n\nNote: This problem is much easier than the IMO problem which also required a proof that it is impossible\nfor a_0 not divisible by 3.\n\nInspired by [IMO 2017 Problem 1](https://www.imo-official.org/problems.aspx)"}, {"name": "FindProductiveList_0", "sat": "def sat(li: List[int], n: int=6):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))", "desc": "Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\nwhere indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\nthat are multiples of 3 (as proven in the IMO problem).\n\nSample input:\n6\n\nSample output:\n[_, _, _, _, _, _]\n\n(Sample output hidden because showing sample output would give away too much information.)\n\nNote: This problem is easier than the IMO problem because the hard part is proving that sequences do not\nexists for non-multiples of 3.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)"}, {"name": "HalfTag_0", "sat": "def sat(li: List[int], n: int=3, tags: List[int]=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "desc": "The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\nThe goal is to find a subset (list) li of half the indices such that:\n* The sum of the indices equals the sum of the sum of the missing indices.\n* The tags of the chosen indices contains exactly each number in range(n) twice.\n\nSample input:\nn = 3\ntags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\nSample output:\n[0, 3, 5, 6, 8, 11]\n\nNote the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n\nInspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)"}, {"name": "AllQuadraticRoots_0", "sat": "def sat(roots: List[float], coeffs: List[float]=[1.3, -0.5]):\n    assert type(roots) is list and all(type(a) is float for a in roots), 'roots must be of type List[float]'\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6", "desc": "Find all (real) solutions for a [quadratic equation](https://en.wikipedia.org/wiki/Quadratic_formula)\nx^2 + b x + c (i.e., factor into roots)"}, {"name": "SumOfDigits_0", "sat": "def sat(x: str, s: int=679):\n    assert type(x) is str, 'x must be of type str'\n    return s == sum([int(d) for d in x])", "desc": "Find a number that its digits sum to a specific value."}, {"name": "FloatWithDecimalValue_0", "sat": "def sat(z: float, v: int=9, d: float=0.0001):\n    assert type(z) is float, 'z must be of type float'\n    return int(z * 1/d % 10) == v", "desc": "Create a float with a specific decimal."}, {"name": "ArithmeticSequence_0", "sat": "def sat(x: List[int], a: int=7, s: int=5, e: int=200):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i+1] for i in range(len(x)-1)])", "desc": "Create a list that is a subrange of an arithmetic sequence."}, {"name": "GeometricSequence_0", "sat": "def sat(x: List[int], a: int=8, r: int=2, l: int=50):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i+1] for i in range(len(x)-1)])", "desc": "Create a list that is a subrange of an gemoetric sequence."}, {"name": "LineIntersection_0", "sat": "def sat(e: List[int], a: int=2, b: int=-1, c: int=1, d: int=2021):\n    assert type(e) is list and all(type(a) is int for a in e), 'e must be of type List[int]'\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5", "desc": "Find the intersection of two lines.\nSolution should be a list of the (x,y) coordinates.\nAccuracy of fifth decimal digit is required."}, {"name": "IfProblem_0", "sat": "def sat(x: int, a: int=324554, b: int=1345345):\n    assert type(x) is int, 'x must be of type int'\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "desc": "Simple if statement"}, {"name": "IfProblemWithAnd_0", "sat": "def sat(x: int, a: int=9384594, b: int=1343663):\n    assert type(x) is int, 'x must be of type int'\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "desc": "Simple if statement with and clause"}, {"name": "IfProblemWithOr_0", "sat": "def sat(x: int, a: int=253532, b: int=1230200):\n    assert type(x) is int, 'x must be of type int'\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "desc": "Simple if statement with or clause"}, {"name": "IfCases_0", "sat": "def sat(x: int, a: int=4, b: int=54368639):\n    assert type(x) is int, 'x must be of type int'\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b", "desc": "Simple if statement with multiple cases"}, {"name": "ListPosSum_0", "sat": "def sat(x: List[int], n: int=5, s: int=19):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])", "desc": "Construct a list of non-negative integers that sum up to some value"}, {"name": "ListDistinctSum_0", "sat": "def sat(x: List[int], n: int=4, s: int=2021):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return len(x) == n and sum(x) == s and len(set(x)) == n", "desc": "Construct a list of distinct integers that sum up to some value"}, {"name": "ConcatStrings_0", "sat": "def sat(x: str, s: List[str]=['a', 'b', 'c', 'd', 'e', 'f'], n: int=4):\n    assert type(x) is str, 'x must be of type str'\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])", "desc": "Concatenate list of characters"}, {"name": "SublistSum_0", "sat": "def sat(x: List[int], t: int=677, a: int=43, e: int=125, s: int=10):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])", "desc": "Sum values of sublist by range specifications"}, {"name": "CumulativeSum_0", "sat": "def sat(x: List[int], t: int=50, n: int=10):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n", "desc": "Number of values with cumulative sum less than target"}, {"name": "BasicStrCounts_0", "sat": "def sat(s: str, s1: str=\"a\", s2: str=\"b\", count1: int=50, count2: int=30):\n    assert type(s) is str, 's must be of type str'\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]", "desc": "Find a string that has `count1` occurrences of `s1` and `count1` occurrences of `s1` and starts and ends with\nthe same 10 characters"}, {"name": "ReverseCat_0", "sat": "def sat(s: str, substrings: List[str]=['foo', 'bar', 'baz']):\n    assert type(s) is str, 's must be of type str'\n    return all(sub in s and sub[::-1] in s for sub in substrings)", "desc": "Find a string that contains all the `substrings` reversed and forward"}, {"name": "EngineerNumbers_0", "sat": "def sat(ls: List[str], n: int=100, a: str=\"bar\", b: str=\"foo\"):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "desc": "Find a list of `n` strings starting with `a` and ending with `b`"}, {"name": "PenultimateString_0", "sat": "def sat(s: str, strings: List[str]=['cat', 'dog', 'bird', 'fly', 'moose']):\n    assert type(s) is str, 's must be of type str'\n    return s in strings and sum(t > s for t in strings) == 1", "desc": "Find the alphabetically second to last last string in a list."}, {"name": "PenultimateRevString_0", "sat": "def sat(s: str, strings: List[str]=['cat', 'dog', 'bird', 'fly', 'moose']):\n    assert type(s) is str, 's must be of type str'\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1", "desc": "Find the reversed version of the alphabetically second string in a list."}, {"name": "CenteredString_0", "sat": "def sat(s: str, target: str=\"foobarbazwow\", length: int=6):\n    assert type(s) is str, 's must be of type str'\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s", "desc": "Find a substring of length `length` centered within `target`."}, {"name": "Abbreviate_0", "sat": "def sat(s: str, word: str=\"antidisestablishmentarianism\", max_len: int=10):\n    assert type(s) is str, 's must be of type str'\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]", "desc": "Abbreviate strings longer than a given length by replacing everything but the first and last characters by\nan integer indicating how many characters there were in between them.\n\nInspired by [Codeforces Problem 71 A](https://codeforces.com/problemset/problem/71/A)"}, {"name": "DecreasingCountComparison_0", "sat": "def sat(n: int, scores: List[int]=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k: int=6):\n    assert type(n) is int, 'n must be of type int'\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])", "desc": "Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\nare at least as large as the kth.\n\nInspired by [Codeforces Problem 158 A](https://codeforces.com/problemset/problem/158/A)"}, {"name": "IncDec_0", "sat": "def sat(n: int, ops: List[str]=['x++', '--x', '--x'], target: int=19143212):\n    assert type(n) is int, 'n must be of type int'\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target", "desc": "This straightforward problem is a little harder than the Codeforces one.\nGiven a sequence of operations \"++x\",\n\"x++\", \"--x\", \"x--\", and a target value, find initial value so that the final value is the target value.\n\nSample Input:\nops = [\"x++\", \"--x\", \"--x\"]\ntarget = 12\n\nSample Output:\n13\n\nInspired by [Codeforces Problem 282 A](https://codeforces.com/problemset/problem/282/A)"}, {"name": "SlidingOne_0", "sat": "def sat(s: str, matrix: List[List[int]]=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves: int=3):\n    assert type(s) is str, 's must be of type str'\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "desc": "We are given a 5x5 bimatrix with a single 1 like:\n0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n\nFind a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\nin \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n\nInspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)"}, {"name": "SortPlusPlus_0", "sat": "def sat(s: str, inp: str=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    assert type(s) is str, 's must be of type str'\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "desc": "Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\n\nInspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)"}, {"name": "FindHomogeneousSubstring_0", "sat": "def sat(n: int, s: str=\"0000111111100000\", k: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return s[n:n + k] == s[n] * k", "desc": "You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\nall 0's or all 1's.\n\nSample Input:\ns = 01010000111111100000, k = 5\n\nSample Output:\n8\n(or 9 or 10 or 15)\n\nInspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)"}, {"name": "FivePowers_0", "sat": "def sat(s: str, n: int=7):\n    assert type(s) is str, 's must be of type str'\n    return int(str(5 ** n)[:-2] + s) == 5 ** n", "desc": "What are the last two digits of 5^n?\n\nInspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/630/A)"}, {"name": "CombinationLock_0", "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len", "desc": "Shortest Combination Lock Path\n\nGiven a starting a final lock position, find the (minimal) intermediate states, where each transition\ninvolves increasing or decreasing a single digit (mod 10)\ne.g.\nstart = \"120\"\ncombo = \"293\"\n\noutput: ['220', '210', '200', '290', '291', '292']\n\nInspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)"}, {"name": "CombinationLockObfuscated_0", "sat": "def sat(states: List[str], start: str=\"012\", combo: str=\"329\", target_len: int=6):\n    assert type(states) is list and all(type(a) is str for a in states), 'states must be of type List[str]'\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))", "desc": "An obfuscated version of CombinationLock above"}, {"name": "InvertPermutation_0", "sat": "def sat(s: str, perm: str=\"qwertyuiopasdfghjklzxcvbnm\", target: str=\"hello are you there?\"):\n    assert type(s) is str, 's must be of type str'\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target", "desc": "Find a string that, when a given permutation of characters is applied, has a given result.\n\nInspired by [Codeforces Problem 474 A](https://codeforces.com/problemset/problem/474/A)"}, {"name": "OnesAndTwos_0", "sat": "def sat(seq: List[int], n: int=10000, length: int=5017):\n    assert type(seq) is list and all(type(a) is int for a in seq), 'seq must be of type List[int]'\n    return set(seq) <= {1, 2} and sum(seq) == n and len(seq) == length", "desc": "Find a sequence of 1's and 2's of a given length that that adds up to n\n\nInspired by [Codeforces Problem 476 A](https://codeforces.com/problemset/problem/476/A)"}, {"name": "MinConsecutiveSum_0", "sat": "def sat(start: int, k: int=3, upper: int=6, seq: List[int]=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper", "desc": "Find a sequence of k consecutive indices whose sum is minimal\n\nInspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)"}, {"name": "MaxConsecutiveSum_0", "sat": "def sat(start: int, k: int=3, lower: int=150, seq: List[int]=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    assert type(start) is int, 'start must be of type int'\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower", "desc": "Find a sequence of k consecutive indices whose sum is maximal\n\nInspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)"}, {"name": "MaxConsecutiveProduct_0", "sat": "def sat(start: int, k: int=3, lower: int=100000, seq: List[int]=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    assert type(start) is int, 'start must be of type int'\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower", "desc": "Find a sequence of k consecutive indices whose product is maximal, possibly looping around\n\nInspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)"}, {"name": "MinRotations_0", "sat": "def sat(rotations: List[int], target: str=\"dad\", upper: int=9):\n    assert type(rotations) is list and all(type(a) is int for a in rotations), 'rotations must be of type List[int]'\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper", "desc": "We begin with the string `\"a...z\"`\n\nAn `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\ncycling around. Given a target string of length n, find the n rotations that put the consecutive characters\nof that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\nFor example if the string was `'fab'`, the minimal rotations would be `[5, -5, 1]` with a total of `11`.\n\nInspired by [Codeforces Problem 731 A](https://codeforces.com/problemset/problem/731/A)"}, {"name": "KnightsTour_0", "sat": "def sat(tour: List[List[int]], m: int=8, n: int=8):\n    assert type(tour) is list and all(type(a) is list and all(type(b) is int for b in a) for a in tour), 'tour must be of type List[List[int]]'\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once", "desc": "Knights Tour\n\nFind an (open) tour of knight moves on an m x n chess-board that visits each square once.\n\nSee Wikipedia entry on [Knight's tour](https://en.wikipedia.org/w/index.php?title=Knight%27s_tour)"}, {"name": "GCD_0", "sat": "def sat(n: int, a: int=15482, b: int=23223, lower_bound: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return a % n == 0 and b % n == 0 and n >= lower_bound", "desc": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nFind the greatest common divisor of two integers.\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)"}, {"name": "GCD_multi_0", "sat": "def sat(n: int, nums: List[int]=[77410, 23223, 54187], lower_bound: int=2):\n    assert type(n) is int, 'n must be of type int'\n    return all(i % n == 0 for i in nums) and n >= lower_bound", "desc": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nFind the greatest common divisor of a *list* of integers.\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)"}, {"name": "LCM_multi_0", "sat": "def sat(n: int, nums: List[int]=[15, 27, 102], upper_bound: int=5000):\n    assert type(n) is int, 'n must be of type int'\n    return all(n % i == 0 for i in nums) and n <= upper_bound", "desc": "[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n(LCM)\n\nFind the least common multiple of a list of integers.\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)"}, {"name": "SmallExponentBigSolution_0", "sat": "def sat(n: int, b: int=2, target: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return (b ** n) % n == target", "desc": "Small exponent, big solution\n\nSolve for n: b^n = target (mod n)\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)"}, {"name": "ThreeCubes_0", "sat": "def sat(nums: List[int], target: int=10):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "desc": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)"}, {"name": "FourSquares_0", "sat": "def sat(nums: List[int], n: int=12345):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n", "desc": "Sum of four squares\n\n[Lagrange's Four Square Theorem](https://en.wikipedia.org/w/index.php?title=Lagrange%27s_four-square_theorem)\n\nGiven a non-negative integer `n`, a classic theorem of Lagrange says that `n` can be written as the sum of four\nintegers. The problem here is to find them. This is a nice problem and we give an elementary solution\nthat runs in time \tilde{O}(n),\nwhich is not \"polynomial time\" because it is not polynomial in log(n), the length of n. A poly-log(n)\nalgorithm using quaternions is described in the book:\n[\"Randomized algorithms in number theory\" by Michael O. Rabin and Jeffery O. Shallit (1986)](https://doi.org/10.1002/cpa.3160390713)\n\nThe first half of the problems involve small numbers and the second half involve some numbers up to 50 digits."}, {"name": "Factoring_0", "sat": "def sat(i: int, n: int=62710561):\n    assert type(i) is int, 'i must be of type int'\n    return 1 < i < n and n % i == 0", "desc": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future."}, {"name": "CollatzDelay_0", "sat": "def sat(n: int, t: int=100, upper: int=10):\n    assert type(n) is int, 'n must be of type int'\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper", "desc": "Collatz Delay\n\nFind `0 < n < upper` so that it takes exactly `t` steps to reach 1 in the Collatz process. For instance,\nthe number `n=9780657630` takes 1,132 steps and the number `n=93,571,393,692,802,302` takes\n2,091 steps, according to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)\n\nNow, this problem can be solved trivially by taking exponentially large `n = 2 ** t` so we also bound the\nnumber of bits of the solution to be upper.\n\nSee [this webpage](http://www.ericr.nl/wondrous/delrecs.html) for up-to-date records."}, {"name": "Tutorial1_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return \"Hello \" + s == \"Hello world\"", "desc": "Find a string that when concatenated onto 'Hello ' gives 'Hello world'."}, {"name": "Tutorial2_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return \"Hello \" + s[::-1] == \"Hello world\"", "desc": "Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'."}, {"name": "Tutorial3_0", "sat": "def sat(x: List[int]):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return len(x) == 2 and sum(x) == 3", "desc": "Find a list of two integers whose sum is 3."}, {"name": "Tutorial4_0", "sat": "def sat(s: List[str]):\n    assert type(s) is list and all(type(a) is str for a in s), 's must be of type List[str]'\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)", "desc": "Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'."}, {"name": "Tutorial5_0", "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    return str(n * n).startswith(\"123456789\")", "desc": "Find an integer whose perfect square begins with 123456789 in its decimal representation."}, {"name": "HelloWorld_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s + 'world' == 'Hello world'", "desc": "Trivial example, no solutions provided"}, {"name": "BackWorlds_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s[::-1] + 'world' == 'Hello world'", "desc": "Two solutions, no inputs"}, {"name": "StrAdd_0", "sat": "def sat(st: str, a: str=\"world\", b: str=\"Hello world\"):\n    assert type(st) is str, 'st must be of type str'\n    return st + a == b", "desc": "Solve simple string addition problem."}, {"name": "StrSetLen_0", "sat": "def sat(s: str, dups: int=2021):\n    assert type(s) is str, 's must be of type str'\n    return len(set(s)) == len(s) - dups", "desc": "Find a string with `dups` duplicate chars"}, {"name": "StrMul_0", "sat": "def sat(s: str, target: str=\"foofoofoofoo\", n: int=2):\n    assert type(s) is str, 's must be of type str'\n    return s * n == target", "desc": "Find a string which when repeated `n` times gives `target`"}, {"name": "StrMul2_0", "sat": "def sat(n: int, target: str=\"foofoofoofoo\", s: str=\"foofoo\"):\n    assert type(n) is int, 'n must be of type int'\n    return s * n == target", "desc": "Find `n` such that `s` repeated `n` times gives `target`"}, {"name": "StrLen_0", "sat": "def sat(s: str, n: int=1000):\n    assert type(s) is str, 's must be of type str'\n    return len(s) == n", "desc": "Find a string of length `n`"}, {"name": "StrAt_0", "sat": "def sat(i: int, s: str=\"cat\", target: str=\"a\"):\n    assert type(i) is int, 'i must be of type int'\n    return s[i] == target", "desc": "Find the index of `target` in string `s`"}, {"name": "StrNegAt_0", "sat": "def sat(i: int, s: str=\"cat\", target: str=\"a\"):\n    assert type(i) is int, 'i must be of type int'\n    return s[i] == target and i < 0", "desc": "Find the index of `target` in `s` using a negative index."}, {"name": "StrSlice_0", "sat": "def sat(inds: List[int], s: str=\"hello world\", target: str=\"do\"):\n    assert type(inds) is list and all(type(a) is int for a in inds), 'inds must be of type List[int]'\n    i, j, k = inds\n    return s[i:j:k] == target", "desc": "Find the three slice indices that give the specific `target` in string `s`"}, {"name": "StrIndex_0", "sat": "def sat(s: str, big_str: str=\"foobar\", index: int=2):\n    assert type(s) is str, 's must be of type str'\n    return big_str.index(s) == index", "desc": "Find a string whose *first* index in `big_str` is `index`"}, {"name": "StrIndex2_0", "sat": "def sat(big_str: str, sub_str: str=\"foobar\", index: int=2):\n    assert type(big_str) is str, 'big_str must be of type str'\n    return big_str.index(sub_str) == index", "desc": "Find a string whose *first* index of `sub_str` is `index`"}, {"name": "StrIn_0", "sat": "def sat(s: str, a: str=\"hello\", b: str=\"yellow\", length: int=4):\n    assert type(s) is str, 's must be of type str'\n    return len(s) == length and s in a and s in b", "desc": "Find a string of length `length` that is in both strings `a` and `b`"}, {"name": "ListSetLen_0", "sat": "def sat(li: List[int], dups: int=42155):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return len(set(li)) == len(li) - dups", "desc": "Find a list with a certain number of duplicate items"}, {"name": "ListMul_0", "sat": "def sat(li: List[int], target: List[int]=[17, 9, -1, 17, 9, -1], n: int=2):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li * n == target", "desc": "Find a list that when multiplied n times gives the target list"}, {"name": "ListLen_0", "sat": "def sat(li: List[int], n: int=85012):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return len(li) == n", "desc": "Find a list of a given length n"}, {"name": "ListAt_0", "sat": "def sat(i: int, li: List[int]=[17, 31, 91, 18, 42, 1, 9], target: int=18):\n    assert type(i) is int, 'i must be of type int'\n    return li[i] == target", "desc": "Find the index of an item in a list. Any such index is fine."}, {"name": "ListNegAt_0", "sat": "def sat(i: int, li: List[int]=[17, 31, 91, 18, 42, 1, 9], target: int=91):\n    assert type(i) is int, 'i must be of type int'\n    return li[i] == target and i < 0", "desc": "Find the index of an item in a list using negative indexing."}, {"name": "ListSlice_0", "sat": "def sat(inds: List[int], li: List[int]=[42, 18, 21, 103, -2, 11], target: List[int]=[-2, 21, 42]):\n    assert type(inds) is list and all(type(a) is int for a in inds), 'inds must be of type List[int]'\n    i, j, k = inds\n    return li[i:j:k] == target", "desc": "Find three slice indices to achieve a given list slice"}, {"name": "ListIndex_0", "sat": "def sat(item: int, li: List[int]=[17, 2, 3, 9, 11, 11], index: int=4):\n    assert type(item) is int, 'item must be of type int'\n    return li.index(item) == index", "desc": "Find the item whose first index in `li` is `index`"}, {"name": "ListIndex2_0", "sat": "def sat(li: List[int], i: int=29, index: int=10412):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li.index(i) == index", "desc": "Find a list that contains `i` first at index `index`"}, {"name": "ListIn_0", "sat": "def sat(s: str, a: List[str]=['cat', 'dot', 'bird'], b: List[str]=['tree', 'fly', 'dot']):\n    assert type(s) is str, 's must be of type str'\n    return s in a and s in b", "desc": "Find an item that is in both lists `a` and `b`"}, {"name": "IntNeg_0", "sat": "def sat(x: int, a: int=93252338):\n    assert type(x) is int, 'x must be of type int'\n    return -x == a", "desc": "Solve unary negation problem"}, {"name": "IntSum_0", "sat": "def sat(x: int, a: int=1073258, b: int=72352549):\n    assert type(x) is int, 'x must be of type int'\n    return a + x == b", "desc": "Solve sum problem"}, {"name": "IntSub_0", "sat": "def sat(x: int, a: int=-382, b: int=14546310):\n    assert type(x) is int, 'x must be of type int'\n    return x - a == b", "desc": "Solve subtraction problem"}, {"name": "IntSub2_0", "sat": "def sat(x: int, a: int=8665464, b: int=-93206):\n    assert type(x) is int, 'x must be of type int'\n    return a - x == b", "desc": "Solve subtraction problem"}, {"name": "IntMul_0", "sat": "def sat(n: int, a: int=14302, b: int=5):\n    assert type(n) is int, 'n must be of type int'\n    return b * n + (a % b) == a", "desc": "Solve multiplication problem"}, {"name": "IntDiv_0", "sat": "def sat(n: int, a: int=3, b: int=23463462):\n    assert type(n) is int, 'n must be of type int'\n    return b // n == a", "desc": "Solve division problem"}, {"name": "IntDiv2_0", "sat": "def sat(n: int, a: int=345346363, b: int=10):\n    assert type(n) is int, 'n must be of type int'\n    return n // b == a", "desc": "Find `n` that when divided by `b` is `a`"}, {"name": "IntSquareRoot_0", "sat": "def sat(x: int, a: int=10201202001):\n    assert type(x) is int, 'x must be of type int'\n    return x ** 2 == a", "desc": "Compute square root of number.\nThe target has a round (integer) square root."}, {"name": "IntNegSquareRoot_0", "sat": "def sat(n: int, a: int=10000200001):\n    assert type(n) is int, 'n must be of type int'\n    return a == n * n and n < 0", "desc": "Compute negative square root of number.\nThe target has a round (integer) square root."}, {"name": "FloatSquareRoot_0", "sat": "def sat(x: float, a: int=1020):\n    assert type(x) is float, 'x must be of type float'\n    return abs(x ** 2 - a) < 10 ** -3", "desc": "Compute square root of number.\nThe target might not have a round solution.\nAccuracy of third decimal digit is required."}, {"name": "FloatNegSquareRoot_0", "sat": "def sat(x: float, a: int=1020):\n    assert type(x) is float, 'x must be of type float'\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0", "desc": "Compute (negative) square root of number.\nThe target might not have a round solution.\nAccuracy of third decimal digit is required."}, {"name": "LongestMonotonicSubstringTricky_0", "sat": "def sat(x: List[int], length: int=20, s: str=\"Dynamic programming solves this puzzle!!!\"):\n    assert type(x) is list and all(type(a) is int for a in x), 'x must be of type List[int]'\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "desc": "Find the indices of the longest substring with characters in sorted order, with a twist!"}, {"name": "ClockAngle_0", "sat": "def sat(hands: List[int], target_angle: int=45):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle", "desc": "[Clock Angle Problem](https://en.wikipedia.org/wiki/Clock_angle_problem)\n\nEasy variant checks if angle at li = [hour, min] is a given number of degrees."}, {"name": "MonkeyAndCoconuts_0", "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1", "desc": "[The Monkey and the Coconuts](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts)\n\nFind the number of coconuts to solve the following riddle quoted from\n[Wikipedia article](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts):\n    There is a pile of coconuts, owned by five men.\n    One man divides the pile into five equal piles, giving the one left over coconut to a passing monkey,\n    and takes away his own share. The second man then repeats the procedure, dividing the remaining pile\n    into five and taking away his share, as do the third, fourth, and fifth, each of them finding one\n    coconut left over when dividing the pile by five, and giving it to a monkey. Finally, the group\n     divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n    How many coconuts were there in the original pile?"}, {"name": "PostageStamp_0", "sat": "def sat(stamps: List[int], target: int=80, max_stamps: int=4, options: List[int]=[10, 32, 8]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target", "desc": "[Postage stamp problem](https://en.wikipedia.org/wiki/Postage_stamp_problem)\n\nIn this problem version, one must find a selection of stamps to achieve a given value."}, {"name": "NecklaceSplit_0", "sat": "def sat(n: int, lace: str=\"bbbbrrbrbrbbrrrr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")", "desc": "[Necklace Splitting Problem](https://en.wikipedia.org/wiki/Necklace_splitting_problem)\n\nSplit a specific red/blue necklace in half at n so that each piece has an equal number of reds and blues."}, {"name": "PandigitalSquare_0", "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    return sorted([int(s) for s in str(n * n)]) == list(range(10))", "desc": "[Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Square\n\nFind an integer whose square has all digits 0-9 once."}, {"name": "AllPandigitalSquares_0", "sat": "def sat(nums: List[int]):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174", "desc": "All [Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Squares\n\nFind all 174 integers whose 10-digit square has all digits 0-9"}, {"name": "VerbalArithmetic_0", "sat": "def sat(li: List[int], words: List[str]=['SEND', 'MORE', 'MONEY']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]", "desc": "Find a substitution of digits for characters to make the numbers add up, like this:\nSEND + MORE = MONEY\n\nThe first digit in any cannot be 0.\nSee [Wikipedia article](https://en.wikipedia.org/wiki/Verbal_arithmetic)"}, {"name": "AnyEdge_0", "sat": "def sat(e: List[int], edges: List[List[int]]=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    assert type(e) is list and all(type(a) is int for a in e), 'e must be of type List[int]'\n    return e in edges", "desc": "Find any edge in a given [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics))."}, {"name": "UnweightedShortestPath_0", "sat": "def sat(path: List[int], edges: List[List[int]]=[[0, 11], [0, 22], [11, 22], [11, 33], [22, 33]], u: int=0, v: int=33, bound: int=3):\n    assert type(path) is list and all(type(a) is int for a in path), 'path must be of type List[int]'\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound", "desc": "Unweighted Shortest Path\n\nFind a path from node u to node v, of a bounded length, in a given digraph on vertices 0, 1,..., n.\n\nSee (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]"}, {"name": "AnyPath_0", "sat": "def sat(path: List[int], edges: List[List[int]]=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    assert type(path) is list and all(type(a) is int for a in path), 'path must be of type List[int]'\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True", "desc": "Any Path\n\nFind any path from node 0 to node n in a given graph on vertices 0, 1,..., n."}, {"name": "EvenPath_0", "sat": "def sat(path: List[int], edges: List[List[int]]=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    assert type(path) is list and all(type(a) is int for a in path), 'path must be of type List[int]'\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0", "desc": "Even Path\n\nFind any path with an even number of nodes from node 0 to node n in a given graph on vertices 0, 1,..., n."}, {"name": "OddPath_0", "sat": "def sat(p: List[int], edges: List[List[int]]=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    assert type(p) is list and all(type(a) is int for a in p), 'p must be of type List[int]'\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])", "desc": "Odd Path\n\n*** Note the change to go from node 0 to node 1 ***\n\nFind any path with an odd number of nodes from node 0 to node 1 in a given graph on vertices 0, 1,..., n."}, {"name": "Zarankiewicz_0", "sat": "def sat(edges: List[List[int]]):\n    assert type(edges) is list and all(type(a) is list and all(type(b) is int for b in a) for a in edges), 'edges must be of type List[List[int]]'\n    assert len(edges) == len({(a, b) for a, b in edges}) == 13  # weights\n    assert all(i in range(4) for li in edges for i in li)  # 4 nodes on each side\n    for i in range(4):\n        v = [m for m in range(4) if m != i]\n        for j in range(4):\n            u = [m for m in range(4) if m != j]\n            if all([m, n] in edges for m in v for n in u):\n                return False\n    return True", "desc": "[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)\n\nFind a bipartite graph with 4 vertices on each side, 13 edges, and no K_3,3 subgraph."}, {"name": "GraphIsomorphism_0", "sat": "def sat(bi: List[int], g1: List[List[int]]=[[0, 1], [1, 2], [2, 3], [3, 4]], g2: List[List[int]]=[[0, 4], [4, 1], [1, 2], [2, 3]]):\n    assert type(bi) is list and all(type(a) is int for a in bi), 'bi must be of type List[int]'\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}", "desc": "In the classic [Graph Isomorphism](https://en.wikipedia.org/wiki/Graph_isomorphism) problem,\none is given two graphs which are permutations of one another and\nthe goal is to find the permutation. It is unknown wheter or not there exists a polynomial-time algorithm\nfor this problem, though an unpublished quasi-polynomial-time algorithm has been announced by Babai.\n\nEach graph is specified by a list of edges where each edge is a pair of integer vertex numbers."}, {"name": "Study_1_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s.count('o') == 1000 and s.count('oo') == 0", "desc": "Find a string with 1000 'o's but no two adjacent 'o's."}, {"name": "Study_2_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801", "desc": "Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'."}, {"name": "Study_3_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))", "desc": "Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998."}, {"name": "Study_4_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return len(li) == 10 and li.count(li[3]) == 2", "desc": "Find a list of length 10 where the fourth element occurs exactly twice."}, {"name": "Study_5_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([li.count(i) == i for i in range(10)])", "desc": "Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9."}, {"name": "Study_6_0", "sat": "def sat(i: int):\n    assert type(i) is int, 'i must be of type int'\n    return i % 123 == 4 and i > 10 ** 10", "desc": "Find an integer greater than 10^10 which is 4 mod 123."}, {"name": "Study_7_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3", "desc": "Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888."}, {"name": "Study_8_0", "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]", "desc": "Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th."}, {"name": "Study_9_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")", "desc": "Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to\nget the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\nmappings."}, {"name": "Study_10_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11", "desc": "Find a palindrome of length greater than 11 in the decimal representation of 8^1818."}, {"name": "Study_11_0", "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return min(ls) == max(ls) == str(len(ls))", "desc": "Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\nand is equal to the lexicographically smallest element."}, {"name": "Study_12_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000", "desc": "Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first\ninteger plus 4 is 9."}, {"name": "Study_13_0", "sat": "def sat(x: float):\n    assert type(x) is float, 'x must be of type float'\n    return str(x - 3.1415).startswith(\"123.456\")", "desc": "Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456."}, {"name": "Study_14_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([sum(li[:i]) == i for i in range(20)])", "desc": "Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19."}, {"name": "Study_15_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))", "desc": "Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19."}, {"name": "Study_16_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return float(s) + len(s) == 4.5", "desc": "Find a real number such that when you add the length of its decimal representation to it, you get 4.5.\nYour answer should be the string form of the number in its decimal representation."}, {"name": "Study_17_0", "sat": "def sat(i: int):\n    assert type(i) is int, 'i must be of type int'\n    return len(str(i + 1000)) > len(str(i + 1001))", "desc": "Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001."}, {"name": "Study_18_0", "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()", "desc": "Find a list of strings that when you combine them in all pairwise combinations gives the six strings:\n'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'"}, {"name": "Study_19_0", "sat": "def sat(si: Set[int]):\n    assert type(si) is set and all(type(a) is int for a in si), 'si must be of type Set[int]'\n    return {i + j for i in si for j in si} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}", "desc": "Find a set of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\nThat is find set S such that, { i + j | i, j in S } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}."}, {"name": "Study_20_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))", "desc": "Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from\nthe previous one by one or is thrice the previous one."}, {"name": "Study_21_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3", "desc": "Find a list integers containing exactly three distinct values, such that no integer repeats\ntwice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)"}, {"name": "Study_22_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return s[::2] in s and len(set(s)) == 5", "desc": "Find a string s containing exactly five distinct characters which also contains as a substring every other\ncharacter of s (e.g., if the string s were 'parrotfish' every other character would be 'profs')."}, {"name": "Study_23_0", "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return tuple(ls) in zip('dee', 'doo', 'dah!')", "desc": "Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'."}, {"name": "Study_24_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li.count(17) == 3 and li.count(3) >= 2", "desc": "Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three."}, {"name": "Study_25_0", "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]", "desc": "Find a permutation of the string 'Permute me true' which is a palindrome."}, {"name": "Study_26_0", "sat": "def sat(ls: List[str]):\n    assert type(ls) is list and all(type(a) is str for a in ls), 'ls must be of type List[str]'\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)", "desc": "Divide the decimal representation of 8^88 up into strings of length eight."}, {"name": "Study_27_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]", "desc": "Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\nv the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\nshare the same great-grandchildren. Represented this digraph by the list of children indices."}, {"name": "Study_28_0", "sat": "def sat(si: Set[int]):\n    assert type(si) is set and all(type(a) is int for a in si), 'si must be of type Set[int]'\n    return all(i in range(1000) and abs(i - j) >= 10 for i in si for j in si if i != j) and len(si) == 100", "desc": "Find a set of one hundred integers between 0 and 999 which all differ by at least ten from one another."}, {"name": "Study_29_0", "sat": "def sat(si: Set[int]):\n    assert type(si) is set and all(type(a) is int for a in si), 'si must be of type Set[int]'\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in si for j in si if i != j) and len(si) > 995", "desc": "Find a set of more than 995 integers between 0 and 999, inclusive, such that each pair of integers have\nsquares that differ by at least 10."}, {"name": "Study_30_0", "sat": "def sat(li: List[int]):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])", "desc": "Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one\nare between 0 and 999, inclusive, and are strictly increasing in terms of f(n)."}, {"name": "RockPaperScissors_0", "sat": "def sat(probs: List[float]):\n    assert type(probs) is list and all(type(a) is float for a in probs), 'probs must be of type List[float]'  # rock prob, paper prob, scissors prob\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6", "desc": "Find optimal strategy for Rock-Paper-Scissors zero-sum game\n\nCan the computer figure out that 1/3, 1/3, 1/3 achieves the maximal expected value of 0"}]