[
  {
    "name": "Study_1_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a string with 1000 'o's but no two adjacent 'o's.\"\"\"\n    return s.count('o') == 1000 and s.count('oo') == 0",
    "sols": [
      "def sol():\n    return ('h' + 'o') * 1000"
    ],
    "module": "study"
  },
  {
    "name": "Study_2_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'.\"\"\"\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801",
    "sols": [
      "def sol():\n    return 'ho' * (800 + 1) + 'o' * (100 * 2 - 1)"
    ],
    "module": "study"
  },
  {
    "name": "Study_3_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998.\"\"\"\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))",
    "sols": [
      "def sol():\n    return [((i + 1) % 999) for i in range(999)]"
    ],
    "module": "study"
  },
  {
    "name": "Study_4_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list of length 10 where the fourth element occurs exactly twice.\"\"\"\n    return len(li) == 10 and li.count(li[3]) == 2",
    "sols": [
      "def sol():\n    return list(range(10 // 2)) * 2"
    ],
    "module": "study"
  },
  {
    "name": "Study_5_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9.\"\"\"\n    return all([li.count(i) == i for i in range(10)])",
    "sols": [
      "def sol():\n    return [i for i in range(10) for j in range(i)]"
    ],
    "module": "study"
  },
  {
    "name": "Study_6_0",
    "sat": "def sat(i: int):\n    \"\"\"Find an integer greater than 10^10 which is 4 mod 123.\"\"\"\n    return i % 123 == 4 and i > 10 ** 10",
    "sols": [
      "def sol():\n    return 4 + 10 ** 10 + 123 - 10 ** 10 % 123"
    ],
    "module": "study"
  },
  {
    "name": "Study_7_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888.\"\"\"\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3",
    "sols": [
      "def sol():\n    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))"
    ],
    "module": "study"
  },
  {
    "name": "Study_8_0",
    "sat": "def sat(ls: List[str]):\n    \"\"\"Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th.\"\"\"\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]",
    "sols": [
      "def sol():\n    return [''] * 1235 + ['a']"
    ],
    "module": "study"
  },
  {
    "name": "Study_9_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to get\n    the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\n    mappings.\n    \"\"\"\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")",
    "sols": [
      "def sol():\n    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']"
    ],
    "module": "study"
  },
  {
    "name": "Study_10_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a palindrome of length greater than 11 in the decimal representation of 8^1818.\"\"\"\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11",
    "sols": [
      "def sol():\n    s = str(8 ** 1818)\n    return next(s[i: i + le]\n                for le in range(12, len(s) + 1)\n                for i in range(len(s) - le + 1)\n                if s[i: i + le] == s[i: i + le][::-1]\n                )"
    ],
    "module": "study"
  },
  {
    "name": "Study_11_0",
    "sat": "def sat(ls: List[str]):\n    \"\"\"\n    Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\n    and is equal to the lexicographically smallest element.\n    \"\"\"\n    return min(ls) == max(ls) == str(len(ls))",
    "sols": [
      "def sol():\n    return ['1']"
    ],
    "module": "study"
  },
  {
    "name": "Study_12_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first\n    integer plus 4 is 9.\"\"\"\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000",
    "sols": [
      "def sol():\n    return [9 - 4, 4] * (1000 // 2)"
    ],
    "module": "study"
  },
  {
    "name": "Study_13_0",
    "sat": "def sat(x: float):\n    \"\"\"Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456.\"\"\"\n    return str(x - 3.1415).startswith(\"123.456\")",
    "sols": [
      "def sol():\n    return 123.456 + 3.1415"
    ],
    "module": "study"
  },
  {
    "name": "Study_14_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19.\"\"\"\n    return all([sum(li[:i]) == i for i in range(20)])",
    "sols": [
      "def sol():\n    return [1] * 20"
    ],
    "module": "study"
  },
  {
    "name": "Study_15_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19.\"\"\"\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))",
    "sols": [
      "def sol():\n    return [(2 ** i) for i in range(20)]"
    ],
    "module": "study"
  },
  {
    "name": "Study_16_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a real number such that when you add the length of its decimal representation to it, you get 4.5.\n    Your answer should be the string form of the number in its decimal representation.\"\"\"\n    return float(s) + len(s) == 4.5",
    "sols": [
      "def sol():\n    return str(4.5 - len(str(4.5)))"
    ],
    "module": "study"
  },
  {
    "name": "Study_17_0",
    "sat": "def sat(i: int):\n    \"\"\"Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001.\"\"\"\n    return len(str(i + 1000)) > len(str(i + 1001))",
    "sols": [
      "def sol():\n    return -1001"
    ],
    "module": "study"
  },
  {
    "name": "Study_18_0",
    "sat": "def sat(ls: List[str]):\n    \"\"\"\n    Find a list of strings that when you combine them in all pairwise combinations gives the six strings:\n    'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'\n    \"\"\"\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()",
    "sols": [
      "def sol():\n    seen = set()\n    ans = []\n    for s in 'berlin berger linber linger gerber gerlin'.split():\n        t = s[:3]\n        if t not in seen:\n            ans.append(t)\n            seen.add(t)\n    return ans"
    ],
    "module": "study"
  },
  {
    "name": "Study_19_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Find a list of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    That is find L such that, { i + j | i, j in L } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    \"\"\"\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}",
    "sols": [
      "def sol():\n    return [0, 1, 2, 3, 17]"
    ],
    "module": "study"
  },
  {
    "name": "Study_20_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\n    \"\"\"\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))",
    "sols": [
      "def sol():\n    return [1, 3, 4, 12, 13, 14, 42, 126, 127]"
    ],
    "module": "study"
  },
  {
    "name": "Study_21_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Find a list integers containing exactly three distinct values, such that no integer repeats\n    twice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)\n    \"\"\"\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3",
    "sols": [
      "def sol():\n    return list(range(3)) * 10"
    ],
    "module": "study"
  },
  {
    "name": "Study_22_0",
    "sat": "def sat(s: str):\n    \"\"\"\n    Find a string s containing exactly five distinct characters which also contains as a substring every other\n    character of s (e.g., if the string s were 'parrotfish' every other character would be 'profs').\n    \"\"\"\n    return s[::2] in s and len(set(s)) == 5",
    "sols": [
      "def sol():\n    return \"\"\"abacadaeaaaaaaaaaa\"\"\""
    ],
    "module": "study"
  },
  {
    "name": "Study_23_0",
    "sat": "def sat(ls: List[str]):\n    \"\"\"\n    Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.\n    \"\"\"\n    return tuple(ls) in zip('dee', 'doo', 'dah!')",
    "sols": [
      "def sol():\n    return list(next(zip('dee', 'doo', 'dah!')))"
    ],
    "module": "study"
  },
  {
    "name": "Study_24_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three.\"\"\"\n    return li.count(17) == 3 and li.count(3) >= 2",
    "sols": [
      "def sol():\n    return [17] * 3 + [3] * 2"
    ],
    "module": "study"
  },
  {
    "name": "Study_25_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a permutation of the string 'Permute me true' which is a palindrome.\"\"\"\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]",
    "sols": [
      "def sol():\n    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])"
    ],
    "module": "study"
  },
  {
    "name": "Study_26_0",
    "sat": "def sat(ls: List[str]):\n    \"\"\"Divide the decimal representation of 8^88 up into strings of length eight.\"\"\"\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)",
    "sols": [
      "def sol():\n    return [str(8 ** 88)[i:i + 8] for i in range(0, len(str(8 ** 88)), 8)]"
    ],
    "module": "study"
  },
  {
    "name": "Study_27_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\n    v the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\n    share the same great-grandchildren. Represented this digraph by the list of children indices.\n    \"\"\"\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]",
    "sols": [
      "def sol():\n    return [1, 2, 3, 3]"
    ],
    "module": "study"
  },
  {
    "name": "Study_28_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"Find a list of one hundred integers between 0 and 999 which all differ by at least ten from one another.\"\"\"\n    return all(i in range(1000) and abs(i - j) >= 10 for i in li for j in li if i != j) and len(set(li)) == 100",
    "sols": [
      "def sol():\n    return list(range(0, 1000, 10))"
    ],
    "module": "study"
  },
  {
    "name": "Study_29_0",
    "sat": "def sat(l: List[int]):\n    \"\"\"\n    Find a list of more than 995 distinct integers between 0 and 999, inclusive, such that each pair of integers\n    have squares that differ by at least 10.\n    \"\"\"\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j) and len(set(l)) > 995",
    "sols": [
      "def sol():\n    return [0, 4] + list(range(6, 1000))"
    ],
    "module": "study"
  },
  {
    "name": "Study_30_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one\n    are between 0 and 999, inclusive, and are strictly increasing in terms of f(n).\n    \"\"\"\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])",
    "sols": [
      "def sol():\n    return sorted(range(1000), key=lambda n: 123 * n % 1000)[:21]",
      "def sol():\n    return list(range(1000))[::8][::-1]"
    ],
    "module": "study"
  },
  {
    "name": "TowersOfHanoi_0",
    "sat": "def sat(moves: List[List[int]]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Eight disks of sizes 1-8 are stacked on three towers, with each tower having disks in order of largest to\n    smallest. Move [i, j] corresponds to taking the smallest disk off tower i and putting it on tower j, and it\n    is legal as long as the towers remain in sorted order. Find a sequence of moves that moves all the disks\n    from the first to last towers.\n    \"\"\"\n    rods = ([8, 7, 6, 5, 4, 3, 2, 1], [], [])\n    for [i, j] in moves:\n        rods[j].append(rods[i].pop())\n        assert rods[j][-1] == min(rods[j]), \"larger disk on top of smaller disk\"\n    return rods[0] == rods[1] == []",
    "sols": [
      "def sol():\n    def helper(m, i, j):\n        if m == 0:\n            return []\n        k = 3 - i - j\n        return helper(m - 1, i, k) + [[i, j]] + helper(m - 1, k, j)\n\n    return helper(8, 0, 2)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_0",
    "sat": "def sat(moves: List[List[int]], source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_1",
    "sat": "def sat(moves: List[List[int]], source=[[0, 1, 2], [3], [4]], target=[[], [0, 1], [2, 3, 4]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[0, 1, 2], [3], [4]], target=[[], [0, 1], [2, 3, 4]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_2",
    "sat": "def sat(moves: List[List[int]], source=[[], [1, 4, 5, 6], [0, 2, 3]], target=[[0, 2, 3, 4, 5], [6], [1]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[], [1, 4, 5, 6], [0, 2, 3]], target=[[0, 2, 3, 4, 5], [6], [1]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_3",
    "sat": "def sat(moves: List[List[int]], source=[[2], [1, 5], [0, 3, 4]], target=[[3, 4], [0, 5], [1, 2]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[2], [1, 5], [0, 3, 4]], target=[[3, 4], [0, 5], [1, 2]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_4",
    "sat": "def sat(moves: List[List[int]], source=[[2, 12], [0, 7, 8, 11], [1, 3, 4, 5, 6, 9, 10]], target=[[2, 10, 12], [1, 5, 6, 7, 8, 9, 11], [0, 3, 4]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[2, 12], [0, 7, 8, 11], [1, 3, 4, 5, 6, 9, 10]], target=[[2, 10, 12], [1, 5, 6, 7, 8, 9, 11], [0, 3, 4]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_5",
    "sat": "def sat(moves: List[List[int]], source=[[1, 3, 5, 7, 9], [0, 2, 6, 10, 11], [4, 8, 12]], target=[[1, 2, 10, 11], [3, 4, 5, 12], [0, 6, 7, 8, 9]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[1, 3, 5, 7, 9], [0, 2, 6, 10, 11], [4, 8, 12]], target=[[1, 2, 10, 11], [3, 4, 5, 12], [0, 6, 7, 8, 9]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_6",
    "sat": "def sat(moves: List[List[int]], source=[[1, 3, 5], [0, 4], [2]], target=[[0, 4], [], [1, 2, 3, 5]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[1, 3, 5], [0, 4], [2]], target=[[0, 4], [], [1, 2, 3, 5]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_7",
    "sat": "def sat(moves: List[List[int]], source=[[3, 4, 5, 10], [1, 7, 8, 9, 12], [0, 2, 6, 11]], target=[[6], [1, 2, 3, 5, 9, 12], [0, 4, 7, 8, 10, 11]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[3, 4, 5, 10], [1, 7, 8, 9, 12], [0, 2, 6, 11]], target=[[6], [1, 2, 3, 5, 9, 12], [0, 4, 7, 8, 10, 11]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_8",
    "sat": "def sat(moves: List[List[int]], source=[[0, 1, 3, 5, 8], [6], [2, 4, 7]], target=[[3, 6], [0, 4], [1, 2, 5, 7, 8]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[0, 1, 3, 5, 8], [6], [2, 4, 7]], target=[[3, 6], [0, 4], [1, 2, 5, 7, 8]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "TowersOfHanoiArbitrary_9",
    "sat": "def sat(moves: List[List[int]], source=[[4, 6, 8, 9, 10, 13], [0, 1, 2, 5], [3, 7, 11, 12]], target=[[0, 1, 3, 4, 5], [7, 11, 12], [2, 6, 8, 9, 10, 13]]):\n    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[4, 6, 8, 9, 10, 13], [0, 1, 2, 5], [3, 7, 11, 12]], target=[[0, 1, 3, 4, 5], [7, 11, 12], [2, 6, 8, 9, 10, 13]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_0",
    "sat": "def sat(x: List[int], length=13, s=\"Dynamic programming solves this puzzle!!!\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=13, s=\"Dynamic programming solves this puzzle!!!\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_1",
    "sat": "def sat(x: List[int], length=23, s=\"h%&tb--524578Q@ABJGIM8)[E];^_]ajjw$jN\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=23, s=\"h%&tb--524578Q@ABJGIM8)[E];^_]ajjw$jN\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_2",
    "sat": "def sat(x: List[int], length=407, s=\"  0!!!i!!\\\"\\\"\\\"^##$$$&$$$%$%%%%%%&Y&&&''((((())))))6)**)++,---t--....////0000111q112333r344444444555555O55j66677J77777788889999@:::;;;$;;;<<<j<==>>>>f>>????@@@AAABBBBCCCCCCDDDDDDDDEEFFFFFFFFGGHIHHHHIzHIJJJ)JKKKLLMMMMMNN?NNNNO7OOOOOPPPQQQRRYSSTTTTUUUUUUUUUUVVWWWWWXXXYYYYZ[[[[D\\\\\\\\\\\\\\\\\\\\]]]]]]^^^^^^____1___```aaabbbbbcccFcXccdddddeheeeffffggggggqggggghhiOiijujjjkkkkkklllllmmmmmmmmmnnnoooooooroopppq$qqqqqqrrrr(rGrrXsssstttuuvvvvvvvvvvvwwxxxyyyzzzzGz{{{{\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=407, s=\"  0!!!i!!\\\"\\\"\\\"^##$$$&$$$%$%%%%%%&Y&&&''((((())))))6)**)++,---t--....////0000111q112333r344444444555555O55j66677J77777788889999@:::;;;$;;;<<<j<==>>>>f>>????@@@AAABBBBCCCCCCDDDDDDDDEEFFFFFFFFGGHIHHHHIzHIJJJ)JKKKLLMMMMMNN?NNNNO7OOOOOPPPQQQRRYSSTTTTUUUUUUUUUUVVWWWWWXXXYYYYZ[[[[D\\\\\\\\\\\\\\\\\\\\]]]]]]^^^^^^____1___```aaabbbbbcccFcXccdddddeheeeffffggggggqggggghhiOiijujjjkkkkkklllllmmmmmmmmmnnnoooooooroopppq$qqqqqqrrrr(rGrrXsssstttuuvvvvvvvvvvvwwxxxyyyzzzzGz{{{{\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_3",
    "sat": "def sat(x: List[int], length=28, s=\"%-(o./<)_345!Ll6bki=_mC%LuLQV:WWo\\\\\\\\P\\\\-T,!`fg%gklEkUpmqJqtt8$y$;U\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=28, s=\"%-(o./<)_345!Ll6bki=_mC%LuLQV:WWo\\\\\\\\P\\\\-T,!`fg%gklEkUpmqJqtt8$y$;U\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_4",
    "sat": "def sat(x: List[int], length=0, s=\"%\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=0, s=\"%\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_5",
    "sat": "def sat(x: List[int], length=1, s=\":kau \"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=1, s=\":kau \"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_6",
    "sat": "def sat(x: List[int], length=29, s=\"n%&A*O.sH7e44R:<f=u?h?ASKM2x)KiKMOyOr?tPB&6jRS0jXGY0c]@[_MlnrYv[XHwCVlYpM\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=29, s=\"n%&A*O.sH7e44R:<f=u?h?ASKM2x)KiKMOyOr?tPB&6jRS0jXGY0c]@[_MlnrYv[XHwCVlYpM\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_7",
    "sat": "def sat(x: List[int], length=5, s=\"c3\\\\\\\\Xd{l\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=5, s=\"c3\\\\\\\\Xd{l\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_8",
    "sat": "def sat(x: List[int], length=3, s=\"C3r>ry_B\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=3, s=\"C3r>ry_B\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstring_9",
    "sat": "def sat(x: List[int], length=665, s=\"      \\\\  &!!!!!!!!!!!J!\\\"\\\"\\\"\\\"\\\"\\\"\\\"########j$$$f!Q$$$$$$%%%&&&&&'D''''''='(((((((((*))))cx))))*K>*+'+++,,o,H,,,,,,E,,,--M-........./////VHm//00=0000000n111111{1x122222U2222333333333444444444445555o556666x666667777777788888T09999999999::::::::E:::;;;;;g<<=====C===>>6>>>>>???????@@@@@@@@A\\\"AAAAAABBBBwCCJCCCCCCDDDDDDDDEEEFFFFFFFGGGG=HHHHwHHHII5II'IJJJJJJJ%KKKKKKKKL8LLLLLLLMMMMMMMNNNNNOOOOOOOOOOPPPPPQQQQQQQbQRR3gRRRRSSSSSSSSSSTTTXTXTUUUUUUUnUUVVVVVVVVVVVWWWWWWWXXXXXXGXX(YYYYY{YZZZZZZZ[[[\\\\\\\\\\\\\\\\\\\\\\\\\\\\]]]]]^^^^^c^#__.)________````aaaa;abbbbbbbbbbbbcccccdddddddddddd9deeeeeefffffggggggggggNghhnhhhhiiiiiiiii:jjjjjjjajjkkkkkk6kllllllmmmmmmnnnnnnnooooooo{p)Apppp<ppppqq@qqqqqqrrrrrrssssssttttttuuuuuuuuvvvvvyvvvvvvwwwwwwwwxxxIxxxxxx;yysSyyyysVyzzzzz+zz{{{{{\"):\n    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "sols": [
      "def sol(length=665, s=\"      \\\\  &!!!!!!!!!!!J!\\\"\\\"\\\"\\\"\\\"\\\"\\\"########j$$$f!Q$$$$$$%%%&&&&&'D''''''='(((((((((*))))cx))))*K>*+'+++,,o,H,,,,,,E,,,--M-........./////VHm//00=0000000n111111{1x122222U2222333333333444444444445555o556666x666667777777788888T09999999999::::::::E:::;;;;;g<<=====C===>>6>>>>>???????@@@@@@@@A\\\"AAAAAABBBBwCCJCCCCCCDDDDDDDDEEEFFFFFFFGGGG=HHHHwHHHII5II'IJJJJJJJ%KKKKKKKKL8LLLLLLLMMMMMMMNNNNNOOOOOOOOOOPPPPPQQQQQQQbQRR3gRRRRSSSSSSSSSSTTTXTXTUUUUUUUnUUVVVVVVVVVVVWWWWWWWXXXXXXGXX(YYYYY{YZZZZZZZ[[[\\\\\\\\\\\\\\\\\\\\\\\\\\\\]]]]]^^^^^c^#__.)________````aaaa;abbbbbbbbbbbbcccccdddddddddddd9deeeeeefffffggggggggggNghhnhhhhiiiiiiiii:jjjjjjjajjkkkkkk6kllllllmmmmmmnnnnnnnooooooo{p)Apppp<ppppqq@qqqqqqrrrrrrssssssttttttuuuuuuuuvvvvvyvvvvvvwwwwwwwwxxxIxxxxxx;yysSyyyysVyzzzzz+zz{{{{{\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_0",
    "sat": "def sat(x: List[int], length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_1",
    "sat": "def sat(x: List[int], length=0, s=\"Vo32t5-Gr\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=0, s=\"Vo32t5-Gr\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_2",
    "sat": "def sat(x: List[int], length=22, s=\"CDTFteM%kelopd#qz{'(^>o(%+2389:B\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=22, s=\"CDTFteM%kelopd#qz{'(^>o(%+2389:B\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_3",
    "sat": "def sat(x: List[int], length=1, s=\"WQWule]\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=1, s=\"WQWule]\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_4",
    "sat": "def sat(x: List[int], length=0, s=\"NolL\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=0, s=\"NolL\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_5",
    "sat": "def sat(x: List[int], length=49, s=\"?!PJZ\\\"KK0\\\"QVYd%&'Za(y*\\\\]#]_Fcd(*l]nefk=*7.Llpyp.023q5p6]u7wx@n<2>yHa@{FrID3@Q+IBJ\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=49, s=\"?!PJZ\\\"KK0\\\"QVYd%&'Za(y*\\\\]#]_Fcd(*l]nefk=*7.Llpyp.023q5p6]u7wx@n<2>yHa@{FrID3@Q+IBJ\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_6",
    "sat": "def sat(x: List[int], length=20, s=\" %9<.yG\\\"-;t:Fl&b.z3@hJDhU14ky!9:Wb\\\\1sLT0f:0J+fxu;ldR.np\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=20, s=\" %9<.yG\\\"-;t:Fl&b.z3@hJDhU14ky!9:Wb\\\\1sLT0f:0J+fxu;ldR.np\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_7",
    "sat": "def sat(x: List[int], length=5, s=\"w'.xMN0z\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=5, s=\"w'.xMN0z\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_8",
    "sat": "def sat(x: List[int], length=23, s=\"!MOZ_e`;&bg)+XNT d,+-<dmun=uJA@nGuxI\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=23, s=\"!MOZ_e`;&bg)+XNT d,+-<dmun=uJA@nGuxI\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "LongestMonotonicSubstringTricky_9",
    "sat": "def sat(x: List[int], length=292, s=\"wOM1GM #N=^ygY.?,NO G hUX q!fP!PvQ*YkApzbBz;!4\\\",W/rtb#P#PS@H`fQ#na#Ni#7X=R%$Bvr$$:Rsi%2RRDzhRTRi%>,%&cSx&r>bS&d&-gjA0jLdS3sT&J&UzUW:UU&1'U'('J;(w^(V3aL77(j3WKWGQXX(8cfpsX)DX7?=YfI\\\"f)OY))a*YgxV+#ZZZea+[+[T-[[B[-Y?c9qh>-\\\\F\\\\5vSA\\\\0\\\\-\\\\gCS<;]Q-0]:edao.\\\"u9.q]f/`:/D/(Z/]#)C0^^0_<m1Kv_M4uW@%z<Y1*8_Xe1cp1s_nkPUK_``^(a15XSL(ahYv1heZ.agqbIW<61NtT?b9bc2c8cq)A#V2Z3Tg+4?&SEdddQ5ew*55kY9]MY5>P[K5c6fm:g9flID.ff6ggggX%gg6;Blhh7h74ijha1j7^8jH9[2G69`:kj-.kwkLk*l7m*ll!:.lXm:PQj<m:%/Tm7nnnopG;W>op\\\\;A'Gq[qc)4#q6-?q;'kql)<oQBVyrrrra%Wnsgs$tJ5<t8tD?OuS6<<H)a/=CSu==u=A\\\\>1G?uu?{u33h?Wqhbewu*@WzCv@vBvJ0Wvwx.Xxxx`y@@yfJyA-v+y+a0z4ts;k1z*mA_#Azb'Ip1qVx,+SyRxz9mIoB2G3(Bzz{BR{s6{BW@B\\\"C.ClgmqDmobVDfEEEEN EEEF]_:/zF7DF+FH]fV2OI2I>Ib IbIFJHJ/#J\\\\r[JuJ<Jr1\\\\u&+!J?J45DBJ0LH*sJTgy7KKKULLCLMQD\"):\n    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "sols": [
      "def sol(length=292, s=\"wOM1GM #N=^ygY.?,NO G hUX q!fP!PvQ*YkApzbBz;!4\\\",W/rtb#P#PS@H`fQ#na#Ni#7X=R%$Bvr$$:Rsi%2RRDzhRTRi%>,%&cSx&r>bS&d&-gjA0jLdS3sT&J&UzUW:UU&1'U'('J;(w^(V3aL77(j3WKWGQXX(8cfpsX)DX7?=YfI\\\"f)OY))a*YgxV+#ZZZea+[+[T-[[B[-Y?c9qh>-\\\\F\\\\5vSA\\\\0\\\\-\\\\gCS<;]Q-0]:edao.\\\"u9.q]f/`:/D/(Z/]#)C0^^0_<m1Kv_M4uW@%z<Y1*8_Xe1cp1s_nkPUK_``^(a15XSL(ahYv1heZ.agqbIW<61NtT?b9bc2c8cq)A#V2Z3Tg+4?&SEdddQ5ew*55kY9]MY5>P[K5c6fm:g9flID.ff6ggggX%gg6;Blhh7h74ijha1j7^8jH9[2G69`:kj-.kwkLk*l7m*ll!:.lXm:PQj<m:%/Tm7nnnopG;W>op\\\\;A'Gq[qc)4#q6-?q;'kql)<oQBVyrrrra%Wnsgs$tJ5<t8tD?OuS6<<H)a/=CSu==u=A\\\\>1G?uu?{u33h?Wqhbewu*@WzCv@vBvJ0Wvwx.Xxxx`y@@yfJyA-v+y+a0z4ts;k1z*mA_#Azb'Ip1qVx,+SyRxz9mIoB2G3(Bzz{BR{s6{BW@B\\\"C.ClgmqDmobVDfEEEEN EEEF]_:/zF7DF+FH]fV2OI2I>Ib IbIFJHJ/#J\\\\r[JuJ<Jr1\\\\u&+!J?J45DBJ0LH*sJTgy7KKKULLCLMQD\"):  # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "Quine_0",
    "sat": "def sat(quine: str):\n    \"\"\"Find a string that when evaluated as a Python expression is that string itself.\"\"\"\n    return eval(quine) == quine",
    "sols": [
      "def sol():\n    return \"(lambda x: f'({x})({chr(34)}{x}{chr(34)})')(\\\"lambda x: f'({x})({chr(34)}{x}{chr(34)})'\\\")\"",
      "def sol():  # thanks for this simple solution, GPT-3!\n    return 'quine'"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "RevQuine_0",
    "sat": "def sat(rev_quine: str):\n    \"\"\"Find a string that, when reversed and evaluated gives you back that same string.\"\"\"\n    return eval(rev_quine[::-1]) == rev_quine",
    "sols": [
      "def sol():\n    return \"rev_quine\"[::-1]  # thanks GPT-3!"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_0",
    "sat": "def sat(colors: List[int], n=100):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=100):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_1",
    "sat": "def sat(colors: List[int], n=7824):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_2",
    "sat": "def sat(colors: List[int], n=0):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=0):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_3",
    "sat": "def sat(colors: List[int], n=1):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=1):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_4",
    "sat": "def sat(colors: List[int], n=2):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=2):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_5",
    "sat": "def sat(colors: List[int], n=3):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=3):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_6",
    "sat": "def sat(colors: List[int], n=4):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=4):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_7",
    "sat": "def sat(colors: List[int], n=5):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=5):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_8",
    "sat": "def sat(colors: List[int], n=6):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=6):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "BooleanPythagoreanTriples_9",
    "sat": "def sat(colors: List[int], n=7):\n    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=7):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_0",
    "sat": "def sat(hands: List[int], target_angle=45):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=45):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_1",
    "sat": "def sat(hands: List[int], target_angle=30):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=30):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_2",
    "sat": "def sat(hands: List[int], target_angle=19):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=19):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_3",
    "sat": "def sat(hands: List[int], target_angle=8):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=8):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_4",
    "sat": "def sat(hands: List[int], target_angle=357):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=357):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_5",
    "sat": "def sat(hands: List[int], target_angle=346):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=346):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_6",
    "sat": "def sat(hands: List[int], target_angle=335):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=335):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_7",
    "sat": "def sat(hands: List[int], target_angle=324):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=324):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_8",
    "sat": "def sat(hands: List[int], target_angle=313):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=313):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "ClockAngle_9",
    "sat": "def sat(hands: List[int], target_angle=302):\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    hour, min = hands\n    return 0 < hour <= 12 and 0 <= min < 60 and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=302):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "Kirkman_0",
    "sat": "def sat(daygroups: List[List[List[int]]]):\n    \"\"\"\n    Arrange 15 people into groups of 3 each day for seven days so that no two people are in the same group twice.\n    \"\"\"\n    assert len(daygroups) == 7\n    assert all(len(groups) == 5 and {i for g in groups for i in g} == set(range(15)) for groups in daygroups)\n    assert all(len(g) == 3 for groups in daygroups for g in groups)\n    return len({(i, j) for groups in daygroups for g in groups for i in g for j in g}) == 15 * 15",
    "sols": [
      "def sol():\n    from itertools import combinations\n    import random\n    rand = random.Random(0)\n    days = [[list(range(15)) for _2 in range(2)] for _ in range(7)]  # each day is pi, inv\n    counts = {(i, j): (7 if j in range(k, k + 3) else 0)\n              for k in range(0, 15, 3)\n              for i in range(k, k + 3)\n              for j in range(15) if j != i\n              }\n\n    todos = [pair for pair, count in counts.items() if count == 0]\n    while True:\n        pair = rand.choice(todos)  # choose i and j to make next to each other on some day\n        if rand.randrange(2):\n            pair = pair[::-1]\n\n        a, u = pair\n        pi, inv = rand.choice(days)\n        assert pi[inv[a]] == a and pi[inv[u]] == u\n        bases = [3 * (inv[i] // 3) for i in pair]\n        (b, c), (v, w) = [[x for x in pi[b: b + 3] if x != i] for i, b in zip(pair, bases)]\n        if rand.randrange(2):\n            b, c, = c, b\n        # current (a, b, c) (u, v, w). consider swap of u with b to make (a, u, c) (b, v, w)\n\n        new_pairs = [(a, u), (c, u), (b, v), (b, w)]\n        old_pairs = [(u, v), (u, w), (b, a), (b, c)]\n        gained = sum(counts[p] == 0 for p in new_pairs)\n        lost = sum(counts[p] == 1 for p in old_pairs)\n        if rand.random() <= 100 ** (gained - lost):\n            for p in new_pairs:\n                counts[p] += 1\n                counts[p[::-1]] += 1\n            for p in old_pairs:\n                counts[p] -= 1\n                counts[p[::-1]] -= 1\n            pi[inv[b]], pi[inv[u]], inv[b], inv[u] = u, b, inv[u], inv[b]\n            todos = [pair for pair, count in counts.items() if count == 0]\n            if len(todos) == 0:\n                return [[pi[k:k + 3] for k in range(0, 15, 3)] for pi, _inv in days]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "MonkeyAndCoconuts_0",
    "sat": "def sat(n: int):\n    \"\"\"\n    Find the number of coconuts to solve the following riddle:\n        There is a pile of coconuts, owned by five men. One man divides the pile into five equal piles, giving the\n        one left over coconut to a passing monkey, and takes away his own share. The second man then repeats the\n        procedure, dividing the remaining pile into five and taking away his share, as do the third, fourth, and\n        fifth, each of them finding one coconut left over when dividing the pile by five, and giving it to a monkey.\n        Finally, the group divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n        How many coconuts were there in the original pile?\n                                          Quoted from https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts\n    \"\"\"\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1",
    "sols": [
      "def sol():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_0",
    "sat": "def sat(coords: List[List[int]], side=10, num_points=20):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=10, num_points=20):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_1",
    "sat": "def sat(coords: List[List[int]], side=0, num_points=0):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=0, num_points=0):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_2",
    "sat": "def sat(coords: List[List[int]], side=1, num_points=1):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=1, num_points=1):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_3",
    "sat": "def sat(coords: List[List[int]], side=2, num_points=4):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=2, num_points=4):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_4",
    "sat": "def sat(coords: List[List[int]], side=3, num_points=6):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=3, num_points=6):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_5",
    "sat": "def sat(coords: List[List[int]], side=4, num_points=8):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=4, num_points=8):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_6",
    "sat": "def sat(coords: List[List[int]], side=5, num_points=10):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_7",
    "sat": "def sat(coords: List[List[int]], side=6, num_points=12):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_8",
    "sat": "def sat(coords: List[List[int]], side=7, num_points=14):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [],
    "module": "classic_puzzles"
  },
  {
    "name": "No3Colinear_9",
    "sat": "def sat(coords: List[List[int]], side=8, num_points=16):\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_0",
    "sat": "def sat(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=80, max_stamps=4, options=[10, 32, 8]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_1",
    "sat": "def sat(stamps: List[int], target=194, max_stamps=5, options=[57, 25, 19, 65, 83, 72, 14, 38]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=194, max_stamps=5, options=[57, 25, 19, 65, 83, 72, 14, 38]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_2",
    "sat": "def sat(stamps: List[int], target=99, max_stamps=5, options=[3, 32, 82, 72]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=99, max_stamps=5, options=[3, 32, 82, 72]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_3",
    "sat": "def sat(stamps: List[int], target=131, max_stamps=5, options=[45, 86, 49]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=131, max_stamps=5, options=[45, 86, 49]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_4",
    "sat": "def sat(stamps: List[int], target=295, max_stamps=7, options=[98, 25, 99, 59]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=295, max_stamps=7, options=[98, 25, 99, 59]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_5",
    "sat": "def sat(stamps: List[int], target=37, max_stamps=2, options=[80, 37, 41, 46, 71, 43]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=37, max_stamps=2, options=[80, 37, 41, 46, 71, 43]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_6",
    "sat": "def sat(stamps: List[int], target=19, max_stamps=1, options=[19]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=19, max_stamps=1, options=[19]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_7",
    "sat": "def sat(stamps: List[int], target=66, max_stamps=6, options=[98, 83, 57, 12, 44, 8, 58]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=66, max_stamps=6, options=[98, 83, 57, 12, 44, 8, 58]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_8",
    "sat": "def sat(stamps: List[int], target=48, max_stamps=9, options=[6]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=48, max_stamps=9, options=[6]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PostageStamp_9",
    "sat": "def sat(stamps: List[int], target=124, max_stamps=7, options=[37, 63, 49, 25, 69, 99, 87, 23]):\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=124, max_stamps=7, options=[37, 63, 49, 25, 69, 99, 87, 23]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SquaringTheSquare_0",
    "sat": "def sat(xy_sides: List[List[int]]):  # List of (x, y, side)\n    \"\"\"\n    Partition a square into smaller squares with unique side lengths. A perfect squared path has distinct sides.\n    \"\"\"\n    n = max(x + side for x, y, side in xy_sides)\n    assert len({side for x, y, side in xy_sides}) == len(xy_sides) > 1\n    for x, y, s in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for x2, y2, s2 in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or y2 >= y + s or y2 + s2 <= y\n\n    return sum(side ** 2 for x, y, side in xy_sides) == n ** 2",
    "sols": [
      "def sol():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_0",
    "sat": "def sat(n: int, lace=\"bbbbrrbrbrbbrrrr\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"bbbbrrbrbrbbrrrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_1",
    "sat": "def sat(n: int, lace=\"bbrrbbrbbbrbbrbrbbbrbbrbbbbrrbrbrrrbrrrrbrbbbbbrbbrrrbbrbrbrrbbbrrbbrbrbrbrbbbbrrbbbbbbbrrrrrrrrbbrrbbbbrrbbrbrrrbbbrrrbrbbrrbrbrrbbbrrbbrbrrrrrrrrbbbbrrbrrbbrrrrrrbrrrrbbrrbrrrbrbrbrrbbrbrbbbrrbrbrrbrrrrbbbbbbbbbrrrbbrbbrrr\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"bbrrbbrbbbrbbrbrbbbrbbrbbbbrrbrbrrrbrrrrbrbbbbbrbbrrrbbrbrbrrbbbrrbbrbrbrbrbbbbrrbbbbbbbrrrrrrrrbbrrbbbbrrbbrbrrrbbbrrrbrbbrrbrbrrbbbrrbbrbrrrrrrrrbbbbrrbrrbbrrrrrrbrrrrbbrrbrrrbrbrbrrbbrbrbbbrrbrbrrbrrrrbbbbbbbbbrrrbbrbbrrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_2",
    "sat": "def sat(n: int, lace=\"rrrrbrbrbbbrbbrrrbbrrrrrrbbbrrbrbbrrbbrbbbbbrrbbbrbbrrbbrbrbrbbrbrbrrrrrbbbrrbbbbrrbbbbbrrrrbrrrbrbrrrrbrrrrrbbrbrbrbrbrrrrrrbbrrrrbrbbbbbbbrbrbrbrbrbrrbrbbrbbrrbrrrbrbbbrbbbbrbrbbbbbrbrrrrrbbrbrbrbrbrbrbbrrbrbbbrrbbrrbbrbbbrbrrrbrbrbbrbbbbrbrrbbbbrbbrrrrbbbbbrrrrrbrrbrrrrbrbrrrbbrbrbbbrrbrrbbrrbbbrbbrr\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rrrrbrbrbbbrbbrrrbbrrrrrrbbbrrbrbbrrbbrbbbbbrrbbbrbbrrbbrbrbrbbrbrbrrrrrbbbrrbbbbrrbbbbbrrrrbrrrbrbrrrrbrrrrrbbrbrbrbrbrrrrrrbbrrrrbrbbbbbbbrbrbrbrbrbrrbrbbrbbrrbrrrbrbbbrbbbbrbrbbbbbrbrrrrrbbrbrbrbrbrbrbbrrbrbbbrrbbrrbbrbbbrbrrrbrbrbbrbbbbrbrrbbbbrbbrrrrbbbbbrrrrrbrrbrrrrbrbrrrbbrbrbbbrrbrrbbrrbbbrbbrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_3",
    "sat": "def sat(n: int, lace=\"bbbrbrrbbrrbrrrb\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"bbbrbrrbbrrbrrrb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_4",
    "sat": "def sat(n: int, lace=\"rbbrrrrrbbrrbbbbrrbbbbrbrbbbrbrrrrrb\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rbbrrrrrbbrrbbbbrrbbbbrbrbbbrbrrrrrb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_5",
    "sat": "def sat(n: int, lace=\"rrrbrrrbrbbbrrbbbbbbrrbrrrbbbrbrbbrrbrrrrrbbrbrbrrbbrbrbrrbbrrbbrrbbbbrrbbrrrrbbrrrbrrrrbrrbrrbbbrrrrbbbrrrrbrrbbbbrbbbrrrbbbbbbrbbbbrrbrbrbbbbrbrrrbrrrrbbrrrbbbbrbrbbbrrbrrrbbbrrrrrrbbrrbrrrrbrbrbrbrrrbrrbbbbbbrrrrrbrbbrbrbrbrrrbrbrbrbrrrrbrbrrrrbrrbrrrbrrbbbrrrrbrrrbbbrbbrrbbbbbbrbrrrrbrrrrrbbrbbbbbrrbrbrrbrbbbbbbbrrbrrrbrrbbbrbbbrbbbbbrrrrbrrrbbrbbbrbrbrrrrbrbrbrbrbbrrrbrbbbbrrrbrrrrbbbrbrrbrbbrrrrrbbbbrbbbrrrbrrrrbrbrrrrbrrrbbbrrrrrbrrbrbrrbbbrrbrbbrbrrrbbrbrbrbrbbrbrbrrbbrbrbrrrrbbbrrrbbbrrbbrrbrrbrrrrbrbrbbrbbbrrrrrrrbbrrrrrrrbbrrrrrbbbrbrrrbrbrbrrrbbrrrbbbbbbbbrrrrbbbbrbbrbbbrbrrrbbbrrbbbbbbbrrrbrrrrbbrrbbbbbbrbrbrbbrrbrbbrrbrbrrbrbrrrbrbbrrrbrbbbrbrbrbrbrrrrbbbrrrrrbrrbbbbbbrbbbrrrrrrbbrbrrrbbrbrbbbrrrbrrrbbbrrrbrrbbrbrrbrrrrbrrrbbbrrbrbbrbrrbbbbbrbbrbbbrrbbrbbrrbbbbrrbbrbbrrbbrbrrrbbrbbbbbrbrbbrrrrbbbrbbrbrrbbbbbbrrbbbrrrrbbbbrbbbrrrrrrrbrbrbbbbbbrrbbrbbrbbrbbbbbbrbbbbrbbrrrrrbrbrbrbbbrbbrbrrrrbbrbrbbrbbbrbbrrbrbrbbbbbbbrbbrrbrbrbrbbrbrrbrrrrbbbbbrbrbrbbrbrbrrbbrbrrbrrrrbbrbrrbrrbrbbrbbrbbrbbbrrrbbrbrbbrrbbrrrrrbbrbrrbrbrbrrrbrbbbbrbbbbbrrbrbbbbbbrrbbbbrrbbbbbrbrbbbrrrbrbrbrbrbbbrbrbrrrrbrrrbbrrrbbrrbbrrbbrrrbrrrrrbbrrbbbrbbrbbrbrrbbrbrrrrrbbrbbbbbrbbbrbrrrbrbbrrrbbbbbrbrrbbrbbbbbrbrbrrrbrrrbrrrrbbbbrbbbrbbrbrbrrbbbbbrrbrrbbrbbrrrbbrrrrbrrbbbrrbbrbrrbbrrrbbbbrrbrbrbbrbbrbrbbbrrrrrbbbrrrbrbrbrbbbrrrrbbbrbbrrbrrrrbrbbrrrbrbbrbrrrrrbbrrrbbrbrbbbrrbbrrbrrbbbrbbbrbbbrrrbbrrbrrrbrbrbrrrbrrbbrbrrrrrrbbrrbbbrbbbrrrrbrrrbbrbrbbrrbrbrbbrbrbrrrrrbbbrbbbbbbbbrrrrbbrrrrrrbrrbrrbbrrbbrrrbrbbrbrbbrrrrrrbrrbrrrrrrrbrbrbrrbbrrrbrrbbbbbrrrrbrbrrrrrbbbbrbrrbbrrbrrbrbrbbbbbrrrbrbrbbbrbbbbrbbbrrbbbrbrbbbrrrbrbbrrbbbrrrrbbbbbrbbrbbbbbrrbrbbrbbbbbbbbbbbrbbbbrrbbrrrbbbrrbrbbrrbbrbrrbbrrbbrbbbbbrbrrrrrbrrrrrbbbrbrrbbbbrbrrrbrbbbrbbrbbbrrrrbrbrbrrbbrrrrbrbbrrbrbbrrrbrbbbrbbrrrbrrrrrbbrbbbbrrrbbrrbbrbrrbrbbrbrrrrrbbrrbbbrbrrrrbbbrrbbbrbrbbrrrrrbrbbrrrrrbrbrbrrbrbrbbrrbrbbrrrbbrbrrbbrrrbrrrbbbbrbbrrbbbrrbrbbrbbbbrbrbrbbrbbbbbrbrrrbbbbbrbbbrbbbbrbrbrbrbrrbrrrbrrbrbbbrrbbrbrbbrrrrrbbbrbbrbbrbbbrbbbbbrbrrbbrrbrbbbbbrrrbrrbbbrrrrbrbrbrrbbbbrrbbrrbrrbbrbbbrrrbrrbbrbrrrrrrrrbbbbbbrrbbbrbrbbrrrrbrrbbbrrrbbrrbrbbrrrbrbbbbbrrrrbbbrbbbbbbbrrbrbrrrrbbbrbrrbrrbrbbbbbbbrrbbbbbrrbbbbbbrbrrrbrbbbrrrbrbrrrrbrrrrbrrbrrbbbbrbrrrrbrrrrbrrrbrrbbrbrbrrbbbbrrrrrbrbbbbrrbbrbbrrrbrrrrrrbrbbrbrbrbbrbrbbbrrbbbrrrrbbbrrbbbbbbbbbbrrrbrrbrbrrbbrrrbrbbrrrrbrbrrrbrrrbrrbrrbbbbbbbrbrbbrbbrrbrrrbrbrrrrrbbbrrbbbbbrbbbbbrbrrbrrbrrrbrrrbrrrrrbbrrrrrrr\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rrrbrrrbrbbbrrbbbbbbrrbrrrbbbrbrbbrrbrrrrrbbrbrbrrbbrbrbrrbbrrbbrrbbbbrrbbrrrrbbrrrbrrrrbrrbrrbbbrrrrbbbrrrrbrrbbbbrbbbrrrbbbbbbrbbbbrrbrbrbbbbrbrrrbrrrrbbrrrbbbbrbrbbbrrbrrrbbbrrrrrrbbrrbrrrrbrbrbrbrrrbrrbbbbbbrrrrrbrbbrbrbrbrrrbrbrbrbrrrrbrbrrrrbrrbrrrbrrbbbrrrrbrrrbbbrbbrrbbbbbbrbrrrrbrrrrrbbrbbbbbrrbrbrrbrbbbbbbbrrbrrrbrrbbbrbbbrbbbbbrrrrbrrrbbrbbbrbrbrrrrbrbrbrbrbbrrrbrbbbbrrrbrrrrbbbrbrrbrbbrrrrrbbbbrbbbrrrbrrrrbrbrrrrbrrrbbbrrrrrbrrbrbrrbbbrrbrbbrbrrrbbrbrbrbrbbrbrbrrbbrbrbrrrrbbbrrrbbbrrbbrrbrrbrrrrbrbrbbrbbbrrrrrrrbbrrrrrrrbbrrrrrbbbrbrrrbrbrbrrrbbrrrbbbbbbbbrrrrbbbbrbbrbbbrbrrrbbbrrbbbbbbbrrrbrrrrbbrrbbbbbbrbrbrbbrrbrbbrrbrbrrbrbrrrbrbbrrrbrbbbrbrbrbrbrrrrbbbrrrrrbrrbbbbbbrbbbrrrrrrbbrbrrrbbrbrbbbrrrbrrrbbbrrrbrrbbrbrrbrrrrbrrrbbbrrbrbbrbrrbbbbbrbbrbbbrrbbrbbrrbbbbrrbbrbbrrbbrbrrrbbrbbbbbrbrbbrrrrbbbrbbrbrrbbbbbbrrbbbrrrrbbbbrbbbrrrrrrrbrbrbbbbbbrrbbrbbrbbrbbbbbbrbbbbrbbrrrrrbrbrbrbbbrbbrbrrrrbbrbrbbrbbbrbbrrbrbrbbbbbbbrbbrrbrbrbrbbrbrrbrrrrbbbbbrbrbrbbrbrbrrbbrbrrbrrrrbbrbrrbrrbrbbrbbrbbrbbbrrrbbrbrbbrrbbrrrrrbbrbrrbrbrbrrrbrbbbbrbbbbbrrbrbbbbbbrrbbbbrrbbbbbrbrbbbrrrbrbrbrbrbbbrbrbrrrrbrrrbbrrrbbrrbbrrbbrrrbrrrrrbbrrbbbrbbrbbrbrrbbrbrrrrrbbrbbbbbrbbbrbrrrbrbbrrrbbbbbrbrrbbrbbbbbrbrbrrrbrrrbrrrrbbbbrbbbrbbrbrbrrbbbbbrrbrrbbrbbrrrbbrrrrbrrbbbrrbbrbrrbbrrrbbbbrrbrbrbbrbbrbrbbbrrrrrbbbrrrbrbrbrbbbrrrrbbbrbbrrbrrrrbrbbrrrbrbbrbrrrrrbbrrrbbrbrbbbrrbbrrbrrbbbrbbbrbbbrrrbbrrbrrrbrbrbrrrbrrbbrbrrrrrrbbrrbbbrbbbrrrrbrrrbbrbrbbrrbrbrbbrbrbrrrrrbbbrbbbbbbbbrrrrbbrrrrrrbrrbrrbbrrbbrrrbrbbrbrbbrrrrrrbrrbrrrrrrrbrbrbrrbbrrrbrrbbbbbrrrrbrbrrrrrbbbbrbrrbbrrbrrbrbrbbbbbrrrbrbrbbbrbbbbrbbbrrbbbrbrbbbrrrbrbbrrbbbrrrrbbbbbrbbrbbbbbrrbrbbrbbbbbbbbbbbrbbbbrrbbrrrbbbrrbrbbrrbbrbrrbbrrbbrbbbbbrbrrrrrbrrrrrbbbrbrrbbbbrbrrrbrbbbrbbrbbbrrrrbrbrbrrbbrrrrbrbbrrbrbbrrrbrbbbrbbrrrbrrrrrbbrbbbbrrrbbrrbbrbrrbrbbrbrrrrrbbrrbbbrbrrrrbbbrrbbbrbrbbrrrrrbrbbrrrrrbrbrbrrbrbrbbrrbrbbrrrbbrbrrbbrrrbrrrbbbbrbbrrbbbrrbrbbrbbbbrbrbrbbrbbbbbrbrrrbbbbbrbbbrbbbbrbrbrbrbrrbrrrbrrbrbbbrrbbrbrbbrrrrrbbbrbbrbbrbbbrbbbbbrbrrbbrrbrbbbbbrrrbrrbbbrrrrbrbrbrrbbbbrrbbrrbrrbbrbbbrrrbrrbbrbrrrrrrrrbbbbbbrrbbbrbrbbrrrrbrrbbbrrrbbrrbrbbrrrbrbbbbbrrrrbbbrbbbbbbbrrbrbrrrrbbbrbrrbrrbrbbbbbbbrrbbbbbrrbbbbbbrbrrrbrbbbrrrbrbrrrrbrrrrbrrbrrbbbbrbrrrrbrrrrbrrrbrrbbrbrbrrbbbbrrrrrbrbbbbrrbbrbbrrrbrrrrrrbrbbrbrbrbbrbrbbbrrbbbrrrrbbbrrbbbbbbbbbbrrrbrrbrbrrbbrrrbrbbrrrrbrbrrrbrrrbrrbrrbbbbbbbrbrbbrbbrrbrrrbrbrrrrrbbbrrbbbbbrbbbbbrbrrbrrbrrrbrrrbrrrrrbbrrrrrrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_6",
    "sat": "def sat(n: int, lace=\"rbrrrrbbbbrrbbbrbbrrrrbrbbbbbrrbrrbrbbrrrbrbrbbbbrbbrrrrrbrbrbbbrbbrrbbbrrrrbrbbbbrbrbbbrrrrrrbbrrrbbrbrrbbrrrbbbrrbrbbrbrrrrrrrbrbrbrrrbrbbbrrbrbrrbbrbbbbbbbrb\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rbrrrrbbbbrrbbbrbbrrrrbrbbbbbrrbrrbrbbrrrbrbrbbbbrbbrrrrrbrbrbbbrbbrrbbbrrrrbrbbbbrbrbbbrrrrrrbbrrrbbrbrrbbrrrbbbrrbrbbrbrrrrrrrbrbrbrrrbrbbbrrbrbrrbbrbbbbbbbrb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_7",
    "sat": "def sat(n: int, lace=\"brbbbbrrrrrbbrbbrbbbrrrbbrrbbbrbbrrbrbbbbrbbrrbrrrbrrbbrbbbbbbbbbrrbbrrrrbrbbbrbrbrrbrbbrrrbrbrbbbbbrrrbrbrbrrbrbbbrrbbrrrbbrrrbrrbbbbrrbrrbbbbrbrrrrrbbbbbrrbbbrrbrrrbbrrbrbrbbbrbbbbbbrrrrbbrrrrrrrbrbrbbrbbrrrrrbrbbrbbrbbrbrrrbbrbrrbbbrbbrbrrrrrbbbbbrbbrrrrbrbrrbrbrbrbbbrbrrbrrbrrrbrrbrbbrbbrrbrrbrrbrrbbrbbbrbrbrrbbrrbbrbbrbrrrrrbrbbrrbbbrrbrrrbbrrrbrbrrrrrbrrrbbrbbbrrbbrrbbrrrrrbrrbrrrrrrbrbbbrbbrbrbbbrbrrrrbrbrrbrbbbrbrrrbbbrrbrbbbbbrrrbrrbrrrrrrrrrbrbbrbbbbrrrrrrrbbrbbbbbrrbbbbbrrrbbbbrbrbrrbbrbbrrrrbrbrrbrbbbbbrbrbbbrbrbrrrrrrbbbbbrbbbbbbrbbrbbrrrrrrrbrrrbrbbrbrbbrrrbbrrbrbrbbrbbbrrrrbrbrbrrrbrbrbrbrbrbrrrrrbbbbbbbbrrrrbrbrbbrrrbbbbrrrbbbbrbrrrrbrrbrbbrbrbbrbrbbbrrbrrrrbbbrbbrbrrbbrrrrrbbbbrbrbrbbbbrrrrrrrrbbbbbbbbbbbbrbrbrbrbrbrbbbrbrbrrbbbbbbrbrbbrbrbbrrbbbrbrbbrrrrbbrbbbbrbbbrrrrrbrbrbbrrbrbbrbrrbbbbrbbrrrbbbbbbrrrrrbbbrrbrrbbbbrbrbbrrrbbbrbrrrrbrrrrrbrbbrrrbrrrrrbbrrrbrrbrrbrrbrrrbrbbbbbrbrbrbbbrrrbbbbbbbrbrbrrbrbbbrrrbrbrbbrrbrrrrrbbbbrbrrbbbrbrbbrrrbbbrrrbbbbrrbrrrrbrrbrrrrrbbrrbrrbrbrrrbrbrrbbrrrrbbbrbrrrrbrrrbrbbrrbrrrrrrbbrrbrbrbrbbrbbrbbbbbbbbrbbrrrbbbrbrbbrbbbbrrbbrbbrbbrbbbrrrbbbbbrrbbrbrbrrbrbrrrrrbbrrrbrrbbrbbbrrrbbrrbbbbrrbbrrbrrbbrrbbrbbbbrrbrbbbrbrbrrrbrbrrbrrbbrrrbrrrbrrrrrbbrrrbrbbrrrbbrrbbrrbbrrbbrbrrbbrrbrrbbbrbbbrbrbrrbrrrbbrrbbbrbbrrrbbbbrbrrrrrrbbrrbbrrbbrbbbbrrrbrrrbbbrbbbbbbbbrbbrrrrrrbbbrrrbbbbrbrrrbrbbrrbbrrbbrrbrrbrrrrrrbbbbrrrbbrrrrrrbbrrrbbbbrrbrrbbrbbbbbrrbrrrbbbbrrbrrbbbrbbbbbrbbrrrrbrbrbbbrrbbbrrbrbbrbbbbbrbbbbbrbrrrrbrrrbrrrrrbrrrbbbbrbrbrbrbbrrrrrrbbbbrbrbrbbrbbrbbrrbbrbbbbrrbbrrbrbrrbrbbbrrbrbrbrrbrbbrbrrbrrrbrrbrrrbbrbrbrbrrrbbrbbrrrbrrrrbbrbbbrrrbbrrrrbrbbrrbbbrbbbrbbbbrbrrbbbrbbbrbrrrbrrbrbrbrbbrbbrrbbbrrbbrrbrrbbbbrrrbbrbbbbrrrbrbrbrbrbbbbrrbbrrbrrrbrbbrbrrbrrbrrrrbrrbbbrbbrbrrrrrbrbrbrrbrbbrbbbbrbbrbbrbrbrbrrbrbbbbbrrbbbrrbrrrbrrrbbrrrrrbrbrrrbbrrbbbrbrbbbrbrrrrbbrbbbbrrrbbrbbbbrbrbrrrrrrbrbbrrbbbrbrrrbbbrbbrrrbbbrbrrrrrrrrrrrbrrrbrbbbrrrbrrbrrrbrrbrbrbbbbbbrrbrbbbbbrrrbbrrbbrbbrrbrbbrbrrbbbbbbrrrrbbbrbrrrrbbbbbbrbbbbbrrrrrbrbbbbrbbrbrrbbrrbbbbbbbbrrrrrbrrbbrrrbbrbbrbbrbbbrrrbrrrbbbbrbbbbrrrrrbbbbrbrbrbbbrrbrbrbrrrbrbbbbbrrrbrrbbrbbbrrbbrrbrbrrrbrrbrrbbrrbrbbrbbrrbrrbrrrbbrrrbbbbrrrrrrrrbrbrrrbrbbbrbbrbbrrbrbbrrrbrbbbrrbbbrbrrbb\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"brbbbbrrrrrbbrbbrbbbrrrbbrrbbbrbbrrbrbbbbrbbrrbrrrbrrbbrbbbbbbbbbrrbbrrrrbrbbbrbrbrrbrbbrrrbrbrbbbbbrrrbrbrbrrbrbbbrrbbrrrbbrrrbrrbbbbrrbrrbbbbrbrrrrrbbbbbrrbbbrrbrrrbbrrbrbrbbbrbbbbbbrrrrbbrrrrrrrbrbrbbrbbrrrrrbrbbrbbrbbrbrrrbbrbrrbbbrbbrbrrrrrbbbbbrbbrrrrbrbrrbrbrbrbbbrbrrbrrbrrrbrrbrbbrbbrrbrrbrrbrrbbrbbbrbrbrrbbrrbbrbbrbrrrrrbrbbrrbbbrrbrrrbbrrrbrbrrrrrbrrrbbrbbbrrbbrrbbrrrrrbrrbrrrrrrbrbbbrbbrbrbbbrbrrrrbrbrrbrbbbrbrrrbbbrrbrbbbbbrrrbrrbrrrrrrrrrbrbbrbbbbrrrrrrrbbrbbbbbrrbbbbbrrrbbbbrbrbrrbbrbbrrrrbrbrrbrbbbbbrbrbbbrbrbrrrrrrbbbbbrbbbbbbrbbrbbrrrrrrrbrrrbrbbrbrbbrrrbbrrbrbrbbrbbbrrrrbrbrbrrrbrbrbrbrbrbrrrrrbbbbbbbbrrrrbrbrbbrrrbbbbrrrbbbbrbrrrrbrrbrbbrbrbbrbrbbbrrbrrrrbbbrbbrbrrbbrrrrrbbbbrbrbrbbbbrrrrrrrrbbbbbbbbbbbbrbrbrbrbrbrbbbrbrbrrbbbbbbrbrbbrbrbbrrbbbrbrbbrrrrbbrbbbbrbbbrrrrrbrbrbbrrbrbbrbrrbbbbrbbrrrbbbbbbrrrrrbbbrrbrrbbbbrbrbbrrrbbbrbrrrrbrrrrrbrbbrrrbrrrrrbbrrrbrrbrrbrrbrrrbrbbbbbrbrbrbbbrrrbbbbbbbrbrbrrbrbbbrrrbrbrbbrrbrrrrrbbbbrbrrbbbrbrbbrrrbbbrrrbbbbrrbrrrrbrrbrrrrrbbrrbrrbrbrrrbrbrrbbrrrrbbbrbrrrrbrrrbrbbrrbrrrrrrbbrrbrbrbrbbrbbrbbbbbbbbrbbrrrbbbrbrbbrbbbbrrbbrbbrbbrbbbrrrbbbbbrrbbrbrbrrbrbrrrrrbbrrrbrrbbrbbbrrrbbrrbbbbrrbbrrbrrbbrrbbrbbbbrrbrbbbrbrbrrrbrbrrbrrbbrrrbrrrbrrrrrbbrrrbrbbrrrbbrrbbrrbbrrbbrbrrbbrrbrrbbbrbbbrbrbrrbrrrbbrrbbbrbbrrrbbbbrbrrrrrrbbrrbbrrbbrbbbbrrrbrrrbbbrbbbbbbbbrbbrrrrrrbbbrrrbbbbrbrrrbrbbrrbbrrbbrrbrrbrrrrrrbbbbrrrbbrrrrrrbbrrrbbbbrrbrrbbrbbbbbrrbrrrbbbbrrbrrbbbrbbbbbrbbrrrrbrbrbbbrrbbbrrbrbbrbbbbbrbbbbbrbrrrrbrrrbrrrrrbrrrbbbbrbrbrbrbbrrrrrrbbbbrbrbrbbrbbrbbrrbbrbbbbrrbbrrbrbrrbrbbbrrbrbrbrrbrbbrbrrbrrrbrrbrrrbbrbrbrbrrrbbrbbrrrbrrrrbbrbbbrrrbbrrrrbrbbrrbbbrbbbrbbbbrbrrbbbrbbbrbrrrbrrbrbrbrbbrbbrrbbbrrbbrrbrrbbbbrrrbbrbbbbrrrbrbrbrbrbbbbrrbbrrbrrrbrbbrbrrbrrbrrrrbrrbbbrbbrbrrrrrbrbrbrrbrbbrbbbbrbbrbbrbrbrbrrbrbbbbbrrbbbrrbrrrbrrrbbrrrrrbrbrrrbbrrbbbrbrbbbrbrrrrbbrbbbbrrrbbrbbbbrbrbrrrrrrbrbbrrbbbrbrrrbbbrbbrrrbbbrbrrrrrrrrrrrbrrrbrbbbrrrbrrbrrrbrrbrbrbbbbbbrrbrbbbbbrrrbbrrbbrbbrrbrbbrbrrbbbbbbrrrrbbbrbrrrrbbbbbbrbbbbbrrrrrbrbbbbrbbrbrrbbrrbbbbbbbbrrrrrbrrbbrrrbbrbbrbbrbbbrrrbrrrbbbbrbbbbrrrrrbbbbrbrbrbbbrrbrbrbrrrbrbbbbbrrrbrrbbrbbbrrbbrrbrbrrrbrrbrrbbrrbrbbrbbrrbrrbrrrbbrrrbbbbrrrrrrrrbrbrrrbrbbbrbbrbbrrbrbbrrrbrbbbrrbbbrbrrbb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_8",
    "sat": "def sat(n: int, lace=\"brrrrbbrbrrbrbbrrrrrbbrbbbbbrbbrrrbbrbbbrbbbbrrbbrbrbrrbbrrbrbbbrrbrrrbbbrbrbbbrbrrrbbbbrrrbrbbbbbrbbbbbrbrrbrbbrrbbrrrrbrbbbrrrrrbbrrrbbrrrbbrbrbrrbbbrrrrbbrbrrrrrbrrr\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"brrrrbbrbrrbrbbrrrrrbbrbbbbbrbbrrrbbrbbbrbbbbrrbbrbrbrrbbrrbrbbbrrbrrrbbbrbrbbbrbrrrbbbbrrrbrbbbbbrbbbbbrbrrbrbbrrbbrrrrbrbbbrrrrrbbrrrbbrrrbbrbrbrrbbbrrrrbbrbrrrrrbrrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "NecklaceSplit_9",
    "sat": "def sat(n: int, lace=\"rbrbbrrbbrrrbrrrbrrrbrbbbrbbrrrbbrbbbrbrrrbbrbbbrrrrbrrbrbrrrbrrrrbbbrrrbbrrrbbrrbrrbrbbrrrrbbbbbbbrbrbbrbrrrbbbrbbbrrrrbrrrbrbbbrrrbbrbrrbbbrbrbrbbrbbbbbbbrbrrrrbbrbbrrbrrrbbrbrrbbbrrbbbrbrbb\"):\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rbrbbrrbbrrrbrrrbrrrbrbbbrbbrrrbbrbbbrbrrrbbrbbbrrrrbrrbrbrrrbrrrrbbbrrrbbrrrbbrrbrrbrbbrrrrbbbbbbbrbrbbrbrrrbbbrbbbrrrrbrrrbrbbbrrrbbrbrrbbbrbrbrbbrbbbbbbbrbrrrrbbrbbrrbrrrbbrbrrbbbrrbbbrbrbb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "PandigitalSquare_0",
    "sat": "def sat(n: int):\n    \"\"\"Find an integer whose square has all digits 0-9 once.\"\"\"\n    s = str(n * n)\n    for i in \"0123456789\":\n        assert s.count(i) == 1\n    return True",
    "sols": [
      "def sol():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "AllPandigitalSquares_0",
    "sat": "def sat(nums: List[int]):\n    \"\"\"Find all 174 integers whose 10-digit square has all digits 0-9 just once.\"\"\"\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174",
    "sols": [
      "def sol():\n    return [i for i in range(-10 ** 5, 10 ** 5) if sorted([int(s) for s in str(i * i)]) == list(range(10))]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_0",
    "sat": "def sat(expr: str, nums=[3, 7, 3, 7]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[3, 7, 3, 7]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_1",
    "sat": "def sat(expr: str, nums=[7, 11, 8, 2]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[7, 11, 8, 2]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_2",
    "sat": "def sat(expr: str, nums=[12, 6, 12, 2]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[12, 6, 12, 2]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_3",
    "sat": "def sat(expr: str, nums=[13, 13, 10, 8]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[13, 13, 10, 8]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_4",
    "sat": "def sat(expr: str, nums=[4, 9, 3, 11]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[4, 9, 3, 11]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_5",
    "sat": "def sat(expr: str, nums=[11, 7, 11, 5]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[11, 7, 11, 5]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_6",
    "sat": "def sat(expr: str, nums=[11, 8, 12, 9]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[11, 8, 12, 9]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_7",
    "sat": "def sat(expr: str, nums=[13, 7, 3, 1]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[13, 7, 3, 1]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_8",
    "sat": "def sat(expr: str, nums=[8, 10, 8, 7]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[8, 10, 8, 7]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "CardGame24_9",
    "sat": "def sat(expr: str, nums=[10, 8, 10, 2]):\n    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[10, 8, 10, 2]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "Easy63_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a formula using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 2 and s.count(\"1\") == 1 and eval(s) == 63",
    "sols": [
      "def sol():\n    return \"8*8-1\""
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "Harder63_0",
    "sat": "def sat(s: str):\n    \"\"\"Find an expression using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 3 and s.count(\"1\") == 1 and eval(s) == 63",
    "sols": [
      "def sol():\n    return \"8*8-1**8\""
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_0",
    "sat": "def sat(moves: List[List[int]], capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_1",
    "sat": "def sat(moves: List[List[int]], capacities=[292, 855, 439], init=[80, 92, 10], goal=[80, 0, 102]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[292, 855, 439], init=[80, 92, 10], goal=[80, 0, 102]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_2",
    "sat": "def sat(moves: List[List[int]], capacities=[629, 269, 623], init=[25, 18, 582], goal=[538, 87, 0]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[629, 269, 623], init=[25, 18, 582], goal=[538, 87, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_3",
    "sat": "def sat(moves: List[List[int]], capacities=[623, 594, 669], init=[157, 558, 490], goal=[618, 587, 0]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[623, 594, 669], init=[157, 558, 490], goal=[618, 587, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_4",
    "sat": "def sat(moves: List[List[int]], capacities=[809, 194, 51], init=[724, 182, 42], goal=[746, 151, 51]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[809, 194, 51], init=[724, 182, 42], goal=[746, 151, 51]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_5",
    "sat": "def sat(moves: List[List[int]], capacities=[101, 990, 918], init=[78, 635, 630], goal=[101, 586, 656]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[101, 990, 918], init=[78, 635, 630], goal=[101, 586, 656]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_6",
    "sat": "def sat(moves: List[List[int]], capacities=[666, 854, 836], init=[459, 476, 800], goal=[252, 647, 836]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[666, 854, 836], init=[459, 476, 800], goal=[252, 647, 836]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_7",
    "sat": "def sat(moves: List[List[int]], capacities=[597, 30, 615], init=[86, 15, 170], goal=[170, 0, 101]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[597, 30, 615], init=[86, 15, 170], goal=[170, 0, 101]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_8",
    "sat": "def sat(moves: List[List[int]], capacities=[198, 131, 154], init=[108, 59, 75], goal=[157, 0, 85]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[198, 131, 154], init=[108, 59, 75], goal=[157, 0, 85]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "WaterPouring_9",
    "sat": "def sat(moves: List[List[int]], capacities=[598, 140, 658], init=[97, 30, 338], goal=[198, 140, 127]):  # moves is list of [from, to] pairs\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    \"\"\"\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[598, 140, 658], init=[97, 30, 338], goal=[198, 140, 127]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_0",
    "sat": "def sat(li: List[int], words=['SEND', 'MORE', 'MONEY']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['SEND', 'MORE', 'MONEY']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_1",
    "sat": "def sat(li: List[int], words=['FORTY', 'TEN', 'TEN', 'SIXTY']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['FORTY', 'TEN', 'TEN', 'SIXTY']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_2",
    "sat": "def sat(li: List[int], words=['GREEN', 'ORANGE', 'COLORS']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['GREEN', 'ORANGE', 'COLORS']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_3",
    "sat": "def sat(li: List[int], words=['yyft', 'tdga', 'rvgfj']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['yyft', 'tdga', 'rvgfj']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_4",
    "sat": "def sat(li: List[int], words=['oiaa', 'ddcc', 'cwsy', 'coyy', 'dhdoc']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['oiaa', 'ddcc', 'cwsy', 'coyy', 'dhdoc']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_5",
    "sat": "def sat(li: List[int], words=['lzz', 'vkka', 'gezl', 'gmle', 'lmmk', 'yylv', 'krzk', 'mayv', 'reey', 'lrakl']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['lzz', 'vkka', 'gezl', 'gmle', 'lmmk', 'yylv', 'krzk', 'mayv', 'reey', 'lrakl']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_6",
    "sat": "def sat(li: List[int], words=['epeg', 'dne', 'elge', 'leli', 'inmq', 'gqnl', 'qlenl']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['epeg', 'dne', 'elge', 'leli', 'inmq', 'gqnl', 'qlenl']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_7",
    "sat": "def sat(li: List[int], words=['jrbf', 'ajaj', 'jfvs', 'rgwvw']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['jrbf', 'ajaj', 'jfvs', 'rgwvw']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_8",
    "sat": "def sat(li: List[int], words=['xcxh', 'sxc', 'vsmv']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['xcxh', 'sxc', 'vsmv']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "VerbalArithmetic_9",
    "sat": "def sat(li: List[int], words=['kxrv', 'qjqv', 'kxoq', 'mmqkr']):\n    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['kxrv', 'qjqv', 'kxoq', 'mmqkr']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_0",
    "sat": "def sat(moves: List[int], start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_1",
    "sat": "def sat(moves: List[int], start=[[1, 0, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[1, 0, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_2",
    "sat": "def sat(moves: List[int], start=[[6, 7, 0], [4, 3, 1], [8, 5, 2]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[6, 7, 0], [4, 3, 1], [8, 5, 2]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_3",
    "sat": "def sat(moves: List[int], start=[[1, 2, 0], [3, 4, 5], [6, 7, 8]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[1, 2, 0], [3, 4, 5], [6, 7, 8]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_4",
    "sat": "def sat(moves: List[int], start=[[3, 2], [0, 1]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[3, 2], [0, 1]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_5",
    "sat": "def sat(moves: List[int], start=[[0, 1, 5], [3, 2, 4], [6, 7, 8]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[0, 1, 5], [3, 2, 4], [6, 7, 8]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_6",
    "sat": "def sat(moves: List[int], start=[[1, 3, 6, 5], [4, 2, 10, 7], [8, 9, 14, 0], [12, 13, 15, 11]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[1, 3, 6, 5], [4, 2, 10, 7], [8, 9, 14, 0], [12, 13, 15, 11]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_7",
    "sat": "def sat(moves: List[int], start=[[1, 3], [2, 0]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[1, 3], [2, 0]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_8",
    "sat": "def sat(moves: List[int], start=[[2, 4, 3, 10], [1, 0, 6, 7], [8, 5, 9, 11], [12, 13, 14, 15]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[2, 4, 3, 10], [1, 0, 6, 7], [8, 5, 9, 11], [12, 13, 14, 15]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "SlidingPuzzle_9",
    "sat": "def sat(moves: List[int], start=[[3, 1, 4], [6, 5, 2], [0, 7, 8]]):\n    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "sols": [
      "def sol(start=[[3, 1, 4], [6, 5, 2], [0, 7, 8]]):\n    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles"
  },
  {
    "name": "FindCloseElements_0",
    "sat": "def sat(pair: List[float], nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_1",
    "sat": "def sat(pair: List[float], nums=[-0.10243265886121833, -0.10243265886121833, -6.212282963714153]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[-0.10243265886121833, -0.10243265886121833, -6.212282963714153]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_2",
    "sat": "def sat(pair: List[float], nums=[1.5477810805020198, 6.116672952812706, 0.15059393813417543, -7.318644030593244, -6.297522263271795, 0.16617166130978234, 6.116672952812706, -9.389279505161346, -1.4986516099683165, 4.88033360573967]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[1.5477810805020198, 6.116672952812706, 0.15059393813417543, -7.318644030593244, -6.297522263271795, 0.16617166130978234, 6.116672952812706, -9.389279505161346, -1.4986516099683165, 4.88033360573967]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_3",
    "sat": "def sat(pair: List[float], nums=[6.9759640202474635, 4.66029895525315, -4.310387899978892, 0.06077557720323057, -2.1876900984216068, -0.13559765327554096, 4.66029895525315, 6.807120764137871]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[6.9759640202474635, 4.66029895525315, -4.310387899978892, 0.06077557720323057, -2.1876900984216068, -0.13559765327554096, 4.66029895525315, 6.807120764137871]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_4",
    "sat": "def sat(pair: List[float], nums=[6.765553659759561, 6.765553659759561, -1.2506134022421218]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[6.765553659759561, 6.765553659759561, -1.2506134022421218]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_5",
    "sat": "def sat(pair: List[float], nums=[2.6486250341779343, 9.949297879478529, -5.642411311304432, -4.709641649547076, -8.794115984858484, 7.041453579810899, 7.848641831263706, -8.794115984858484, -8.239087013309694, -2.6724533718708816]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[2.6486250341779343, 9.949297879478529, -5.642411311304432, -4.709641649547076, -8.794115984858484, 7.041453579810899, 7.848641831263706, -8.794115984858484, -8.239087013309694, -2.6724533718708816]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_6",
    "sat": "def sat(pair: List[float], nums=[4.258147438798643, 4.258147438798643, -2.6777278931310473]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[4.258147438798643, 4.258147438798643, -2.6777278931310473]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_7",
    "sat": "def sat(pair: List[float], nums=[6.15617809397137, -0.3171140161532584, 3.628546865157986, 1.71305168120913, -0.8433270017307137, -9.884771940110566, -0.3171140161532584, -2.4353094465632967]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[6.15617809397137, -0.3171140161532584, 3.628546865157986, 1.71305168120913, -0.8433270017307137, -9.884771940110566, -0.3171140161532584, -2.4353094465632967]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_8",
    "sat": "def sat(pair: List[float], nums=[4.005959584915715, 5.431273517776759, -5.717221030622655, 2.484826049551474, 3.781904063057155, 2.516691533332569, -0.22849856281115777, 2.484826049551474]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[4.005959584915715, 5.431273517776759, -5.717221030622655, 2.484826049551474, 3.781904063057155, 2.516691533332569, -0.22849856281115777, 2.484826049551474]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindCloseElements_9",
    "sat": "def sat(pair: List[float], nums=[8.732821260781634, 8.667740839992312, 9.83271682844481, 8.667740839992312, 9.79949792028205]):\n    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"\n    a, b = pair\n    assert a in nums and b in nums\n    return abs(a - b) == min({abs(x - y) for x in nums for y in nums} - {0})",
    "sols": [
      "def sol(nums=[8.732821260781634, 8.667740839992312, 9.83271682844481, 8.667740839992312, 9.79949792028205]):\n    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_0",
    "sat": "def sat(ls: List[str], combined=\"() (()) ((() () ())) (() )\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"() (()) ((() () ())) (() )\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_1",
    "sat": "def sat(ls: List[str], combined=\"((())((()( ( ( (  )()((())))( )))( )( ) ) ())( ) ) ( )()\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"((())((()( ( ( (  )()((())))( )))( )( ) ) ())( ) ) ( )()\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_2",
    "sat": "def sat(ls: List[str], combined=\"()( () ((( ( ) ))()( ) ((()()))(())) )(( (()))( )( (( ()()((  ))  )))())   ()\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"()( () ((( ( ) ))()( ) ((()()))(())) )(( (()))( )( (( ()()((  ))  )))())   ()\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_3",
    "sat": "def sat(ls: List[str], combined=\"()()\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"()()\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_4",
    "sat": "def sat(ls: List[str], combined=\" ( )()(  ) ()  \"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\" ( )()(  ) ()  \"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_5",
    "sat": "def sat(ls: List[str], combined=\"       ( ()( ( )) )( )()( )( ())() ( )\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"       ( ()( ( )) )( )()( )( ())() ( )\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_6",
    "sat": "def sat(ls: List[str], combined=\"( )()()\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"( )()()\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_7",
    "sat": "def sat(ls: List[str], combined=\"\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_8",
    "sat": "def sat(ls: List[str], combined=\"  (() ) ()()\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\"  (() ) ()()\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SeparateParenGroups_9",
    "sat": "def sat(ls: List[str], combined=\" ( )   ( )( )\"):\n    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"\n    assert ''.join(ls) == combined.replace(' ', '')\n    for s in ls:  # check that s is not further divisible\n        depth = 0\n        for c in s[:-1]:\n            if c == '(':\n                depth += 1\n            else:\n                assert c == ')'\n                depth -= 1\n                assert depth >= 1\n        assert depth == 1 and s[-1] == ')'\n    return True",
    "sols": [
      "def sol(combined=\" ( )   ( )( )\"):\n    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_0",
    "sat": "def sat(x: float, v=523.12892):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=523.12892):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_1",
    "sat": "def sat(x: float, v=67.08595730976853):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=67.08595730976853):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_2",
    "sat": "def sat(x: float, v=-64.44411386903717):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=-64.44411386903717):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_3",
    "sat": "def sat(x: float, v=-99.76385639169243):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=-99.76385639169243):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_4",
    "sat": "def sat(x: float, v=-75.25940568266422):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=-75.25940568266422):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_5",
    "sat": "def sat(x: float, v=70.74233909701084):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=70.74233909701084):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_6",
    "sat": "def sat(x: float, v=-26.263555195851595):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=-26.263555195851595):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_7",
    "sat": "def sat(x: float, v=-57.45351519577808):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=-57.45351519577808):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_8",
    "sat": "def sat(x: float, v=75.74526366400872):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=75.74526366400872):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Frac_9",
    "sat": "def sat(x: float, v=97.81810275659444):\n    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"\n    return 0 <= x < 1 and (v - x).is_integer()",
    "sols": [
      "def sol(v=97.81810275659444):\n    return v % 1.0"
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_0",
    "sat": "def sat(n: int, balances=[2, 7, -2, 4, 3, -15, 10, -45, 3]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[2, 7, -2, 4, 3, -15, 10, -45, 3]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_1",
    "sat": "def sat(n: int, balances=[-9191625242, 6090192405, 3091414958]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[-9191625242, 6090192405, 3091414958]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_2",
    "sat": "def sat(n: int, balances=[-6854417346, -2893651524, 2085940089, -2771655618]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[-6854417346, -2893651524, 2085940089, -2771655618]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_3",
    "sat": "def sat(n: int, balances=[-7215322377, -5613001816, 4327830602, 1681827727]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[-7215322377, -5613001816, 4327830602, 1681827727]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_4",
    "sat": "def sat(n: int, balances=[-1295319876, 5886917858, 1180430248, 8163076058, -7769426623, -9248654922, 12583438, 8225601249, -7898249262]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[-1295319876, 5886917858, 1180430248, 8163076058, -7769426623, -9248654922, 12583438, 8225601249, -7898249262]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_5",
    "sat": "def sat(n: int, balances=[5888315298, -6945273299]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[5888315298, -6945273299]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_6",
    "sat": "def sat(n: int, balances=[4749814998, -7157960864, 3711936075, 6889181424, 6788202373, -9478178974, 5735163877, 5345546573, -6854448913, -8021434451]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[4749814998, -7157960864, 3711936075, 6889181424, 6788202373, -9478178974, 5735163877, 5345546573, -6854448913, -8021434451]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_7",
    "sat": "def sat(n: int, balances=[-5327982347, 1888100548, -1440743989]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[-5327982347, 1888100548, -1440743989]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_8",
    "sat": "def sat(n: int, balances=[-5108697749, 335836875]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[-5108697749, 335836875]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "FirstNegCumulative_9",
    "sat": "def sat(n: int, balances=[2709073461, 4475270890, -6819477273, -8167777637, -7583365454, -2761184034, 9053594676]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    -89\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total == n",
    "sols": [
      "def sol(balances=[2709073461, 4475270890, -6819477273, -8167777637, -7583365454, -2761184034, 9053594676]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return total\n    assert False, \"should not reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_0",
    "sat": "def sat(neg: bool, balances=[2, 7, -2, 4, 3, -15, 10, -45, 3]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[2, 7, -2, 4, 3, -15, 10, -45, 3]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_1",
    "sat": "def sat(neg: bool, balances=[7989207800, 3322787901, -6517648201, -5142268537, 7269625538, 5408903548, -6270910295, 7881178598, -7920111517]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[7989207800, 3322787901, -6517648201, -5142268537, 7269625538, 5408903548, -6270910295, 7881178598, -7920111517]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_2",
    "sat": "def sat(neg: bool, balances=[-86296390, -471641712]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-86296390, -471641712]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_3",
    "sat": "def sat(neg: bool, balances=[3327074376, 7366686112, 7072480379, -3621938036, -8232651954, -6883105418, 508172229, 4439005964]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[3327074376, 7366686112, 7072480379, -3621938036, -8232651954, -6883105418, 508172229, 4439005964]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_4",
    "sat": "def sat(neg: bool, balances=[-1191606688, 1047701228, -6149798522]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-1191606688, 1047701228, -6149798522]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_5",
    "sat": "def sat(neg: bool, balances=[-8665571121, -6130239233, 348347495, -7175787995]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-8665571121, -6130239233, 348347495, -7175787995]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_6",
    "sat": "def sat(neg: bool, balances=[-6259345050]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-6259345050]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_7",
    "sat": "def sat(neg: bool, balances=[-3300684996, -6034152090, -6984064031, 729906057, -1625793020, -3029481314]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-3300684996, -6034152090, -6984064031, 729906057, -1625793020, -3029481314]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_8",
    "sat": "def sat(neg: bool, balances=[-3544766048, -8868032242, 3689181739, -3275917476, 1063079176, -1747451832, 2606105810, 1849558216, 81975907, -8527499263]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-3544766048, -8868032242, 3689181739, -3275917476, 1063079176, -1747451832, 2606105810, 1849558216, 81975907, -8527499263]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "NegCumulative_Trivial_9",
    "sat": "def sat(neg: bool, balances=[-6009982864, 4440688674, -3208789720, 9111111692, -472223324, -4685547659, 5687547493, 339326111, -1205916875]):\n    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals,\n    determine if the cumulative sum is negative.\n\n    Sample Input:\n    [12, -5, 3, -99, 14, 88, -99]\n\n    Sample Output:\n    True\n    \"\"\"\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return neg == True\n    return neg == False",
    "sols": [
      "def sol(balances=[-6009982864, 4440688674, -3208789720, 9111111692, -472223324, -4685547659, 5687547493, 339326111, -1205916875]):\n    total = 0\n    for b in balances:\n        total += b\n        if total < 0:\n            return True\n    return False"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_0",
    "sat": "def sat(x: float, nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_1",
    "sat": "def sat(x: float, nums=[-9494612849, -7470443330, 7106228618, -5830735381, 4463150412, 743675962, -8640059973, -812360333]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[-9494612849, -7470443330, 7106228618, -5830735381, 4463150412, 743675962, -8640059973, -812360333]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_2",
    "sat": "def sat(x: float, nums=[-924519684, 4649474318, 2081865709, 5995762407, -1588029654, 2569545257, -9758457935, -2820694607, -8037538275]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[-924519684, 4649474318, 2081865709, 5995762407, -1588029654, 2569545257, -9758457935, -2820694607, -8037538275]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_3",
    "sat": "def sat(x: float, nums=[6809363842, -2520151101, -2829307727, -7919542139]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[6809363842, -2520151101, -2829307727, -7919542139]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_4",
    "sat": "def sat(x: float, nums=[-4319808176, -3476685650, -8148344264, -8911359055, 6416253095]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[-4319808176, -3476685650, -8148344264, -8911359055, 6416253095]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_5",
    "sat": "def sat(x: float, nums=[-7286701070, -6069126572, 8439368490, -8207132042]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[-7286701070, -6069126572, 8439368490, -8207132042]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_6",
    "sat": "def sat(x: float, nums=[9636248715, 7608871883]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[9636248715, 7608871883]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_7",
    "sat": "def sat(x: float, nums=[-3385525889, 4094714316, 8252449572, 3051155707]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[-3385525889, 4094714316, 8252449572, 3051155707]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_8",
    "sat": "def sat(x: float, nums=[712501911, -7275452232, 5654760309, 793200001, -9916794349, -4541696154, 5783249641, -5496381285, 6145987180, 1134282911]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[712501911, -7275452232, 5654760309, 793200001, -9916794349, -4541696154, 5783249641, -5496381285, 6145987180, 1134282911]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "MinSquaredDeviation_9",
    "sat": "def sat(x: float, nums=[5728120820, 652653115, -4575252160, 6731442048, 5967932086, -2181084704]):\n    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"\n    return sum((n - x) ** 2 for n in nums) <= sum((m - n) ** 2 for m in nums for n in nums) * 0.501 / len(nums)",
    "sols": [
      "def sol(nums=[5728120820, 652653115, -4575252160, 6731442048, 5967932086, -2181084704]):\n    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_0",
    "sat": "def sat(li: List[int], nums=[12, 23, -2, 5, 0], sep=4):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[12, 23, -2, 5, 0], sep=4):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_1",
    "sat": "def sat(li: List[int], nums=[62, 87, 86, 8, 84, 59, 57], sep=29):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[62, 87, 86, 8, 84, 59, 57], sep=29):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_2",
    "sat": "def sat(li: List[int], nums=[53, 50, 48, 0, 70, 93, 3], sep=17):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[53, 50, 48, 0, 70, 93, 3], sep=17):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_3",
    "sat": "def sat(li: List[int], nums=[22, 68, 88, 72, 86, 59, 89, 83, 32], sep=18):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[22, 68, 88, 72, 86, 59, 89, 83, 32], sep=18):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_4",
    "sat": "def sat(li: List[int], nums=[17, 5, 97, 59, 4, 94], sep=57):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[17, 5, 97, 59, 4, 94], sep=57):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_5",
    "sat": "def sat(li: List[int], nums: List[int]=[], sep=61):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[], sep=61):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_6",
    "sat": "def sat(li: List[int], nums=[91, 14, 32, 89, 68, 40, 49, 28, 54], sep=10):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[91, 14, 32, 89, 68, 40, 49, 28, 54], sep=10):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_7",
    "sat": "def sat(li: List[int], nums=[57, 41, 7, 43, 99], sep=66):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[57, 41, 7, 43, 99], sep=66):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_8",
    "sat": "def sat(li: List[int], nums=[99], sep=41):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[99], sep=41):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Intersperse_9",
    "sat": "def sat(li: List[int], nums: List[int]=[], sep=39):\n    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"\n    assert len(li) == max(0, len(nums) * 2 - 1)\n    for i, n in enumerate(nums):\n        assert li[2 * i] == n\n        if i > 0:\n            assert li[2 * i - 1] == sep\n    return True",
    "sols": [
      "def sol(nums=[], sep=39):\n    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_0",
    "sat": "def sat(depths: List[int], parens=\"() (()) ((()()())) (())\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"() (()) ((()()())) (())\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_1",
    "sat": "def sat(depths: List[int], parens=\"()()() ()()()()()()() (())(()())()()()(())()()()()()(((((((()))()()()()()()()))()()((())()())()())())(()))()()()()(()()(()))()()()(())()(())(()(())())()()()()((()()()))()()()()(()()()(())(()))(()())()((())) (()) ()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"()()() ()()()()()()() (())(()())()()()(())()()()()()(((((((()))()()()()()()()))()()((())()())()())())(()))()()()()(()()(()))()()()(())()(())(()(())())()()()()((()()()))()()()()(()()()(())(()))(()())()((())) (()) ()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_2",
    "sat": "def sat(depths: List[int], parens=\"()(())()(())((()()))()() () ()()()()() ()()(()()) ()()()()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"()(())()(())((()()))()() () ()()()()() ()()(()()) ()()()()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_3",
    "sat": "def sat(depths: List[int], parens=\"() ()()((()()))()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"() ()()((()()))()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_4",
    "sat": "def sat(depths: List[int], parens=\"((()))() ()()()()()()((()((()((()))())()(()()()()((())(())))))) (())(())()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"((()))() ()()()()()()((()((()((()))())()(()()()()((())(())))))) (())(())()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_5",
    "sat": "def sat(depths: List[int], parens=\"\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_6",
    "sat": "def sat(depths: List[int], parens=\"() ()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"() ()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_7",
    "sat": "def sat(depths: List[int], parens=\"(()) ()() ()()()(())()()()()()()()() ()(()())()()(())(())()((((()(())()))))((()))() ()()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"(()) ()() ()()()(())()()()()()()()() ()(()())()()(())(())()((((()(())()))))((()))() ()()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_8",
    "sat": "def sat(depths: List[int], parens=\"() ()((()))() ()(()((()())))() (())()()()\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"() ()((()))() ()(()((()())))() (())()()()\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DeepestParens_9",
    "sat": "def sat(depths: List[int], parens=\"() ()()()()(())(())(())\"):\n    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "sols": [
      "def sol(parens=\"() ()()()()(())(())(())\"):\n    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_0",
    "sat": "def sat(containers: List[str], strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_1",
    "sat": "def sat(containers: List[str], strings=['v', 'ruzr', 'ruzxahac', 'red'], substring=\"ruz\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['v', 'ruzr', 'ruzxahac', 'red'], substring=\"ruz\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_2",
    "sat": "def sat(containers: List[str], strings=['pitwakoj', 'fuvawazu'], substring=\"wa\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['pitwakoj', 'fuvawazu'], substring=\"wa\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_3",
    "sat": "def sat(containers: List[str], strings=['mudtik', 'kezadfely', 'sefud'], substring=\"d\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['mudtik', 'kezadfely', 'sefud'], substring=\"d\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_4",
    "sat": "def sat(containers: List[str], strings=['fat', 'ju', 'biwugchn', 'k'], substring=\"ch\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['fat', 'ju', 'biwugchn', 'k'], substring=\"ch\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_5",
    "sat": "def sat(containers: List[str], strings=['r', 'lerozan', 'zylete', 'lecojo'], substring=\"le\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['r', 'lerozan', 'zylete', 'lecojo'], substring=\"le\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_6",
    "sat": "def sat(containers: List[str], strings: List[str]=[], substring=\"h\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=[], substring=\"h\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_7",
    "sat": "def sat(containers: List[str], strings=['tywexufeb', 'taxo', 'thwechym', ''], substring=\"we\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['tywexufeb', 'taxo', 'thwechym', ''], substring=\"we\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_8",
    "sat": "def sat(containers: List[str], strings=['fiji', 'w', 'jub', 'jiwin'], substring=\"\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['fiji', 'w', 'jub', 'jiwin'], substring=\"\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindContainers_9",
    "sat": "def sat(containers: List[str], strings=['muthdebic'], substring=\"th\"):\n    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "sols": [
      "def sol(strings=['muthdebic'], substring=\"th\"):\n    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_0",
    "sat": "def sat(nums: List[int], tot=14, prod=99):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=14, prod=99):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_1",
    "sat": "def sat(nums: List[int], tot=-12, prod=56):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=-12, prod=56):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_2",
    "sat": "def sat(nums: List[int], tot=-3, prod=-35):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=-3, prod=-35):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_3",
    "sat": "def sat(nums: List[int], tot=1, prod=18):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=1, prod=18):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_4",
    "sat": "def sat(nums: List[int], tot=9, prod=-79):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=9, prod=-79):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_5",
    "sat": "def sat(nums: List[int], tot=-1, prod=-27):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=-1, prod=-27):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_6",
    "sat": "def sat(nums: List[int], tot=-67, prod=-55):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=-67, prod=-55):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_7",
    "sat": "def sat(nums: List[int], tot=-48, prod=38):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=-48, prod=38):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_8",
    "sat": "def sat(nums: List[int], tot=45, prod=-44):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=45, prod=-44):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_9",
    "sat": "def sat(nums: List[int], tot=-78, prod=47):\n    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "sols": [
      "def sol(tot=-78, prod=47):\n    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_0",
    "sat": "def sat(sum_prod: List[int], nums=[1, 3, 2, -6, 19]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[1, 3, 2, -6, 19]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_1",
    "sat": "def sat(sum_prod: List[int], nums=[31, 5, -10]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[31, 5, -10]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_2",
    "sat": "def sat(sum_prod: List[int], nums=[-55, -67, -35]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[-55, -67, -35]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_3",
    "sat": "def sat(sum_prod: List[int], nums=[57]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[57]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_4",
    "sat": "def sat(sum_prod: List[int], nums=[-63]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[-63]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_5",
    "sat": "def sat(sum_prod: List[int], nums=[-78]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[-78]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_6",
    "sat": "def sat(sum_prod: List[int], nums=[-59, -86]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[-59, -86]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_7",
    "sat": "def sat(sum_prod: List[int], nums=[50, -3, 34]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[50, -3, 34]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_8",
    "sat": "def sat(sum_prod: List[int], nums=[92]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[92]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SumProduct_Trivial_9",
    "sat": "def sat(sum_prod: List[int], nums=[-8]):\n    \"\"\"\n    Find the sum and product of a list of numbers.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [12, 32]\n    \"\"\"\n    p = 1\n    for n in nums:\n        p *= n\n    return sum_prod == [sum(nums), p]",
    "sols": [
      "def sol(nums=[-8]):\n    p = 1\n    for n in nums:\n        p *= n\n    return [sum(nums), p]"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_0",
    "sat": "def sat(maxes: List[int], nums=[1, 4, 3, -6, 19]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[1, 4, 3, -6, 19]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[1, 4, 3, -6, 19]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_1",
    "sat": "def sat(maxes: List[int], nums=[-33, 84]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[-33, 84]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[-33, 84]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_2",
    "sat": "def sat(maxes: List[int], nums=[-83, -55, -67, -66, 14]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[-83, -55, -67, -66, 14]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[-83, -55, -67, -66, 14]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_3",
    "sat": "def sat(maxes: List[int], nums=[-87, -14, 44, -87, -56]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[-87, -14, 44, -87, -56]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[-87, -14, 44, -87, -56]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_4",
    "sat": "def sat(maxes: List[int], nums=[11, 4, -43]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[11, 4, -43]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[11, 4, -43]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_5",
    "sat": "def sat(maxes: List[int], nums=[-38, -97, 78]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[-38, -97, 78]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[-38, -97, 78]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_6",
    "sat": "def sat(maxes: List[int], nums=[-93, 41, -81, 63, 5]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[-93, 41, -81, 63, 5]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[-93, 41, -81, 63, 5]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_7",
    "sat": "def sat(maxes: List[int], nums: List[int]=[]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_8",
    "sat": "def sat(maxes: List[int], nums=[7, 94, 38, -94, 58, 96, -80, -56]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[7, 94, 38, -94, 58, 96, -80, -56]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[7, 94, 38, -94, 58, 96, -80, -56]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "RollingMax_9",
    "sat": "def sat(maxes: List[int], nums=[-41, 71, -65]):\n    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "sols": [
      "def sol(nums=[-41, 71, -65]):\n    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "def sol(nums=[-41, 71, -65]):\n    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_0",
    "sat": "def sat(ans: str, s=\"so easy\", length=13):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"so easy\", length=13):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_1",
    "sat": "def sat(ans: str, s=\"aabbab\", length=32):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"aabbab\", length=32):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_2",
    "sat": "def sat(ans: str, s=\"\", length=1):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"\", length=1):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_3",
    "sat": "def sat(ans: str, s=\"bab\", length=18):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"bab\", length=18):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_4",
    "sat": "def sat(ans: str, s=\"aabbbba\", length=34):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"aabbbba\", length=34):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_5",
    "sat": "def sat(ans: str, s=\"baabbaaa\", length=29):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"baabbaaa\", length=29):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_6",
    "sat": "def sat(ans: str, s=\"abaab\", length=13):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"abaab\", length=13):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_7",
    "sat": "def sat(ans: str, s=\"abababaabbbbaaaaa\", length=29):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"abababaabbbbaaaaa\", length=29):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_8",
    "sat": "def sat(ans: str, s=\"aaaaaa\", length=16):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"aaaaaa\", length=16):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeStartingWith_9",
    "sat": "def sat(ans: str, s=\"b\", length=6):\n    \"\"\"\n    Find a palindrome of a given length starting with a given string.\n\n    Sample Input:\n    \"foo\", 4\n\n    Sample Output:\n    \"foof\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and ans.startswith(s)",
    "sols": [
      "def sol(s=\"b\", length=6):\n    return s[:length // 2] + ' ' * (length - len(s) * 2) + s[:(length + 1) // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_0",
    "sat": "def sat(ans: str, s=\"so easy\", length=20):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"so easy\", length=20):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_1",
    "sat": "def sat(ans: str, s=\"baabaabb\", length=14):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"baabaabb\", length=14):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_2",
    "sat": "def sat(ans: str, s=\"\", length=13):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"\", length=13):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_3",
    "sat": "def sat(ans: str, s=\"\", length=14):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"\", length=14):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_4",
    "sat": "def sat(ans: str, s=\"baaabbabb\", length=36):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"baaabbabb\", length=36):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_5",
    "sat": "def sat(ans: str, s=\"\", length=3):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"\", length=3):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_6",
    "sat": "def sat(ans: str, s=\"bbbbabbbbaaabbbaa\", length=27):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"bbbbabbbbaaabbbaa\", length=27):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_7",
    "sat": "def sat(ans: str, s=\"ba\", length=18):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"ba\", length=18):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_8",
    "sat": "def sat(ans: str, s=\"ba\", length=8):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"ba\", length=8):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "PalindromeContaining_9",
    "sat": "def sat(ans: str, s=\"a\", length=1):\n    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "sols": [
      "def sol(s=\"a\", length=1):\n    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_0",
    "sat": "def sat(str_num: str, nums=['100011101100001', '100101100101110']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['100011101100001', '100101100101110']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_1",
    "sat": "def sat(str_num: str, nums=['1111001011', '1111011']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['1111001011', '1111011']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_2",
    "sat": "def sat(str_num: str, nums=['1011101', '110']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['1011101', '110']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_3",
    "sat": "def sat(str_num: str, nums=['111111100', '111110000']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['111111100', '111110000']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_4",
    "sat": "def sat(str_num: str, nums=['111010110', '11000011']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['111010110', '11000011']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_5",
    "sat": "def sat(str_num: str, nums=['110110011', '101001']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['110110011', '101001']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_6",
    "sat": "def sat(str_num: str, nums=['10011111', '101010']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['10011111', '101010']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_7",
    "sat": "def sat(str_num: str, nums=['101100110', '1011110011']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['101100110', '1011110011']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_8",
    "sat": "def sat(str_num: str, nums=['101001000', '1010000010']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['101001000', '1010000010']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BinaryStrXOR_9",
    "sat": "def sat(str_num: str, nums=['1010111101', '11']):\n    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "sols": [
      "def sol(nums=['1010111101', '11']):\n    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_0",
    "sat": "def sat(ans: str, words=['these', 'are', 'some', 'pretty', 'long', 'words']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['these', 'are', 'some', 'pretty', 'long', 'words']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_1",
    "sat": "def sat(ans: str, words=['chuxynazykygekifari', 'thexoxaxuth', 'matextenojivyd']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['chuxynazykygekifari', 'thexoxaxuth', 'matextenojivyd']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_2",
    "sat": "def sat(ans: str, words=['kothaketutext']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['kothaketutext']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_3",
    "sat": "def sat(ans: str, words=['h', 'bequupajazecudutadib', 'vyxuxuweru', 'gejohugebugitexte', 'quethuthemijythu']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['h', 'bequupajazecudutadib', 'vyxuxuweru', 'gejohugebugitexte', 'quethuthemijythu']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_4",
    "sat": "def sat(ans: str, words=['puh', 'caxychacuquezunumoro', 'textekuj', 'facuhigere', 'thazecyvejy', 'peba', 'pitextumuthapon', 'juritextakedy', 'w']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['puh', 'caxychacuquezunumoro', 'textekuj', 'facuhigere', 'thazecyvejy', 'peba', 'pitextumuthapon', 'juritextakedy', 'w']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_5",
    "sat": "def sat(ans: str, words=['thavitext', 'vuzabywynehobyfuhy', 'wufawubugokuxos', 'chiv', 'lexyvuv', 'kypyxathawykachefuc', 'jasatextikoxudidaf', 'gafa', 'xetochipejycuhyzavu']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['thavitext', 'vuzabywynehobyfuhy', 'wufawubugokuxos', 'chiv', 'lexyvuv', 'kypyxathawykachefuc', 'jasatextikoxudidaf', 'gafa', 'xetochipejycuhyzavu']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_6",
    "sat": "def sat(ans: str, words=['cokesahech', 'mochivoquotewififu', 'xudizyradythuq', 'ciqu']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['cokesahech', 'mochivoquotewififu', 'xudizyradythuq', 'ciqu']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_7",
    "sat": "def sat(ans: str, words=['xuvi', 'bevirig', 'hogynovypuhupachinu']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['xuvi', 'bevirig', 'hogynovypuhupachinu']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_8",
    "sat": "def sat(ans: str, words=['sely', 'zohyholuquenathahobo', 'wawovixedorachewyb']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['sely', 'zohyholuquenathahobo', 'wawovixedorachewyb']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LongestStr_9",
    "sat": "def sat(ans: str, words=['nolip', 'chejyluwit', 'suvoquenuchigadoci', 'coxoxef', 'quuhechekin', 'hotudinit', 'cyber']):\n    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "sols": [
      "def sol(words=['nolip', 'chejyluwit', 'suvoquenuchigadoci', 'coxoxef', 'quuhechekin', 'hotudinit', 'cyber']):\n    return max(words, key=len)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_0",
    "sat": "def sat(ans: List[int], m=1408862, n=2113293):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=1408862, n=2113293):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_1",
    "sat": "def sat(ans: List[int], m=721, n=721):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=721, n=721):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_2",
    "sat": "def sat(ans: List[int], m=86178834, n=6908621981870):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=86178834, n=6908621981870):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_3",
    "sat": "def sat(ans: List[int], m=41225167011, n=733912738612214):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=41225167011, n=733912738612214):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_4",
    "sat": "def sat(ans: List[int], m=512, n=99):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=512, n=99):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_5",
    "sat": "def sat(ans: List[int], m=20818411475, n=1010390):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=20818411475, n=1010390):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_6",
    "sat": "def sat(ans: List[int], m=43649907512734516, n=11611968592):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=43649907512734516, n=11611968592):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_7",
    "sat": "def sat(ans: List[int], m=369, n=61):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=369, n=61):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_8",
    "sat": "def sat(ans: List[int], m=6084254304, n=561952):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=6084254304, n=561952):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CertifiedGCD_9",
    "sat": "def sat(ans: List[int], m=13570217710519530, n=17235992111544552):\n    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "sols": [
      "def sol(m=13570217710519530, n=17235992111544552):\n    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_0",
    "sat": "def sat(prefixes: List[str], s=\"donesezichethofalij\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"donesezichethofalij\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_1",
    "sat": "def sat(prefixes: List[str], s=\"narychonuquylurovajekysinyj\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"narychonuquylurovajekysinyj\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_2",
    "sat": "def sat(prefixes: List[str], s=\"lomutextithu\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"lomutextithu\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_3",
    "sat": "def sat(prefixes: List[str], s=\"cikihagolitaz\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"cikihagolitaz\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_4",
    "sat": "def sat(prefixes: List[str], s=\"thepywogazechonoxarogepyky\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"thepywogazechonoxarogepyky\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_5",
    "sat": "def sat(prefixes: List[str], s=\"chyja\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"chyja\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_6",
    "sat": "def sat(prefixes: List[str], s=\"hoquefuzehonitextythur\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"hoquefuzehonitextythur\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_7",
    "sat": "def sat(prefixes: List[str], s=\"goducukisobuzuwicha\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"goducukisobuzuwicha\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_8",
    "sat": "def sat(prefixes: List[str], s=\"thafyzuthesa\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"thafyzuthesa\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "AllPrefixes_9",
    "sat": "def sat(prefixes: List[str], s=\"tyxositextupotet\"):\n    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "sols": [
      "def sol(s=\"tyxositextupotet\"):\n    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_0",
    "sat": "def sat(ans: str, n=15):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=15):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_1",
    "sat": "def sat(ans: str, n=57686):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=57686):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_2",
    "sat": "def sat(ans: str, n=52590):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=52590):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_3",
    "sat": "def sat(ans: str, n=12282):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=12282):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_4",
    "sat": "def sat(ans: str, n=88427):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=88427):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_5",
    "sat": "def sat(ans: str, n=52830):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=52830):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_6",
    "sat": "def sat(ans: str, n=51111):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=51111):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_7",
    "sat": "def sat(ans: str, n=3681):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=3681):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_8",
    "sat": "def sat(ans: str, n=10918):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=10918):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "SpaceyRange_9",
    "sat": "def sat(ans: str, n=86218):\n    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "sols": [
      "def sol(n=86218):\n    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_0",
    "sat": "def sat(ans: List[str], s=\"The quick brown fox jumps over the lazy dog!\", n=28):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"The quick brown fox jumps over the lazy dog!\", n=28):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_1",
    "sat": "def sat(ans: List[str], s=\"1UIam\", n=5):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"1UIam\", n=5):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_2",
    "sat": "def sat(ans: List[str], s=\"J)o3$RKv\", n=8):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"J)o3$RKv\", n=8):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_3",
    "sat": "def sat(ans: List[str], s=\"!\", n=1):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"!\", n=1):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_4",
    "sat": "def sat(ans: List[str], s=\"NODpu Zu)bmqFf\", n=12):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"NODpu Zu)bmqFf\", n=12):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_5",
    "sat": "def sat(ans: List[str], s=\"Qu6vsWV!(nal3aoz0v,\", n=16):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"Qu6vsWV!(nal3aoz0v,\", n=16):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_6",
    "sat": "def sat(ans: List[str], s=\"Ln|ZzWFm/b\", n=9):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"Ln|ZzWFm/b\", n=9):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_7",
    "sat": "def sat(ans: List[str], s=\"?gP@N]Y\", n=7):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"?gP@N]Y\", n=7):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_8",
    "sat": "def sat(ans: List[str], s=\"D!E15\", n=5):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"D!E15\", n=5):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "DistinctChars_9",
    "sat": "def sat(ans: List[str], s=\"Hh Rk0(a#%\", n=9):\n    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "sols": [
      "def sol(s=\"Hh Rk0(a#%\", n=9):\n    return list(set(s.lower()))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_0",
    "sat": "def sat(beats: List[int], score=\"o o o| o| .| .| .| o| o| o o o| .|\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"o o o| o| .| .| .| o| o| o o o| .|\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_1",
    "sat": "def sat(beats: List[int], score=\"o| o| o| o| o o| .| o o\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"o| o| o| o| o o| .| o o\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_2",
    "sat": "def sat(beats: List[int], score=\"\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_3",
    "sat": "def sat(beats: List[int], score=\".| o| o| o| .| .|\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\".| o| o| o| .| .|\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_4",
    "sat": "def sat(beats: List[int], score=\"o| .| o o\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"o| .| o o\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_5",
    "sat": "def sat(beats: List[int], score=\".| .| .| o| .| .|\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\".| .| .| o| .| .|\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_6",
    "sat": "def sat(beats: List[int], score=\"o|\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"o|\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_7",
    "sat": "def sat(beats: List[int], score=\"o| o| o| .| o| o o o .| o .|\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"o| o| o| .| o| o o o .| o .|\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_8",
    "sat": "def sat(beats: List[int], score=\".| .| .| .| o .| .| o o\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\".| .| .| .| o .| .| o o\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParseMusic_9",
    "sat": "def sat(beats: List[int], score=\"o\"):\n    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "sols": [
      "def sol(score=\"o\"):\n    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_0",
    "sat": "def sat(ans: List[int], s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_1",
    "sat": "def sat(ans: List[int], s=\"gulyjybechociquychezyzocubecaxodytheleluxuholupimi\", sub=\"chociquyche\", count=1):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"gulyjybechociquychezyzocubecaxodytheleluxuholupimi\", sub=\"chociquyche\", count=1):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_2",
    "sat": "def sat(ans: List[int], s=\"wyjifethugibathosetyfezidechy\", sub=\"setyfezi\", count=1):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"wyjifethugibathosetyfezidechy\", sub=\"setyfezi\", count=1):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_3",
    "sat": "def sat(ans: List[int], s=\"tafyvew\", sub=\"tafyv\", count=1):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"tafyvew\", sub=\"tafyv\", count=1):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_4",
    "sat": "def sat(ans: List[int], s=\"jypachaturyxiquyfufaponotimusesorepenevyquucivyperedowuvid\", sub=\"qu\", count=2):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"jypachaturyxiquyfufaponotimusesorepenevyquucivyperedowuvid\", sub=\"qu\", count=2):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_5",
    "sat": "def sat(ans: List[int], s=\"zygirigulanet\", sub=\"ygirigul\", count=1):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"zygirigulanet\", sub=\"ygirigul\", count=1):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_6",
    "sat": "def sat(ans: List[int], s=\"quonujetextiwequyzeq\", sub=\"nujetext\", count=1):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"quonujetextiwequyzeq\", sub=\"nujetext\", count=1):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_7",
    "sat": "def sat(ans: List[int], s=\"gedobemyxekalegimogyzomykoche\", sub=\"egim\", count=1):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"gedobemyxekalegimogyzomykoche\", sub=\"egim\", count=1):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_8",
    "sat": "def sat(ans: List[int], s=\"bityvobizinetextu\", sub=\"b\", count=2):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"bityvobizinetextu\", sub=\"b\", count=2):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "OverlappingCount_9",
    "sat": "def sat(ans: List[int], s=\"tatysexalapycocarowocijybakychoguxymisuwufafiwedyfyruhichipikawonutuzywatextopakykacyr\", sub=\"c\", count=6):\n    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "sols": [
      "def sol(s=\"tatysexalapycocarowocijybakychoguxymisuwufafiwedyfyruhichipikawonutuzywatextopakykacyr\", sub=\"c\", count=6):\n    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_0",
    "sat": "def sat(ans: str, s=\"six one four three two nine eight\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"six one four three two nine eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_1",
    "sat": "def sat(ans: str, s=\"five zero five eight eight eight\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"five zero five eight eight eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_2",
    "sat": "def sat(ans: str, s=\"zero five four five three\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"zero five four five three\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_3",
    "sat": "def sat(ans: str, s=\"four eight three one nine four\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"four eight three one nine four\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_4",
    "sat": "def sat(ans: str, s=\"four three three nine six seven six\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"four three three nine six seven six\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_5",
    "sat": "def sat(ans: str, s=\"five zero two four zero six\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"five zero two four zero six\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_6",
    "sat": "def sat(ans: str, s=\"nine six zero five\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"nine six zero five\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_7",
    "sat": "def sat(ans: str, s=\"three zero eight three two seven nine\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"three zero eight three two seven nine\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_8",
    "sat": "def sat(ans: str, s=\"zero five three six one five eight\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"zero five three six one five eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "SortNumbers_9",
    "sat": "def sat(ans: str, s=\"two one two five one zero eight six\"):\n    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "sols": [
      "def sol(s=\"two one two five one zero eight six\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_0",
    "sat": "def sat(inds: List[int], nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_1",
    "sat": "def sat(inds: List[int], nums=[-7.100774460186852, 8.214376030545353, -1.7009204096212844, -8.823734880201869, -7.698423480359862, -7.100774460186852, 0.7591071890698604, -1.0422539455003275, 7.61764114066365, 2.294996063292947]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[-7.100774460186852, 8.214376030545353, -1.7009204096212844, -8.823734880201869, -7.698423480359862, -7.100774460186852, 0.7591071890698604, -1.0422539455003275, 7.61764114066365, 2.294996063292947]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_2",
    "sat": "def sat(inds: List[int], nums=[2.856398660224288, -9.957900856301347, 3.204617799899715, 7.742015968889515, -4.58467253278166, 6.685580022725301, 5.874082594196565, -2.0381023120854014]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[2.856398660224288, -9.957900856301347, 3.204617799899715, 7.742015968889515, -4.58467253278166, 6.685580022725301, 5.874082594196565, -2.0381023120854014]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_3",
    "sat": "def sat(inds: List[int], nums=[-2.3914795446784094, 3.2614247105169873, 7.733833264823392, -0.8571404735187205, 1.7141258601487657, -2.0182346895314707]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[-2.3914795446784094, 3.2614247105169873, 7.733833264823392, -0.8571404735187205, 1.7141258601487657, -2.0182346895314707]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_4",
    "sat": "def sat(inds: List[int], nums=[-8.216988467741434, 9.962997852406524, -1.408013499267529, 6.553809251575128, 4.500407651339263, -2.762791549360837, -9.469641423316887]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[-8.216988467741434, 9.962997852406524, -1.408013499267529, 6.553809251575128, 4.500407651339263, -2.762791549360837, -9.469641423316887]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_5",
    "sat": "def sat(inds: List[int], nums=[7.771434249725896, 8.696961130226377, -2.93742321896707, -8.959898086741395, -6.195698682308235, 2.6809604995128495, 5.316064658415678, -1.7745212100489134]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[7.771434249725896, 8.696961130226377, -2.93742321896707, -8.959898086741395, -6.195698682308235, 2.6809604995128495, 5.316064658415678, -1.7745212100489134]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_6",
    "sat": "def sat(inds: List[int], nums=[-4.668905979667681, -4.668905979667681, -8.462898731914157, -5.784550067357735, -4.516989318615272, 9.407447927908478, 4.983462341854082, -2.4309984314638626, -4.261682358880517, -0.5031981597626967]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[-4.668905979667681, -4.668905979667681, -8.462898731914157, -5.784550067357735, -4.516989318615272, 9.407447927908478, 4.983462341854082, -2.4309984314638626, -4.261682358880517, -0.5031981597626967]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_7",
    "sat": "def sat(inds: List[int], nums=[8.538444536239833, 5.152023771669036, 5.082843301065216, 3.5108130217372633]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[8.538444536239833, 5.152023771669036, 5.082843301065216, 3.5108130217372633]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_8",
    "sat": "def sat(inds: List[int], nums=[5.8222203969109, -8.011203866157409, -3.1187447722248756, 2.4820495316314393, -4.817574983608179, 0.5489639026371496, -5.854710414120669, -5.854710414120669]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[5.8222203969109, -8.011203866157409, -3.1187447722248756, 2.4820495316314393, -4.817574983608179, 0.5489639026371496, -5.854710414120669, -5.854710414120669]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindClosePair_9",
    "sat": "def sat(inds: List[int], nums=[-2.416494140583332, -2.556348207992418]):\n    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "sols": [
      "def sol(nums=[-2.416494140583332, -2.556348207992418]):\n    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_0",
    "sat": "def sat(ans: List[float], nums=[13.0, 17.0, 17.0, 15.5, 2.94]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[13.0, 17.0, 17.0, 15.5, 2.94]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_1",
    "sat": "def sat(ans: List[float], nums=[4.375436807988567, 1.1936024735670099, -0.4422772321919341, -0.6288097011516314, -30.541263962133545, 0.12157957613488131, -21.162753933381225, -0.10811553087129984, 0.7770547763111839]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[4.375436807988567, 1.1936024735670099, -0.4422772321919341, -0.6288097011516314, -30.541263962133545, 0.12157957613488131, -21.162753933381225, -0.10811553087129984, 0.7770547763111839]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_2",
    "sat": "def sat(ans: List[float], nums=[-9.295344757623715, 0.13513982782910886]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[-9.295344757623715, 0.13513982782910886]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_3",
    "sat": "def sat(ans: List[float], nums=[-0.563513842494808, -0.6578650257661035, -0.4321040743415739, 7.646619164449988, 0.16462510963972635]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[-0.563513842494808, -0.6578650257661035, -0.4321040743415739, 7.646619164449988, 0.16462510963972635]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_4",
    "sat": "def sat(ans: List[float], nums=[-11.764906213704284, -0.8344378822429834, 0.3255430110469843, -18.20690097667145, 0.4993303427358898, -0.27554144463715313, 3.027526455865262, -0.968896064266663]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[-11.764906213704284, -0.8344378822429834, 0.3255430110469843, -18.20690097667145, 0.4993303427358898, -0.27554144463715313, 3.027526455865262, -0.968896064266663]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_5",
    "sat": "def sat(ans: List[float], nums=[-4.035470390431591, 0.20759444412587102, -0.0832753897121794, 0.09137141564683482, -0.12561763880166557, 564.9147171469245, -1.5005816820004132]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[-4.035470390431591, 0.20759444412587102, -0.0832753897121794, 0.09137141564683482, -0.12561763880166557, 564.9147171469245, -1.5005816820004132]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_6",
    "sat": "def sat(ans: List[float], nums=[-333.11579456758426, 0.5000298908760158, -0.878359137141477, -119.47559024844162, 24.91451440588779, 0.10362862528492227, 0.098034270306855, 0.601373225107737, -620.029230525705]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[-333.11579456758426, 0.5000298908760158, -0.878359137141477, -119.47559024844162, 24.91451440588779, 0.10362862528492227, 0.098034270306855, 0.601373225107737, -620.029230525705]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_7",
    "sat": "def sat(ans: List[float], nums=[98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368, 98.04121877237368]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_8",
    "sat": "def sat(ans: List[float], nums=[0.490974812394292, 0.490974812394292]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[0.490974812394292, 0.490974812394292]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Rescale_9",
    "sat": "def sat(ans: List[float], nums=[-14.098218500957131, -14.098218500957131, -14.098218500957131]):\n    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "sols": [
      "def sol(nums=[-14.098218500957131, -14.098218500957131, -14.098218500957131]):\n    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "FilterInts_0",
    "sat": "def sat(indexes: List[int], li=['Hello', '5', '10', 'bye'], num=2):\n    \"\"\"\n    Find the indices of valid python integers in a list of strings\n\n    Sample input\n    ---\n    [\"18.5\", \"-1\", \"2+2\", \"7\", \"foo\"]\n\n    Sample output\n    ---\n    [1, 3]\n    \"\"\"\n    [int(li[i]) for i in indexes]\n    return len(set(indexes)) >= num and min(indexes) >= 0",
    "sols": [
      "def sol(li=['Hello', '5', '10', 'bye'], num=2):\n    ans = []\n    for i in range(len(li)):\n        try:\n            int(li[i])\n            ans.append(i)\n        except:\n            pass\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_0",
    "sat": "def sat(length: int, s=\"pneumonoultramicroscopicsilicovolcanoconiosis\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"pneumonoultramicroscopicsilicovolcanoconiosis\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_1",
    "sat": "def sat(length: int, s=\"U7CJMV.q-#mZ=y#-yK)aS zgXz(zN8NE-<gw**Vn@bj@\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"U7CJMV.q-#mZ=y#-yK)aS zgXz(zN8NE-<gw**Vn@bj@\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_2",
    "sat": "def sat(length: int, s=\"T6R\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"T6R\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_3",
    "sat": "def sat(length: int, s=\">OLk+cAj6k69KgF/iL4hNPXf^g#cf!X&[5Dx6Gb7jt?SM[!W%\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\">OLk+cAj6k69KgF/iL4hNPXf^g#cf!X&[5Dx6Gb7jt?SM[!W%\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_4",
    "sat": "def sat(length: int, s=\"s2+-#^vd.LL<c#w05 dBS;*!D<6=s4Q\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"s2+-#^vd.LL<c#w05 dBS;*!D<6=s4Q\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_5",
    "sat": "def sat(length: int, s=\"cF4Bj5B&H<2;:G$=Wvb?-o->l]\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"cF4Bj5B&H<2;:G$=Wvb?-o->l]\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_6",
    "sat": "def sat(length: int, s=\"*w55c=6]Av$X/(f>|JdI@VHD0R=y7yE,%0z\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"*w55c=6]Av$X/(f>|JdI@VHD0R=y7yE,%0z\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_7",
    "sat": "def sat(length: int, s=\"L6TS7O/!#P@NeGDe3)9=v:(a)J@H\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"L6TS7O/!#P@NeGDe3)9=v:(a)J@H\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_8",
    "sat": "def sat(length: int, s=\"ms6=6cKDq,KKF.B/*]?O;R?X[R\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"ms6=6cKDq,KKF.B/*]?O;R?X[R\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrLength_9",
    "sat": "def sat(length: int, s=\"&q,bA[3ypJ6!C*?6U ]Q 0myc+[%(S&fY)y\"):\n    \"\"\"\n    Find the length of a non-empty string\n\n    Sample input\n    ---\n    \"foo\"\n\n    Sample output\n    ---\n    3\n    \"\"\"\n    try:\n        s[length]\n    except IndexError:\n        s[length - 1]\n        return True",
    "sols": [
      "def sol(s=\"&q,bA[3ypJ6!C*?6U ]Q 0myc+[%(S&fY)y\"):\n    return len(s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_0",
    "sat": "def sat(d: int, n=123456):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=123456):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_1",
    "sat": "def sat(d: int, n=56865):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=56865):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_2",
    "sat": "def sat(d: int, n=30769):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=30769):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_3",
    "sat": "def sat(d: int, n=19008):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=19008):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_4",
    "sat": "def sat(d: int, n=78477):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=78477):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_5",
    "sat": "def sat(d: int, n=83312):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=83312):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_6",
    "sat": "def sat(d: int, n=55485):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=55485):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_7",
    "sat": "def sat(d: int, n=84906):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=84906):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_8",
    "sat": "def sat(d: int, n=84197):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=84197):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestDivisor_9",
    "sat": "def sat(d: int, n=36714):\n    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "sols": [
      "def sol(n=36714):\n    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_0",
    "sat": "def sat(factors: List[int], n=123456, num_factors=8):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=123456, num_factors=8):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_1",
    "sat": "def sat(factors: List[int], n=754319, num_factors=4):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=754319, num_factors=4):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_2",
    "sat": "def sat(factors: List[int], n=126576392075, num_factors=9):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=126576392075, num_factors=9):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_3",
    "sat": "def sat(factors: List[int], n=24440, num_factors=6):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=24440, num_factors=6):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_4",
    "sat": "def sat(factors: List[int], n=65968, num_factors=7):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=65968, num_factors=7):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_5",
    "sat": "def sat(factors: List[int], n=1272150880, num_factors=12):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=1272150880, num_factors=12):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_6",
    "sat": "def sat(factors: List[int], n=13127296, num_factors=12):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=13127296, num_factors=12):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_7",
    "sat": "def sat(factors: List[int], n=37764002270592, num_factors=16):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=37764002270592, num_factors=16):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_8",
    "sat": "def sat(factors: List[int], n=789824, num_factors=9):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=789824, num_factors=9):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFactorization_9",
    "sat": "def sat(factors: List[int], n=14273248, num_factors=9):\n    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "sols": [
      "def sol(n=14273248, num_factors=9):\n    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_0",
    "sat": "def sat(ans: List[int], li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_1",
    "sat": "def sat(ans: List[int], li=[1, 3, 7, 2, 1, 6]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[1, 3, 7, 2, 1, 6]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_2",
    "sat": "def sat(ans: List[int], li=[7, 5, 4, 1, 3, 0, 8, 0, 3, 6, 5, 7, 1]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[7, 5, 4, 1, 3, 0, 8, 0, 3, 6, 5, 7, 1]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_3",
    "sat": "def sat(ans: List[int], li=[8, 6, 5, 8, 8, 2, 1, 8, 1]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[8, 6, 5, 8, 8, 2, 1, 8, 1]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_4",
    "sat": "def sat(ans: List[int], li=[3, 2, 2, 9, 8, 6, 0, 7, 1, 4, 7, 2]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[3, 2, 2, 9, 8, 6, 0, 7, 1, 4, 7, 2]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_5",
    "sat": "def sat(ans: List[int], li=[1, 0, 5, 1, 3, 8, 5, 9, 3, 4, 4, 8, 1, 2, 6, 9]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[1, 0, 5, 1, 3, 8, 5, 9, 3, 4, 4, 8, 1, 2, 6, 9]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_6",
    "sat": "def sat(ans: List[int], li=[7, 1, 9, 0, 7]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[7, 1, 9, 0, 7]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_7",
    "sat": "def sat(ans: List[int], li=[1, 2, 9, 1, 7, 7, 2, 2]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[1, 2, 9, 1, 7, 7, 2, 2]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_8",
    "sat": "def sat(ans: List[int], li=[5, 6]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[5, 6]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Dedup_9",
    "sat": "def sat(ans: List[int], li=[2, 8, 3]):\n    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "sols": [
      "def sol(li=[2, 8, 3]):\n    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_0",
    "sat": "def sat(ans: str, s=\"FlIp ME!\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"FlIp ME!\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_1",
    "sat": "def sat(ans: str, s=\"3nI\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"3nI\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_2",
    "sat": "def sat(ans: str, s=\"t3m.!gnfB!\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"t3m.!gnfB!\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_3",
    "sat": "def sat(ans: str, s=\"b!\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"b!\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_4",
    "sat": "def sat(ans: str, s=\"/ \"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"/ \"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_5",
    "sat": "def sat(ans: str, s=\"X3G3J%:3pA-3\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"X3G3J%:3pA-3\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_6",
    "sat": "def sat(ans: str, s=\"!1#5FDR3 L\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"!1#5FDR3 L\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_7",
    "sat": "def sat(ans: str, s=\" 16P3r!kz!f^)H\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\" 16P3r!kz!f^)H\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_8",
    "sat": "def sat(ans: str, s=\"JSBA\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"JSBA\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FlipCase_9",
    "sat": "def sat(ans: str, s=\"Tl$wXSsE3wV0N j!\"):\n    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "sols": [
      "def sol(s=\"Tl$wXSsE3wV0N j!\"):\n    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_0",
    "sat": "def sat(cat: str, strings=['Will', 'i', 'am', 'Now', 'here']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['Will', 'i', 'am', 'Now', 'here']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_1",
    "sat": "def sat(cat: str, strings=['jilyxotex', 'kedafifazuchate', 'chawisemafur', 'wytextoguwodiby', 'xafenisefilup', 'quegechethyx', 'tiquenagotyvanethu']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['jilyxotex', 'kedafifazuchate', 'chawisemafur', 'wytextoguwodiby', 'xafenisefilup', 'quegechethyx', 'tiquenagotyvanethu']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_2",
    "sat": "def sat(cat: str, strings=['texto', 'syruthufokimewuchak', 'fasaboxuth', 'rute']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['texto', 'syruthufokimewuchak', 'fasaboxuth', 'rute']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_3",
    "sat": "def sat(cat: str, strings: List[str]=[]):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=[]):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_4",
    "sat": "def sat(cat: str, strings=['bir', 'rythyde', 'wycufypi', 'do', 'lacyby', 'fasucha']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['bir', 'rythyde', 'wycufypi', 'do', 'lacyby', 'fasucha']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_5",
    "sat": "def sat(cat: str, strings=['jotorowivecalulylec', 'cezevymutextuquitot', 'ryg', 'sitextathijunyt', 'chychahacujyk', 'gadoty', 'lefizojyvazujyteryvo', 'senomochufipap']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['jotorowivecalulylec', 'cezevymutextuquitot', 'ryg', 'sitextathijunyt', 'chychahacujyk', 'gadoty', 'lefizojyvazujyteryvo', 'senomochufipap']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_6",
    "sat": "def sat(cat: str, strings=['tygesixefazovy', 'puvyj', 'lozal', 'zepa', 'heq', 'hew', 'wowy', 'huxo', 'dexat']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['tygesixefazovy', 'puvyj', 'lozal', 'zepa', 'heq', 'hew', 'wowy', 'huxo', 'dexat']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_7",
    "sat": "def sat(cat: str, strings=['bicopiquoquiwyx', 'vy', 'bogoquosojyfeze', 'chagaza', 'megym', 'p', 'za', 'tekuwopenico', 'quevokocapyb']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['bicopiquoquiwyx', 'vy', 'bogoquosojyfeze', 'chagaza', 'megym', 'p', 'za', 'tekuwopenico', 'quevokocapyb']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_8",
    "sat": "def sat(cat: str, strings=['wybux', 'fosuhihuluhachateque', 'muhypychilo', 'chyde', 'helefawamo', 'vy', 'xit']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['wybux', 'fosuhihuluhachateque', 'muhypychilo', 'chyde', 'helefawamo', 'vy', 'xit']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "CatStrings_9",
    "sat": "def sat(cat: str, strings=['dytyjasywodovixethop', 'thuhelathifynawy', 'nech', 'kugoxuchimy', 'kenog', 'xinabytextythupave']):\n    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "sols": [
      "def sol(strings=['dytyjasywodovixethop', 'thuhelathifynawy', 'nech', 'kugoxuchimy', 'kenog', 'xinabytextythupave']):\n    return \"\".join(strings)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_0",
    "sat": "def sat(extensions: List[str], strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_1",
    "sat": "def sat(extensions: List[str], strings=['futh', 'zuquy'], prefix=\"zu\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['futh', 'zuquy'], prefix=\"zu\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_2",
    "sat": "def sat(extensions: List[str], strings: List[str]=[], prefix=\"\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=[], prefix=\"\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_3",
    "sat": "def sat(extensions: List[str], strings=['hitin', 'dej', 'gu', 'nozo'], prefix=\"\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['hitin', 'dej', 'gu', 'nozo'], prefix=\"\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_4",
    "sat": "def sat(extensions: List[str], strings=['f', 'chewa', 'sa'], prefix=\"\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['f', 'chewa', 'sa'], prefix=\"\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_5",
    "sat": "def sat(extensions: List[str], strings=['b', 'hek', 'x', 'we', 'heks'], prefix=\"hek\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['b', 'hek', 'x', 'we', 'heks'], prefix=\"hek\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_6",
    "sat": "def sat(extensions: List[str], strings=['xupzapug', 'd', 'xupw', 'xupthuzo', 'xupnera'], prefix=\"xup\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['xupzapug', 'd', 'xupw', 'xupthuzo', 'xupnera'], prefix=\"xup\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_7",
    "sat": "def sat(extensions: List[str], strings=['quid', 'bwe'], prefix=\"b\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['quid', 'bwe'], prefix=\"b\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_8",
    "sat": "def sat(extensions: List[str], strings=['kus'], prefix=\"mij\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['kus'], prefix=\"mij\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindExtensions_9",
    "sat": "def sat(extensions: List[str], strings=['gafe', 'chit', 'g'], prefix=\"g\"):\n    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "sols": [
      "def sol(strings=['gafe', 'chit', 'g'], prefix=\"g\"):\n    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_0",
    "sat": "def sat(positives: List[int], nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_1",
    "sat": "def sat(positives: List[int], nums=[74, -81, -92, -61, -66, 3, 45, 49]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[74, -81, -92, -61, -66, 3, 45, 49]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_2",
    "sat": "def sat(positives: List[int], nums=[-12, 71, -18, 60]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[-12, 71, -18, 60]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_3",
    "sat": "def sat(positives: List[int], nums=[-47, 97, -18, 40, -18, 86, -80, 64]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[-47, 97, -18, 40, -18, 86, -80, 64]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_4",
    "sat": "def sat(positives: List[int], nums=[40, 47, -69, -90, -72]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[40, 47, -69, -90, -72]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_5",
    "sat": "def sat(positives: List[int], nums=[64]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[64]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_6",
    "sat": "def sat(positives: List[int], nums=[-87, -94, -3, -51]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[-87, -94, -3, -51]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_7",
    "sat": "def sat(positives: List[int], nums=[-62, 46]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[-62, 46]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_8",
    "sat": "def sat(positives: List[int], nums=[-62, -88, 17]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[-62, -88, 17]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindPositives_9",
    "sat": "def sat(positives: List[int], nums=[-65, 1, -37, 53, 65, 78, -28, 60, -16]):\n    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "sols": [
      "def sol(nums=[-65, 1, -37, 53, 65, 78, -28, 60, -16]):\n    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_0",
    "sat": "def sat(certificate: int, n=1449):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=1449):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_1",
    "sat": "def sat(certificate: int, n=655104277):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=655104277):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_2",
    "sat": "def sat(certificate: int, n=920168717):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=920168717):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_3",
    "sat": "def sat(certificate: int, n=4983298341):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=4983298341):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_4",
    "sat": "def sat(certificate: int, n=3913828247):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=3913828247):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_5",
    "sat": "def sat(certificate: int, n=2104081263):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=2104081263):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_6",
    "sat": "def sat(certificate: int, n=5244805773):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=5244805773):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_7",
    "sat": "def sat(certificate: int, n=652935809):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=652935809):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_8",
    "sat": "def sat(certificate: int, n=906851145):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=906851145):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "FermatComposite_9",
    "sat": "def sat(certificate: int, n=9802903371):\n    \"\"\"\n    Find a Fermat composite certificate for a number n > 1\n\n    Sample Input:\n    1469\n\n    Sample Output:\n    3  # because (3 ** 1468) % 1469 != 1\n    \"\"\"\n    return pow(certificate, n - 1, n) > 1",
    "sols": [
      "def sol(n=9802903371):\n    return next(i for i in range(2, n) if pow(i, n - 1, n) > 1)"
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_0",
    "sat": "def sat(root: float, coeffs=[1, 2, 3, 17]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[1, 2, 3, 17]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_1",
    "sat": "def sat(root: float, coeffs=[-1, 1, -5, 4, -10, 1]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[-1, 1, -5, 4, -10, 1]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_2",
    "sat": "def sat(root: float, coeffs=[2, 6, -2, -2, -4, 4]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[2, 6, -2, -2, -4, 4]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_3",
    "sat": "def sat(root: float, coeffs=[-3, -6, -1, 2]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[-3, -6, -1, 2]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_4",
    "sat": "def sat(root: float, coeffs=[-8, -5, 2, -1, -10, 6, 2, 7, 3, 5]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[-8, -5, 2, -1, -10, 6, 2, 7, 3, 5]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_5",
    "sat": "def sat(root: float, coeffs=[-3, 1]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[-3, 1]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_6",
    "sat": "def sat(root: float, coeffs=[0, 3, 8, 9]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[0, 3, 8, 9]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_7",
    "sat": "def sat(root: float, coeffs=[1, -4, -2, -8, -1, 1]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[1, -4, -2, -8, -1, 1]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_8",
    "sat": "def sat(root: float, coeffs=[-2, 4]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[-2, 4]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "OddDegreePolynomialRoot_9",
    "sat": "def sat(root: float, coeffs=[1, -5, 1, 5, 9, 2]):\n    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "sols": [
      "def sol(coeffs=[1, -5, 1, 5, 9, 2]):\n    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_0",
    "sat": "def sat(li: List[int], orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_1",
    "sat": "def sat(li: List[int], orig=[8]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[8]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_2",
    "sat": "def sat(li: List[int], orig=[7]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[7]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_3",
    "sat": "def sat(li: List[int], orig=[4, 9, -3]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[4, 9, -3]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_4",
    "sat": "def sat(li: List[int], orig=[-6, -1, -2, 9, -1, -3, -6, -1, 0, -9, -4, 6, -5, 3, -10, -3, -1, 2]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[-6, -1, -2, 9, -1, -3, -6, -1, 0, -9, -4, 6, -5, 3, -10, -3, -1, 2]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_5",
    "sat": "def sat(li: List[int], orig=[8, 2, -3, -10, -2]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[8, 2, -3, -10, -2]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_6",
    "sat": "def sat(li: List[int], orig=[7, 5, 3, 7, -2, 1, -6, 7, 3, 9]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[7, 5, 3, 7, -2, 1, -6, 7, 3, 9]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_7",
    "sat": "def sat(li: List[int], orig=[1, 1, 4, 7, 9, 3, 8, 4, -1, -8, -7, -5, -3, -7, -7]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[1, 1, 4, 7, 9, 3, 8, 4, -1, -8, -7, -5, -3, -7, -7]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_8",
    "sat": "def sat(li: List[int], orig: List[int]=[]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "TwoThirdsSorted_9",
    "sat": "def sat(li: List[int], orig=[-1, 6, -1, 9, 0, 2, 7, -5, -5, -5, 4, 9, 5, 7, -3, 4]):\n    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "sols": [
      "def sol(orig=[-1, 6, -1, 9, 0, 2, 7, -5, -5, -5, 4, 9, 5, 7, -3, 4]):\n    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_0",
    "sat": "def sat(li: List[int], orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_1",
    "sat": "def sat(li: List[int], orig=[1, -3, -7, -9, 8, 2, -2, 8, -3, 0, -3, 0, -9, 3]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[1, -3, -7, -9, 8, 2, -2, 8, -3, 0, -3, 0, -9, 3]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_2",
    "sat": "def sat(li: List[int], orig=[-4, 3, -8, -9, 9, 1, 8, -2, 6, 1, -5, 0, 7, -2, -9, 4, 0, -7, 9]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[-4, 3, -8, -9, 9, 1, 8, -2, 6, 1, -5, 0, 7, -2, -9, 4, 0, -7, 9]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_3",
    "sat": "def sat(li: List[int], orig=[-2, -1, -1, 1, 5, -8, -10, 4, 5, 9, 3, 0, -3]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[-2, -1, -1, 1, 5, -8, -10, 4, 5, 9, 3, 0, -3]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_4",
    "sat": "def sat(li: List[int], orig=[9, -1, 1, 8, 6]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[9, -1, 1, 8, 6]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_5",
    "sat": "def sat(li: List[int], orig=[-6, 5, 6, -5, 9]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[-6, 5, 6, -5, 9]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_6",
    "sat": "def sat(li: List[int], orig=[9, 4, 5, 5, -9, -3, -10, 8, 5, 2, 2, 5, 7]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[9, 4, 5, 5, -9, -3, -10, 8, 5, 2, 2, 5, 7]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_7",
    "sat": "def sat(li: List[int], orig=[-9, -3, 4]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[-9, -3, 4]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_8",
    "sat": "def sat(li: List[int], orig=[3, -7, 4, -3, -4]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[3, -7, 4, -3, -4]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "UniqueSorted_9",
    "sat": "def sat(li: List[int], orig=[-5, -7, -10, 6]):\n    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "sols": [
      "def sol(orig=[-5, -7, -10, 6]):\n    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_0",
    "sat": "def sat(m: int, hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 35, 35, 21, 18, 2, 60]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 35, 35, 21, 18, 2, 60]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_1",
    "sat": "def sat(m: int, hello=[-4, -4, 0, -1, -1, 6, 7, -5, -10, -6, 7, -5]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[-4, -4, 0, -1, -1, 6, 7, -5, -10, -6, 7, -5]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_2",
    "sat": "def sat(m: int, hello=[-6, -6]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[-6, -6]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_3",
    "sat": "def sat(m: int, hello=[7, -9, 2, -8, -8, -8, -3, 9, -2, 5]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[7, -9, 2, -8, -8, -8, -3, 9, -2, 5]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_4",
    "sat": "def sat(m: int, hello=[6, 8, 6, 1, 5, -2, -4, -2]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[6, 8, 6, 1, 5, -2, -4, -2]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_5",
    "sat": "def sat(m: int, hello=[9, 2, 4, -8, 3, -6, 9]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[9, 2, 4, -8, 3, -6, 9]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_6",
    "sat": "def sat(m: int, hello=[1, -5]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[1, -5]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_7",
    "sat": "def sat(m: int, hello=[-2, -3, -9, 4]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[-2, -3, -9, 4]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_8",
    "sat": "def sat(m: int, hello=[-5, 9, 5, 0, -4, 0, 4, -3, -6, -4, 7]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[-5, 9, 5, 0, -4, 0, 4, -3, -6, -4, 7]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "MaxInt_9",
    "sat": "def sat(m: int, hello=[3, 9, -2, 0, -5, -3, 3, 8, 8, 0, -4]):\n    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"\n    return m in hello and not any(m < i for i in hello)",
    "sols": [
      "def sol(hello=[3, 9, -2, 0, -5, -3, 3, 8, 8, 0, -4]):\n    return max(hello)"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_0",
    "sat": "def sat(li: List[List[int]], n=19723, lower=1000):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=19723, lower=1000):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_1",
    "sat": "def sat(li: List[List[int]], n=10, lower=0):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=10, lower=0):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_2",
    "sat": "def sat(li: List[List[int]], n=63, lower=0):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=63, lower=0):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_3",
    "sat": "def sat(li: List[List[int]], n=80, lower=3):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=80, lower=3):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_4",
    "sat": "def sat(li: List[List[int]], n=98, lower=3):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=98, lower=3):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_5",
    "sat": "def sat(li: List[List[int]], n=99, lower=3):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=99, lower=3):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_6",
    "sat": "def sat(li: List[List[int]], n=127, lower=4):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=127, lower=4):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_7",
    "sat": "def sat(li: List[List[int]], n=132, lower=4):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=132, lower=4):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_8",
    "sat": "def sat(li: List[List[int]], n=138, lower=4):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=138, lower=4):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "SevenElevenThirteen_9",
    "sat": "def sat(li: List[List[int]], n=153, lower=4):\n    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "sols": [
      "def sol(n=153, lower=4):\n    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_0",
    "sat": "def sat(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_1",
    "sat": "def sat(li: List[int], orig=[3, 6, 3, -3, -6, 1, 1, -2, -2, -3, 9, -6, 1, 9, 4, -9, -8, -4, 0]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[3, 6, 3, -3, -6, 1, 1, -2, -2, -3, 9, -6, 1, 9, 4, -9, -8, -4, 0]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_2",
    "sat": "def sat(li: List[int], orig=[1, -1, 5]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[1, -1, 5]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_3",
    "sat": "def sat(li: List[int], orig=[-4, 6, 1, -3]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-4, 6, 1, -3]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_4",
    "sat": "def sat(li: List[int], orig=[-9, -7, -3, -7, 6, -1, 1, 9, 0, 7, 0]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-9, -7, -3, -7, 6, -1, 1, 9, 0, 7, 0]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_5",
    "sat": "def sat(li: List[int], orig=[-5, 0, 1, -5, 3, -7, -7, -2, 2, 2, 6, -1, 5, 7, -5, -8, 6]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-5, 0, 1, -5, 3, -7, -7, -2, 2, 2, 6, -1, 5, 7, -5, -8, 6]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_6",
    "sat": "def sat(li: List[int], orig=[-10, -7, -7, 9, -5, 8, 9, -10, 8, 8, 4, -2, -5, 0]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-10, -7, -7, 9, -5, 8, 9, -10, 8, 8, 4, -2, -5, 0]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_7",
    "sat": "def sat(li: List[int], orig=[-6, -9, 4, -4, -3, 2, -9, 5, 9, 8, -5, 6]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-6, -9, 4, -4, -3, 2, -9, 5, 9, 8, -5, 6]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_8",
    "sat": "def sat(li: List[int], orig=[-9, 6, -1]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-9, 6, -1]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HalfSorted_9",
    "sat": "def sat(li: List[int], orig=[-1, 1, -3, 7, 0, -8, -4, -9, 1, -3, 0, -4, 1, -4, -6]):\n    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "sols": [
      "def sol(orig=[-1, 1, -3, 7, 0, -8, -4, -9, 1, -3, 0, -4, 1, -4, -6]):\n    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_0",
    "sat": "def sat(s: str, target=\"Hello world\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"Hello world\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_1",
    "sat": "def sat(s: str, target=\"pagyne\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"pagyne\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_2",
    "sat": "def sat(s: str, target=\"dilozothucanixowanysuquoned\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"dilozothucanixowanysuquoned\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_3",
    "sat": "def sat(s: str, target=\"d\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"d\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_4",
    "sat": "def sat(s: str, target=\"z\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"z\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_5",
    "sat": "def sat(s: str, target=\"wecylo\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"wecylo\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_6",
    "sat": "def sat(s: str, target=\"quafetextoxomakakofuthuthuvav\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"quafetextoxomakakofuthuthuvav\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_7",
    "sat": "def sat(s: str, target=\"textathyxymiquuquaxyth\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"textathyxymiquuquaxyth\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_8",
    "sat": "def sat(s: str, target=\"fugelyfycyjydototextyxut\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"fugelyfycyjydototextyxut\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreeCycle_9",
    "sat": "def sat(s: str, target=\"kyvamegewekuluhafet\"):\n    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n    \"\"\"\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "sols": [
      "def sol(target=\"kyvamegewekuluhafet\"):\n    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_0",
    "sat": "def sat(n: int, lower=123456):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=123456):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_1",
    "sat": "def sat(n: int, lower=57):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=57):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_2",
    "sat": "def sat(n: int, lower=308):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=308):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_3",
    "sat": "def sat(n: int, lower=120):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=120):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_4",
    "sat": "def sat(n: int, lower=0):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=0):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_5",
    "sat": "def sat(n: int, lower=98):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=98):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_6",
    "sat": "def sat(n: int, lower=16214):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=16214):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_7",
    "sat": "def sat(n: int, lower=16989):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=16989):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_8",
    "sat": "def sat(n: int, lower=427):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=427):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "PrimeFib_9",
    "sat": "def sat(n: int, lower=14904):\n    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n    \"\"\"\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "sols": [
      "def sol(lower=14904):\n    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_0",
    "sat": "def sat(inds: List[int], nums=[12, -10452, 18242, 10440]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[12, -10452, 18242, 10440]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_1",
    "sat": "def sat(inds: List[int], nums=[39, 45, -84, -9]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[39, 45, -84, -9]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_2",
    "sat": "def sat(inds: List[int], nums=[12, -14, -31, 2]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[12, -14, -31, 2]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_3",
    "sat": "def sat(inds: List[int], nums=[-39, 21, 111, -72]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[-39, 21, 111, -72]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_4",
    "sat": "def sat(inds: List[int], nums=[-81, 35, -58, 23]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[-81, 35, -58, 23]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_5",
    "sat": "def sat(inds: List[int], nums=[55, -55, -10, -45]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[55, -55, -10, -45]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_6",
    "sat": "def sat(inds: List[int], nums=[6, 75, -14, -61]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[6, 75, -14, -61]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_7",
    "sat": "def sat(inds: List[int], nums=[69, -16, -53, 39]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[69, -16, -53, 39]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_8",
    "sat": "def sat(inds: List[int], nums=[51, 83, -69, 18]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[51, 83, -69, 18]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "TripleZeroSum_9",
    "sat": "def sat(inds: List[int], nums=[113, -87, -26, -9]):\n    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n    \"\"\"\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0 and min(inds) >= 0",
    "sols": [
      "def sol(nums=[113, -87, -26, -9]):\n    assert len(nums) == 4\n    n = sum(nums)\n    for i in range(4):\n        if nums[i] == n:\n            return [j for j in range(4) if j != i]"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_0",
    "sat": "def sat(count: int, n=981):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=981):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_1",
    "sat": "def sat(count: int, n=83):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=83):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_2",
    "sat": "def sat(count: int, n=876):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=876):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_3",
    "sat": "def sat(count: int, n=687):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=687):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_4",
    "sat": "def sat(count: int, n=358):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=358):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_5",
    "sat": "def sat(count: int, n=719):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=719):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_6",
    "sat": "def sat(count: int, n=456):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=456):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_7",
    "sat": "def sat(count: int, n=228):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=228):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_8",
    "sat": "def sat(count: int, n=5):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=5):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "NumPasses_9",
    "sat": "def sat(count: int, n=348):\n    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "sols": [
      "def sol(n=348):\n    return n ** 2"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_0",
    "sat": "def sat(new_list: List[int], old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_1",
    "sat": "def sat(new_list: List[int], old_list=[70, 64, 96, 24, 4, 65, 69, 58]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[70, 64, 96, 24, 4, 65, 69, 58]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_2",
    "sat": "def sat(new_list: List[int], old_list=[42, 94, 14, 84]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[42, 94, 14, 84]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_3",
    "sat": "def sat(new_list: List[int], old_list=[76, 31, 9, 15, 86, 97, 50, 86]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[76, 31, 9, 15, 86, 97, 50, 86]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_4",
    "sat": "def sat(new_list: List[int], old_list=[87, 66, 87, 11, 22, 64]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[87, 66, 87, 11, 22, 64]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_5",
    "sat": "def sat(new_list: List[int], old_list=[34, 23, 91, 66, 5]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[34, 23, 91, 66, 5]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_6",
    "sat": "def sat(new_list: List[int], old_list=[93, 1, 74, 81]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[93, 1, 74, 81]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_7",
    "sat": "def sat(new_list: List[int], old_list=[46, 30, 97, 44, 82]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[46, 30, 97, 44, 82]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_8",
    "sat": "def sat(new_list: List[int], old_list=[65, 49]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[65, 49]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListInc_9",
    "sat": "def sat(new_list: List[int], old_list=[67, 39, 40, 66, 39]):\n    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n    \"\"\"\n    return [i - 1 for i in new_list] == old_list",
    "sols": [
      "def sol(old_list=[67, 39, 40, 66, 39]):\n    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_0",
    "sat": "def sat(inds: List[int], nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_1",
    "sat": "def sat(inds: List[int], nums=[-4, -1, 4, -2, -1]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[-4, -1, 4, -2, -1]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_2",
    "sat": "def sat(inds: List[int], nums=[41, -6, 14, 43, -1, -36, 22, 31, 61, 21, -71, 65, 59, 32, -59, -83, 43, 78, -29, -38, 19, -23, -49, 37, 18, 18, 10, -65, 26, -27, -77, 25, 84, -11, 38, 75, -22, 10, -68, 19, 4, -20, 52, 50, -79, -8, 63, -12, 23, -29, -16, -29, 18, -25, -3, 63, -30, 83, -70, -23, -13, -40, -18, 29, -5, 77, -38, 81, 2, -2, -8, 0, 43, -37, 79, 26, -13, -75, -3, -35, 25, -36, 45, -37, -32]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[41, -6, 14, 43, -1, -36, 22, 31, 61, 21, -71, 65, 59, 32, -59, -83, 43, 78, -29, -38, 19, -23, -49, 37, 18, 18, 10, -65, 26, -27, -77, 25, 84, -11, 38, 75, -22, 10, -68, 19, 4, -20, 52, 50, -79, -8, 63, -12, 23, -29, -16, -29, 18, -25, -3, 63, -30, 83, -70, -23, -13, -40, -18, 29, -5, 77, -38, 81, 2, -2, -8, 0, 43, -37, 79, 26, -13, -75, -3, -35, 25, -36, 45, -37, -32]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_3",
    "sat": "def sat(inds: List[int], nums=[17, -10, 2, -32, 12, 25, -30, -4, -12, -13, 31, -17, -21, 17, 7, 26, 21, 31, 10, -27, -30, -4, 25, -23, 23, 26, -20, -4, 19, 0, 25, 24]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[17, -10, 2, -32, 12, 25, -30, -4, -12, -13, 31, -17, -21, 17, 7, 26, 21, 31, 10, -27, -30, -4, 25, -23, 23, 26, -20, -4, 19, 0, 25, 24]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_4",
    "sat": "def sat(inds: List[int], nums=[56, -31, -25, -46, -38, -13, -50, -22, 44, -28, 9, 39, -49, -51, 9, 49, 18, 58, 33, 17, -19, -1, -37, 4, -16, -8, -38, 28, 14, -27, -2, -7, -5, -7, 18, 51, -41, 52, -28, -22, -30, -7, -47, -9, -47, 55, 21, -5, 46, 37, 43, 18, -24, 49, 8, 28, 37, -14, 4, 45]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[56, -31, -25, -46, -38, -13, -50, -22, 44, -28, 9, 39, -49, -51, 9, 49, 18, 58, 33, 17, -19, -1, -37, 4, -16, -8, -38, 28, 14, -27, -2, -7, -5, -7, 18, 51, -41, 52, -28, -22, -30, -7, -47, -9, -47, 55, 21, -5, 46, 37, 43, 18, -24, 49, 8, 28, 37, -14, 4, 45]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_5",
    "sat": "def sat(inds: List[int], nums=[12, 28, -44, -28, 25, 16, -51, -33, 3, -17, -31, 1, -2, 7, -27, -24, -15, -10, 23, 26, 13, -25, -52, -6, 6, 7, 22, -46, -24, -18, -35, 15, -43, 20, -38, -8, 40, -19, -45, 8, 4, 5, 0, -40, 6, -3, -23, 52, 14, -33, -3, -20, -6, 35]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[12, 28, -44, -28, 25, 16, -51, -33, 3, -17, -31, 1, -2, 7, -27, -24, -15, -10, 23, 26, 13, -25, -52, -6, 6, 7, 22, -46, -24, -18, -35, 15, -43, 20, -38, -8, 40, -19, -45, 8, 4, 5, 0, -40, 6, -3, -23, 52, 14, -33, -3, -20, -6, 35]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_6",
    "sat": "def sat(inds: List[int], nums=[8, 5, 8, 0, 6, 0, -7, 12, -12, 12, -8, 7, 4]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[8, 5, 8, 0, 6, 0, -7, 12, -12, 12, -8, 7, 4]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_7",
    "sat": "def sat(inds: List[int], nums=[21, 21, -38, -1, 67, -14, -18, -22, -70, -7, 75, 33, 7, -71, -34, 47, -57, 67, -37, 37, 76, -34, 44, -34, 50, 71, 43, -70, -57, -43, -24, -14, 23, 73, -68, 71, -30, 36, 64, -48, -56, -61, -73, 9, -16, 41, -42, -36, -78, -16, -32, -30, -41, -46, 45, -34, -57, -74, 30, 66, -35, -25, 76, -4, -60, 23, -7, 17, 6, 28, -63, 14, 16, -8, -75, 27, 20, 29, 6, -66, 43, 63, 8]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[21, 21, -38, -1, 67, -14, -18, -22, -70, -7, 75, 33, 7, -71, -34, 47, -57, 67, -37, 37, 76, -34, 44, -34, 50, 71, 43, -70, -57, -43, -24, -14, 23, 73, -68, 71, -30, 36, 64, -48, -56, -61, -73, 9, -16, 41, -42, -36, -78, -16, -32, -30, -41, -46, 45, -34, -57, -74, 30, 66, -35, -25, 76, -4, -60, 23, -7, 17, 6, 28, -63, 14, 16, -8, -75, 27, 20, 29, 6, -66, 43, 63, 8]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_8",
    "sat": "def sat(inds: List[int], nums=[-14, 11, 8, 3, 6, -2, -8, -7, 12, -2, -15, -14, -5, 2, 1, -4]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[-14, 11, 8, 3, 6, -2, -8, -7, 12, -2, -15, -14, -5, 2, 1, -4]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "PairZeroSum_9",
    "sat": "def sat(inds: List[int], nums=[16, 6, 15, -8, -7, -5, 19, -12, -24, -4, -3, 2, -6, 5, 15, 1, -1, -2, 19, -1, -19, 15, 15, 17, -12]):\n    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n    \"\"\"\n    a, b = inds\n    return nums[a] + nums[b] == 0",
    "sols": [
      "def sol(nums=[16, 6, 15, -8, -7, -5, 19, -12, -24, -4, -3, 2, -6, 5, 15, 1, -1, -2, 19, -1, -19, 15, 15, 17, -12]):\n    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_0",
    "sat": "def sat(s: str, n=142, base=7):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=142, base=7):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_1",
    "sat": "def sat(s: str, n=8470955, base=10):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=8470955, base=10):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_2",
    "sat": "def sat(s: str, n=991338, base=4):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=991338, base=4):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_3",
    "sat": "def sat(s: str, n=5096704, base=6):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=5096704, base=6):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_4",
    "sat": "def sat(s: str, n=2394005, base=7):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=2394005, base=7):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_5",
    "sat": "def sat(s: str, n=2380540, base=4):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=2380540, base=4):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_6",
    "sat": "def sat(s: str, n=3904768, base=6):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=3904768, base=6):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_7",
    "sat": "def sat(s: str, n=4909694, base=2):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=4909694, base=2):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_8",
    "sat": "def sat(s: str, n=9073203, base=6):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=9073203, base=6):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "ChangeBase_9",
    "sat": "def sat(s: str, n=7929139, base=2):\n    \"\"\"\n    Write n in the given base as a string\n    \"\"\"\n    return int(s, base) == n",
    "sols": [
      "def sol(n=7929139, base=2):\n    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_0",
    "sat": "def sat(height: int, area=1319098728582, base=45126):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=1319098728582, base=45126):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_1",
    "sat": "def sat(height: int, area=72136680, base=3005695):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=72136680, base=3005695):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_2",
    "sat": "def sat(height: int, area=172415554166854, base=56789731):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=172415554166854, base=56789731):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_3",
    "sat": "def sat(height: int, area=10212520672002541, base=65712382):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=10212520672002541, base=65712382):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_4",
    "sat": "def sat(height: int, area=384582846, base=64097141):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=384582846, base=64097141):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_5",
    "sat": "def sat(height: int, area=7802549, base=7802549):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=7802549, base=7802549):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_6",
    "sat": "def sat(height: int, area=123995445, base=49598178):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=123995445, base=49598178):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_7",
    "sat": "def sat(height: int, area=6124408800, base=4800):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=6124408800, base=4800):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_8",
    "sat": "def sat(height: int, area=93321676, base=37828):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=93321676, base=37828):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "TriangleArea_9",
    "sat": "def sat(height: int, area=240741468096, base=552):\n    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n    \"\"\"\n    return base * height == 2 * area",
    "sols": [
      "def sol(area=240741468096, base=552):\n    return (2 * area) // base"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_0",
    "sat": "def sat(init: List[int], target=2021):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=2021):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_1",
    "sat": "def sat(init: List[int], target=3):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=3):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_2",
    "sat": "def sat(init: List[int], target=53433):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=53433):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_3",
    "sat": "def sat(init: List[int], target=2576):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=2576):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_4",
    "sat": "def sat(init: List[int], target=4983):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=4983):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_5",
    "sat": "def sat(init: List[int], target=98030):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=98030):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_6",
    "sat": "def sat(init: List[int], target=60):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=60):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_7",
    "sat": "def sat(init: List[int], target=493543604):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=493543604):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_8",
    "sat": "def sat(init: List[int], target=8260):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=8260):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib4_9",
    "sat": "def sat(init: List[int], target=292058):\n    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "sols": [
      "def sol(target=292058):\n    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_0",
    "sat": "def sat(x: int, nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_1",
    "sat": "def sat(x: int, nums=[-5624733488, 8408757827, -6568690512, -8927133614, -4763999565, -8351956524, 5465911060, 2225814715], upper=19975966419):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-5624733488, 8408757827, -6568690512, -8927133614, -4763999565, -8351956524, 5465911060, 2225814715], upper=19975966419):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_2",
    "sat": "def sat(x: int, nums=[-8552804371, 2229782415, 9686256849], upper=-3326112352):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-8552804371, 2229782415, 9686256849], upper=-3326112352):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_3",
    "sat": "def sat(x: int, nums=[-3908345602, 6904707144, -2293233196, 7028537036, -7794227665, -8475873064], upper=5220963829):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-3908345602, 6904707144, -2293233196, 7028537036, -7794227665, -8475873064], upper=5220963829):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_4",
    "sat": "def sat(x: int, nums=[5250272007, -1900046707], upper=-7150318714):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[5250272007, -1900046707], upper=-7150318714):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_5",
    "sat": "def sat(x: int, nums=[-7942113137, 3609311799, -5464247907, 2531105534, 1952221205, -8658809979], upper=-25685859715):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-7942113137, 3609311799, -5464247907, 2531105534, 1952221205, -8658809979], upper=-25685859715):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_6",
    "sat": "def sat(x: int, nums=[-4935625551, -1107874374, -953928557, -789996661, 7778987793, 8673175201, -7065924183, 9062320954, 2590456185], upper=20361560756):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-4935625551, -1107874374, -953928557, -789996661, 7778987793, 8673175201, -7065924183, 9062320954, 2590456185], upper=20361560756):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_7",
    "sat": "def sat(x: int, nums=[1484758927, 4639926909], upper=-3155167982):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[1484758927, 4639926909], upper=-3155167982):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_8",
    "sat": "def sat(x: int, nums=[-7008578992, -6845394202, 1875815961], upper=8558025373):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-7008578992, -6845394202, 1875815961], upper=8558025373):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Median_9",
    "sat": "def sat(x: int, nums=[-2047577438, -3329955530, -1392603113, 2249144385], upper=1049420756):\n    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n    \"\"\"\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "sols": [
      "def sol(nums=[-2047577438, -3329955530, -1392603113, 2249144385], upper=1049420756):\n    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_0",
    "sat": "def sat(p: bool, s=\"This problem is trivial but common\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"This problem is trivial but common\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_1",
    "sat": "def sat(p: bool, s=\"nn\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"nn\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_2",
    "sat": "def sat(p: bool, s=\"xitakifefyjovuquuhav\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"xitakifefyjovuquuhav\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_3",
    "sat": "def sat(p: bool, s=\"pecutavathazilofub\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"pecutavathazilofub\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_4",
    "sat": "def sat(p: bool, s=\"r\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"r\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_5",
    "sat": "def sat(p: bool, s=\"ses\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"ses\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_6",
    "sat": "def sat(p: bool, s=\"tocathivenochemaxyx\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"tocathivenochemaxyx\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_7",
    "sat": "def sat(p: bool, s=\"quotybifu\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"quotybifu\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_8",
    "sat": "def sat(p: bool, s=\"thutexetuht\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"thutexetuht\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Palindrome_Trivial_9",
    "sat": "def sat(p: bool, s=\"juvysesat\"):\n    \"\"\"\n    Test whether the given string is a palindrome\n    \"\"\"\n    return p == (s == s[::-1])",
    "sols": [
      "def sol(s=\"juvysesat\"):\n    return s == s[::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_0",
    "sat": "def sat(exp_poly: List[int], d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_1",
    "sat": "def sat(exp_poly: List[int], d=537598, poly=[2, 1, 0, 3, 2]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=537598, poly=[2, 1, 0, 3, 2]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_2",
    "sat": "def sat(exp_poly: List[int], d=211880, poly=[2, 6, 5, 2, 2, 2, 1]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=211880, poly=[2, 6, 5, 2, 2, 2, 1]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_3",
    "sat": "def sat(exp_poly: List[int], d=1318, poly=[3, 4, 0, 4, 3, 2, 0]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=1318, poly=[3, 4, 0, 4, 3, 2, 0]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_4",
    "sat": "def sat(exp_poly: List[int], d=0, poly=[0, 2, 1]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=0, poly=[0, 2, 1]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_5",
    "sat": "def sat(exp_poly: List[int], d=5010065165455, poly=[1, 1, 3, 3, 3]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=5010065165455, poly=[1, 1, 3, 3, 3]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_6",
    "sat": "def sat(exp_poly: List[int], d=70086, poly=[1, 1, 3, 1, 2]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=70086, poly=[1, 1, 3, 1, 2]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_7",
    "sat": "def sat(exp_poly: List[int], d=34717466499705734980085262332, poly=[0, 2, 3, 3, 1]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=34717466499705734980085262332, poly=[0, 2, 3, 3, 1]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_8",
    "sat": "def sat(exp_poly: List[int], d=20563741751773273584, poly=[2, 5, 3, 3, 1, 1, 5]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=20563741751773273584, poly=[2, 5, 3, 3, 1, 1, 5]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "LittleFermat_9",
    "sat": "def sat(exp_poly: List[int], d=3826878, poly=[4, 0, 2, 3, 6, 2, 2]):\n    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n    \"\"\"\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "sols": [
      "def sol(d=3826878, poly=[4, 0, 2, 3, 6, 2, 2]):\n    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_0",
    "sat": "def sat(orig: str, result=\"Hello, world!\", shift=7):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"Hello, world!\", shift=7):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_1",
    "sat": "def sat(orig: str, result=\"basowythythexaz\", shift=5):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"basowythythexaz\", shift=5):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_2",
    "sat": "def sat(orig: str, result=\"tex\", shift=-11):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"tex\", shift=-11):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_3",
    "sat": "def sat(orig: str, result=\"mafubafeboh\", shift=0):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"mafubafeboh\", shift=0):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_4",
    "sat": "def sat(orig: str, result=\"chi\", shift=-10):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"chi\", shift=-10):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_5",
    "sat": "def sat(orig: str, result=\"natuzewoc\", shift=-11):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"natuzewoc\", shift=-11):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_6",
    "sat": "def sat(orig: str, result=\"rebalechy\", shift=-1):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"rebalechy\", shift=-1):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_7",
    "sat": "def sat(orig: str, result=\"racihiwatext\", shift=6):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"racihiwatext\", shift=6):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_8",
    "sat": "def sat(orig: str, result=\"ta\", shift=8):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"ta\", shift=8):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ShiftChars_9",
    "sat": "def sat(orig: str, result=\"myv\", shift=-5):\n    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n    \"\"\"\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "sols": [
      "def sol(result=\"myv\", shift=-5):\n    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_0",
    "sat": "def sat(txt: str, text=\"Hello, world!\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"Hello, world!\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_1",
    "sat": "def sat(txt: str, text=\"WiqUiSeLokAdIV\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"WiqUiSeLokAdIV\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_2",
    "sat": "def sat(txt: str, text=\"bEQUOtHEjyJETEXt\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"bEQUOtHEjyJETEXt\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_3",
    "sat": "def sat(txt: str, text=\"hEx\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"hEx\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_4",
    "sat": "def sat(txt: str, text=\"wIbEtiHOVuQuOHYJYte\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"wIbEtiHOVuQuOHYJYte\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_5",
    "sat": "def sat(txt: str, text=\"JUQuiwuhUzUText\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"JUQuiwuhUzUText\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_6",
    "sat": "def sat(txt: str, text=\"vAK\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"vAK\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_7",
    "sat": "def sat(txt: str, text=\"TAsUmuReboBUquYfoch\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"TAsUmuReboBUquYfoch\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_8",
    "sat": "def sat(txt: str, text=\"MyCuChyMybuhiT\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"MyCuChyMybuhiT\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "RemoveVowels_9",
    "sat": "def sat(txt: str, text=\"rItExtynIGatE\"):\n    \"\"\"\n    Remove the vowels from the original string.\n    \"\"\"\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "sols": [
      "def sol(text=\"rItExtynIGatE\"):\n    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_0",
    "sat": "def sat(indexes: List[int], nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_1",
    "sat": "def sat(indexes: List[int], nums=[79, -46, -37, -88, -96, 70, -38, 94], thresh=91):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[79, -46, -37, -88, -96, 70, -38, 94], thresh=91):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_2",
    "sat": "def sat(indexes: List[int], nums=[70], thresh=-61):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[70], thresh=-61):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_3",
    "sat": "def sat(indexes: List[int], nums=[4, -66, 62, -33, -8, -74], thresh=73):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[4, -66, 62, -33, -8, -74], thresh=73):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_4",
    "sat": "def sat(indexes: List[int], nums=[-57, 13, -39, 84, 85, 87, -24, -29, 34], thresh=42):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[-57, 13, -39, 84, 85, 87, -24, -29, 34], thresh=42):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_5",
    "sat": "def sat(indexes: List[int], nums=[-75, 56, -53, 89], thresh=-24):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[-75, 56, -53, 89], thresh=-24):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_6",
    "sat": "def sat(indexes: List[int], nums=[-65, -70, -53], thresh=-9):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[-65, -70, -53], thresh=-9):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_7",
    "sat": "def sat(indexes: List[int], nums=[64, 60, -66, 9, -10], thresh=-16):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[64, 60, -66, 9, -10], thresh=-16):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_8",
    "sat": "def sat(indexes: List[int], nums=[20, -70, 59, 67], thresh=-18):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[20, -70, 59, 67], thresh=-18):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "BelowThreshold_9",
    "sat": "def sat(indexes: List[int], nums=[-24, 67, -35, -31, -16], thresh=30):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "sols": [
      "def sol(nums=[-24, 67, -35, -31, -16], thresh=30):\n    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_0",
    "sat": "def sat(n: int, nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_1",
    "sat": "def sat(n: int, nums=[-441, 4766]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[-441, 4766]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_2",
    "sat": "def sat(n: int, nums=[59, 36, -3, -22, -58, 36]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[59, 36, -3, -22, -58, 36]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_3",
    "sat": "def sat(n: int, nums=[88926687, 99485253, -66128676, -68712893]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[88926687, 99485253, -66128676, -68712893]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_4",
    "sat": "def sat(n: int, nums=[-711, 455, -842, -818]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[-711, 455, -842, -818]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_5",
    "sat": "def sat(n: int, nums=[87095274, -21194277, 93366516, -50576478, 98979046, 96228363]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[87095274, -21194277, 93366516, -50576478, 98979046, 96228363]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_6",
    "sat": "def sat(n: int, nums=[-27332, -86141, 35290, 87482, -11213, -79277, 74909, 19920, -93686]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[-27332, -86141, 35290, 87482, -11213, -79277, 74909, 19920, -93686]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_7",
    "sat": "def sat(n: int, nums=[434513, -247818, 734376]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[434513, -247818, 734376]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_8",
    "sat": "def sat(n: int, nums: List[int]=[]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "ListTotal_9",
    "sat": "def sat(n: int, nums=[-679076, -803973, 2498, 472590, -718752, 322674]):\n    \"\"\"\n    Find the indexes of numbers below a given threshold\n    \"\"\"\n    return sum(nums + [-n]) == 0",
    "sols": [
      "def sol(nums=[-679076, -803973, 2498, 472590, -718752, 322674]):\n    return sum(nums)"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_0",
    "sat": "def sat(c: str, a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_1",
    "sat": "def sat(c: str, a=\"thath\", b=\"howirethybenil\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"thath\", b=\"howirethybenil\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_2",
    "sat": "def sat(c: str, a=\"gikebedi\", b=\"bdeegiikm\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"gikebedi\", b=\"bdeegiikm\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_3",
    "sat": "def sat(c: str, a=\"bocysytacetextiwed\", b=\"abccdeeeimostttwxyy\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"bocysytacetextiwed\", b=\"abccdeeeimostttwxyy\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_4",
    "sat": "def sat(c: str, a=\"bufegu\", b=\"bo\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"bufegu\", b=\"bo\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_5",
    "sat": "def sat(c: str, a=\"cyhekekisecih\", b=\"cceeehhiikkmsy\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"cyhekekisecih\", b=\"cceeehhiikkmsy\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_6",
    "sat": "def sat(c: str, a=\"ruchozujolusilith\", b=\"chhiijllmoorstuuuz\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"ruchozujolusilith\", b=\"chhiijllmoorstuuuz\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_7",
    "sat": "def sat(c: str, a=\"chyruwuvu\", b=\"chmruuuvwy\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"chyruwuvu\", b=\"chmruuuvwy\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_8",
    "sat": "def sat(c: str, a=\"quurynolo\", b=\"dufebo\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"quurynolo\", b=\"dufebo\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DiffChars_9",
    "sat": "def sat(c: str, a=\"raqualezudupu\", b=\"lobukizovopa\"):\n    \"\"\"\n    Find a character in one string that is not in the other.\n    \"\"\"\n    return (c in a) != (c in b)",
    "sols": [
      "def sol(a=\"raqualezudupu\", b=\"lobukizovopa\"):\n    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_0",
    "sat": "def sat(nums: List[int], n=1402):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=1402):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_1",
    "sat": "def sat(nums: List[int], n=6517):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=6517):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_2",
    "sat": "def sat(nums: List[int], n=10988):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=10988):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_3",
    "sat": "def sat(nums: List[int], n=544):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=544):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_4",
    "sat": "def sat(nums: List[int], n=312):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=312):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_5",
    "sat": "def sat(nums: List[int], n=3597):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=3597):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_6",
    "sat": "def sat(nums: List[int], n=11040):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=11040):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_7",
    "sat": "def sat(nums: List[int], n=6023):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=6023):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_8",
    "sat": "def sat(nums: List[int], n=749):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=749):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fibonacci_9",
    "sat": "def sat(nums: List[int], n=1072):\n    \"\"\"\n    Find the first n Fibonacci numbers\n    \"\"\"\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "sols": [
      "def sol(n=1072):\n    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_0",
    "sat": "def sat(matches: List[int], brackets=\"<<>><<<><>><<>>>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<<>><<<><>><<>>>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_1",
    "sat": "def sat(matches: List[int], brackets=\"<>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_2",
    "sat": "def sat(matches: List[int], brackets=\"<><<>><><<>><><<>><><>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<><<>><><<>><><<>><><>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_3",
    "sat": "def sat(matches: List[int], brackets=\"<<>><<>><<>><>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<<>><<>><<>><>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_4",
    "sat": "def sat(matches: List[int], brackets=\"<<<>>><>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<<<>>><>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_5",
    "sat": "def sat(matches: List[int], brackets=\"<><<>><><><>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<><<>><><><>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_6",
    "sat": "def sat(matches: List[int], brackets=\"<<><>><><><><><<>><>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<<><>><><><><><<>><>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_7",
    "sat": "def sat(matches: List[int], brackets=\"<<>><<><>><><<>><><><><<>><><><><><><>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<<>><<><>><><<>><><><><<>><><><><><><>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_8",
    "sat": "def sat(matches: List[int], brackets=\"<<<>><>><><><><><<>>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<<<>><>><><><><><<>>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "MatchBrackets_9",
    "sat": "def sat(matches: List[int], brackets=\"<><><<>>\"):\n    \"\"\"\n    Find the index of the matching brackets for each character in the string\n    \"\"\"\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "sols": [
      "def sol(brackets=\"<><><<>>\"):\n    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_0",
    "sat": "def sat(direction: str, nums=[2, 4, 17, 29, 31, 1000, 416629]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[2, 4, 17, 29, 31, 1000, 416629]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_1",
    "sat": "def sat(direction: str, nums=[388, 422, 557, 822, 833]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[388, 422, 557, 822, 833]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_2",
    "sat": "def sat(direction: str, nums=[152, 299, 968]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[152, 299, 968]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_3",
    "sat": "def sat(direction: str, nums=[52, 255, 633, 715]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[52, 255, 633, 715]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_4",
    "sat": "def sat(direction: str, nums: List[int]=[]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_5",
    "sat": "def sat(direction: str, nums=[173, 609, 698, 730]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[173, 609, 698, 730]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_6",
    "sat": "def sat(direction: str, nums=[0, 259, 644, 668, 692, 741, 743, 764, 820]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[0, 259, 644, 668, 692, 741, 743, 764, 820]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_7",
    "sat": "def sat(direction: str, nums=[931, 924, 757, 589, 476, 80]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[931, 924, 757, 589, 476, 80]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_8",
    "sat": "def sat(direction: str, nums=[747, 577, 422, 408]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[747, 577, 422, 408]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "Monotonic_9",
    "sat": "def sat(direction: str, nums=[907, 698, 540, 318, 206]):\n    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n    \"\"\"\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "sols": [
      "def sol(nums=[907, 698, 540, 318, 206]):\n    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_0",
    "sat": "def sat(common: List[int], a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_1",
    "sat": "def sat(common: List[int], a=[128, 291, 738, 270, 164, 168, 680, 750], b=[750, 738]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[128, 291, 738, 270, 164, 168, 680, 750], b=[750, 738]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_2",
    "sat": "def sat(common: List[int], a=[698, 282, 238, 451, 800, 2, 424, 471], b=[698, 796, 997, 800, 406, 338, 451]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[698, 282, 238, 451, 800, 2, 424, 471], b=[698, 796, 997, 800, 406, 338, 451]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_3",
    "sat": "def sat(common: List[int], a=[79, 649, 500, 158, 481, 523, 62, 722, 106], b=[858, 500, 114, 158, 802, 79, 4, 649, 411, 939, 722, 392, 492, 523, 481]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[79, 649, 500, 158, 481, 523, 62, 722, 106], b=[858, 500, 114, 158, 802, 79, 4, 649, 411, 939, 722, 392, 492, 523, 481]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_4",
    "sat": "def sat(common: List[int], a=[455], b=[455]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[455], b=[455]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_5",
    "sat": "def sat(common: List[int], a=[847, 119, 574, 229, 291, 746, 777, 233], b=[54, 291, 38, 417, 746, 574, 119, 658, 847, 777, 229, 233]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[847, 119, 574, 229, 291, 746, 777, 233], b=[54, 291, 38, 417, 746, 574, 119, 658, 847, 777, 229, 233]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_6",
    "sat": "def sat(common: List[int], a=[965, 36, 728, 233, 437, 268, 158, 567, 584, 131, 894, 658, 755, 991, 664], b=[268, 233, 444, 131, 894, 664, 36, 561, 991]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[965, 36, 728, 233, 437, 268, 158, 567, 584, 131, 894, 658, 755, 991, 664], b=[268, 233, 444, 131, 894, 664, 36, 561, 991]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_7",
    "sat": "def sat(common: List[int], a=[626, 13, 155, 378, 13, 597, 457, 746, 800, 426, 231, 612, 526, 835, 626], b=[13, 977, 13, 854, 628, 626, 746, 802, 870, 929, 231, 835, 800, 155, 643, 999, 665]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[626, 13, 155, 378, 13, 597, 457, 746, 800, 426, 231, 612, 526, 835, 626], b=[13, 977, 13, 854, 628, 626, 746, 802, 870, 929, 231, 835, 800, 155, 643, 999, 665]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_8",
    "sat": "def sat(common: List[int], a=[334, 964], b=[755, 964, 334]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[334, 964], b=[755, 964, 334]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CommonNumbers_9",
    "sat": "def sat(common: List[int], a=[973, 817, 10, 469], b=[402, 258, 487]):\n    \"\"\"\n    Find numbers common to a and b\n    \"\"\"\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "sols": [
      "def sol(a=[973, 817, 10, 469], b=[402, 258, 487]):\n    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_0",
    "sat": "def sat(p: int, n=101076):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=101076):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_1",
    "sat": "def sat(p: int, n=67952):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=67952):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_2",
    "sat": "def sat(p: int, n=31073):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=31073):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_3",
    "sat": "def sat(p: int, n=75132):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=75132):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_4",
    "sat": "def sat(p: int, n=89988):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=89988):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_5",
    "sat": "def sat(p: int, n=1773):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=1773):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_6",
    "sat": "def sat(p: int, n=71885):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=71885):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_7",
    "sat": "def sat(p: int, n=85011):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=85011):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_8",
    "sat": "def sat(p: int, n=62098):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=62098):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "LargestPrimeFactor_9",
    "sat": "def sat(p: int, n=29082):\n    \"\"\"\n    Find the largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "sols": [
      "def sol(n=29082):\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_0",
    "sat": "def sat(sums: List[int], n=104):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=104):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_1",
    "sat": "def sat(sums: List[int], n=18180):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=18180):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_2",
    "sat": "def sat(sums: List[int], n=7495):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=7495):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_3",
    "sat": "def sat(sums: List[int], n=8551):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=8551):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_4",
    "sat": "def sat(sums: List[int], n=9412):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=9412):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_5",
    "sat": "def sat(sums: List[int], n=14206):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=14206):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_6",
    "sat": "def sat(sums: List[int], n=18481):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=18481):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_7",
    "sat": "def sat(sums: List[int], n=5202):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=5202):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_8",
    "sat": "def sat(sums: List[int], n=9363):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=9363):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "CumulativeSums_9",
    "sat": "def sat(sums: List[int], n=12647):\n    \"\"\"\n    Find the sums of the integers from 1 to n\n    \"\"\"\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "sols": [
      "def sol(n=12647):\n    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_0",
    "sat": "def sat(matches: List[int], parens=\"((())()(()()))(())\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"((())()(()()))(())\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_1",
    "sat": "def sat(matches: List[int], parens=\"()(((())))\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"()(((())))\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_2",
    "sat": "def sat(matches: List[int], parens=\"\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_3",
    "sat": "def sat(matches: List[int], parens=\"()()()()(())()()(())\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"()()()()(())()()(())\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_4",
    "sat": "def sat(matches: List[int], parens=\"(())()(()(()))\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"(())()(()(()))\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_5",
    "sat": "def sat(matches: List[int], parens=\"()()\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"()()\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_6",
    "sat": "def sat(matches: List[int], parens=\"()()()()()\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"()()()()()\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_7",
    "sat": "def sat(matches: List[int], parens=\"()()()\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"()()()\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_8",
    "sat": "def sat(matches: List[int], parens=\"(())()()\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"(())()()\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "ParenDepth_9",
    "sat": "def sat(matches: List[int], parens=\"(())(())()()\"):\n    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n    \"\"\"\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "sols": [
      "def sol(parens=\"(())(())()()\"):\n    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_0",
    "sat": "def sat(derivative: List[int], poly=[2, 1, 0, 4, 19, 231, 0, 5]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[2, 1, 0, 4, 19, 231, 0, 5]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_1",
    "sat": "def sat(derivative: List[int], poly=[3, 3, 2]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[3, 3, 2]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_2",
    "sat": "def sat(derivative: List[int], poly=[2, 4, -7, -10, -6, 6, 3, 3]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[2, 4, -7, -10, -6, 6, 3, 3]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_3",
    "sat": "def sat(derivative: List[int], poly=[-9, -9, 3, 9, 8, 6, 7]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[-9, -9, 3, 9, 8, 6, 7]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_4",
    "sat": "def sat(derivative: List[int], poly=[-8, 7, 0, -1, 4]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[-8, 7, 0, -1, 4]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_5",
    "sat": "def sat(derivative: List[int], poly=[-9]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[-9]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_6",
    "sat": "def sat(derivative: List[int], poly=[5, 6, 1, -6, -3, -9, 9]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[5, 6, 1, -6, -3, -9, 9]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_7",
    "sat": "def sat(derivative: List[int], poly=[-8, 9, 9, 8]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[-8, 9, 9, 8]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_8",
    "sat": "def sat(derivative: List[int], poly=[-7]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[-7]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Derivative_9",
    "sat": "def sat(derivative: List[int], poly=[5, -10, 5]):\n    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n    \"\"\"\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "sols": [
      "def sol(poly=[5, -10, 5]):\n    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_0",
    "sat": "def sat(init: List[int], target=124156):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=124156):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_1",
    "sat": "def sat(init: List[int], target=14222):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=14222):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_2",
    "sat": "def sat(init: List[int], target=65):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=65):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_3",
    "sat": "def sat(init: List[int], target=0):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=0):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_4",
    "sat": "def sat(init: List[int], target=21):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=21):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_5",
    "sat": "def sat(init: List[int], target=485):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=485):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_6",
    "sat": "def sat(init: List[int], target=26):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=26):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_7",
    "sat": "def sat(init: List[int], target=3724):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=3724):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_8",
    "sat": "def sat(init: List[int], target=10):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=10):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "Fib3_9",
    "sat": "def sat(init: List[int], target=2941):\n    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n    \"\"\"\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "sols": [
      "def sol(target=2941):\n    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_0",
    "sat": "def sat(vowels: str, text=\"Hello, world!\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"Hello, world!\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_1",
    "sat": "def sat(vowels: str, text=\"SaTheZYwaMYcUC\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"SaTheZYwaMYcUC\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_2",
    "sat": "def sat(vowels: str, text=\"ZejUkAQUE\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"ZejUkAQUE\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_3",
    "sat": "def sat(vowels: str, text=\"GOGaRolATEk\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"GOGaRolATEk\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_4",
    "sat": "def sat(vowels: str, text=\"FiBAlaXYchyLuPoW\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"FiBAlaXYchyLuPoW\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_5",
    "sat": "def sat(vowels: str, text=\"ChEGon\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"ChEGon\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_6",
    "sat": "def sat(vowels: str, text=\"ZitOxUwUGOmEcHunU\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"ZitOxUwUGOmEcHunU\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_7",
    "sat": "def sat(vowels: str, text=\"HENaDUWIMYdYXUTE\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"HENaDUWIMYdYXUTE\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_8",
    "sat": "def sat(vowels: str, text=\"texTIsob\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"texTIsob\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "FindVowels_9",
    "sat": "def sat(vowels: str, text=\"qu\"):\n    \"\"\"\n    Find the vowels from the original string.\n    \"\"\"\n    i = 0\n    for j, c in enumerate(text):\n        if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(text) - 1:\n            assert vowels[i] == c\n            i += 1\n    return i == len(vowels)",
    "sols": [
      "def sol(text=\"qu\"):\n    return \"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_0",
    "sat": "def sat(shifted: str, n=124582369835, shift=3):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=124582369835, shift=3):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_1",
    "sat": "def sat(shifted: str, n=8625726, shift=7):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=8625726, shift=7):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_2",
    "sat": "def sat(shifted: str, n=89520340554199623724, shift=8):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=89520340554199623724, shift=8):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_3",
    "sat": "def sat(shifted: str, n=76021591812703433, shift=18):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=76021591812703433, shift=18):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_4",
    "sat": "def sat(shifted: str, n=66336671073623537, shift=12):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=66336671073623537, shift=12):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_5",
    "sat": "def sat(shifted: str, n=395034393337403, shift=19):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=395034393337403, shift=19):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_6",
    "sat": "def sat(shifted: str, n=773144819, shift=8):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=773144819, shift=8):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_7",
    "sat": "def sat(shifted: str, n=86761666514307411870804, shift=14):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=86761666514307411870804, shift=14):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_8",
    "sat": "def sat(shifted: str, n=836707735176, shift=25):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=836707735176, shift=25):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "CircularShiftNum_9",
    "sat": "def sat(shifted: str, n=9554662, shift=23):\n    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n    \"\"\"\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "sols": [
      "def sol(n=9554662, shift=23):\n    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_0",
    "sat": "def sat(tot: int, s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_1",
    "sat": "def sat(tot: int, s=\"^J),KaL@wU/a:o8N(D\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"^J),KaL@wU/a:o8N(D\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_2",
    "sat": "def sat(tot: int, s=\"GH,4b.gcKj&*+2WV9\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"GH,4b.gcKj&*+2WV9\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_3",
    "sat": "def sat(tot: int, s=\"RNS\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"RNS\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_4",
    "sat": "def sat(tot: int, s=\" [6d>Mp\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\" [6d>Mp\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_5",
    "sat": "def sat(tot: int, s=\"R]:;P*t2/lAzl<,]\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"R]:;P*t2/lAzl<,]\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_6",
    "sat": "def sat(tot: int, s=\"?LRPdNCfVWDXLe.\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"?LRPdNCfVWDXLe.\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_7",
    "sat": "def sat(tot: int, s=\"BnC;rsQe^k9zj2SN\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"BnC;rsQe^k9zj2SN\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_8",
    "sat": "def sat(tot: int, s=\"Xcr6IOp#s1mZkXoG/S\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"Xcr6IOp#s1mZkXoG/S\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "DigitSum_9",
    "sat": "def sat(tot: int, s=\"&ngbc|lkB|W9ah)fVJ\"):\n    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n    \"\"\"\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "sols": [
      "def sol(s=\"&ngbc|lkB|W9ah)fVJ\"):\n    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_0",
    "sat": "def sat(bananas: int, bowl=\"5024 apples and 12189 oranges\", total=12491241):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"5024 apples and 12189 oranges\", total=12491241):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_1",
    "sat": "def sat(bananas: int, bowl=\"21053 apples and 67580 oranges\", total=130644):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"21053 apples and 67580 oranges\", total=130644):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_2",
    "sat": "def sat(bananas: int, bowl=\"39 apples and 610 oranges\", total=1155):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"39 apples and 610 oranges\", total=1155):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_3",
    "sat": "def sat(bananas: int, bowl=\"987 apples and 249 oranges\", total=1238):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"987 apples and 249 oranges\", total=1238):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_4",
    "sat": "def sat(bananas: int, bowl=\"9 apples and 6 oranges\", total=18):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"9 apples and 6 oranges\", total=18):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_5",
    "sat": "def sat(bananas: int, bowl=\"9 apples and 9 oranges\", total=18):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"9 apples and 9 oranges\", total=18):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_6",
    "sat": "def sat(bananas: int, bowl=\"88015668 apples and 27695749 oranges\", total=173985843):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"88015668 apples and 27695749 oranges\", total=173985843):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_7",
    "sat": "def sat(bananas: int, bowl=\"80675 apples and 40362 oranges\", total=181691):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"80675 apples and 40362 oranges\", total=181691):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_8",
    "sat": "def sat(bananas: int, bowl=\"569 apples and 646 oranges\", total=2056):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"569 apples and 646 oranges\", total=2056):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "MissingBananas_9",
    "sat": "def sat(bananas: int, bowl=\"485366 apples and 418580 oranges\", total=1445037):\n    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n    \"\"\"\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "sols": [
      "def sol(bowl=\"485366 apples and 418580 oranges\", total=1445037):\n    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_0",
    "sat": "def sat(val_index: List[int], nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_1",
    "sat": "def sat(val_index: List[int], nums=[385, 4563]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[385, 4563]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_2",
    "sat": "def sat(val_index: List[int], nums=[0, 0, 0]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[0, 0, 0]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_3",
    "sat": "def sat(val_index: List[int], nums: List[int]=[]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_4",
    "sat": "def sat(val_index: List[int], nums=[98655022, 85494312, 83387260, 49740778]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[98655022, 85494312, 83387260, 49740778]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_5",
    "sat": "def sat(val_index: List[int], nums=[54595]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[54595]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_6",
    "sat": "def sat(val_index: List[int], nums=[12, 47, 40, 40]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[12, 47, 40, 40]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_7",
    "sat": "def sat(val_index: List[int], nums=[218356096, 788458698]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[218356096, 788458698]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_8",
    "sat": "def sat(val_index: List[int], nums=[71432, 42617, 72159, 847447]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[71432, 42617, 72159, 847447]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "SmallestEven_9",
    "sat": "def sat(val_index: List[int], nums=[2540638, 7415332, 6879096, 5477033]):\n    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n    \"\"\"\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "sols": [
      "def sol(nums=[2540638, 7415332, 6879096, 5477033]):\n    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_0",
    "sat": "def sat(h: int, seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_1",
    "sat": "def sat(h: int, seq=[5, 4, 2, 1, 1, 4, 1, 1, 1, 7, 3, 2, 7, 8, 2, 4, 7, 6, 2, 5, 8, 4, 9, 5, 5, 1, 6, 4, 5, 9, 6, 5, 5, 8, 7, 6, 6, 9, 4, 0, 7, 4, 3, 7, 2, 5, 6, 2, 5, 8, 3, 2, 2, 9, 9, 0, 8, 5, 1, 9, 9, 4, 4, 6, 1, 4, 9, 8, 3, 8, 0, 6, 1, 0]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[5, 4, 2, 1, 1, 4, 1, 1, 1, 7, 3, 2, 7, 8, 2, 4, 7, 6, 2, 5, 8, 4, 9, 5, 5, 1, 6, 4, 5, 9, 6, 5, 5, 8, 7, 6, 6, 9, 4, 0, 7, 4, 3, 7, 2, 5, 6, 2, 5, 8, 3, 2, 2, 9, 9, 0, 8, 5, 1, 9, 9, 4, 4, 6, 1, 4, 9, 8, 3, 8, 0, 6, 1, 0]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_2",
    "sat": "def sat(h: int, seq=[2, 4, 2, 4, 8, 3, 7, 2, 3, 2, 4, 3, 8, 1, 5, 1, 9, 8, 8, 7, 1, 5, 5, 7, 5, 8, 2, 1, 2, 7, 5, 1, 1, 0, 2, 8, 8, 9, 4, 0, 4, 4, 3, 1, 9, 9, 5, 5, 1, 0, 8, 9]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[2, 4, 2, 4, 8, 3, 7, 2, 3, 2, 4, 3, 8, 1, 5, 1, 9, 8, 8, 7, 1, 5, 5, 7, 5, 8, 2, 1, 2, 7, 5, 1, 1, 0, 2, 8, 8, 9, 4, 0, 4, 4, 3, 1, 9, 9, 5, 5, 1, 0, 8, 9]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_3",
    "sat": "def sat(h: int, seq=[7, 2, 5, 9, 3, 3]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[7, 2, 5, 9, 3, 3]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_4",
    "sat": "def sat(h: int, seq=[8, 5, 6, 3, 6, 9, 8, 6, 2, 4, 0, 4, 6, 4, 8, 5, 3, 0, 2, 9, 5, 3, 3, 8, 3, 2, 0]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[8, 5, 6, 3, 6, 9, 8, 6, 2, 4, 0, 4, 6, 4, 8, 5, 3, 0, 2, 9, 5, 3, 3, 8, 3, 2, 0]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_5",
    "sat": "def sat(h: int, seq=[8, 6, 5, 0, 6, 1, 1, 4, 4, 3, 6, 1, 0, 0, 6, 7, 4, 0, 1, 2, 1, 5, 2, 0, 7, 7, 2, 6, 8, 6, 0, 2, 0, 8, 8, 8, 4, 1, 4, 1, 6, 1, 5, 4, 7, 8, 1, 8, 9]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[8, 6, 5, 0, 6, 1, 1, 4, 4, 3, 6, 1, 0, 0, 6, 7, 4, 0, 1, 2, 1, 5, 2, 0, 7, 7, 2, 6, 8, 6, 0, 2, 0, 8, 8, 8, 4, 1, 4, 1, 6, 1, 5, 4, 7, 8, 1, 8, 9]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_6",
    "sat": "def sat(h: int, seq=[7, 3, 6, 4, 5, 2, 0, 0, 2, 1, 1, 9, 1, 4, 7, 3, 6, 8, 1, 6, 0, 7, 4, 3, 3, 3, 5, 7, 8, 0, 4, 5, 9, 5, 8, 1, 1, 7, 8, 5, 5, 7, 5, 8, 8, 6, 5, 0, 0, 5, 3, 9, 4, 2, 0, 6, 9, 4]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[7, 3, 6, 4, 5, 2, 0, 0, 2, 1, 1, 9, 1, 4, 7, 3, 6, 8, 1, 6, 0, 7, 4, 3, 3, 3, 5, 7, 8, 0, 4, 5, 9, 5, 8, 1, 1, 7, 8, 5, 5, 7, 5, 8, 8, 6, 5, 0, 0, 5, 3, 9, 4, 2, 0, 6, 9, 4]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_7",
    "sat": "def sat(h: int, seq=[4, 1, 4, 4, 7, 5, 5, 0, 2, 5, 0, 5, 0, 6, 2, 5, 8, 6, 7, 5, 2, 7, 0, 3, 2, 5, 5, 8, 7, 5, 6, 2, 0, 4, 7, 1, 4, 1, 3, 0, 0, 8, 0, 0, 2, 9, 8, 2, 8, 3, 6, 4, 5, 1, 8, 3, 1, 6, 6, 7, 7, 7, 9, 8, 2, 5, 6, 6, 8, 7, 6, 1, 3, 1, 2, 0, 9, 2, 0, 4, 2, 9, 8, 5, 8, 5, 1, 9, 6]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[4, 1, 4, 4, 7, 5, 5, 0, 2, 5, 0, 5, 0, 6, 2, 5, 8, 6, 7, 5, 2, 7, 0, 3, 2, 5, 5, 8, 7, 5, 6, 2, 0, 4, 7, 1, 4, 1, 3, 0, 0, 8, 0, 0, 2, 9, 8, 2, 8, 3, 6, 4, 5, 1, 8, 3, 1, 6, 6, 7, 7, 7, 9, 8, 2, 5, 6, 6, 8, 7, 6, 1, 3, 1, 2, 0, 9, 2, 0, 4, 2, 9, 8, 5, 8, 5, 1, 9, 6]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_8",
    "sat": "def sat(h: int, seq=[5, 7, 4, 7, 6, 8, 2, 8, 3, 9, 5, 2, 2, 0, 4, 1, 7, 6, 3, 8, 6, 4, 4, 5, 4, 1, 4, 8, 2, 5, 2, 5, 4, 4, 4, 2, 5, 8, 4, 7, 7, 1, 4, 1, 3, 2, 3, 7, 4, 2, 2, 0, 6, 9, 8, 8, 5, 7, 0, 1, 8, 2, 6, 9, 0, 6, 1, 9, 6, 1, 4, 3, 8, 5]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[5, 7, 4, 7, 6, 8, 2, 8, 3, 9, 5, 2, 2, 0, 4, 1, 7, 6, 3, 8, 6, 4, 4, 5, 4, 1, 4, 8, 2, 5, 2, 5, 4, 4, 4, 2, 5, 8, 4, 7, 7, 1, 4, 1, 3, 2, 3, 7, 4, 2, 2, 0, 6, 9, 8, 8, 5, 7, 0, 1, 8, 2, 6, 9, 0, 6, 1, 9, 6, 1, 4, 3, 8, 5]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "GreatestHIndex_9",
    "sat": "def sat(h: int, seq=[7, 2, 5, 4, 4, 8, 5, 5, 8, 1, 1, 3, 1]):\n    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n    \"\"\"\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "sols": [
      "def sol(seq=[7, 2, 5, 4, 4, 8, 5, 5, 8, 1, 1, 3, 1]):\n    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_0",
    "sat": "def sat(strange: List[int], li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_1",
    "sat": "def sat(strange: List[int], li=[7, 8, 8, 2, 4, 7, 1, 9, 3, 4, 7, 7, 6, 7, 8, 2, 8, 9, 5]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[7, 8, 8, 2, 4, 7, 1, 9, 3, 4, 7, 7, 6, 7, 8, 2, 8, 9, 5]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_2",
    "sat": "def sat(strange: List[int], li=[7, 1, 5, 3]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[7, 1, 5, 3]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_3",
    "sat": "def sat(strange: List[int], li=[7, 5, 6, 8]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[7, 5, 6, 8]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_4",
    "sat": "def sat(strange: List[int], li=[3, 6, 7, 6, 4, 2, 1]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[3, 6, 7, 6, 4, 2, 1]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_5",
    "sat": "def sat(strange: List[int], li=[8, 0, 4, 5, 4, 9, 5, 9, 4, 3, 2, 0, 3, 7, 8, 1, 0]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[8, 0, 4, 5, 4, 9, 5, 9, 4, 3, 2, 0, 3, 7, 8, 1, 0]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_6",
    "sat": "def sat(strange: List[int], li=[6, 4, 5, 3, 9, 7, 5, 4, 4, 5, 3, 3, 9, 2, 2, 8, 4, 6]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[6, 4, 5, 3, 9, 7, 5, 4, 4, 5, 3, 3, 9, 2, 2, 8, 4, 6]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_7",
    "sat": "def sat(strange: List[int], li=[2, 4, 9, 8, 6]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[2, 4, 9, 8, 6]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_8",
    "sat": "def sat(strange: List[int], li=[0, 0, 6]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[0, 0, 6]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "StrangeSort_9",
    "sat": "def sat(strange: List[int], li=[0, 0, 6, 3]):\n    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n    \"\"\"\n    if len(li) < 2:\n        return strange == li\n    bounds = strange[:2]  # lower, upper\n    for i, n in enumerate(strange):\n        assert bounds[0] <= n <= bounds[1]\n        bounds[i % 2] = n\n    return sorted(strange) == sorted(li)  # permutation check",
    "sols": [
      "def sol(li=[0, 0, 6, 3]):\n    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_0",
    "sat": "def sat(coords: List[List[float]], sides=[8.9, 10.8, 17.0]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[8.9, 10.8, 17.0]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_1",
    "sat": "def sat(coords: List[List[float]], sides=[31.147192483581243, 63.83992603620599, 89.92198610073204]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[31.147192483581243, 63.83992603620599, 89.92198610073204]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_2",
    "sat": "def sat(coords: List[List[float]], sides=[51.2495420505752, 56.38380871519867, 79.71650129633139]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[51.2495420505752, 56.38380871519867, 79.71650129633139]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_3",
    "sat": "def sat(coords: List[List[float]], sides=[63.10620665280613, 72.41890186491725, 89.47739756139286]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[63.10620665280613, 72.41890186491725, 89.47739756139286]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_4",
    "sat": "def sat(coords: List[List[float]], sides=[51.004897801286354, 58.032341779993914, 99.6313559087806]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[51.004897801286354, 58.032341779993914, 99.6313559087806]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_5",
    "sat": "def sat(coords: List[List[float]], sides=[15.227441857106783, 69.29825804596149, 74.75560471842103]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[15.227441857106783, 69.29825804596149, 74.75560471842103]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_6",
    "sat": "def sat(coords: List[List[float]], sides=[65.98541851118428, 70.23703010155045, 85.68779217388806]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[65.98541851118428, 70.23703010155045, 85.68779217388806]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_7",
    "sat": "def sat(coords: List[List[float]], sides=[44.360744454059585, 57.69963419834724, 61.71736703730848]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[44.360744454059585, 57.69963419834724, 61.71736703730848]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_8",
    "sat": "def sat(coords: List[List[float]], sides=[27.499986348608275, 50.27744798607622, 77.59512363067961]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[27.499986348608275, 50.27744798607622, 77.59512363067961]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "HeronTriangle_9",
    "sat": "def sat(coords: List[List[float]], sides=[61.65456320960063, 75.61322754037535, 89.20199715394837]):\n    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n    \"\"\"\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "sols": [
      "def sol(sides=[61.65456320960063, 75.61322754037535, 89.20199715394837]):\n    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_0",
    "sat": "def sat(problem: int, weights=[1, 2, 5, 2, 1, 17], max_weight=100):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[1, 2, 5, 2, 1, 17], max_weight=100):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_1",
    "sat": "def sat(problem: int, weights=[87, 65, 41, 94, 41, 50, 87], max_weight=558):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[87, 65, 41, 94, 41, 50, 87], max_weight=558):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_2",
    "sat": "def sat(problem: int, weights=[97, 36, 83, 36, 49], max_weight=303):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[97, 36, 83, 36, 49], max_weight=303):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_3",
    "sat": "def sat(problem: int, weights=[85, 27, 82, 90, 97, 51, 51, 77, 90, 82, 27, 85], max_weight=853):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[85, 27, 82, 90, 97, 51, 51, 77, 90, 82, 27, 85], max_weight=853):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_4",
    "sat": "def sat(problem: int, weights=[55, 83, 1, 38, 38, 1, 93, 55], max_weight=431):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[55, 83, 1, 38, 38, 1, 93, 55], max_weight=431):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_5",
    "sat": "def sat(problem: int, weights=[91, 82, 95, 8, 64, 8, 95, 82, 64], max_weight=637):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[91, 82, 95, 8, 64, 8, 95, 82, 64], max_weight=637):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_6",
    "sat": "def sat(problem: int, weights=[37, 13, 31, 21, 99, 82, 82, 81, 21, 31, 13, 37], max_weight=562):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[37, 13, 31, 21, 99, 82, 82, 81, 21, 31, 13, 37], max_weight=562):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_7",
    "sat": "def sat(problem: int, weights=[82, 3, 21, 23, 96, 1, 1, 96, 44, 21, 3, 82], max_weight=517):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[82, 3, 21, 23, 96, 1, 1, 96, 44, 21, 3, 82], max_weight=517):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_8",
    "sat": "def sat(problem: int, weights=[91, 44, 99, 15, 81, 39, 39, 13, 94, 13, 39, 39, 81, 15, 99, 44, 76], max_weight=973):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[91, 44, 99, 15, 81, 39, 39, 13, 94, 13, 39, 39, 81, 15, 99, 44, 76], max_weight=973):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "InvestigateCrash_9",
    "sat": "def sat(problem: int, weights=[20, 70, 56, 29, 20], max_weight=203):\n    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n    \"\"\"\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "sols": [
      "def sol(weights=[20, 70, 56, 29, 20], max_weight=203):\n    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_0",
    "sat": "def sat(pal: str, s=\"palindromordinals\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"palindromordinals\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_1",
    "sat": "def sat(pal: str, s=\"kamaxyquuk&mqWsRuy\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"kamaxyquuk&mqWsRuy\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_2",
    "sat": "def sat(pal: str, s=\"quiqwi\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"quiqwi\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_3",
    "sat": "def sat(pal: str, s=\"wumeum\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"wumeum\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_4",
    "sat": "def sat(pal: str, s=\"g\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"g\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_5",
    "sat": "def sat(pal: str, s=\"tepogyteJom\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"tepogyteJom\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_6",
    "sat": "def sat(pal: str, s=\"lita,;!\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"lita,;!\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_7",
    "sat": "def sat(pal: str, s=\"goxywPyy\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"goxywPyy\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_8",
    "sat": "def sat(pal: str, s=\"kihedefhOhedef\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"kihedefhOhedef\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "ClosestPalindrome_9",
    "sat": "def sat(pal: str, s=\"vupicyvupicy\"):\n    \"\"\"\n    Find the closest palindrome\n    \"\"\"\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "sols": [
      "def sol(s=\"vupicyvupicy\"):\n    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_0",
    "sat": "def sat(li: List[str], lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_1",
    "sat": "def sat(li: List[str], lists=[['xinasihamyxi', 'saxujojugebyzulas']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['xinasihamyxi', 'saxujojugebyzulas']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_2",
    "sat": "def sat(li: List[str], lists=[['cipytutuh', 'k', 'quufysyquyt', 'lumim'], ['mo', 'mogy'], ['rugocyzo', 'xoquagychocefitextu', 'dochi']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['cipytutuh', 'k', 'quufysyquyt', 'lumim'], ['mo', 'mogy'], ['rugocyzo', 'xoquagychocefitextu', 'dochi']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_3",
    "sat": "def sat(li: List[str], lists=[['nytabywilubiquaf', 'baquychapuraqu'], ['bodoguxechyfu', 'zyfasycamuchogu', 'ducedasytypyjabu']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['nytabywilubiquaf', 'baquychapuraqu'], ['bodoguxechyfu', 'zyfasycamuchogu', 'ducedasytypyjabu']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_4",
    "sat": "def sat(li: List[str], lists=[['sechuzulequyc', 'fezalatex', 'textamo', 'bithaxac'], ['quytynujyquuzoja', 'quihefyte', 'hawechihumysygicus'], ['thetesa', 'g', 'divukesutextu'], ['r', 'saquoc']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['sechuzulequyc', 'fezalatex', 'textamo', 'bithaxac'], ['quytynujyquuzoja', 'quihefyte', 'hawechihumysygicus'], ['thetesa', 'g', 'divukesutextu'], ['r', 'saquoc']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_5",
    "sat": "def sat(li: List[str], lists=[['vupesedudethubilyd', 'ruquywekawakavoc']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['vupesedudethubilyd', 'ruquywekawakavoc']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_6",
    "sat": "def sat(li: List[str], lists=[['quupefogoquykagy', 'myrajahydi'], ['jacilyvahatextixa', 'cobifequarothu']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['quupefogoquykagy', 'myrajahydi'], ['jacilyvahatextixa', 'cobifequarothu']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_7",
    "sat": "def sat(li: List[str], lists=[['zo', 'xaloquixolytanutezu'], ['nowuguq', 'fucewigazahikefonoh', 'kocotextuxace', 'fozanoh'], ['vyhufir', 'q'], ['t', 'cukybofad', 'saquaquypyquaxetixoj', 'cechirukamo']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['zo', 'xaloquixolytanutezu'], ['nowuguq', 'fucewigazahikefonoh', 'kocotextuxace', 'fozanoh'], ['vyhufir', 'q'], ['t', 'cukybofad', 'saquaquypyquaxetixoj', 'cechirukamo']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_8",
    "sat": "def sat(li: List[str], lists=[['fyxavejycyhec', 'zacheh', 'curesochuzasewurite'], ['hosyvyzuchere', 'rimokunytynyxipyth']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['fyxavejycyhec', 'zacheh', 'curesochuzasewurite'], ['hosyvyzuchere', 'rimokunytynyxipyth']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "NarrowerList_9",
    "sat": "def sat(li: List[str], lists=[['nyxozuqui', 'chithegi']]):\n    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n    \"\"\"\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "sols": [
      "def sol(lists=[['nyxozuqui', 'chithegi']]):\n    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval"
  },
  {
    "name": "ThreePrimes_0",
    "sat": "def sat(factors: List[List[int]]):\n    \"\"\"\n    Find all 247 integers <= 1000 that are the product of exactly three primes.\n    Each integer should represented as the list of its three prime factors.\n    \"\"\"\n    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    assert all(p in primes for f in factors for p in f), \"all factors must be prime\"\n    nums = {p * q * r for p, q, r in factors}\n    return max(nums) < 1000 and len(nums) == 247",
    "sols": [
      "def sol():\n    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    return [[p, q, r] for p in primes for q in primes if p <= q for r in primes if q <= r and p * q * r < 1000]"
    ],
    "module": "human_eval"
  },
  {
    "name": "IsEven_0",
    "sat": "def sat(b: bool, n=10):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=10):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_1",
    "sat": "def sat(b: bool, n=0):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=0):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_2",
    "sat": "def sat(b: bool, n=1):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=1):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_3",
    "sat": "def sat(b: bool, n=2):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=2):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_4",
    "sat": "def sat(b: bool, n=3):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=3):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_5",
    "sat": "def sat(b: bool, n=4):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=4):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_6",
    "sat": "def sat(b: bool, n=5):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=5):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_7",
    "sat": "def sat(b: bool, n=6):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=6):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_8",
    "sat": "def sat(b: bool, n=7):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=7):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "IsEven_9",
    "sat": "def sat(b: bool, n=8):\n    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "sols": [
      "def sol(n=8):\n    return n % 2 == 0"
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_0",
    "sat": "def sat(s: str, word=\"antidisestablishmentarianism\", max_len=10):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"antidisestablishmentarianism\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_1",
    "sat": "def sat(s: str, word=\"hukytypa\", max_len=14):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"hukytypa\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_2",
    "sat": "def sat(s: str, word=\"wetasamat\", max_len=7):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"wetasamat\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_3",
    "sat": "def sat(s: str, word=\"madykavowykab\", max_len=9):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"madykavowykab\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_4",
    "sat": "def sat(s: str, word=\"quyxuquo\", max_len=7):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"quyxuquo\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_5",
    "sat": "def sat(s: str, word=\"mecydy\", max_len=9):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"mecydy\", max_len=9):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_6",
    "sat": "def sat(s: str, word=\"hyvunecukakohocysegalawa\", max_len=11):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"hyvunecukakohocysegalawa\", max_len=11):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_7",
    "sat": "def sat(s: str, word=\"xowyquychivaquikug\", max_len=7):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"xowyquychivaquikug\", max_len=7):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_8",
    "sat": "def sat(s: str, word=\"rynofutezobugumozothoth\", max_len=10):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"rynofutezobugumozothoth\", max_len=10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "Abbreviate_9",
    "sat": "def sat(s: str, word=\"gyxojokutivyfotathu\", max_len=14):\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "sols": [
      "def sol(word=\"gyxojokutivyfotathu\", max_len=14):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_0",
    "sat": "def sat(corners: List[List[int]], m=10, n=9, a=5, target=4):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=10, n=9, a=5, target=4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_1",
    "sat": "def sat(corners: List[List[int]], m=36, n=19, a=5, target=34):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=36, n=19, a=5, target=34):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_2",
    "sat": "def sat(corners: List[List[int]], m=3, n=6, a=1, target=18):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=3, n=6, a=1, target=18):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_3",
    "sat": "def sat(corners: List[List[int]], m=181, n=70, a=2, target=3186):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=181, n=70, a=2, target=3186):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_4",
    "sat": "def sat(corners: List[List[int]], m=308, n=4, a=7, target=48):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=308, n=4, a=7, target=48):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_5",
    "sat": "def sat(corners: List[List[int]], m=403, n=486, a=5, target=7938):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=403, n=486, a=5, target=7938):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_6",
    "sat": "def sat(corners: List[List[int]], m=690, n=5, a=2, target=1037):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=690, n=5, a=2, target=1037):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_7",
    "sat": "def sat(corners: List[List[int]], m=4, n=466, a=7, target=67):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=4, n=466, a=7, target=67):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_8",
    "sat": "def sat(corners: List[List[int]], m=744, n=69, a=10, target=529):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=744, n=69, a=10, target=529):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SquareTiles_9",
    "sat": "def sat(corners: List[List[int]], m=7, n=9, a=4, target=7):\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "sols": [
      "def sol(m=7, n=9, a=4, target=7):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_0",
    "sat": "def sat(lb: List[bool], trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_1",
    "sat": "def sat(lb: List[bool], trips=[[0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 1], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 0, 0]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 1], [1, 0, 1], [0, 1, 1], [0, 1, 1], [0, 0, 1], [1, 1, 0], [1, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_2",
    "sat": "def sat(lb: List[bool], trips=[[0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [1, 0, 1], [0, 0, 1], [1, 1, 0], [0, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [1, 0, 1], [0, 0, 1], [1, 1, 0], [0, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_3",
    "sat": "def sat(lb: List[bool], trips=[[0, 1, 1], [0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_4",
    "sat": "def sat(lb: List[bool], trips=[[0, 0, 0], [0, 0, 0], [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 0], [1, 1, 0], [1, 0, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 0], [0, 0, 0], [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 1], [1, 0, 1], [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 0], [0, 1, 0], [1, 1, 0], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_5",
    "sat": "def sat(lb: List[bool], trips=[[0, 0, 1], [1, 1, 1], [0, 0, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 1, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_6",
    "sat": "def sat(lb: List[bool], trips=[[0, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [1, 0, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 1], [1, 0, 0], [0, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_7",
    "sat": "def sat(lb: List[bool], trips=[[0, 0, 1], [1, 0, 1], [0, 1, 0], [0, 0, 1], [0, 0, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 0, 1], [1, 0, 1], [0, 1, 0], [0, 0, 1], [0, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_8",
    "sat": "def sat(lb: List[bool], trips=[[0, 1, 1], [0, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1], [0, 1, 1], [0, 1, 0]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[0, 1, 1], [0, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1], [0, 1, 1], [0, 1, 0]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasyTwos_9",
    "sat": "def sat(lb: List[bool], trips=[[1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [0, 1, 1]]):\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "sols": [
      "def sol(trips=[[1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1], [0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_0",
    "sat": "def sat(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_1",
    "sat": "def sat(n: int, scores=[0, 0], k=1):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[0, 0], k=1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_2",
    "sat": "def sat(n: int, scores=[13, 8, 0], k=1):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[13, 8, 0], k=1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_3",
    "sat": "def sat(n: int, scores=[18, 10, 7, 3], k=0):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[18, 10, 7, 3], k=0):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_4",
    "sat": "def sat(n: int, scores=[28, 24, 19, 13, 3], k=2):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[28, 24, 19, 13, 3], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_5",
    "sat": "def sat(n: int, scores=[27, 24, 24, 21, 17, 15], k=1):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[27, 24, 24, 21, 17, 15], k=1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_6",
    "sat": "def sat(n: int, scores=[34, 22, 15, 15, 11, 6, 2], k=6):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[34, 22, 15, 15, 11, 6, 2], k=6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_7",
    "sat": "def sat(n: int, scores=[21, 20, 18, 17, 14, 13, 13, 8], k=5):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[21, 20, 18, 17, 14, 13, 13, 8], k=5):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_8",
    "sat": "def sat(n: int, scores=[1, 1, 1, 0, 0, 0, 0, 0, 0], k=2):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 0, 0, 0, 0, 0, 0], k=2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DecreasingCountComparison_9",
    "sat": "def sat(n: int, scores=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=1):\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "sols": [
      "def sol(scores=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0], k=1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_0",
    "sat": "def sat(t: str, s=\"Problems\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"Problems\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_1",
    "sat": "def sat(t: str, s=\"FONAweG\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"FONAweG\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_2",
    "sat": "def sat(t: str, s=\"tExtizihYtyC\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"tExtizihYtyC\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_3",
    "sat": "def sat(t: str, s=\"pUWaGIpIDahIfewOracypAkEcHYtHIPikyKedijytekE\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"pUWaGIpIDahIfewOracypAkEcHYtHIPikyKedijytekE\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_4",
    "sat": "def sat(t: str, s=\"GYkUriJuNUtUQUETExTotExTiWocHotahYfocHoSY\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"GYkUriJuNUtUQUETExTotExTiWocHotahYfocHoSY\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_5",
    "sat": "def sat(t: str, s=\"JoDU\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"JoDU\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_6",
    "sat": "def sat(t: str, s=\"jOLecaT\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"jOLecaT\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_7",
    "sat": "def sat(t: str, s=\"WaLikUHOgUkyg\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"WaLikUHOgUkyg\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_8",
    "sat": "def sat(t: str, s=\"VyhYfA\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"VyhYfA\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "VowelDrop_9",
    "sat": "def sat(t: str, s=\"LUtolyJuTEXtOPUKUCIXiHIVUthIDYGURuSonE\"):\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "sols": [
      "def sol(s=\"LUtolyJuTEXtOPUKUCIXiHIVUthIDYGURuSonE\"):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_0",
    "sat": "def sat(squares: List[List[int]], m=10, n=5, target=50):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=5, target=50):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_1",
    "sat": "def sat(squares: List[List[int]], m=39, n=36, target=1404):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=39, n=36, target=1404):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_2",
    "sat": "def sat(squares: List[List[int]], m=26, n=27, target=702):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=26, n=27, target=702):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_3",
    "sat": "def sat(squares: List[List[int]], m=10, n=49, target=490):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=10, n=49, target=490):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_4",
    "sat": "def sat(squares: List[List[int]], m=22, n=20, target=440):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=22, n=20, target=440):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_5",
    "sat": "def sat(squares: List[List[int]], m=5, n=24, target=120):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=5, n=24, target=120):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_6",
    "sat": "def sat(squares: List[List[int]], m=37, n=23, target=850):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=37, n=23, target=850):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_7",
    "sat": "def sat(squares: List[List[int]], m=45, n=41, target=1844):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=45, n=41, target=1844):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_8",
    "sat": "def sat(squares: List[List[int]], m=12, n=49, target=588):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=12, n=49, target=588):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "DominoTile_9",
    "sat": "def sat(squares: List[List[int]], m=41, n=38, target=1558):\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "sols": [
      "def sol(m=41, n=38, target=1558):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_0",
    "sat": "def sat(n: int, ops=['x++', '--x', '--x'], target=19143212):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', '--x', '--x'], target=19143212):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_1",
    "sat": "def sat(n: int, ops=['x--', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', '--x', '--x', '--x', 'x--', '--x', '++x', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x--', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', '++x', '--x'], target=1116):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x--', 'x++', '++x', '--x', 'x++', 'x++', 'x--', '++x', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', '--x', '--x', '--x', 'x--', '--x', '++x', '++x', '--x', '++x', '--x', 'x++', 'x--', '++x', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '++x', 'x--', 'x--', '--x', '++x', '++x', 'x++', 'x++', 'x++', '++x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '--x', '--x', '++x', '--x'], target=1116):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_2",
    "sat": "def sat(n: int, ops=['x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x++'], target=40324):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x--', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x++'], target=40324):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_3",
    "sat": "def sat(n: int, ops=['--x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', 'x--'], target=67045):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++', '++x', 'x++', '++x', 'x++', 'x++', 'x--'], target=67045):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_4",
    "sat": "def sat(n: int, ops=['++x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x--', '++x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '--x', '++x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', '--x', '++x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', '++x', '++x', '++x', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x++', '++x', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', '--x', '--x', '++x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x++', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x--', '--x', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '++x', '--x', '--x', 'x++', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '++x', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x++', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', '--x', '--x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', '--x', '++x', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', '++x', 'x--', '++x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', 'x++', '--x'], target=22674):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '--x', 'x--', '++x', '++x', '--x', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '++x', 'x++', 'x++', 'x++', '--x', 'x--', '++x', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x++', '++x', '--x', '--x', '++x', 'x--', '++x', '++x', 'x--', '++x', 'x--', 'x++', 'x--', '--x', '--x', '++x', '--x', '++x', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', 'x--', '--x', '--x', '++x', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', 'x++', '--x', 'x++', '++x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '--x', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x--', 'x--', '++x', '++x', '++x', '++x', '--x', '--x', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '--x', 'x++', '--x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', '++x', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', 'x++', '--x', '--x', 'x--', '--x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x--', '++x', 'x--', 'x++', '++x', '++x', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', 'x--', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', '--x', '++x', '--x', '--x', '--x', '--x', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', '--x', '--x', '++x', 'x++', '--x', 'x--', '--x', 'x++', '++x', '++x', '++x', '--x', 'x--', '--x', '++x', 'x++', '--x', '--x', '++x', '--x', '++x', 'x++', 'x++', 'x++', 'x++', 'x++', '--x', 'x++', 'x++', '--x', '--x', 'x--', '++x', '--x', '++x', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x++', '--x', 'x--', 'x--', '--x', 'x++', 'x++', '++x', '++x', '++x', '--x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '--x', '++x', '--x', 'x++', '--x', 'x++', '++x', '--x', 'x++', 'x--', '--x', '++x', 'x++', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x--', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', '++x', '--x', '--x', 'x++', 'x--', '--x', 'x--', 'x++', 'x++', 'x--', 'x++', 'x++', 'x++', '--x', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '++x', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', '--x', '++x', 'x--', 'x++', '++x', '--x', '--x', '--x', 'x--', 'x++', '++x', 'x++', '--x', 'x++', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', 'x--', '--x', '--x', '--x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', '--x', '--x', 'x++', '--x', '--x', '++x', 'x++', '++x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x++', 'x--', 'x--', '++x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', '++x', 'x++', '--x', 'x--', '++x', '--x', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', 'x++', '--x', '++x', '--x', '--x', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', '--x', '++x', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '++x', '++x', '--x', '--x', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '--x', '++x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '++x', 'x--', '++x', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', 'x++', 'x++', '++x', '++x', 'x--', '++x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x--', '++x', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', 'x--', 'x++', 'x--', '--x', '--x', 'x--', '--x', '--x', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', '--x', '++x', '++x', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '--x', 'x--', '++x', '--x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '++x', '++x', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '++x', '--x', '++x', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', 'x++', '--x', '++x', '++x', 'x--', 'x--', '++x', '--x', '--x', 'x++', '--x', '--x', '++x', '--x', '--x', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', '++x', 'x++', '--x', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', '--x', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', 'x++', 'x--', 'x++', '++x', 'x++', '--x', 'x++', '--x', '--x', 'x++', '++x', '++x', '++x', '++x', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', 'x--', '++x', '--x', '++x', 'x++', '++x', '++x', 'x++', '--x', '--x', 'x++', 'x++', '++x', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', '++x', 'x--', '++x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', '--x', '--x', '++x', 'x++', '--x', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', 'x++', '++x', 'x--', '--x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', 'x--', '--x', 'x--', 'x++', 'x--', '++x', 'x--', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', 'x++', '--x'], target=22674):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_5",
    "sat": "def sat(n: int, ops=['++x', '++x', '++x', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', '--x'], target=51245):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['++x', '++x', '++x', '++x', 'x++', '++x', '--x', '++x', 'x--', '--x', '--x', '++x', 'x--', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x--', 'x--', 'x++', '--x', '--x', '++x', '++x', 'x--', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', 'x--', 'x++', 'x--', '--x', '++x', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '--x', '++x', '++x', '++x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', 'x--', 'x++', 'x--', '--x'], target=51245):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_6",
    "sat": "def sat(n: int, ops=['--x', 'x++'], target=77225):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x++'], target=77225):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_7",
    "sat": "def sat(n: int, ops=['x++', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', 'x--', 'x--', '++x'], target=87258):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['x++', 'x--', 'x++', 'x++', '--x', 'x--', '--x', '++x', 'x++', '++x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', '++x', '++x', '--x', '++x', '--x', '++x', '++x', '--x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x++', '++x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', 'x--', 'x--', '++x'], target=87258):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_8",
    "sat": "def sat(n: int, ops=['--x', '--x', 'x++', 'x++', '++x', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', '--x', '--x', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '++x', '++x', '++x', 'x--', '--x', '++x', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x--', 'x++', 'x++', '--x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', '--x', '++x', '++x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '--x', '--x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x++'], target=1517):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', '--x', 'x++', 'x++', '++x', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', 'x--', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '++x', '++x', 'x--', 'x--', '--x', 'x--', '++x', 'x++', '++x', '--x', 'x++', '++x', '++x', '++x', 'x++', '--x', '--x', 'x++', '--x', '--x', '--x', 'x--', '++x', '++x', 'x++', 'x++', '--x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', '--x', 'x--', '++x', '++x', 'x--', 'x++', '++x', 'x--', '++x', 'x++', '--x', '--x', 'x--', '++x', '--x', '++x', 'x--', 'x--', '++x', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x++', '++x', '--x', '--x', '++x', 'x--', 'x++', '++x', '--x', 'x++', '++x', 'x--', 'x--', '++x', 'x--', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', 'x++', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '--x', 'x++', '++x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', '++x', 'x--', 'x++', '++x', '--x', 'x++', 'x--', 'x++', '--x', '++x', 'x--', 'x--', 'x++', '--x', '--x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', '++x', 'x--', '--x', '--x', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', 'x++', '++x', '--x', '++x', '++x', 'x++', '++x', '++x', '--x', '++x', 'x--', 'x--', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', 'x++', '++x', 'x++', 'x++', '--x', 'x++', 'x--', 'x++', '--x', '--x', '--x', 'x--', '++x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x++', 'x++', 'x++', '--x', '++x', '++x', '++x', 'x--', '--x', '++x', 'x--', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', '--x', '++x', 'x--', '--x', '++x', '++x', '--x', '--x', '++x', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', '++x', 'x++', 'x++', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x--', '++x', '++x', '++x', 'x++', '++x', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '--x', '--x', 'x--', 'x++', 'x++', '--x', '++x', '--x', '++x', '++x', '--x', 'x--', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '++x', '++x', '--x', '++x', '++x', '--x', '++x', 'x--', 'x--', 'x++', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '--x', 'x--', '--x', 'x--', '--x', 'x--', '--x', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', '--x', '++x', '++x', '++x', 'x--', 'x++', 'x--', 'x++', 'x--', 'x++', '++x', 'x++', 'x--', '++x', '++x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', '++x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '--x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', '--x', '++x', '++x', '--x', '--x', 'x--', '--x', 'x--', '--x', '--x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '--x', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '++x', '++x', '--x', 'x--', '++x', 'x--', '++x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '--x', '++x', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '++x', '--x', 'x++', 'x++', '++x', '--x', 'x--', 'x--', 'x--', '++x', 'x++', '--x', 'x++', '++x', 'x++', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', '--x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '--x', '--x', '--x', '++x', 'x--', 'x++', 'x--', '++x', '++x', '++x', '++x', 'x++', '++x', 'x--', 'x++', 'x++', '++x', 'x--', '--x', '++x', '--x', '--x', 'x++', '++x', 'x++', '--x', '--x', '--x', '++x', '++x', '--x', '++x', 'x--', '--x', 'x++', '--x', '++x', '--x', 'x--', 'x--', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x--', '--x', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', 'x--', 'x++', 'x++', 'x++', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x++', 'x--', 'x++', 'x++', '++x', '--x', '--x', 'x++', 'x++', '--x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', 'x++', 'x++', '--x', '++x', 'x++'], target=1517):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "IncDec_9",
    "sat": "def sat(n: int, ops=['--x', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '--x', '++x', 'x++', 'x++', 'x--'], target=65642):\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "sols": [
      "def sol(ops=['--x', 'x--', '++x', '++x', 'x++', '++x', '--x', '--x', '++x', '--x', '++x', 'x--', 'x--', '--x', 'x--', '--x', '++x', '--x', '++x', '--x', 'x++', 'x++', 'x--', '++x', 'x--', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', 'x++', 'x--', '++x', 'x++', '--x', '--x', '++x', 'x++', 'x++', 'x--'], target=65642):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_0",
    "sat": "def sat(n: int, s=\"aaAab\", t=\"aAaaB\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"aaAab\", t=\"aAaaB\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_1",
    "sat": "def sat(n: int, s=\"lYthAkUgaxIpUHUWUfO\", t=\"lythAkuGAXIpUHUWuFo\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"lYthAkUgaxIpUHUWUfO\", t=\"lythAkuGAXIpUHUWuFo\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_2",
    "sat": "def sat(n: int, s=\"coSukuMoDu\", t=\"COsuKUgUkytexT\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"coSukuMoDu\", t=\"COsuKUgUkytexT\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_3",
    "sat": "def sat(n: int, s=\"quaCAkoQU\", t=\"qUacAKOnoQUaXO\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"quaCAkoQU\", t=\"qUacAKOnoQUaXO\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_4",
    "sat": "def sat(n: int, s=\"VawuLemizu\", t=\"VAWUlemIZUSERAcAJuqU\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"VawuLemizu\", t=\"VAWUlemIZUSERAcAJuqU\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_5",
    "sat": "def sat(n: int, s=\"WeCYGOTExtiDe\", t=\"WecYCarEtEXTUt\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"WeCYGOTExtiDe\", t=\"WecYCarEtEXTUt\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_6",
    "sat": "def sat(n: int, s=\"KEjExeCHomATextaG\", t=\"keJEXEChoMaTextag\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"KEjExeCHomATextaG\", t=\"keJEXEChoMaTextag\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_7",
    "sat": "def sat(n: int, s=\"GiPiThUrypOHUpAgulyh\", t=\"gIpithURYpOHUPagUlyh\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"GiPiThUrypOHUpAgulyh\", t=\"gIpithURYpOHUPagUlyh\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_8",
    "sat": "def sat(n: int, s=\"beViWAbAle\", t=\"BEVIwABalE\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"beViWAbAle\", t=\"BEVIwABalE\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "CompareInAnyCase_9",
    "sat": "def sat(n: int, s=\"teXtihIquocHuzOsaHOV\", t=\"TEXtIhIryBApAgUtyhYD\"):\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "sols": [
      "def sol(s=\"teXtihIquocHuzOsaHOV\", t=\"TEXtIhIryBApAgUtyhYD\"):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_0",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_1",
    "sat": "def sat(s: str, matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_2",
    "sat": "def sat(s: str, matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_3",
    "sat": "def sat(s: str, matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_4",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_5",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_6",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_7",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_8",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=1):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SlidingOne_9",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "sols": [
      "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_0",
    "sat": "def sat(s: str, inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_1",
    "sat": "def sat(s: str, inp=\"2+1+2+1+3+2+2+1+3+1\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+2+1+3+2+2+1+3+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_2",
    "sat": "def sat(s: str, inp=\"3+2+1+3+2+3+3+3+1+1+1+1+3+3+1+3+2+3+1+3+1+3+2+2+2+2+3+1+2+1+1+3+2+2+2+1+1+3+1+1+2+1+3+1+1+1+1+1\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+3+2+3+3+3+1+1+1+1+3+3+1+3+2+3+1+3+1+3+2+2+2+2+3+1+2+1+1+3+2+2+2+1+1+3+1+1+2+1+3+1+1+1+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_3",
    "sat": "def sat(s: str, inp=\"3+2+3+2+3+2+3+1+3+2+2+1+3+2+2+2+1+2+1+1+2+3+2+3+1+3+1+2+3+2+3+2+1\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+3+2+3+2+3+1+3+2+2+1+3+2+2+2+1+2+1+1+2+3+2+3+1+3+1+2+3+2+3+2+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_4",
    "sat": "def sat(s: str, inp=\"3+2+2+2+3+1+3+1+2+3+1+2+2+2+2+3+2\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+2+2+3+1+3+1+2+3+1+2+2+2+2+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_5",
    "sat": "def sat(s: str, inp=\"1+3+3+3+1+2+1+2+1+3+2+2+1+2+2+3+2+2+1+1+1+1+3+3+2+1+1+3+3+2+2+1+2+2+3+3\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+3+3+3+1+2+1+2+1+3+2+2+1+2+2+3+2+2+1+1+1+1+3+3+2+1+1+3+3+2+2+1+2+2+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_6",
    "sat": "def sat(s: str, inp=\"3+2+1+2+2+3+1+2+1+3+1+3+2+3+3+1+2+1+2+3+3+1+1+2+2+2+2+1+3+3+2+2+2+3+2+3+2+2+3+3+3\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"3+2+1+2+2+3+1+2+1+3+1+3+2+3+3+1+2+1+2+3+3+1+1+2+2+2+2+1+3+3+2+2+2+3+2+3+2+2+3+3+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_7",
    "sat": "def sat(s: str, inp=\"2+1+1+1+1+2+2+2+3+1+1+3+2+1+1+3+3+2+3+3+3+3+1+3+1+2+3+3+2\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+1+1+1+1+2+2+2+3+1+1+3+2+1+1+3+3+2+3+3+3+3+1+3+1+2+3+3+2\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_8",
    "sat": "def sat(s: str, inp=\"2+3+1+2+2+2+3+2+3+3+1+1+3+3+1+2+3+1+2+2+2+3+3+3+2+1+1\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"2+3+1+2+2+2+3+2+3+3+1+1+3+3+1+2+3+1+2+2+2+3+3+3+2+1+1\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "SortPlusPlus_9",
    "sat": "def sat(s: str, inp=\"1+2+3\"):\n    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "sols": [
      "def sol(inp=\"1+2+3\"):\n    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_0",
    "sat": "def sat(s: str, word=\"konjac\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"konjac\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_1",
    "sat": "def sat(s: str, word=\"huhusaziv\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"huhusaziv\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_2",
    "sat": "def sat(s: str, word=\"tupifynanerypuchyt\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"tupifynanerypuchyt\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_3",
    "sat": "def sat(s: str, word=\"t\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"t\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_4",
    "sat": "def sat(s: str, word=\"z\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"z\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_5",
    "sat": "def sat(s: str, word=\"zacheheduquanaro\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"zacheheduquanaro\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_6",
    "sat": "def sat(s: str, word=\"fivavobusigy\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"fivavobusigy\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_7",
    "sat": "def sat(s: str, word=\"dahyvotextenotafu\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"dahyvotextenotafu\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_8",
    "sat": "def sat(s: str, word=\"thuvinuhecyvez\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"thuvinuhecyvez\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "CapitalizeFirstLetter_9",
    "sat": "def sat(s: str, word=\"ta\"):\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "sols": [
      "def sol(word=\"ta\"):\n    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_0",
    "sat": "def sat(t: str, s=\"abbbcabbac\", target=7):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"abbbcabbac\", target=7):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_1",
    "sat": "def sat(t: str, s=\"abbcbaccccbcabaabacbbacbbcacabacacbbcccbabbccaabaaacabac\", target=41):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"abbcbaccccbcabaabacbbacbbcacabacacbbcccbabbccaabaaacabac\", target=41):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_2",
    "sat": "def sat(t: str, s=\"abbcaabcccbccbcbbcaabcacbcaabbccccacccaabbcbabaabbbbacbbccbabbbababcbbbcaababccccccbaabccbbbacabcbbacaccabaaacbccbaacbbaababbbcccaaabbaaabaabaaccbaaccbccbbcbabcbbacbbcbcbcacbcaaabbaccbcaaaccbbbcaaabacbabbbbbbbbbbbcaacabccabbbcccabcbcabbbbabacbacbcbcbaabaccbcccbbcbbcbccaacccaaabacccbccacababacaabbaaaababbbccabbacacabaabbaccabbbb\", target=207):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"abbcaabcccbccbcbbcaabcacbcaabbccccacccaabbcbabaabbbbacbbccbabbbababcbbbcaababccccccbaabccbbbacabcbbacaccabaaacbccbaacbbaababbbcccaaabbaaabaabaaccbaaccbccbbcbabcbbacbbcbcbcacbcaaabbaccbcaaaccbbbcaaabacbabbbbbbbbbbbcaacabccabbbcccabcbcabbbbabacbacbcbcbaabaccbcccbbcbbcbccaacccaaabacccbccacababacaabbaaaababbbccabbacacabaabbaccabbbb\", target=207):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_3",
    "sat": "def sat(t: str, s=\"ccbcccbcbbabbbaaacbacabaacabbbababcaccaacabacbcbccaabbabbbaaaccaacabbcbccbcacaacbabaabbaccbcccbbbcacaabababccaacccabacbccbbbaaabaacacaabbbcababcccaaaabcccbbccaacbaccbacabcccbbacaacbabaaacbcbabbbccccbbcaacabccacabcbbcaabaacacaabbaacacaccaacbabacaaaccaabbbaabcacbbacbcccccacbcaabababcababccabccabbcabccababbbcccbbccbaabacbcabccbabaaacabababcbaccccabaacbcbcbaabcbcaccbcccbaababccbaacbaabbbabbaaacaaaacabbaacacabbaaaabacccbacbbcbcbabaabcbacccbcabcaaabaccaaaaaabbbbbbbccbaacccabcccbccccaaaaaabbacacaabacbbbccbbabcbbbbccbcaacacaacbbbaabccbaccbabbbabcaaacccacbbcbcbcacbccbcbaccbbbcbccaabbabaabbcabcaaaaccabaabccbccabbbbabbcbbcacbcbcaabcaaaababccbaaaacbaaabbcacababbcbcaaaaccbccbcaabbcbabaabaabcaaacccccabcacaacabbcacbccabbacbaccccacccbbabbbbacabcbacbcaacaaaccccbcbacacacccccaabbaccccabaababaaccbbbbbcaabccccabcccacbaabbbacaabacbcacaabcbcaaabbcaccccbbbacaaacabccaccccbbacacccbcccbbbccacbcaaaacabcabbbacbcabbbacbbbccbbbcbabcccaabccbacabbaabbbaabbabbacaabbcbbbcbcbacbabacbbacbacaabaacaababbcccbaaaabbbcbcbcac\", target=653):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"ccbcccbcbbabbbaaacbacabaacabbbababcaccaacabacbcbccaabbabbbaaaccaacabbcbccbcacaacbabaabbaccbcccbbbcacaabababccaacccabacbccbbbaaabaacacaabbbcababcccaaaabcccbbccaacbaccbacabcccbbacaacbabaaacbcbabbbccccbbcaacabccacabcbbcaabaacacaabbaacacaccaacbabacaaaccaabbbaabcacbbacbcccccacbcaabababcababccabccabbcabccababbbcccbbccbaabacbcabccbabaaacabababcbaccccabaacbcbcbaabcbcaccbcccbaababccbaacbaabbbabbaaacaaaacabbaacacabbaaaabacccbacbbcbcbabaabcbacccbcabcaaabaccaaaaaabbbbbbbccbaacccabcccbccccaaaaaabbacacaabacbbbccbbabcbbbbccbcaacacaacbbbaabccbaccbabbbabcaaacccacbbcbcbcacbccbcbaccbbbcbccaabbabaabbcabcaaaaccabaabccbccabbbbabbcbbcacbcbcaabcaaaababccbaaaacbaaabbcacababbcbcaaaaccbccbcaabbcbabaabaabcaaacccccabcacaacabbcacbccabbacbaccccacccbbabbbbacabcbacbcaacaaaccccbcbacacacccccaabbaccccabaababaaccbbbbbcaabccccabcccacbaabbbacaabacbcacaabcbcaaabbcaccccbbbacaaacabccaccccbbacacccbcccbbbccacbcaaaacabcabbbacbcabbbacbbbccbbbcbabcccaabccbacabbaabbbaabbabbacaabbcbbbcbcbacbabacbbacbacaabaacaababbcccbaaaabbbcbcbcac\", target=653):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_4",
    "sat": "def sat(t: str, s=\"cb\", target=2):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"cb\", target=2):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_5",
    "sat": "def sat(t: str, s=\"ccabbbcaccaaccababbabac\", target=16):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"ccabbbcaccaaccababbabac\", target=16):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_6",
    "sat": "def sat(t: str, s=\"\", target=0):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"\", target=0):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_7",
    "sat": "def sat(t: str, s=\"abbabbaabacabaaaccccacabbbbcccabaaccbccabbaac\", target=27):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"abbabbaabacabaaaccccacabbbbcccabaaccbccabbaac\", target=27):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_8",
    "sat": "def sat(t: str, s=\"bcabacbacacccabbcccbabcaaacccbccacaaaaccbbaaaaababcbacaaaacbacbbacbbcbacabaccabcacbcbaacccacbbaaaabccaaabccccccccccabcccaabacccaaabcacccbbabccaaccaacabbaaaabccbaabacabcbbaabcbbbbcbbbabbbbacaabcccbcccacaaccbcbabccbbbcbccccacaccaccbbaaacabbcbbcabaaacaacaaca\", target=157):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"bcabacbacacccabbcccbabcaaacccbccacaaaaccbbaaaaababcbacaaaacbacbbacbbcbacabaccabcacbcbaacccacbbaaaabccaaabccccccccccabcccaabacccaaabcacccbbabccaaccaacabbaaaabccbaabacabcbbaabcbbbbcbbbabbbbacaabcccbcccacaaccbcbabccbbbcbccccacaccaccbbaaacabbcbbcabaaacaacaaca\", target=157):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "LongestSubsetString_9",
    "sat": "def sat(t: str, s=\"babbcccccaccbaabcbcccccbaaabbbbacccacaacbcaaccabaccacbbacbcbbbacbcbccabcbbacabaabaacabacbbbcaacac\", target=65):\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "sols": [
      "def sol(s=\"babbcccccaccbaabcbcccccbaaabbbbacccacaacbcaaccabaccacbbacbcbbbacbcbccabcbbacabaabaacabacbbbcaacac\", target=65):  # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_0",
    "sat": "def sat(n: int, s=\"0000101111111000010\", k=5):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"0000101111111000010\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"0000101111111000010\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"0000101111111000010\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"0000101111111000010\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_1",
    "sat": "def sat(n: int, s=\"00010111010010110111000011101001001010000110111101111011011000110011110110010010000110001100111101100011001111110100011010011000100011111001110101011101000001101100000010110001010001101000010110110110010110001111100001101000101111101111000110001100010001101011111000100010000100000111010010111111110100011001000100111111111111110100010000111000000101000011011101001001111111011010010011000011001010000000110110001111110110101010111001011010110110001100000101000011111001100011100001011000010100011010101110001111000110100000001110010111010100100000011110000111011101110011001001010100010110110011011010010011100111111110001001010001101101110011001101001111100111100110010110001000011010010101100100110110110111110000011100010010111100111010000011110111010011110001100011100110101001010011001000110010101100100011100\", k=13):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"00010111010010110111000011101001001010000110111101111011011000110011110110010010000110001100111101100011001111110100011010011000100011111001110101011101000001101100000010110001010001101000010110110110010110001111100001101000101111101111000110001100010001101011111000100010000100000111010010111111110100011001000100111111111111110100010000111000000101000011011101001001111111011010010011000011001010000000110110001111110110101010111001011010110110001100000101000011111001100011100001011000010100011010101110001111000110100000001110010111010100100000011110000111011101110011001001010100010110110011011010010011100111111110001001010001101101110011001101001111100111100110010110001000011010010101100100110110110111110000011100010010111100111010000011110111010011110001100011100110101001010011001000110010101100100011100\", k=13):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"00010111010010110111000011101001001010000110111101111011011000110011110110010010000110001100111101100011001111110100011010011000100011111001110101011101000001101100000010110001010001101000010110110110010110001111100001101000101111101111000110001100010001101011111000100010000100000111010010111111110100011001000100111111111111110100010000111000000101000011011101001001111111011010010011000011001010000000110110001111110110101010111001011010110110001100000101000011111001100011100001011000010100011010101110001111000110100000001110010111010100100000011110000111011101110011001001010100010110110011011010010011100111111110001001010001101101110011001101001111100111100110010110001000011010010101100100110110110111110000011100010010111100111010000011110111010011110001100011100110101001010011001000110010101100100011100\", k=13):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"00010111010010110111000011101001001010000110111101111011011000110011110110010010000110001100111101100011001111110100011010011000100011111001110101011101000001101100000010110001010001101000010110110110010110001111100001101000101111101111000110001100010001101011111000100010000100000111010010111111110100011001000100111111111111110100010000111000000101000011011101001001111111011010010011000011001010000000110110001111110110101010111001011010110110001100000101000011111001100011100001011000010100011010101110001111000110100000001110010111010100100000011110000111011101110011001001010100010110110011011010010011100111111110001001010001101101110011001101001111100111100110010110001000011010010101100100110110110111110000011100010010111100111010000011110111010011110001100011100110101001010011001000110010101100100011100\", k=13):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"00010111010010110111000011101001001010000110111101111011011000110011110110010010000110001100111101100011001111110100011010011000100011111001110101011101000001101100000010110001010001101000010110110110010110001111100001101000101111101111000110001100010001101011111000100010000100000111010010111111110100011001000100111111111111110100010000111000000101000011011101001001111111011010010011000011001010000000110110001111110110101010111001011010110110001100000101000011111001100011100001011000010100011010101110001111000110100000001110010111010100100000011110000111011101110011001001010100010110110011011010010011100111111110001001010001101101110011001101001111100111100110010110001000011010010101100100110110110111110000011100010010111100111010000011110111010011110001100011100110101001010011001000110010101100100011100\", k=13):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_2",
    "sat": "def sat(n: int, s=\"01010010000000001\", k=8):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"01010010000000001\", k=8):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"01010010000000001\", k=8):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"01010010000000001\", k=8):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"01010010000000001\", k=8):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_3",
    "sat": "def sat(n: int, s=\"1010000001111\", k=5):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"1010000001111\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"1010000001111\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"1010000001111\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"1010000001111\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_4",
    "sat": "def sat(n: int, s=\"10011111011011000010110001100001011011100110010001001101100100000001110101110110011001111001001000010001110000011101001100110011110111010001101101010010000101001110011101110110011100110011111001111111110100010001101101110111000011101100001011001010001111111101011101101110010110110010100110111000111100101000001111111111010010110011100010000001010111100101011101100011101111111100111101110101011111011000111111110111110111101110100101001001011000001000101010011001110111101101101111111001110100010010000001010101011110111101100000010110100101001101001001111000010011100110000111011000010110010100010101101011111110001000111001101000101110101000100010011\", k=5):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"10011111011011000010110001100001011011100110010001001101100100000001110101110110011001111001001000010001110000011101001100110011110111010001101101010010000101001110011101110110011100110011111001111111110100010001101101110111000011101100001011001010001111111101011101101110010110110010100110111000111100101000001111111111010010110011100010000001010111100101011101100011101111111100111101110101011111011000111111110111110111101110100101001001011000001000101010011001110111101101101111111001110100010010000001010101011110111101100000010110100101001101001001111000010011100110000111011000010110010100010101101011111110001000111001101000101110101000100010011\", k=5):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"10011111011011000010110001100001011011100110010001001101100100000001110101110110011001111001001000010001110000011101001100110011110111010001101101010010000101001110011101110110011100110011111001111111110100010001101101110111000011101100001011001010001111111101011101101110010110110010100110111000111100101000001111111111010010110011100010000001010111100101011101100011101111111100111101110101011111011000111111110111110111101110100101001001011000001000101010011001110111101101101111111001110100010010000001010101011110111101100000010110100101001101001001111000010011100110000111011000010110010100010101101011111110001000111001101000101110101000100010011\", k=5):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"10011111011011000010110001100001011011100110010001001101100100000001110101110110011001111001001000010001110000011101001100110011110111010001101101010010000101001110011101110110011100110011111001111111110100010001101101110111000011101100001011001010001111111101011101101110010110110010100110111000111100101000001111111111010010110011100010000001010111100101011101100011101111111100111101110101011111011000111111110111110111101110100101001001011000001000101010011001110111101101101111111001110100010010000001010101011110111101100000010110100101001101001001111000010011100110000111011000010110010100010101101011111110001000111001101000101110101000100010011\", k=5):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"10011111011011000010110001100001011011100110010001001101100100000001110101110110011001111001001000010001110000011101001100110011110111010001101101010010000101001110011101110110011100110011111001111111110100010001101101110111000011101100001011001010001111111101011101101110010110110010100110111000111100101000001111111111010010110011100010000001010111100101011101100011101111111100111101110101011111011000111111110111110111101110100101001001011000001000101010011001110111101101101111111001110100010010000001010101011110111101100000010110100101001101001001111000010011100110000111011000010110010100010101101011111110001000111001101000101110101000100010011\", k=5):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_5",
    "sat": "def sat(n: int, s=\"100001101010101010001010010001100101101111010101001110011100010000111101101110110111000001110011100001101100111100110000011011010011011001111010010010101101001010100010000100000111101011011100110110111110001110110010111111111100110100101100000011100111101010100101111000100110000111001000101101100110010110\", k=4):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"100001101010101010001010010001100101101111010101001110011100010000111101101110110111000001110011100001101100111100110000011011010011011001111010010010101101001010100010000100000111101011011100110110111110001110110010111111111100110100101100000011100111101010100101111000100110000111001000101101100110010110\", k=4):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"100001101010101010001010010001100101101111010101001110011100010000111101101110110111000001110011100001101100111100110000011011010011011001111010010010101101001010100010000100000111101011011100110110111110001110110010111111111100110100101100000011100111101010100101111000100110000111001000101101100110010110\", k=4):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"100001101010101010001010010001100101101111010101001110011100010000111101101110110111000001110011100001101100111100110000011011010011011001111010010010101101001010100010000100000111101011011100110110111110001110110010111111111100110100101100000011100111101010100101111000100110000111001000101101100110010110\", k=4):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"100001101010101010001010010001100101101111010101001110011100010000111101101110110111000001110011100001101100111100110000011011010011011001111010010010101101001010100010000100000111101011011100110110111110001110110010111111111100110100101100000011100111101010100101111000100110000111001000101101100110010110\", k=4):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_6",
    "sat": "def sat(n: int, s=\"011000111100110110111010110001001010010110101000010000110010000101111000101101010100101010100101011001011100000111000110101100001010111010011111101100101100110011011100000001101110111011100101001010010111100001000110010101110001011011000100110110000011111001100010001000100001011001011111011001001111101110000001100001101111000111000001001010001110010111111110001101101110101100010011000111101101101011011110100000101011011100110101101001111011011000110101001000111001111001011100011110100111101001000011110000000100111011101100001000001001010011000100111110010111110111010010010010011111000011010110011101111110111101101001000101111111011001101010010110110101111110111100100001001101011001001011101101110010110010100110\", k=1):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"011000111100110110111010110001001010010110101000010000110010000101111000101101010100101010100101011001011100000111000110101100001010111010011111101100101100110011011100000001101110111011100101001010010111100001000110010101110001011011000100110110000011111001100010001000100001011001011111011001001111101110000001100001101111000111000001001010001110010111111110001101101110101100010011000111101101101011011110100000101011011100110101101001111011011000110101001000111001111001011100011110100111101001000011110000000100111011101100001000001001010011000100111110010111110111010010010010011111000011010110011101111110111101101001000101111111011001101010010110110101111110111100100001001101011001001011101101110010110010100110\", k=1):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"011000111100110110111010110001001010010110101000010000110010000101111000101101010100101010100101011001011100000111000110101100001010111010011111101100101100110011011100000001101110111011100101001010010111100001000110010101110001011011000100110110000011111001100010001000100001011001011111011001001111101110000001100001101111000111000001001010001110010111111110001101101110101100010011000111101101101011011110100000101011011100110101101001111011011000110101001000111001111001011100011110100111101001000011110000000100111011101100001000001001010011000100111110010111110111010010010010011111000011010110011101111110111101101001000101111111011001101010010110110101111110111100100001001101011001001011101101110010110010100110\", k=1):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"011000111100110110111010110001001010010110101000010000110010000101111000101101010100101010100101011001011100000111000110101100001010111010011111101100101100110011011100000001101110111011100101001010010111100001000110010101110001011011000100110110000011111001100010001000100001011001011111011001001111101110000001100001101111000111000001001010001110010111111110001101101110101100010011000111101101101011011110100000101011011100110101101001111011011000110101001000111001111001011100011110100111101001000011110000000100111011101100001000001001010011000100111110010111110111010010010010011111000011010110011101111110111101101001000101111111011001101010010110110101111110111100100001001101011001001011101101110010110010100110\", k=1):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"011000111100110110111010110001001010010110101000010000110010000101111000101101010100101010100101011001011100000111000110101100001010111010011111101100101100110011011100000001101110111011100101001010010111100001000110010101110001011011000100110110000011111001100010001000100001011001011111011001001111101110000001100001101111000111000001001010001110010111111110001101101110101100010011000111101101101011011110100000101011011100110101101001111011011000110101001000111001111001011100011110100111101001000011110000000100111011101100001000001001010011000100111110010111110111010010010010011111000011010110011101111110111101101001000101111111011001101010010110110101111110111100100001001101011001001011101101110010110010100110\", k=1):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_7",
    "sat": "def sat(n: int, s=\"110010100101100110111001101001011110010000110000011010101010010101000010110110011100010011101111110111010111100101101100101010111001001011010010101011101111111111000100100101000011011101001111011011111011001001100011111000111001101010011010100100001\", k=10):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110010100101100110111001101001011110010000110000011010101010010101000010110110011100010011101111110111010111100101101100101010111001001011010010101011101111111111000100100101000011011101001111011011111011001001100011111000111001101010011010100100001\", k=10):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110010100101100110111001101001011110010000110000011010101010010101000010110110011100010011101111110111010111100101101100101010111001001011010010101011101111111111000100100101000011011101001111011011111011001001100011111000111001101010011010100100001\", k=10):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110010100101100110111001101001011110010000110000011010101010010101000010110110011100010011101111110111010111100101101100101010111001001011010010101011101111111111000100100101000011011101001111011011111011001001100011111000111001101010011010100100001\", k=10):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110010100101100110111001101001011110010000110000011010101010010101000010110110011100010011101111110111010111100101101100101010111001001011010010101011101111111111000100100101000011011101001111011011111011001001100011111000111001101010011010100100001\", k=10):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_8",
    "sat": "def sat(n: int, s=\"110111000111111010001111011000000010001001000111000000101011110001101011000010101110111101111000000110101101000011000110101110011010111011010000011110001111111001000000011010011000100101110000010110101100001110010001111100010011000111101100111111011001101100110011100000000111101010100001110011110000011001110010111111110011011101001100101101111111010011100110000001100000000000000000000100101101001110010000000011101011110001000111010110111010011100100010100011101110101011100000011001001010110101100010111000001111100000010000110110011110010101100111010111000000111111101001011000111010100110011100101000111000000100010010001010110101001100110100111010011001110011111110000100110000110010010101111000111111100110001000110101101110111001001111101001001\", k=19):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110111000111111010001111011000000010001001000111000000101011110001101011000010101110111101111000000110101101000011000110101110011010111011010000011110001111111001000000011010011000100101110000010110101100001110010001111100010011000111101100111111011001101100110011100000000111101010100001110011110000011001110010111111110011011101001100101101111111010011100110000001100000000000000000000100101101001110010000000011101011110001000111010110111010011100100010100011101110101011100000011001001010110101100010111000001111100000010000110110011110010101100111010111000000111111101001011000111010100110011100101000111000000100010010001010110101001100110100111010011001110011111110000100110000110010010101111000111111100110001000110101101110111001001111101001001\", k=19):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110111000111111010001111011000000010001001000111000000101011110001101011000010101110111101111000000110101101000011000110101110011010111011010000011110001111111001000000011010011000100101110000010110101100001110010001111100010011000111101100111111011001101100110011100000000111101010100001110011110000011001110010111111110011011101001100101101111111010011100110000001100000000000000000000100101101001110010000000011101011110001000111010110111010011100100010100011101110101011100000011001001010110101100010111000001111100000010000110110011110010101100111010111000000111111101001011000111010100110011100101000111000000100010010001010110101001100110100111010011001110011111110000100110000110010010101111000111111100110001000110101101110111001001111101001001\", k=19):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110111000111111010001111011000000010001001000111000000101011110001101011000010101110111101111000000110101101000011000110101110011010111011010000011110001111111001000000011010011000100101110000010110101100001110010001111100010011000111101100111111011001101100110011100000000111101010100001110011110000011001110010111111110011011101001100101101111111010011100110000001100000000000000000000100101101001110010000000011101011110001000111010110111010011100100010100011101110101011100000011001001010110101100010111000001111100000010000110110011110010101100111010111000000111111101001011000111010100110011100101000111000000100010010001010110101001100110100111010011001110011111110000100110000110010010101111000111111100110001000110101101110111001001111101001001\", k=19):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110111000111111010001111011000000010001001000111000000101011110001101011000010101110111101111000000110101101000011000110101110011010111011010000011110001111111001000000011010011000100101110000010110101100001110010001111100010011000111101100111111011001101100110011100000000111101010100001110011110000011001110010111111110011011101001100101101111111010011100110000001100000000000000000000100101101001110010000000011101011110001000111010110111010011100100010100011101110101011100000011001001010110101100010111000001111100000010000110110011110010101100111010111000000111111101001011000111010100110011100101000111000000100010010001010110101001100110100111010011001110011111110000100110000110010010101111000111111100110001000110101101110111001001111101001001\", k=19):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "FindHomogeneousSubstring_9",
    "sat": "def sat(n: int, s=\"110110010001111101111001110100111010000011000100111001010010100110000000111111001111011010111111111111111110101110010110110000010001110000101101000001100100001010110110101\", k=17):\n    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"\n    return s[n:n + k] == s[n] * k",
    "sols": [
      "def sol(s=\"110110010001111101111001110100111010000011000100111001010010100110000000111111001111011010111111111111111110101110010110110000010001110000101101000001100100001010110110101\", k=17):\n    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "def sol(s=\"110110010001111101111001110100111010000011000100111001010010100110000000111111001111011010111111111111111110101110010110110000010001110000101101000001100100001010110110101\", k=17):\n    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "def sol(s=\"110110010001111101111001110100111010000011000100111001010010100110000000111111001111011010111111111111111110101110010110110000010001110000101101000001100100001010110110101\", k=17):\n    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "def sol(s=\"110110010001111101111001110100111010000011000100111001010010100110000000111111001111011010111111111111111110101110010110110000010001110000101101000001100100001010110110101\", k=17):\n    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_0",
    "sat": "def sat(delta: List[int], nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_1",
    "sat": "def sat(delta: List[int], nums=[[41, -31, 82], [81, -74, -2], [6, -33, -10], [75, -17, -58], [-17, 72, 90]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[41, -31, 82], [81, -74, -2], [6, -33, -10], [75, -17, -58], [-17, 72, 90]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_2",
    "sat": "def sat(delta: List[int], nums=[[-52, 94, 92], [-6, 63, 61]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[-52, 94, 92], [-6, 63, 61]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_3",
    "sat": "def sat(delta: List[int], nums=[[-27, 31, -77], [37, 59, 77], [1, 70, 43]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[-27, 31, -77], [37, 59, 77], [1, 70, 43]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_4",
    "sat": "def sat(delta: List[int], nums=[[-7, 38, -74], [-32, -55, 68], [63, -72, 15], [-49, 40, 68], [-29, 22, -79]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[-7, 38, -74], [-32, -55, 68], [63, -72, 15], [-49, 40, 68], [-29, 22, -79]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_5",
    "sat": "def sat(delta: List[int], nums=[[86, 89, -26]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[86, 89, -26]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_6",
    "sat": "def sat(delta: List[int], nums=[[-43, -73, -10], [97, -66, 50], [97, 7, -21], [41, 34, -55], [-48, -47, -76], [-44, -88, -96], [17, 5, 62]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[-43, -73, -10], [97, -66, 50], [97, 7, -21], [41, 34, -55], [-48, -47, -76], [-44, -88, -96], [17, 5, 62]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_7",
    "sat": "def sat(delta: List[int], nums=[[-9, 14, -99], [-9, -58, -24], [-13, 50, -72], [-82, -9, -44]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[-9, 14, -99], [-9, -58, -24], [-13, 50, -72], [-82, -9, -44]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_8",
    "sat": "def sat(delta: List[int], nums=[[-31, 69, 44], [-6, -34, 3], [13, 4, 39], [-11, -7, 34], [80, -10, 91]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[-31, 69, 44], [-6, -34, 3], [13, 4, 39], [-11, -7, 34], [80, -10, 91]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "Triple0_9",
    "sat": "def sat(delta: List[int], nums=[[75, 40, -49], [25, -75, -47], [-66, -60, 30], [-60, -99, 94], [-43, 56, -86], [7, -77, -35], [-88, 56, 46], [-53, 92, 39]]):\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "sols": [
      "def sol(nums=[[75, 40, -49], [25, -75, -47], [-66, -60, 30], [-60, -99, 94], [-43, 56, -86], [7, -77, -35], [-88, 56, 46], [-53, 92, 39]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_0",
    "sat": "def sat(n: int, a=17, b=100, c=20):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=17, b=100, c=20):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_1",
    "sat": "def sat(n: int, a=92, b=24, c=4):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=92, b=24, c=4):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_2",
    "sat": "def sat(n: int, a=29, b=36, c=90):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=29, b=36, c=90):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_3",
    "sat": "def sat(n: int, a=14, b=58, c=78):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=14, b=58, c=78):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_4",
    "sat": "def sat(n: int, a=62, b=92, c=10):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=62, b=92, c=10):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_5",
    "sat": "def sat(n: int, a=18, b=21, c=73):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=18, b=21, c=73):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_6",
    "sat": "def sat(n: int, a=7, b=70, c=70):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=7, b=70, c=70):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_7",
    "sat": "def sat(n: int, a=8, b=82, c=11):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=8, b=82, c=11):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_8",
    "sat": "def sat(n: int, a=6, b=30, c=45):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=6, b=30, c=45):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TotalDifference_9",
    "sat": "def sat(n: int, a=20, b=59, c=48):\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])",
    "sols": [
      "def sol(a=20, b=59, c=48):\n    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_0",
    "sat": "def sat(n: int, v=17, w=100):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=17, w=100):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_1",
    "sat": "def sat(n: int, v=539258317, w=578759884):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=539258317, w=578759884):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_2",
    "sat": "def sat(n: int, v=462396423, w=823717720):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=462396423, w=823717720):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_3",
    "sat": "def sat(n: int, v=444530445, w=529580630):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=444530445, w=529580630):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_4",
    "sat": "def sat(n: int, v=808946310, w=934850272):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=808946310, w=934850272):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_5",
    "sat": "def sat(n: int, v=558198137, w=609150424):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=558198137, w=609150424):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_6",
    "sat": "def sat(n: int, v=478970686, w=573000093):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=478970686, w=573000093):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_7",
    "sat": "def sat(n: int, v=10789527, w=54988632):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=10789527, w=54988632):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_8",
    "sat": "def sat(n: int, v=523284333, w=526850699):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=523284333, w=526850699):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "TripleDouble_9",
    "sat": "def sat(n: int, v=53849894, w=277953556):\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "sols": [
      "def sol(v=53849894, w=277953556):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_0",
    "sat": "def sat(res: int, m=1234578987654321, n=4):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=1234578987654321, n=4):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_1",
    "sat": "def sat(res: int, m=10298583677859451035, n=2):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=10298583677859451035, n=2):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_2",
    "sat": "def sat(res: int, m=14218587904818299351, n=1):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=14218587904818299351, n=1):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_3",
    "sat": "def sat(res: int, m=2408734252885543431, n=3):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=2408734252885543431, n=3):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_4",
    "sat": "def sat(res: int, m=897911330083403789, n=6):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=897911330083403789, n=6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_5",
    "sat": "def sat(res: int, m=27374343650905357360, n=8):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=27374343650905357360, n=8):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_6",
    "sat": "def sat(res: int, m=35575825315027574114, n=7):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=35575825315027574114, n=7):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_7",
    "sat": "def sat(res: int, m=37138297052240637809, n=3):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=37138297052240637809, n=3):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_8",
    "sat": "def sat(res: int, m=75086184749878922656, n=3):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=75086184749878922656, n=3):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "RepeatDec_9",
    "sat": "def sat(res: int, m=93288724085225417694, n=4):\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "sols": [
      "def sol(m=93288724085225417694, n=4):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_0",
    "sat": "def sat(li: List[int], n=149432, upper=14943):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=149432, upper=14943):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_1",
    "sat": "def sat(li: List[int], n=64446, upper=6444):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=64446, upper=6444):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_2",
    "sat": "def sat(li: List[int], n=913730, upper=91372):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=913730, upper=91372):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_3",
    "sat": "def sat(li: List[int], n=994779, upper=99477):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=994779, upper=99477):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_4",
    "sat": "def sat(li: List[int], n=540877, upper=54087):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=540877, upper=54087):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_5",
    "sat": "def sat(li: List[int], n=238871, upper=23886):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=238871, upper=23886):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_6",
    "sat": "def sat(li: List[int], n=565237, upper=56523):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=565237, upper=56523):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_7",
    "sat": "def sat(li: List[int], n=686027, upper=68602):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=686027, upper=68602):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_8",
    "sat": "def sat(li: List[int], n=382168, upper=38216):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=382168, upper=38216):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "ShortestDecDelta_9",
    "sat": "def sat(li: List[int], n=218003, upper=21800):\n    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "sols": [
      "def sol(n=218003, upper=21800):\n    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_0",
    "sat": "def sat(n: int, pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_1",
    "sat": "def sat(n: int, pairs=[[861001, 0], [397160, 414962], [262226, 335059], [380787, 511715], [617579, 66729], [232566, 1100727], [320724, 192254], [798611, 420309], [362982, 819886], [28593, 9769], [959684, 370550], [565589, 449119], [0, 1096423]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[861001, 0], [397160, 414962], [262226, 335059], [380787, 511715], [617579, 66729], [232566, 1100727], [320724, 192254], [798611, 420309], [362982, 819886], [28593, 9769], [959684, 370550], [565589, 449119], [0, 1096423]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_2",
    "sat": "def sat(n: int, pairs=[[869223, 0], [0, 869223]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[869223, 0], [0, 869223]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_3",
    "sat": "def sat(n: int, pairs=[[0, 0]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[0, 0]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_4",
    "sat": "def sat(n: int, pairs=[[860680, 0], [791858, 327891], [633375, 1161632], [961025, 555017], [581473, 1078757], [864580, 676342], [436455, 804801], [885167, 332451], [308970, 483878], [550590, 250099], [629900, 924913], [155501, 249240], [137620, 514365], [941931, 83086], [213984, 1173610], [553246, 260360], [420956, 346537], [628810, 263442], [224067, 681438], [647211, 197689], [391298, 389602], [0, 1063547]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[860680, 0], [791858, 327891], [633375, 1161632], [961025, 555017], [581473, 1078757], [864580, 676342], [436455, 804801], [885167, 332451], [308970, 483878], [550590, 250099], [629900, 924913], [155501, 249240], [137620, 514365], [941931, 83086], [213984, 1173610], [553246, 260360], [420956, 346537], [628810, 263442], [224067, 681438], [647211, 197689], [391298, 389602], [0, 1063547]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_5",
    "sat": "def sat(n: int, pairs=[[399692, 0], [0, 399692]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[399692, 0], [0, 399692]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_6",
    "sat": "def sat(n: int, pairs=[[619441, 0], [721317, 434683], [999118, 868278], [518480, 502688], [803437, 707506], [257801, 1028640], [729373, 319209], [456970, 743820], [422838, 168201], [0, 755750]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[619441, 0], [721317, 434683], [999118, 868278], [518480, 502688], [803437, 707506], [257801, 1028640], [729373, 319209], [456970, 743820], [422838, 168201], [0, 755750]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_7",
    "sat": "def sat(n: int, pairs=[[306190, 0], [504184, 39137], [495024, 143701], [717707, 469160], [0, 1371107]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[306190, 0], [504184, 39137], [495024, 143701], [717707, 469160], [0, 1371107]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_8",
    "sat": "def sat(n: int, pairs=[[854081, 0], [645639, 586494], [596696, 818591], [0, 691331]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[854081, 0], [645639, 586494], [596696, 818591], [0, 691331]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxDelta_9",
    "sat": "def sat(n: int, pairs=[[230830, 0], [689577, 181862], [0, 738545]]):\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "sols": [
      "def sol(pairs=[[230830, 0], [689577, 181862], [0, 738545]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_0",
    "sat": "def sat(s_case: str, s=\"CanYouTellIfItHASmoreCAPITALS\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"CanYouTellIfItHASmoreCAPITALS\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_1",
    "sat": "def sat(s_case: str, s=\"sihUDIw\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"sihUDIw\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_2",
    "sat": "def sat(s_case: str, s=\"MuJUMEbITHusAbaGoMEcHUSUpAbE\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"MuJUMEbITHusAbaGoMEcHUSUpAbE\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_3",
    "sat": "def sat(s_case: str, s=\"LAcuBOc\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"LAcuBOc\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_4",
    "sat": "def sat(s_case: str, s=\"v\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"v\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_5",
    "sat": "def sat(s_case: str, s=\"KEChiQUAkyJaKoxYfyz\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"KEChiQUAkyJaKoxYfyz\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_6",
    "sat": "def sat(s_case: str, s=\"gujiQUUchYjESiThi\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"gujiQUUchYjESiThi\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_7",
    "sat": "def sat(s_case: str, s=\"chIbiwEK\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"chIbiwEK\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_8",
    "sat": "def sat(s_case: str, s=\"FeVechUFufitIBebeTIPeDoKAtoC\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"FeVechUFufitIBebeTIPeDoKAtoC\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "CommonCase_9",
    "sat": "def sat(s_case: str, s=\"C\"):\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "sols": [
      "def sol(s=\"C\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_0",
    "sat": "def sat(inds: List[int], string=\"Sssuubbstriiingg\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"Sssuubbstriiingg\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_1",
    "sat": "def sat(inds: List[int], string=\"rJgsubnTsUiNtKrUiGPJZng\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"rJgsubnTsUiNtKrUiGPJZng\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_2",
    "sat": "def sat(inds: List[int], string=\"sNubsthritng\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"sNubsthritng\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_3",
    "sat": "def sat(inds: List[int], string=\"sCucl brstringS\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"sCucl brstringS\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_4",
    "sat": "def sat(inds: List[int], string=\"substBrinwg\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"substBrinwg\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_5",
    "sat": "def sat(inds: List[int], string=\"substriang\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"substriang\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_6",
    "sat": "def sat(inds: List[int], string=\"scubuEs rtrOWLqkcvitnJi d g\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"scubuEs rtrOWLqkcvitnJi d g\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_7",
    "sat": "def sat(inds: List[int], string=\"sUuQeur dbstSvNdgTqridAng\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"sUuQeur dbstSvNdgTqridAng\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_8",
    "sat": "def sat(inds: List[int], string=\"zYMsZiub jsthzrVinig\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"zYMsZiub jsthzrVinig\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sssuubbstriiingg_9",
    "sat": "def sat(inds: List[int], string=\"s wubstrinVg\"):\n    \"\"\"Find increasing indices to make the substring \"substring\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "sols": [
      "def sol(string=\"s wubstrinVg\"):\n    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_0",
    "sat": "def sat(inds: List[int], string=\"enlightenment\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"enlightenment\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_1",
    "sat": "def sat(inds: List[int], string=\"nirtatbGelihUgenstD\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"nirtatbGelihUgenstD\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_2",
    "sat": "def sat(inds: List[int], string=\"yipy nteligcetCn\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"yipy nteligcetCn\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_3",
    "sat": "def sat(inds: List[int], string=\"nteiligent\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"nteiligent\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_4",
    "sat": "def sat(inds: List[int], string=\"nflth eiligent Kpj\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"nflth eiligent Kpj\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_5",
    "sat": "def sat(inds: List[int], string=\"cpej aiFInltb iARageZniBzRYkt\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"cpej aiFInltb iARageZniBzRYkt\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_6",
    "sat": "def sat(inds: List[int], string=\"iRnFte liPgNLenZt\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"iRnFte liPgNLenZt\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_7",
    "sat": "def sat(inds: List[int], string=\"DinLAXX ptn eMligent o\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"DinLAXX ptn eMligent o\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_8",
    "sat": "def sat(inds: List[int], string=\"iggenntttKXfmevl i\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"iggenntttKXfmevl i\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Sstriiinggssuubb_9",
    "sat": "def sat(inds: List[int], string=\"qYieZn  krZtendlAiFgstKjetQ\"):\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "sols": [
      "def sol(string=\"qYieZn  krZtendlAiFgstKjetQ\"):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_0",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_1",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=15):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=15):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_2",
    "sat": "def sat(seq: List[int], target=[0, 0, 0, 1, 1, 0], n_steps=0):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[0, 0, 0, 1, 1, 0], n_steps=0):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_3",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 0, 0], n_steps=6):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 1, 1, 1, 0, 0, 0, 0, 0], n_steps=6):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_4",
    "sat": "def sat(seq: List[int], target=[1, 0, 0, 0, 0], n_steps=4):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 0, 0, 0, 0], n_steps=4):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_5",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], n_steps=5):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], n_steps=5):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_6",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0], n_steps=4):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 1, 1, 1, 0, 0], n_steps=4):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_7",
    "sat": "def sat(seq: List[int], target=[1, 0, 1, 0, 1, 1, 1], n_steps=0):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 0, 1, 0, 1, 1, 1], n_steps=0):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_8",
    "sat": "def sat(seq: List[int], target=[0, 0, 0], n_steps=1):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[0, 0, 0], n_steps=1):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Moving0s_9",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], n_steps=7):\n    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), target target sequence\n    is achieved.\n    \"\"\"\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "sols": [
      "def sol(target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], n_steps=7):\n    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_0",
    "sat": "def sat(d: int, n=6002685529):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=6002685529):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_1",
    "sat": "def sat(d: int, n=405211767066):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=405211767066):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_2",
    "sat": "def sat(d: int, n=19598254):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=19598254):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_3",
    "sat": "def sat(d: int, n=723758781639):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=723758781639):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_4",
    "sat": "def sat(d: int, n=16805213):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=16805213):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_5",
    "sat": "def sat(d: int, n=12558483227225845954):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=12558483227225845954):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_6",
    "sat": "def sat(d: int, n=21):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=21):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_7",
    "sat": "def sat(d: int, n=270882):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=270882):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_8",
    "sat": "def sat(d: int, n=4004314837116289):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=4004314837116289):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Factor47_9",
    "sat": "def sat(d: int, n=60662058769701264613):\n    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "sols": [
      "def sol(n=60662058769701264613):\n    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_0",
    "sat": "def sat(d: int, n=123456789):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=123456789):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_1",
    "sat": "def sat(d: int, n=1620802):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=1620802):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_2",
    "sat": "def sat(d: int, n=42018520642639622054):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=42018520642639622054):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_3",
    "sat": "def sat(d: int, n=179626861528382455):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=179626861528382455):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_4",
    "sat": "def sat(d: int, n=2023977036646):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=2023977036646):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_5",
    "sat": "def sat(d: int, n=6919):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=6919):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_6",
    "sat": "def sat(d: int, n=22647504):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=22647504):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_7",
    "sat": "def sat(d: int, n=56444504875114144334511600236):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=56444504875114144334511600236):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_8",
    "sat": "def sat(d: int, n=3804034696):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=3804034696):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "Count47_9",
    "sat": "def sat(d: int, n=3912484115352834008349895592):\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "sols": [
      "def sol(n=3912484115352834008349895592):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_0",
    "sat": "def sat(s: str, target=\"reverse me\", reverse=True):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"reverse me\", reverse=True):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_1",
    "sat": "def sat(s: str, target=\"zite\", reverse=True):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"zite\", reverse=True):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_2",
    "sat": "def sat(s: str, target=\"cumawydyl\", reverse=True):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"cumawydyl\", reverse=True):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_3",
    "sat": "def sat(s: str, target=\"quewekonyrarecheju\", reverse=False):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"quewekonyrarecheju\", reverse=False):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_4",
    "sat": "def sat(s: str, target=\"foluto\", reverse=False):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"foluto\", reverse=False):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_5",
    "sat": "def sat(s: str, target=\"xycitextuvuhyc\", reverse=True):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"xycitextuvuhyc\", reverse=True):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_6",
    "sat": "def sat(s: str, target=\"katext\", reverse=True):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"katext\", reverse=True):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_7",
    "sat": "def sat(s: str, target=\"burofezadoquo\", reverse=True):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"burofezadoquo\", reverse=True):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_8",
    "sat": "def sat(s: str, target=\"puzudadygam\", reverse=False):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"puzudadygam\", reverse=False):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MaybeReversed_9",
    "sat": "def sat(s: str, target=\"bacobyv\", reverse=False):\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse",
    "sols": [
      "def sol(target=\"bacobyv\", reverse=False):\n    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_0",
    "sat": "def sat(taken: List[int], val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_1",
    "sat": "def sat(taken: List[int], val_counts=[[68, 48], [98, 39]], upper=37):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[68, 48], [98, 39]], upper=37):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_2",
    "sat": "def sat(taken: List[int], val_counts=[[60, 60], [37, 51], [39, 94], [76, 3], [15, 18], [17, 16]], upper=93):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[60, 60], [37, 51], [39, 94], [76, 3], [15, 18], [17, 16]], upper=93):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_3",
    "sat": "def sat(taken: List[int], val_counts=[[58, 69], [96, 65]], upper=54):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[58, 69], [96, 65]], upper=54):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_4",
    "sat": "def sat(taken: List[int], val_counts=[[85, 78], [98, 19]], upper=48):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[85, 78], [98, 19]], upper=48):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_5",
    "sat": "def sat(taken: List[int], val_counts=[[63, 42], [96, 92], [87, 73], [98, 10], [99, 70]], upper=132):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[63, 42], [96, 92], [87, 73], [98, 10], [99, 70]], upper=132):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_6",
    "sat": "def sat(taken: List[int], val_counts=[[33, 18], [61, 48], [74, 96], [96, 12], [89, 53], [23, 70], [51, 31], [84, 32]], upper=133):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[33, 18], [61, 48], [74, 96], [96, 12], [89, 53], [23, 70], [51, 31], [84, 32]], upper=133):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_7",
    "sat": "def sat(taken: List[int], val_counts=[[97, 13], [75, 44], [5, 58], [93, 33], [24, 54]], upper=50):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[97, 13], [75, 44], [5, 58], [93, 33], [24, 54]], upper=50):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_8",
    "sat": "def sat(taken: List[int], val_counts=[[17, 8], [76, 62], [17, 82], [44, 8]], upper=44):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[17, 8], [76, 62], [17, 82], [44, 8]], upper=44):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinBigger_9",
    "sat": "def sat(taken: List[int], val_counts=[[32, 31], [81, 20], [65, 91], [35, 90], [88, 1], [21, 34], [62, 32], [47, 82], [6, 21]], upper=138):\n    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "sols": [
      "def sol(val_counts=[[32, 31], [81, 20], [65, 91], [35, 90], [88, 1], [21, 34], [62, 32], [47, 82], [6, 21]], upper=138):\n    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_0",
    "sat": "def sat(s: str, a=5129, d=17):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=5129, d=17):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_1",
    "sat": "def sat(s: str, a=6400, d=1600):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=6400, d=1600):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_2",
    "sat": "def sat(s: str, a=4914, d=2550):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=4914, d=2550):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_3",
    "sat": "def sat(s: str, a=3981, d=1780):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=3981, d=1780):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_4",
    "sat": "def sat(s: str, a=2236, d=2630):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=2236, d=2630):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_5",
    "sat": "def sat(s: str, a=4187, d=6505):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=4187, d=6505):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_6",
    "sat": "def sat(s: str, a=3123, d=1695):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=3123, d=1695):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_7",
    "sat": "def sat(s: str, a=6612, d=702):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=6612, d=702):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_8",
    "sat": "def sat(s: str, a=5355, d=4203):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=5355, d=4203):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "Dada_9",
    "sat": "def sat(s: str, a=6448, d=9281):\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "sols": [
      "def sol(a=6448, d=9281):\n    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_0",
    "sat": "def sat(nums: List[int], a=100, b=1000, count=648):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=100, b=1000, count=648):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_1",
    "sat": "def sat(nums: List[int], a=0, b=286, count=225):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=0, b=286, count=225):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_2",
    "sat": "def sat(nums: List[int], a=165, b=865, count=514):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=165, b=865, count=514):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_3",
    "sat": "def sat(nums: List[int], a=17, b=84, count=62):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=17, b=84, count=62):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_4",
    "sat": "def sat(nums: List[int], a=56, b=435, count=284):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=56, b=435, count=284):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_5",
    "sat": "def sat(nums: List[int], a=493, b=505, count=9):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=493, b=505, count=9):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_6",
    "sat": "def sat(nums: List[int], a=407, b=581, count=125):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=407, b=581, count=125):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_7",
    "sat": "def sat(nums: List[int], a=458, b=650, count=147):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=458, b=650, count=147):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_8",
    "sat": "def sat(nums: List[int], a=82, b=892, count=587):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=82, b=892, count=587):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctDigits_9",
    "sat": "def sat(nums: List[int], a=618, b=642, count=21):\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "sols": [
      "def sol(a=618, b=642, count=21):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_0",
    "sat": "def sat(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_1",
    "sat": "def sat(tot: int, nums=[20, 88], thresh=83):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[20, 88], thresh=83):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_2",
    "sat": "def sat(tot: int, nums=[68, 99, 31, 45, 34, 13, 70, 73, 92, 6, 77, 7, 30, 30, 22, 16, 62], thresh=78):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[68, 99, 31, 45, 34, 13, 70, 73, 92, 6, 77, 7, 30, 30, 22, 16, 62], thresh=78):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_3",
    "sat": "def sat(tot: int, nums=[91, 80, 91, 8, 2, 67, 70], thresh=74):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[91, 80, 91, 8, 2, 67, 70], thresh=74):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_4",
    "sat": "def sat(tot: int, nums=[8, 86, 88, 48, 2, 94, 71, 77, 24, 7, 34, 60, 54, 49, 67, 50, 86, 64, 32, 61, 42, 67], thresh=7):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[8, 86, 88, 48, 2, 94, 71, 77, 24, 7, 34, 60, 54, 49, 67, 50, 86, 64, 32, 61, 42, 67], thresh=7):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_5",
    "sat": "def sat(tot: int, nums=[67, 58, 51, 37, 48], thresh=62):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[67, 58, 51, 37, 48], thresh=62):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_6",
    "sat": "def sat(tot: int, nums=[78, 36, 43, 43, 71, 16, 63, 6, 14, 70, 81, 39, 7, 47, 71, 86, 71, 53, 83, 88], thresh=8):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[78, 36, 43, 43, 71, 16, 63, 6, 14, 70, 81, 39, 7, 47, 71, 86, 71, 53, 83, 88], thresh=8):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_7",
    "sat": "def sat(tot: int, nums=[29, 49, 18, 33, 60, 3, 28, 30, 19, 20, 10, 39, 6, 34, 47, 48, 72, 1, 39, 92, 16, 93], thresh=72):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[29, 49, 18, 33, 60, 3, 28, 30, 19, 20, 10, 39, 6, 34, 47, 48, 72, 1, 39, 92, 16, 93], thresh=72):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_8",
    "sat": "def sat(tot: int, nums=[34, 37, 52, 87, 30, 22, 16, 95, 49, 9, 35, 67, 73, 2, 22, 3], thresh=79):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[34, 37, 52, 87, 30, 22, 16, 95, 49, 9, 35, 67, 73, 2, 22, 3], thresh=79):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "EasySum_9",
    "sat": "def sat(tot: int, nums=[70, 20], thresh=25):\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "sols": [
      "def sol(nums=[70, 20], thresh=25):\n    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_0",
    "sat": "def sat(s: str, chars=['o', 'h', 'e', 'l', ' ', 'w', '!', 'r', 'd']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_1",
    "sat": "def sat(s: str, chars=['S', '!', 'Z']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_2",
    "sat": "def sat(s: str, chars=['v', 'V', 'U']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_3",
    "sat": "def sat(s: str, chars=['=', 'v', 'V', ',', '6', 'S', '9', '5', 'y', '-']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_4",
    "sat": "def sat(s: str, chars=['s', 'h', 'R', 'i', 'P', ',', 'Q', 'z', 'r', 'K']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_5",
    "sat": "def sat(s: str, chars=['-', '[', 'l']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_6",
    "sat": "def sat(s: str, chars=['L', 'H', '8', 'x', '$', '#', 'Z', 'd', 'X', 'G']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_7",
    "sat": "def sat(s: str, chars=['P', 'o', 'x']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_8",
    "sat": "def sat(s: str, chars=[')', 'q', ']', 'w', 'R', 'H', 'M', 'q', 'C', 'f']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "GimmeChars_9",
    "sat": "def sat(s: str, chars=['C', 'w', 'L']):\n    \"\"\"Find a string with certain characters\"\"\"\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_0",
    "sat": "def sat(ans: List[List[int]], target=17):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=17):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_1",
    "sat": "def sat(ans: List[List[int]], target=0):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=0):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_2",
    "sat": "def sat(ans: List[List[int]], target=1):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=1):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_3",
    "sat": "def sat(ans: List[List[int]], target=2):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=2):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_4",
    "sat": "def sat(ans: List[List[int]], target=3):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=3):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_5",
    "sat": "def sat(ans: List[List[int]], target=4):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=4):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_6",
    "sat": "def sat(ans: List[List[int]], target=5):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=5):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_7",
    "sat": "def sat(ans: List[List[int]], target=6):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=6):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_8",
    "sat": "def sat(ans: List[List[int]], target=7):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=7):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "HalfPairs_9",
    "sat": "def sat(ans: List[List[int]], target=8):\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "sols": [
      "def sol(target=8):\n    return [[0, 2]] * target"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_0",
    "sat": "def sat(indexes: List[int], target=[1, 3, 4, 2, 5, 6, 7, 13, 12, 11, 9, 10, 8]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_1",
    "sat": "def sat(indexes: List[int], target=[80, 4, 17, 75, 69, 14, 22, 52, 34, 56, 66, 5, 68, 71, 47, 70, 3, 19, 16, 48, 61, 27, 51, 20, 9, 60, 31, 35, 2, 79, 81, 1, 82, 74, 26, 37, 25, 24, 11, 62, 65, 10, 46, 18, 39, 83, 50, 54, 6, 78, 33, 7, 13, 42, 45, 76, 32, 64, 72, 41, 49, 12, 73, 77, 21, 38, 58, 23, 44, 36, 8, 40, 30, 55, 29, 67, 57, 43, 63, 53, 15, 59, 28]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_2",
    "sat": "def sat(indexes: List[int], target=[2, 1]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_3",
    "sat": "def sat(indexes: List[int], target=[3, 23, 6, 14, 24, 10, 19, 12, 22, 13, 20, 15, 18, 21, 9, 7, 2, 16, 1, 25, 8, 26, 17, 4, 11, 5]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_4",
    "sat": "def sat(indexes: List[int], target=[52, 37, 27, 16, 8, 40, 55, 39, 42, 48, 33, 31, 50, 35, 3, 47, 30, 6, 12, 53, 44, 15, 28, 13, 18, 26, 36, 1, 49, 25, 43, 41, 32, 38, 46, 14, 29, 23, 34, 45, 17, 2, 24, 54, 21, 5, 22, 19, 11, 7, 51, 4, 9, 10, 20]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_5",
    "sat": "def sat(indexes: List[int], target=[32, 74, 35, 48, 47, 81, 65, 38, 72, 29, 79, 18, 5, 4, 17, 45, 75, 70, 68, 23, 11, 41, 12, 54, 56, 55, 6, 31, 30, 9, 37, 2, 64, 52, 77, 28, 13, 71, 63, 3, 58, 19, 50, 40, 46, 27, 33, 25, 53, 34, 62, 7, 26, 10, 82, 20, 66, 57, 73, 49, 36, 59, 76, 61, 60, 51, 24, 42, 8, 1, 22, 69, 16, 78, 39, 21, 14, 80, 67, 44, 15, 43]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_6",
    "sat": "def sat(indexes: List[int], target=[60, 70, 38, 25, 54, 5, 56, 8, 42, 12, 9, 48, 24, 72, 28, 29, 73, 15, 32, 34, 10, 45, 55, 53, 67, 1, 35, 40, 78, 37, 31, 68, 77, 65, 22, 41, 26, 49, 16, 57, 27, 62, 61, 59, 4, 76, 36, 75, 52, 66, 20, 51, 58, 18, 44, 43, 11, 33, 7, 74, 3, 23, 47, 69, 13, 30, 39, 6, 21, 19, 17, 64, 63, 14, 46, 2, 71, 50]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_7",
    "sat": "def sat(indexes: List[int], target=[10, 2, 9, 6, 13, 1, 11, 4, 8, 3, 5, 7, 12]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_8",
    "sat": "def sat(indexes: List[int], target=[22, 16, 29, 56, 18, 63, 8, 65, 67, 4, 60, 25, 91, 68, 5, 55, 39, 86, 72, 37, 7, 33, 2, 42, 66, 13, 27, 46, 32, 6, 20, 34, 3, 79, 75, 73, 74, 85, 93, 58, 83, 19, 40, 43, 26, 57, 12, 69, 11, 62, 41, 59, 14, 61, 30, 92, 80, 70, 94, 15, 28, 1, 17, 23, 9, 35, 77, 54, 89, 48, 81, 87, 88, 50, 82, 44, 71, 49, 78, 84, 21, 76, 51, 47, 45, 38, 52, 64, 31, 36, 53, 90, 24, 10]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "InvertIndices_9",
    "sat": "def sat(indexes: List[int], target=[1, 3, 2, 4, 5, 7, 6]):\n    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "sols": [],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_0",
    "sat": "def sat(s: str, n=7012):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=7012):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_1",
    "sat": "def sat(s: str, n=0):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=0):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_2",
    "sat": "def sat(s: str, n=1):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=1):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_3",
    "sat": "def sat(s: str, n=2):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_4",
    "sat": "def sat(s: str, n=3):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=3):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_5",
    "sat": "def sat(s: str, n=4):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=4):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_6",
    "sat": "def sat(s: str, n=5):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=5):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_7",
    "sat": "def sat(s: str, n=6):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=6):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_8",
    "sat": "def sat(s: str, n=7):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=7):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_9",
    "sat": "def sat(s: str, n=8):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=8):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "FivePowers_10",
    "sat": "def sat(s: str, n=9):\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "sols": [
      "def sol(n=9):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_0",
    "sat": "def sat(states: List[str], start=\"424\", combo=\"778\", target_len=12):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"424\", combo=\"778\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_1",
    "sat": "def sat(states: List[str], start=\"9\", combo=\"4\", target_len=4):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9\", combo=\"4\", target_len=4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_2",
    "sat": "def sat(states: List[str], start=\"6319878694\", combo=\"3074225130\", target_len=39):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"6319878694\", combo=\"3074225130\", target_len=39):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_3",
    "sat": "def sat(states: List[str], start=\"9312\", combo=\"5503\", target_len=7):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"9312\", combo=\"5503\", target_len=7):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_4",
    "sat": "def sat(states: List[str], start=\"775112\", combo=\"863016\", target_len=8):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"775112\", combo=\"863016\", target_len=8):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_5",
    "sat": "def sat(states: List[str], start=\"7009572515\", combo=\"3292536646\", target_len=22):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"7009572515\", combo=\"3292536646\", target_len=22):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_6",
    "sat": "def sat(states: List[str], start=\"2325601\", combo=\"2037582\", target_len=9):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"2325601\", combo=\"2037582\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_7",
    "sat": "def sat(states: List[str], start=\"60326818\", combo=\"21178983\", target_len=22):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"60326818\", combo=\"21178983\", target_len=22):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_8",
    "sat": "def sat(states: List[str], start=\"49920\", combo=\"26669\", target_len=12):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"49920\", combo=\"26669\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLock_9",
    "sat": "def sat(states: List[str], start=\"750\", combo=\"010\", target_len=6):\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "sols": [
      "def sol(start=\"750\", combo=\"010\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_0",
    "sat": "def sat(states: List[str], start=\"424\", combo=\"778\", target_len=12):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"424\", combo=\"778\", target_len=12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_1",
    "sat": "def sat(states: List[str], start=\"85535083\", combo=\"91773993\", target_len=14):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"85535083\", combo=\"91773993\", target_len=14):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_2",
    "sat": "def sat(states: List[str], start=\"23\", combo=\"66\", target_len=6):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"23\", combo=\"66\", target_len=6):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_3",
    "sat": "def sat(states: List[str], start=\"132504284\", combo=\"758671069\", target_len=25):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"132504284\", combo=\"758671069\", target_len=25):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_4",
    "sat": "def sat(states: List[str], start=\"4687\", combo=\"9367\", target_len=9):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"4687\", combo=\"9367\", target_len=9):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_5",
    "sat": "def sat(states: List[str], start=\"87686\", combo=\"13708\", target_len=11):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"87686\", combo=\"13708\", target_len=11):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_6",
    "sat": "def sat(states: List[str], start=\"9\", combo=\"5\", target_len=3):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"9\", combo=\"5\", target_len=3):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_7",
    "sat": "def sat(states: List[str], start=\"74002\", combo=\"35777\", target_len=15):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"74002\", combo=\"35777\", target_len=15):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_8",
    "sat": "def sat(states: List[str], start=\"269990585\", combo=\"992565468\", target_len=26):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"269990585\", combo=\"992565468\", target_len=26):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "CombinationLockObfuscated_9",
    "sat": "def sat(states: List[str], start=\"5618\", combo=\"1285\", target_len=13):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "sols": [
      "def sol(start=\"5618\", combo=\"1285\", target_len=13):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_0",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hello are you there?\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hello are you there?\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_1",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"byxysithychuquacy w wyquuque losasyquag dogekurochemepet q rechuvokacuca mezahywonutub busuthi\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"byxysithychuquacy w wyquuque losasyquag dogekurochemepet q rechuvokacuca mezahywonutub busuthi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_2",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"merobulo t liquuhitythyzutezuge textocapina lojechytichefetexte vuxugefimyby jur golojykusobithipef riwaquyxuhufi\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"merobulo t liquuhitythyzutezuge textocapina lojechytichefetexte vuxugefimyby jur golojykusobithipef riwaquyxuhufi\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_3",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"lykehulajumachejocem foqualyw dyzybax c fydi jufathovuweji\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"lykehulajumachejocem foqualyw dyzybax c fydi jufathovuweji\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_4",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kewezaj zomanirobirape textycyh mezebopi saburyxar s gahyhebuvy chaquivawutu\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"kewezaj zomanirobirape textycyh mezebopi saburyxar s gahyhebuvy chaquivawutu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_5",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"depofilugaji vutextizediw futhiquepajut ge viluqueraryfikiwa kotazajuharyho f thytextethypiquobusu\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"depofilugaji vutextizediw futhiquepajut ge viluqueraryfikiwa kotazajuharyho f thytextethypiquobusu\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_6",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hagasejy\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hagasejy\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_7",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chutamazabyvokemy tyh zyruxizochusothequec gadokinitemomezeth\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"chutamazabyvokemy tyh zyruxizochusothequec gadokinitemomezeth\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_8",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fychotoxaxyzoch pehyquycet chitho jot vyrahat\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"fychotoxaxyzoch pehyquycet chitho jot vyrahat\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "InvertPermutation_9",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"desikytextarup\"):\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "sols": [
      "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"desikytextarup\"):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_0",
    "sat": "def sat(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_1",
    "sat": "def sat(lists: List[List[int]], items=[7, 2, 1, 7, 7, 8, 3, 3, 1, 0, 4, 6, 4, 9, 6, 4, 7, 1, 9, 5, 3, 9, 3, 2, 9, 0, 6, 2, 3, 1, 3, 4, 0, 3, 5, 5, 5, 0, 9, 4, 3, 5, 6, 5, 5, 5, 5, 9, 9, 8, 4, 3, 9, 4, 3, 9, 9, 4, 7, 1, 1, 9, 6], length=10):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[7, 2, 1, 7, 7, 8, 3, 3, 1, 0, 4, 6, 4, 9, 6, 4, 7, 1, 9, 5, 3, 9, 3, 2, 9, 0, 6, 2, 3, 1, 3, 4, 0, 3, 5, 5, 5, 0, 9, 4, 3, 5, 6, 5, 5, 5, 5, 9, 9, 8, 4, 3, 9, 4, 3, 9, 9, 4, 7, 1, 1, 9, 6], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_2",
    "sat": "def sat(lists: List[List[int]], items=[8, 1, 5, 7, 2, 4, 1, 8, 4, 9, 5, 4, 5, 9, 9, 9, 2, 3, 9, 4, 7, 6, 2, 4, 3, 2, 3, 8, 1, 9, 7, 7], length=6):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[8, 1, 5, 7, 2, 4, 1, 8, 4, 9, 5, 4, 5, 9, 9, 9, 2, 3, 9, 4, 7, 6, 2, 4, 3, 2, 3, 8, 1, 9, 7, 7], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_3",
    "sat": "def sat(lists: List[List[int]], items=[6, 4, 1, 5, 6, 2, 0, 3, 8, 9, 2, 1, 2, 7, 1, 1, 7, 0, 9, 5, 0, 8, 9, 0, 5, 7, 5, 7, 6, 2, 4, 0, 4, 2, 3, 5, 7, 9, 2, 3, 1, 1, 5, 2, 3, 1, 0, 2, 8, 9, 0, 9, 5, 4, 0, 6, 9, 8, 7, 2, 9, 0, 5, 7, 4, 8, 1, 8, 5, 9, 3, 7, 0, 7, 4, 2, 5, 4, 0, 8, 8, 5, 8, 7, 5], length=10):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[6, 4, 1, 5, 6, 2, 0, 3, 8, 9, 2, 1, 2, 7, 1, 1, 7, 0, 9, 5, 0, 8, 9, 0, 5, 7, 5, 7, 6, 2, 4, 0, 4, 2, 3, 5, 7, 9, 2, 3, 1, 1, 5, 2, 3, 1, 0, 2, 8, 9, 0, 9, 5, 4, 0, 6, 9, 8, 7, 2, 9, 0, 5, 7, 4, 8, 1, 8, 5, 9, 3, 7, 0, 7, 4, 2, 5, 4, 0, 8, 8, 5, 8, 7, 5], length=10):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_4",
    "sat": "def sat(lists: List[List[int]], items=[1, 1, 3, 7, 4, 1, 7, 6, 9, 6, 4, 8, 1, 5, 8, 2, 4, 1, 8, 9, 8, 1, 7, 2, 0, 0, 3, 8, 3, 8, 6, 5, 0, 9], length=6):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[1, 1, 3, 7, 4, 1, 7, 6, 9, 6, 4, 8, 1, 5, 8, 2, 4, 1, 8, 9, 8, 1, 7, 2, 0, 0, 3, 8, 3, 8, 6, 5, 0, 9], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_5",
    "sat": "def sat(lists: List[List[int]], items=[7, 1, 8, 0, 7, 2, 4, 1, 8, 6, 7, 5, 9, 6, 9, 0, 6, 3, 7, 5, 0, 1, 0, 7, 2, 2, 1, 2, 1, 6, 4, 4, 6, 1, 0, 6, 4, 8, 5, 9, 3, 0, 1, 9, 1, 1, 1, 3, 4, 5, 3, 3, 9, 9, 0, 3, 0], length=9):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[7, 1, 8, 0, 7, 2, 4, 1, 8, 6, 7, 5, 9, 6, 9, 0, 6, 3, 7, 5, 0, 1, 0, 7, 2, 2, 1, 2, 1, 6, 4, 4, 6, 1, 0, 6, 4, 8, 5, 9, 3, 0, 1, 9, 1, 1, 1, 3, 4, 5, 3, 3, 9, 9, 0, 3, 0], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_6",
    "sat": "def sat(lists: List[List[int]], items=[8, 1, 3, 2, 4, 3, 6, 7, 9, 7, 1, 8, 1, 1], length=4):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[8, 1, 3, 2, 4, 3, 6, 7, 9, 7, 1, 8, 1, 1], length=4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_7",
    "sat": "def sat(lists: List[List[int]], items=[7, 6, 2, 8, 5, 6, 4, 4, 6, 0, 2, 4, 6, 1, 9, 6, 6, 5, 7, 2, 3, 1, 4, 4, 0, 2, 3, 7, 0, 6, 2, 2, 5, 6, 6, 5, 3, 8, 1, 9, 8], length=9):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[7, 6, 2, 8, 5, 6, 4, 4, 6, 0, 2, 4, 6, 1, 9, 6, 6, 5, 7, 2, 3, 1, 4, 4, 0, 2, 3, 7, 0, 6, 2, 2, 5, 6, 6, 5, 3, 8, 1, 9, 8], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_8",
    "sat": "def sat(lists: List[List[int]], items=[3, 3, 0, 9, 1, 8, 7, 3, 9, 7, 8, 6, 4, 2, 1, 1, 4, 0, 0, 3, 1, 6, 3, 9, 3, 8, 1, 1, 7, 6, 4, 9], length=6):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[3, 3, 0, 9, 1, 8, 7, 3, 9, 7, 8, 6, 4, 2, 1, 1, 4, 0, 0, 3, 1, 6, 3, 9, 3, 8, 1, 1, 7, 6, 4, 9], length=6):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "SameDifferent_9",
    "sat": "def sat(lists: List[List[int]], items=[8, 7, 5, 3, 0, 1, 1, 6, 6, 7, 7, 7, 6, 5, 6, 6, 0, 9, 9, 2, 8, 9, 1, 9, 1, 2, 3, 0, 7, 0, 0, 6, 4, 3, 1, 4, 0, 1, 7, 7, 1, 7, 7, 8, 4, 2, 7, 4, 3, 5, 5], length=9):\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "sols": [
      "def sol(items=[8, 7, 5, 3, 0, 1, 1, 6, 6, 7, 7, 7, 6, 5, 6, 6, 0, 9, 9, 2, 8, 9, 1, 9, 1, 2, 3, 0, 7, 0, 0, 6, 4, 3, 1, 4, 0, 1, 7, 7, 1, 7, 7, 8, 4, 2, 7, 4, 3, 5, 5], length=9):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_0",
    "sat": "def sat(seq: List[int], n=10000, length=5017):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=10000, length=5017):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_1",
    "sat": "def sat(seq: List[int], n=0, length=0):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=0, length=0):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_2",
    "sat": "def sat(seq: List[int], n=38, length=23):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=38, length=23):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_3",
    "sat": "def sat(seq: List[int], n=5, length=3):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=5, length=3):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_4",
    "sat": "def sat(seq: List[int], n=2, length=1):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=2, length=1):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_5",
    "sat": "def sat(seq: List[int], n=2330, length=2197):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=2330, length=2197):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_6",
    "sat": "def sat(seq: List[int], n=1095, length=913):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=1095, length=913):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_7",
    "sat": "def sat(seq: List[int], n=17, length=15):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=17, length=15):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_8",
    "sat": "def sat(seq: List[int], n=48, length=41):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=48, length=41):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "OnesAndTwos_9",
    "sat": "def sat(seq: List[int], n=913, length=811):\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "sols": [
      "def sol(n=913, length=811):\n    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_0",
    "sat": "def sat(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_1",
    "sat": "def sat(start: int, k=1, upper=-71, seq=[82, -10, -24, -38, 86, 46, 1, -13, 86, 76, 47, 94, 16, 99, -71, 6]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=1, upper=-71, seq=[82, -10, -24, -38, 86, 46, 1, -13, 86, 76, 47, 94, 16, 99, -71, 6]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_2",
    "sat": "def sat(start: int, k=8, upper=-86, seq=[94, -99, -9, -34, -49, -64, -18, 93]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=8, upper=-86, seq=[94, -99, -9, -34, -49, -64, -18, 93]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_3",
    "sat": "def sat(start: int, k=7, upper=-508, seq=[-6, -69, 92, -41, 69, 56, -73, 69, -55, -76, 78, -89, -58, -98, -94, -69, -80, -20, 77, 92, 99, -7, 14, 59, -45, 80, -34, 4, 58, 70, -70, -61, 71, -31, 40, 16, 20, -52, 72, 48, -49, -15]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-508, seq=[-6, -69, 92, -41, 69, 56, -73, 69, -55, -76, 78, -89, -58, -98, -94, -69, -80, -20, 77, 92, 99, -7, 14, 59, -45, 80, -34, 4, 58, 70, -70, -61, 71, -31, 40, 16, 20, -52, 72, 48, -49, -15]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_4",
    "sat": "def sat(start: int, k=7, upper=-246, seq=[55, 55, -66, 2, 91, -86, 93, 56, 46, -76, -76, 77, -56, 0, 88, -28, 41, 94, 41, 14, -96, -47, 2, -17, -50, 42, -80, -70, 72, -73, 58, -31, -24, 90]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=-246, seq=[55, 55, -66, 2, 91, -86, 93, 56, 46, -76, -76, 77, -56, 0, 88, -28, 41, 94, 41, 14, -96, -47, 2, -17, -50, 42, -80, -70, 72, -73, 58, -31, -24, 90]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_5",
    "sat": "def sat(start: int, k=9, upper=-157, seq=[98, -99, -36, -70, -30, -66, 87, -76, 35]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-157, seq=[98, -99, -36, -70, -30, -66, 87, -76, 35]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_6",
    "sat": "def sat(start: int, k=7, upper=170, seq=[44, 38, 92, 47, -98, -40, 87]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=7, upper=170, seq=[44, 38, 92, 47, -98, -40, 87]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_7",
    "sat": "def sat(start: int, k=6, upper=-7, seq=[-28, -38, -82, 33, 92, 16]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=6, upper=-7, seq=[-28, -38, -82, 33, 92, 16]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_8",
    "sat": "def sat(start: int, k=9, upper=-443, seq=[-27, 95, 37, -30, -13, -88, -35, -92, 80, 76, -37, -95, 27, 96, -42, -33, -41, -41, -80, -82, -74, 45, -71, -9, -90, 11, 77, -76, -44, 99, 89, -96, -20, -1, -28, -43, 93, -14, 66, 93, -82, -22, -65, -93, -22, 26, -4, -70, 3, -49, -33, 37, -93, -60, -70, 70, 81, -58, 93, -73, -89, 72, -89, -35, -62, 86, 19, -42, 0, -21, 77, -78, 71, 40, -68, -34, -23, 39, 15, -42, 31, 64, 97, 76, 46, -98, -10, 79, -63, -44, -33, -36, -70, 34, 64, -73, 87, -28, 53, 16, 9, -87, -67]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=9, upper=-443, seq=[-27, 95, 37, -30, -13, -88, -35, -92, 80, 76, -37, -95, 27, 96, -42, -33, -41, -41, -80, -82, -74, 45, -71, -9, -90, 11, 77, -76, -44, 99, 89, -96, -20, -1, -28, -43, 93, -14, 66, 93, -82, -22, -65, -93, -22, 26, -4, -70, 3, -49, -33, 37, -93, -60, -70, 70, 81, -58, 93, -73, -89, 72, -89, -35, -62, 86, 19, -42, 0, -21, 77, -78, 71, 40, -68, -34, -23, 39, 15, -42, 31, 64, 97, 76, 46, -98, -10, 79, -63, -44, -33, -36, -70, 34, 64, -73, 87, -28, 53, 16, 9, -87, -67]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinConsecutiveSum_9",
    "sat": "def sat(start: int, k=2, upper=31, seq=[93, -62]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "sols": [
      "def sol(k=2, upper=31, seq=[93, -62]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_0",
    "sat": "def sat(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_1",
    "sat": "def sat(start: int, k=7, lower=75, seq=[-6, 84, -60, 97, 0, -86, 46]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=75, seq=[-6, 84, -60, 97, 0, -86, 46]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_2",
    "sat": "def sat(start: int, k=2, lower=90, seq=[-53, 77, -54, -59, 58, -60, 25, 64, 26, 8]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=90, seq=[-53, 77, -54, -59, 58, -60, 25, 64, 26, 8]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_3",
    "sat": "def sat(start: int, k=3, lower=89, seq=[-49, 60, 9, -11, 91]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=3, lower=89, seq=[-49, 60, 9, -11, 91]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_4",
    "sat": "def sat(start: int, k=6, lower=203, seq=[-56, 59, -2, 89, 1, 30, 5, -23, -22, 25, -62, 63, 50, -94, -36, -21, -94, 5, 31, 71, 37, -30, 72, -27, 80, 15, -53, 21, -88, 43, 81, 17, -21, 4, 35, 46, -79, -36, 52, 40, -41]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=6, lower=203, seq=[-56, 59, -2, 89, 1, 30, 5, -23, -22, 25, -62, 63, 50, -94, -36, -21, -94, 5, 31, 71, 37, -30, 72, -27, 80, 15, -53, 21, -88, 43, 81, 17, -21, 4, 35, 46, -79, -36, 52, 40, -41]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_5",
    "sat": "def sat(start: int, k=1, lower=96, seq=[-18, 96, -31]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=96, seq=[-18, 96, -31]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_6",
    "sat": "def sat(start: int, k=7, lower=395, seq=[-25, 92, 46, -80, 11, -88, -73, -28, 87, -16, -26, 14, -31, -67, 25, -1, 97, -27, 68, -12, -74, 32, -98, -64, -89, 42, 56, 55, 48, 12, -61, 55, -24, 60, -23, -45, 69, 27, 27, 87, 5, 12, 98, -4, 14, 46, 48, -4, 57, -35, -60, 62, -85, -6, -78, 50, 40, 93, 51, -13, 98, 76, 48, -12, -59, -33, 54, 43, -67, 49]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=7, lower=395, seq=[-25, 92, 46, -80, 11, -88, -73, -28, 87, -16, -26, 14, -31, -67, 25, -1, 97, -27, 68, -12, -74, 32, -98, -64, -89, 42, 56, 55, 48, 12, -61, 55, -24, 60, -23, -45, 69, 27, 27, 87, 5, 12, 98, -4, 14, 46, 48, -4, 57, -35, -60, 62, -85, -6, -78, 50, 40, 93, 51, -13, 98, 76, 48, -12, -59, -33, 54, 43, -67, 49]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_7",
    "sat": "def sat(start: int, k=9, lower=287, seq=[-19, -41, 81, 72, 48, -90, -61, 80, 14, 67, 76, 0, -7, 15, -49, -2, 21, 26, -67, 83, -81, -70, 84, -71, 76, 78, -67, 31, -69, -89, 25, 0, 0, -30, 27, -6, -45, 5, -89, -69, -49, 92, 23, -25, -78, 6, -70, -53, -35, 8, 25, 54, -72, -62, 42, -65, 93]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=9, lower=287, seq=[-19, -41, 81, 72, 48, -90, -61, 80, 14, 67, 76, 0, -7, 15, -49, -2, 21, 26, -67, 83, -81, -70, 84, -71, 76, 78, -67, 31, -69, -89, 25, 0, 0, -30, 27, -6, -45, 5, -89, -69, -49, 92, 23, -25, -78, 6, -70, -53, -35, 8, 25, 54, -72, -62, 42, -65, 93]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_8",
    "sat": "def sat(start: int, k=2, lower=111, seq=[61, 50]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=2, lower=111, seq=[61, 50]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveSum_9",
    "sat": "def sat(start: int, k=1, lower=36, seq=[13, 36, -11, -57]):\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "sols": [
      "def sol(k=1, lower=36, seq=[13, 36, -11, -57]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_0",
    "sat": "def sat(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_1",
    "sat": "def sat(start: int, k=2, lower=9800, seq=[57, 80, 98, 79, -40, -77, -91, 20, -20, -34, -31, 56, -91, -44, 96, 56, -74, 76, -77, 69, 25, -59, 47, 76, 56, 49, -22, 47, -59, 79, 5, 77, -100, -98, -99, 67, -11, 79, 57, -46, -11, 98, 91, 38, 63, -13, -68, -12, 96, 8, 32]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=9800, seq=[57, 80, 98, 79, -40, -77, -91, 20, -20, -34, -31, 56, -91, -44, 96, 56, -74, 76, -77, 69, 25, -59, 47, 76, 56, 49, -22, 47, -59, 79, 5, 77, -100, -98, -99, 67, -11, 79, 57, -46, -11, 98, 91, 38, 63, -13, -68, -12, 96, 8, 32]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_2",
    "sat": "def sat(start: int, k=2, lower=-1196, seq=[23, -52]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=2, lower=-1196, seq=[23, -52]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_3",
    "sat": "def sat(start: int, k=3, lower=278320, seq=[-29, 50, 4, 53, 36, 98, -50, 55, 58, 55, -17, -79, 23, 90, 91, -35, 47, 68, 54, -100, -21, -69, 61, 17, 69, 35, -58, 54, 17, 60, -57, 2, 70, -56, -71, 26, -92]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=3, lower=278320, seq=[-29, 50, 4, 53, 36, 98, -50, 55, 58, 55, -17, -79, 23, 90, 91, -35, 47, 68, 54, -100, -21, -69, 61, 17, 69, 35, -58, 54, 17, 60, -57, 2, 70, -56, -71, 26, -92]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_4",
    "sat": "def sat(start: int, k=8, lower=-9493028269200, seq=[-79, 7, 95, 10, -68, -74, -57, -63]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=8, lower=-9493028269200, seq=[-79, 7, 95, 10, -68, -74, -57, -63]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_5",
    "sat": "def sat(start: int, k=1, lower=29, seq=[-20, 28, -33, -37, -66, 8, -82, 29]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=1, lower=29, seq=[-20, 28, -33, -37, -66, 8, -82, 29]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_6",
    "sat": "def sat(start: int, k=5, lower=-2951520, seq=[-52, -43, 6, -44, 5]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=5, lower=-2951520, seq=[-52, -43, 6, -44, 5]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_7",
    "sat": "def sat(start: int, k=9, lower=253566473582592, seq=[-32, 53, -89, 79, -58, -4, 67, 19, 72]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=9, lower=253566473582592, seq=[-32, 53, -89, 79, -58, -4, 67, 19, 72]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_8",
    "sat": "def sat(start: int, k=7, lower=3359089489392, seq=[-46, 87, 37, -29, -58, -38, -22, 16, -40, 63, -67, -35, 10, 73, 44, -58, -93, 94, 26, -20, 91, 78, 34, -94]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=7, lower=3359089489392, seq=[-46, 87, 37, -29, -58, -38, -22, 16, -40, 63, -67, -35, 10, 73, 44, -58, -93, 94, 26, -20, 91, 78, 34, -94]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "MaxConsecutiveProduct_9",
    "sat": "def sat(start: int, k=6, lower=4747345200, seq=[-85, -39, -6, 60, 78, -51]):\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "sols": [
      "def sol(k=6, lower=4747345200, seq=[-85, -39, -6, 60, 78, -51]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_0",
    "sat": "def sat(nums: List[int], tot=12345, n=5):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=12345, n=5):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_1",
    "sat": "def sat(nums: List[int], tot=43393, n=79):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=43393, n=79):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_2",
    "sat": "def sat(nums: List[int], tot=17694, n=38):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=17694, n=38):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_3",
    "sat": "def sat(nums: List[int], tot=39761, n=83):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=39761, n=83):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_4",
    "sat": "def sat(nums: List[int], tot=45301, n=95):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=45301, n=95):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_5",
    "sat": "def sat(nums: List[int], tot=32883, n=65):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=32883, n=65):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_6",
    "sat": "def sat(nums: List[int], tot=46876, n=90):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=46876, n=90):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_7",
    "sat": "def sat(nums: List[int], tot=44281, n=79):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=44281, n=79):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_8",
    "sat": "def sat(nums: List[int], tot=4998, n=8):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=4998, n=8):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "DistinctOddSum_9",
    "sat": "def sat(nums: List[int], tot=45969, n=89):\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "sols": [
      "def sol(tot=45969, n=89):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_0",
    "sat": "def sat(rotations: List[int], target=\"wonderful\", upper=69):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"wonderful\", upper=69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_1",
    "sat": "def sat(rotations: List[int], target=\"xevyfolupowo\", upper=72):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"xevyfolupowo\", upper=72):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_2",
    "sat": "def sat(rotations: List[int], target=\"thequybatext\", upper=75):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"thequybatext\", upper=75):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_3",
    "sat": "def sat(rotations: List[int], target=\"fevachytexta\", upper=70):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"fevachytexta\", upper=70):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_4",
    "sat": "def sat(rotations: List[int], target=\"chedofysugirypi\", upper=92):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"chedofysugirypi\", upper=92):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_5",
    "sat": "def sat(rotations: List[int], target=\"thachiquuniquuvyloh\", upper=97):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"thachiquuniquuvyloh\", upper=97):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_6",
    "sat": "def sat(rotations: List[int], target=\"biju\", upper=20):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"biju\", upper=20):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_7",
    "sat": "def sat(rotations: List[int], target=\"lytaca\", upper=40):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"lytaca\", upper=40):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_8",
    "sat": "def sat(rotations: List[int], target=\"t\", upper=7):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"t\", upper=7):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "MinRotations_9",
    "sat": "def sat(rotations: List[int], target=\"ziqueke\", upper=44):\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "sols": [
      "def sol(target=\"ziqueke\", upper=44):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces"
  },
  {
    "name": "QuadraticRoot_0",
    "sat": "def sat(x: float, coeffs=[2.5, 1.3, -0.5]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[2.5, 1.3, -0.5]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[2.5, 1.3, -0.5]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_1",
    "sat": "def sat(x: float, coeffs=[0.14247631113539816, 0.0580487499201053, 0.002351142783718817]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.14247631113539816, 0.0580487499201053, 0.002351142783718817]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[0.14247631113539816, 0.0580487499201053, 0.002351142783718817]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_2",
    "sat": "def sat(x: float, coeffs=[3.4823149147203325, 2.4840048876859715, -2575361.7365742377]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[3.4823149147203325, 2.4840048876859715, -2575361.7365742377]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[3.4823149147203325, 2.4840048876859715, -2575361.7365742377]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_3",
    "sat": "def sat(x: float, coeffs=[0.5866669210326788, 0.009799653973447805, -4.447967324598238]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.5866669210326788, 0.009799653973447805, -4.447967324598238]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[0.5866669210326788, 0.009799653973447805, -4.447967324598238]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_4",
    "sat": "def sat(x: float, coeffs=[0.5211381783558434, 1.248783962496373, 0.7327564040407003]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.5211381783558434, 1.248783962496373, 0.7327564040407003]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[0.5211381783558434, 1.248783962496373, 0.7327564040407003]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_5",
    "sat": "def sat(x: float, coeffs=[-2.998399798940723, -3.553321458157187, -0.560153230270126]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-2.998399798940723, -3.553321458157187, -0.560153230270126]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[-2.998399798940723, -3.553321458157187, -0.560153230270126]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_6",
    "sat": "def sat(x: float, coeffs=[0.21709973330437085, 0.2904651557927372, -0.06814390661719039]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.21709973330437085, 0.2904651557927372, -0.06814390661719039]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[0.21709973330437085, 0.2904651557927372, -0.06814390661719039]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_7",
    "sat": "def sat(x: float, coeffs=[2.844969017253877, -0.005819714291618612, -0.013091744163979745]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[2.844969017253877, -0.005819714291618612, -0.013091744163979745]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[2.844969017253877, -0.005819714291618612, -0.013091744163979745]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_8",
    "sat": "def sat(x: float, coeffs=[0.9688134613211372, 0.4486276179446301, -14.252343751332672]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.9688134613211372, 0.4486276179446301, -14.252343751332672]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[0.9688134613211372, 0.4486276179446301, -14.252343751332672]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "QuadraticRoot_9",
    "sat": "def sat(x: float, coeffs=[4.752826360326748, -0.11322273857840015, -5.572835639299346]):\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[4.752826360326748, -0.11322273857840015, -5.572835639299346]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "def sol(coeffs=[4.752826360326748, -0.11322273857840015, -5.572835639299346]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_0",
    "sat": "def sat(roots: List[float], coeffs=[1.3, -0.5]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[1.3, -0.5]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_1",
    "sat": "def sat(roots: List[float], coeffs=[-0.6329945081103016, 0.09953938202925676]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-0.6329945081103016, 0.09953938202925676]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_2",
    "sat": "def sat(roots: List[float], coeffs=[205.37801521859794, 84.19275693145096]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[205.37801521859794, 84.19275693145096]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_3",
    "sat": "def sat(roots: List[float], coeffs=[0.25737214990183793, -0.1842734596984684]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.25737214990183793, -0.1842734596984684]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_4",
    "sat": "def sat(roots: List[float], coeffs=[0.5357283742248716, -2.6032107280025207]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.5357283742248716, -2.6032107280025207]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_5",
    "sat": "def sat(roots: List[float], coeffs=[-0.22087952907375344, 0.010251361101614074]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-0.22087952907375344, 0.010251361101614074]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_6",
    "sat": "def sat(roots: List[float], coeffs=[0.6686359596019678, 0.11122892244864349]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.6686359596019678, 0.11122892244864349]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_7",
    "sat": "def sat(roots: List[float], coeffs=[1.3493561729548045, -44.13010867375246]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[1.3493561729548045, -44.13010867375246]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_8",
    "sat": "def sat(roots: List[float], coeffs=[4.065624595356067, 0.7910905002166271]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[4.065624595356067, 0.7910905002166271]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "AllQuadraticRoots_9",
    "sat": "def sat(roots: List[float], coeffs=[0.31737809522026145, -554.5111828665348]):\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.31737809522026145, -554.5111828665348]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_0",
    "sat": "def sat(x: float, coeffs=[2.0, 1.0, 0.0, 8.0]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[2.0, 1.0, 0.0, 8.0]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_1",
    "sat": "def sat(x: float, coeffs=[0.2757105239401003, -5.0265217921174985, -1.2165409442363915, 35.99423725860742]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.2757105239401003, -5.0265217921174985, -1.2165409442363915, 35.99423725860742]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_2",
    "sat": "def sat(x: float, coeffs=[-2.9053091068196046, 0.053667691688644416, -19.78165326835212, 40.32395765264794]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[-2.9053091068196046, 0.053667691688644416, -19.78165326835212, 40.32395765264794]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_3",
    "sat": "def sat(x: float, coeffs=[0.07579505238917321, -15.339902256837142, -24.810677592280665, -7.813817379028617]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.07579505238917321, -15.339902256837142, -24.810677592280665, -7.813817379028617]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_4",
    "sat": "def sat(x: float, coeffs=[-1.252351774404479, 0.013481018053594621, -0.3813177566794912, 26346.04141507707]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[-1.252351774404479, 0.013481018053594621, -0.3813177566794912, 26346.04141507707]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_5",
    "sat": "def sat(x: float, coeffs=[0.9090455471816742, -8.48677006916831, 0.49167814150345607, 0.9991699799654209]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.9090455471816742, -8.48677006916831, 0.49167814150345607, 0.9991699799654209]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_6",
    "sat": "def sat(x: float, coeffs=[-0.18684268977603158, 0.4990407685283236, 0.07179175092352315, -0.011853287815768433]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[-0.18684268977603158, 0.4990407685283236, 0.07179175092352315, -0.011853287815768433]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_7",
    "sat": "def sat(x: float, coeffs=[-15.735800684185671, 0.6920738467961973, -2.6366769219863806, -0.8601188142228484]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[-15.735800684185671, 0.6920738467961973, -2.6366769219863806, -0.8601188142228484]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_8",
    "sat": "def sat(x: float, coeffs=[-4.716578848058378, -24.48182117966112, 1.0344009324701569, 4048.8737869411466]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[-4.716578848058378, -24.48182117966112, 1.0344009324701569, 4048.8737869411466]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "CubicRoot_9",
    "sat": "def sat(x: float, coeffs=[-7.88696676872425, -3.1619274279051273, 6.12885032774813, -0.39570982002685184]):\n    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "sols": [
      "def sol(coeffs=[-7.88696676872425, -3.1619274279051273, 6.12885032774813, -0.39570982002685184]):\n    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_0",
    "sat": "def sat(roots: List[float], coeffs=[1.0, -2.0, -1.0]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[1.0, -2.0, -1.0]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_1",
    "sat": "def sat(roots: List[float], coeffs=[-3.9792928861776984, 2.133038730163511, 1.638138878943189]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-3.9792928861776984, 2.133038730163511, 1.638138878943189]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_2",
    "sat": "def sat(roots: List[float], coeffs=[13.354831072884561, -4.595025525483049, -2.4264677936411747]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[13.354831072884561, -4.595025525483049, -2.4264677936411747]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_3",
    "sat": "def sat(roots: List[float], coeffs=[0.34016642063764496, -0.17124300520980765, -0.019472435680922565]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.34016642063764496, -0.17124300520980765, -0.019472435680922565]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_4",
    "sat": "def sat(roots: List[float], coeffs=[-3.865189014481809, 1.1515812489611212, 0.3070462657668704]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-3.865189014481809, 1.1515812489611212, 0.3070462657668704]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_5",
    "sat": "def sat(roots: List[float], coeffs=[6.567612587999834, -0.4012469353764956, -0.2997271514299456]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[6.567612587999834, -0.4012469353764956, -0.2997271514299456]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_6",
    "sat": "def sat(roots: List[float], coeffs=[-1.982539223250326, -3.918349070812101, -0.10332535387891573]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-1.982539223250326, -3.918349070812101, -0.10332535387891573]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_7",
    "sat": "def sat(roots: List[float], coeffs=[-64.07087694397408, -247.643171505104, -93.7193566883485]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[-64.07087694397408, -247.643171505104, -93.7193566883485]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_8",
    "sat": "def sat(roots: List[float], coeffs=[0.3945560905084002, -0.32787674961027524, -0.0004560777800547628]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[0.3945560905084002, -0.32787674961027524, -0.0004560777800547628]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "AllCubicRoots_9",
    "sat": "def sat(roots: List[float], coeffs=[3.120490226020043, -3.5223093810804205, -10.496774412546113]):\n    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "sols": [
      "def sol(coeffs=[3.120490226020043, -3.5223093810804205, -10.496774412546113]):\n    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra"
  },
  {
    "name": "SumOfDigits_0",
    "sat": "def sat(x: str, s=679):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=679):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_1",
    "sat": "def sat(x: str, s=66511):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=66511):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_2",
    "sat": "def sat(x: str, s=14925):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=14925):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_3",
    "sat": "def sat(x: str, s=32435):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=32435):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_4",
    "sat": "def sat(x: str, s=58196):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=58196):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_5",
    "sat": "def sat(x: str, s=23906):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=23906):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_6",
    "sat": "def sat(x: str, s=79805):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=79805):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_7",
    "sat": "def sat(x: str, s=11002):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=11002):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_8",
    "sat": "def sat(x: str, s=66191):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=66191):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "SumOfDigits_9",
    "sat": "def sat(x: str, s=95227):\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])",
    "sols": [
      "def sol(s=95227):\n    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_0",
    "sat": "def sat(z: float, v=9, d=0.0001):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=9, d=0.0001):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_1",
    "sat": "def sat(z: float, v=5, d=0.1):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=5, d=0.1):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_2",
    "sat": "def sat(z: float, v=8, d=1e-91):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=8, d=1e-91):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_3",
    "sat": "def sat(z: float, v=5, d=1e-30):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=5, d=1e-30):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_4",
    "sat": "def sat(z: float, v=3, d=1000.0):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=3, d=1000.0):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_5",
    "sat": "def sat(z: float, v=3, d=1e+23):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=3, d=1e+23):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_6",
    "sat": "def sat(z: float, v=2, d=1e+84):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=2, d=1e+84):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_7",
    "sat": "def sat(z: float, v=1, d=1e-59):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=1, d=1e-59):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_8",
    "sat": "def sat(z: float, v=3, d=1e+56):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=3, d=1e+56):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "FloatWithDecimalValue_9",
    "sat": "def sat(z: float, v=1, d=1e-31):\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v",
    "sols": [
      "def sol(v=1, d=1e-31):\n    return v * d"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_0",
    "sat": "def sat(x: List[int], a=7, s=5, e=200):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=7, s=5, e=200):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_1",
    "sat": "def sat(x: List[int], a=-4680, s=8298, e=892407):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-4680, s=8298, e=892407):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_2",
    "sat": "def sat(x: List[int], a=3476, s=1455, e=529734):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=3476, s=1455, e=529734):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_3",
    "sat": "def sat(x: List[int], a=-35453, s=2726, e=465600):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-35453, s=2726, e=465600):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_4",
    "sat": "def sat(x: List[int], a=69797, s=9193, e=618550):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=69797, s=9193, e=618550):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_5",
    "sat": "def sat(x: List[int], a=38738, s=6248, e=233237):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=38738, s=6248, e=233237):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_6",
    "sat": "def sat(x: List[int], a=15258, s=4619, e=366423):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=15258, s=4619, e=366423):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_7",
    "sat": "def sat(x: List[int], a=-97310, s=1718, e=814142):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-97310, s=1718, e=814142):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_8",
    "sat": "def sat(x: List[int], a=27422, s=4964, e=500946):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=27422, s=4964, e=500946):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "ArithmeticSequence_9",
    "sat": "def sat(x: List[int], a=85211, s=7360, e=703590):\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=85211, s=7360, e=703590):\n    return list(range(a, e + 1, s))"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_0",
    "sat": "def sat(x: List[int], a=8, r=2, l=50):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=8, r=2, l=50):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_1",
    "sat": "def sat(x: List[int], a=-347, r=9, l=726):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-347, r=9, l=726):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_2",
    "sat": "def sat(x: List[int], a=-488, r=5, l=536):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-488, r=5, l=536):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_3",
    "sat": "def sat(x: List[int], a=-89, r=9, l=211):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-89, r=9, l=211):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_4",
    "sat": "def sat(x: List[int], a=802, r=2, l=311):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=802, r=2, l=311):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_5",
    "sat": "def sat(x: List[int], a=292, r=2, l=949):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=292, r=2, l=949):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_6",
    "sat": "def sat(x: List[int], a=502, r=4, l=64):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=502, r=4, l=64):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_7",
    "sat": "def sat(x: List[int], a=-32, r=3, l=535):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-32, r=3, l=535):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_8",
    "sat": "def sat(x: List[int], a=-930, r=7, l=388):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=-930, r=7, l=388):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "GeometricSequence_9",
    "sat": "def sat(x: List[int], a=700, r=1, l=519):\n    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "sols": [
      "def sol(a=700, r=1, l=519):\n    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_0",
    "sat": "def sat(e: List[int], a=2, b=-1, c=1, d=2021):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=2, b=-1, c=1, d=2021):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_1",
    "sat": "def sat(e: List[int], a=90849683, b=-44176570, c=-36026147, d=99535647):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=90849683, b=-44176570, c=-36026147, d=99535647):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_2",
    "sat": "def sat(e: List[int], a=7708002, b=-47754712, c=64769575, d=-29334341):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=7708002, b=-47754712, c=64769575, d=-29334341):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_3",
    "sat": "def sat(e: List[int], a=59121887, b=-59337384, c=-74600879, d=10087939):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=59121887, b=-59337384, c=-74600879, d=10087939):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_4",
    "sat": "def sat(e: List[int], a=54521274, b=-29664331, c=-58122382, d=70244493):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=54521274, b=-29664331, c=-58122382, d=70244493):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_5",
    "sat": "def sat(e: List[int], a=-70535633, b=-37636091, c=-26800125, d=30223710):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=-70535633, b=-37636091, c=-26800125, d=30223710):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_6",
    "sat": "def sat(e: List[int], a=-95993836, b=-37562105, c=20135305, d=54661256):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=-95993836, b=-37562105, c=20135305, d=54661256):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_7",
    "sat": "def sat(e: List[int], a=-15232639, b=-82991956, c=98429883, d=53910941):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=-15232639, b=-82991956, c=98429883, d=53910941):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_8",
    "sat": "def sat(e: List[int], a=-93988857, b=-71191364, c=69628273, d=-91156209):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=-93988857, b=-71191364, c=69628273, d=-91156209):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "LineIntersection_9",
    "sat": "def sat(e: List[int], a=-10295200, b=-16740199, c=-50054209, d=-16604688):\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "sols": [
      "def sol(a=-10295200, b=-16740199, c=-50054209, d=-16604688):\n    return [d - b, a - c]"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_0",
    "sat": "def sat(x: int, a=324554, b=1345345):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=324554, b=1345345):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_1",
    "sat": "def sat(x: int, a=50, b=-76219538):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=50, b=-76219538):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_2",
    "sat": "def sat(x: int, a=64, b=87150134):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=64, b=87150134):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_3",
    "sat": "def sat(x: int, a=27, b=18483008):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=27, b=18483008):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_4",
    "sat": "def sat(x: int, a=4, b=19022071):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=4, b=19022071):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_5",
    "sat": "def sat(x: int, a=24, b=-65478424):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=24, b=-65478424):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_6",
    "sat": "def sat(x: int, a=23, b=14795441):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=23, b=14795441):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_7",
    "sat": "def sat(x: int, a=65, b=-35284717):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=65, b=-35284717):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_8",
    "sat": "def sat(x: int, a=87, b=-24724774):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=87, b=-24724774):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblem_9",
    "sat": "def sat(x: int, a=49, b=-5289497):\n    \"\"\"Satisfy a simple if statement\"\"\"\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "sols": [
      "def sol(a=49, b=-5289497):\n    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_0",
    "sat": "def sat(x: int, a=9384594, b=1343663):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=9384594, b=1343663):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_1",
    "sat": "def sat(x: int, a=14, b=88007924):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=14, b=88007924):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_2",
    "sat": "def sat(x: int, a=4, b=68817237):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=4, b=68817237):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_3",
    "sat": "def sat(x: int, a=49, b=19705116):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=49, b=19705116):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_4",
    "sat": "def sat(x: int, a=20, b=64864798):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=20, b=64864798):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_5",
    "sat": "def sat(x: int, a=19, b=57492328):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=19, b=57492328):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_6",
    "sat": "def sat(x: int, a=54, b=47681774):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=54, b=47681774):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_7",
    "sat": "def sat(x: int, a=11, b=67712370):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=11, b=67712370):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_8",
    "sat": "def sat(x: int, a=41, b=26035431):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=41, b=26035431):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithAnd_9",
    "sat": "def sat(x: int, a=57, b=12189801):\n    \"\"\"Satisfy a simple if statement with an and clause\"\"\"\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=57, b=12189801):\n    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_0",
    "sat": "def sat(x: int, a=253532, b=1230200):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=253532, b=1230200):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_1",
    "sat": "def sat(x: int, a=8, b=55131149):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=8, b=55131149):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_2",
    "sat": "def sat(x: int, a=82, b=-38493436):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=82, b=-38493436):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_3",
    "sat": "def sat(x: int, a=25, b=-87900629):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=25, b=-87900629):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_4",
    "sat": "def sat(x: int, a=19, b=41154612):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=19, b=41154612):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_5",
    "sat": "def sat(x: int, a=50, b=-54956093):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=50, b=-54956093):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_6",
    "sat": "def sat(x: int, a=70, b=-33372308):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=70, b=-33372308):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_7",
    "sat": "def sat(x: int, a=97, b=19550361):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=97, b=19550361):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_8",
    "sat": "def sat(x: int, a=80, b=50192291):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=80, b=50192291):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfProblemWithOr_9",
    "sat": "def sat(x: int, a=25, b=-78115978):\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=25, b=-78115978):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_0",
    "sat": "def sat(x: int, a=4, b=54368639):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=4, b=54368639):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_1",
    "sat": "def sat(x: int, a=5, b=36951455):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=5, b=36951455):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_2",
    "sat": "def sat(x: int, a=1, b=81339647):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=1, b=81339647):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_3",
    "sat": "def sat(x: int, a=-1, b=35693535):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=-1, b=35693535):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_4",
    "sat": "def sat(x: int, a=3, b=-16220033):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=3, b=-16220033):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_5",
    "sat": "def sat(x: int, a=0, b=32621630):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=0, b=32621630):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_6",
    "sat": "def sat(x: int, a=3, b=-14249823):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=3, b=-14249823):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_7",
    "sat": "def sat(x: int, a=-2, b=61741141):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=-2, b=61741141):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_8",
    "sat": "def sat(x: int, a=-3, b=-57634295):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=-3, b=-57634295):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "IfCases_9",
    "sat": "def sat(x: int, a=5, b=25123635):\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "sols": [
      "def sol(a=5, b=25123635):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_0",
    "sat": "def sat(x: List[int], n=5, s=19):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=5, s=19):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_1",
    "sat": "def sat(x: List[int], n=5610, s=61543322):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=5610, s=61543322):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_2",
    "sat": "def sat(x: List[int], n=2070, s=45059454):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=2070, s=45059454):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_3",
    "sat": "def sat(x: List[int], n=2722, s=91795551):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=2722, s=91795551):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_4",
    "sat": "def sat(x: List[int], n=2658, s=8803811):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=2658, s=8803811):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_5",
    "sat": "def sat(x: List[int], n=210, s=5754159):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=210, s=5754159):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_6",
    "sat": "def sat(x: List[int], n=1302, s=55822805):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=1302, s=55822805):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_7",
    "sat": "def sat(x: List[int], n=3400, s=28594760):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=3400, s=28594760):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_8",
    "sat": "def sat(x: List[int], n=9266, s=10011015):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=9266, s=10011015):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListPosSum_9",
    "sat": "def sat(x: List[int], n=5065, s=79210746):\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "sols": [
      "def sol(n=5065, s=79210746):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_0",
    "sat": "def sat(x: List[int], n=4, s=2021):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=4, s=2021):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_1",
    "sat": "def sat(x: List[int], n=785, s=28294138):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=785, s=28294138):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_2",
    "sat": "def sat(x: List[int], n=327, s=22807991):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=327, s=22807991):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_3",
    "sat": "def sat(x: List[int], n=837, s=95083719):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=837, s=95083719):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_4",
    "sat": "def sat(x: List[int], n=773, s=36312443):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=773, s=36312443):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_5",
    "sat": "def sat(x: List[int], n=572, s=20062708):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=572, s=20062708):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_6",
    "sat": "def sat(x: List[int], n=254, s=19390096):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=254, s=19390096):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_7",
    "sat": "def sat(x: List[int], n=530, s=34621322):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=530, s=34621322):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_8",
    "sat": "def sat(x: List[int], n=84, s=71428295):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=84, s=71428295):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ListDistinctSum_9",
    "sat": "def sat(x: List[int], n=292, s=99954457):\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "sols": [
      "def sol(n=292, s=99954457):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_0",
    "sat": "def sat(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_1",
    "sat": "def sat(x: str, s=['4', 't', 'E', 'I', 'N', '!', 'J', 'L', '4', 'G', '5', 'p', 'L', '+', 'm', ';', ':', '!', '@', '1', 'k', '.', 'A', '$', 'S', 'S', ' ', 'o', 'n', '/', ')', 'L', '3', '|'], n=21):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['4', 't', 'E', 'I', 'N', '!', 'J', 'L', '4', 'G', '5', 'p', 'L', '+', 'm', ';', ':', '!', '@', '1', 'k', '.', 'A', '$', 'S', 'S', ' ', 'o', 'n', '/', ')', 'L', '3', '|'], n=21):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_2",
    "sat": "def sat(x: str, s=['g', 'K', '9', 'i', 'S'], n=0):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['g', 'K', '9', 'i', 'S'], n=0):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_3",
    "sat": "def sat(x: str, s=['@', 'T', '?', 'z', '6', '*', '1', 'U', 'G', '/', 'm', 'k', 't', '!', '%', 'T', '2', 'c', 'o', '|', 'Y', 'U', '7', 'y', '5', '(', '1', '5', 'W', 'J', 'D', '2', '-', 'c', '.', '2', 'K', 'k', 'J', 'm', 'r', 'g', 'b', ':'], n=19):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['@', 'T', '?', 'z', '6', '*', '1', 'U', 'G', '/', 'm', 'k', 't', '!', '%', 'T', '2', 'c', 'o', '|', 'Y', 'U', '7', 'y', '5', '(', '1', '5', 'W', 'J', 'D', '2', '-', 'c', '.', '2', 'K', 'k', 'J', 'm', 'r', 'g', 'b', ':'], n=19):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_4",
    "sat": "def sat(x: str, s=['?', '(', '0', 'H'], n=3):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['?', '(', '0', 'H'], n=3):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_5",
    "sat": "def sat(x: str, s=['q', 'J', 'Z', '#', '.', 'y', 'f', 'r', '^', 'J', '6', ';', ')', 't', 'I', 'd', '>', 'A', 'o', '@', 'k', ']', 'p', '%', 'Z', '7', '2', 'T', 'X', ' ', 'o', 'l', '$', 'b', '%', '/', '!'], n=17):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['q', 'J', 'Z', '#', '.', 'y', 'f', 'r', '^', 'J', '6', ';', ')', 't', 'I', 'd', '>', 'A', 'o', '@', 'k', ']', 'p', '%', 'Z', '7', '2', 'T', 'X', ' ', 'o', 'l', '$', 'b', '%', '/', '!'], n=17):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_6",
    "sat": "def sat(x: str, s=['v', '2', '9', 'v', '0', 'K', ':', '7', '$', 'x'], n=8):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['v', '2', '9', 'v', '0', 'K', ':', '7', '$', 'x'], n=8):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_7",
    "sat": "def sat(x: str, s=['5', '@', '?', '?', 'Y', '7', '*', 'C', '>', '?', ',', 'b', 'S', '^', 'Z', 'M', 'e', '&', '5', '2', '.', '^', 'q', 'I', '#', 'Y', 'E', '-'], n=6):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['5', '@', '?', '?', 'Y', '7', '*', 'C', '>', '?', ',', 'b', 'S', '^', 'Z', 'M', 'e', '&', '5', '2', '.', '^', 'q', 'I', '#', 'Y', 'E', '-'], n=6):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_8",
    "sat": "def sat(x: str, s=['o', '<', '0', 'I', '/', 'B', 'X', 'V', '^', 'C', '+', 'b', '3', 'f', '!', ' ', 'e', 'M', '0', 'x', 'e', 'T', 'E', '&', '!', 'B', 'O', ')', 'Q', 'y', ':', 'h', '4', 'n', 'Z', '@', 'L', 'R', 'Q', '>', '=', '9'], n=21):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['o', '<', '0', 'I', '/', 'B', 'X', 'V', '^', 'C', '+', 'b', '3', 'f', '!', ' ', 'e', 'M', '0', 'x', 'e', 'T', 'E', '&', '!', 'B', 'O', ')', 'Q', 'y', ':', 'h', '4', 'n', 'Z', '@', 'L', 'R', 'Q', '>', '=', '9'], n=21):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "ConcatStrings_9",
    "sat": "def sat(x: str, s=['j', 'f', 's', '.', 'Y', '0', 'X', 'x', '?', 'p', ']', 'f', 'j', '4', 's', 'C', '9', 'G', 'T', '5', 'm', ',', '*', ']', 'O', 'u', '|', 'f', 'M', '-', 'a', 'P'], n=19):\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "sols": [
      "def sol(s=['j', 'f', 's', '.', 'Y', '0', 'X', 'x', '?', 'p', ']', 'f', 'j', '4', 's', 'C', '9', 'G', 'T', '5', 'm', ',', '*', ']', 'O', 'u', '|', 'f', 'M', '-', 'a', 'P'], n=19):\n    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_0",
    "sat": "def sat(x: List[int], t=677, a=43, e=125, s=10):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=677, a=43, e=125, s=10):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_1",
    "sat": "def sat(x: List[int], t=7613305, a=58, e=2190, s=8):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=7613305, a=58, e=2190, s=8):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_2",
    "sat": "def sat(x: List[int], t=11532381, a=68, e=505, s=10):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=11532381, a=68, e=505, s=10):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_3",
    "sat": "def sat(x: List[int], t=2385492, a=2, e=8827, s=6):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=2385492, a=2, e=8827, s=6):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_4",
    "sat": "def sat(x: List[int], t=16692414, a=30, e=5928, s=7):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=16692414, a=30, e=5928, s=7):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_5",
    "sat": "def sat(x: List[int], t=16018053, a=76, e=1161, s=2):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=16018053, a=76, e=1161, s=2):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_6",
    "sat": "def sat(x: List[int], t=27609189, a=86, e=8489, s=8):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=27609189, a=86, e=8489, s=8):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_7",
    "sat": "def sat(x: List[int], t=34709446, a=34, e=9582, s=1):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=34709446, a=34, e=9582, s=1):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_8",
    "sat": "def sat(x: List[int], t=53116452, a=50, e=1115, s=4):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=53116452, a=50, e=1115, s=4):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "SublistSum_9",
    "sat": "def sat(x: List[int], t=31033316, a=2, e=4771, s=6):\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "sols": [
      "def sol(t=31033316, a=2, e=4771, s=6):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_0",
    "sat": "def sat(x: List[int], t=50, n=10):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=50, n=10):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_1",
    "sat": "def sat(x: List[int], t=4538022512, n=5554):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=4538022512, n=5554):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_2",
    "sat": "def sat(x: List[int], t=6904126605, n=8109):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=6904126605, n=8109):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_3",
    "sat": "def sat(x: List[int], t=9522506410, n=9282):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=9522506410, n=9282):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_4",
    "sat": "def sat(x: List[int], t=3802981343, n=2199):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=3802981343, n=2199):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_5",
    "sat": "def sat(x: List[int], t=4828660547, n=4689):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=4828660547, n=4689):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_6",
    "sat": "def sat(x: List[int], t=4392141578, n=3284):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=4392141578, n=3284):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_7",
    "sat": "def sat(x: List[int], t=8816640319, n=5104):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=8816640319, n=5104):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_8",
    "sat": "def sat(x: List[int], t=3556945850, n=8146):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=3556945850, n=8146):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "CumulativeSum_9",
    "sat": "def sat(x: List[int], t=137915544, n=3900):\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "sols": [
      "def sol(t=137915544, n=3900):\n    return [1] * n + [t]"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_0",
    "sat": "def sat(s: str, s1=\"a\", s2=\"b\", count1=50, count2=30):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"a\", s2=\"b\", count1=50, count2=30):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_1",
    "sat": "def sat(s: str, s1=\"kah\", s2=\"w\", count1=61, count2=91):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"kah\", s2=\"w\", count1=61, count2=91):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_2",
    "sat": "def sat(s: str, s1=\"x\", s2=\"n\", count1=16, count2=65):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"x\", s2=\"n\", count1=16, count2=65):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_3",
    "sat": "def sat(s: str, s1=\"heb\", s2=\"xis\", count1=54, count2=37):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"heb\", s2=\"xis\", count1=54, count2=37):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_4",
    "sat": "def sat(s: str, s1=\"fok\", s2=\"suc\", count1=56, count2=14):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"fok\", s2=\"suc\", count1=56, count2=14):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_5",
    "sat": "def sat(s: str, s1=\"tex\", s2=\"b\", count1=76, count2=82):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"tex\", s2=\"b\", count1=76, count2=82):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_6",
    "sat": "def sat(s: str, s1=\"t\", s2=\"gu\", count1=49, count2=57):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"t\", s2=\"gu\", count1=49, count2=57):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_7",
    "sat": "def sat(s: str, s1=\"l\", s2=\"voj\", count1=74, count2=61):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"l\", s2=\"voj\", count1=74, count2=61):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_8",
    "sat": "def sat(s: str, s1=\"m\", s2=\"gu\", count1=94, count2=34):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"m\", s2=\"gu\", count1=94, count2=34):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "BasicStrCounts_9",
    "sat": "def sat(s: str, s1=\"niz\", s2=\"r\", count1=35, count2=61):\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "sols": [
      "def sol(s1=\"niz\", s2=\"r\", count1=35, count2=61):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_0",
    "sat": "def sat(s: str, substrings=['foo', 'bar', 'baz', 'oddball']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['foo', 'bar', 'baz', 'oddball']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_1",
    "sat": "def sat(s: str, substrings=['bonunipygofonuwuqu', 'bazokilimothutilyny', 'dokavechuthymepo', 'hutysuchivebocu']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['bonunipygofonuwuqu', 'bazokilimothutilyny', 'dokavechuthymepo', 'hutysuchivebocu']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_2",
    "sat": "def sat(s: str, substrings=['puquox', 'jolohazomithumy', 'quexofy', 'thagabaxyxachomub']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['puquox', 'jolohazomithumy', 'quexofy', 'thagabaxyxachomub']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_3",
    "sat": "def sat(s: str, substrings=['doqueboquothu']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['doqueboquothu']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_4",
    "sat": "def sat(s: str, substrings=['wyjyd', 'chuwejopufezethujipi', 'tyhowikut', 'cyre']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['wyjyd', 'chuwejopufezethujipi', 'tyhowikut', 'cyre']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_5",
    "sat": "def sat(s: str, substrings=['c', 'semuvojumu', 'lavoda', 'bybyhusewireniruzah']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['c', 'semuvojumu', 'lavoda', 'bybyhusewireniruzah']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_6",
    "sat": "def sat(s: str, substrings=['chiq', 'poxequyti']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['chiq', 'poxequyti']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_7",
    "sat": "def sat(s: str, substrings=['rokitextaneraxo', 'vithi']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['rokitextaneraxo', 'vithi']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_8",
    "sat": "def sat(s: str, substrings=['gygimususutexty', 'th', 'quicok']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['gygimususutexty', 'th', 'quicok']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ZipStr_9",
    "sat": "def sat(s: str, substrings=['chasix', 'siroka', 'jykow']):\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "sols": [
      "def sol(substrings=['chasix', 'siroka', 'jykow']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_0",
    "sat": "def sat(s: str, substrings=['foo', 'bar', 'baz']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['foo', 'bar', 'baz']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_1",
    "sat": "def sat(s: str, substrings=['hadoris']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['hadoris']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_2",
    "sat": "def sat(s: str, substrings=['hyjapofatebododedy', 'quir', 'ma']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['hyjapofatebododedy', 'quir', 'ma']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_3",
    "sat": "def sat(s: str, substrings=['jynirezyfyryte', 'dochichutextolisu']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['jynirezyfyryte', 'dochichutextolisu']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_4",
    "sat": "def sat(s: str, substrings=['xatozi', 'nojocituche', 'fikelopysydi']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['xatozi', 'nojocituche', 'fikelopysydi']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_5",
    "sat": "def sat(s: str, substrings=['zocabu']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['zocabu']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_6",
    "sat": "def sat(s: str, substrings=['xif', 'texta', 'wikyrivexajucugen']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['xif', 'texta', 'wikyrivexajucugen']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_7",
    "sat": "def sat(s: str, substrings=['givisolut']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['givisolut']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_8",
    "sat": "def sat(s: str, substrings=['gucupachetextuty', 'polet', 'z', 'junitowymydy']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['gucupachetextuty', 'polet', 'z', 'junitowymydy']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "ReverseCat_9",
    "sat": "def sat(s: str, substrings=['gehigucilazutuve']):\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "sols": [
      "def sol(substrings=['gehigucilazutuve']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_0",
    "sat": "def sat(ls: List[str], n=100, a=\"bar\", b=\"foo\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=100, a=\"bar\", b=\"foo\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_1",
    "sat": "def sat(ls: List[str], n=53, a=\"chyxocym\", b=\"zisulique\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=53, a=\"chyxocym\", b=\"zisulique\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_2",
    "sat": "def sat(ls: List[str], n=76, a=\"h\", b=\"tuthixitotexticho\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=76, a=\"h\", b=\"tuthixitotexticho\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_3",
    "sat": "def sat(ls: List[str], n=72, a=\"texturypu\", b=\"xigabimitextehygilof\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=72, a=\"texturypu\", b=\"xigabimitextehygilof\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_4",
    "sat": "def sat(ls: List[str], n=97, a=\"bebut\", b=\"chitykitextono\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=97, a=\"bebut\", b=\"chitykitextono\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_5",
    "sat": "def sat(ls: List[str], n=63, a=\"bigy\", b=\"chychononobucij\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=63, a=\"bigy\", b=\"chychononobucij\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_6",
    "sat": "def sat(ls: List[str], n=58, a=\"hurepithejo\", b=\"xobijyvethythepychob\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=58, a=\"hurepithejo\", b=\"xobijyvethythepychob\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_7",
    "sat": "def sat(ls: List[str], n=53, a=\"wonafojosifevekuf\", b=\"zijycoquunomateq\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=53, a=\"wonafojosifevekuf\", b=\"zijycoquunomateq\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_8",
    "sat": "def sat(ls: List[str], n=60, a=\"dyba\", b=\"thoza\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=60, a=\"dyba\", b=\"thoza\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "EngineerNumbers_9",
    "sat": "def sat(ls: List[str], n=30, a=\"chebidirol\", b=\"quuvycewafukotehyr\"):\n    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "sols": [
      "def sol(n=30, a=\"chebidirol\", b=\"quuvycewafukotehyr\"):\n    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_0",
    "sat": "def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_1",
    "sat": "def sat(s: str, strings=['vyquykykazaveliryji', 'kycimypywavoxedu', 'coluxomujekacoquaz', 'k', 'nu', 'zih', 't', 'vagywijuzygy', 'hychepyhytexti', 'lycoxumachuwoqu']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['vyquykykazaveliryji', 'kycimypywavoxedu', 'coluxomujekacoquaz', 'k', 'nu', 'zih', 't', 'vagywijuzygy', 'hychepyhytexti', 'lycoxumachuwoqu']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_2",
    "sat": "def sat(s: str, strings=['voxobijypu', 'mybyhelyth', 'chana', 'thuthi', 'kylufyguvutextaf', 'thozifofutext', 'lequat', 'kechuvew', 'fybutextylifyv', 'pisoregyfunut']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['voxobijypu', 'mybyhelyth', 'chana', 'thuthi', 'kylufyguvutextaf', 'thozifofutext', 'lequat', 'kechuvew', 'fybutextylifyv', 'pisoregyfunut']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_3",
    "sat": "def sat(s: str, strings=['bajuzike', 'wyvacovegitup', 'xamacumirukelotowyh', 'kytajyligivifechasu', 'tat', 'negolys', 'quakys', 'sacerisufothavymoma', 'chec', 'tex']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['bajuzike', 'wyvacovegitup', 'xamacumirukelotowyh', 'kytajyligivifechasu', 'tat', 'negolys', 'quakys', 'sacerisufothavymoma', 'chec', 'tex']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_4",
    "sat": "def sat(s: str, strings=['ramusav', 'vu', 'thiquachode', 'bocherujythijiny', 'gucugamijyth', 'sebopehal', 'ma', 'rinawasavobevitexto', 'cethikukiteh', 'xofuvijaq']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['ramusav', 'vu', 'thiquachode', 'bocherujythijiny', 'gucugamijyth', 'sebopehal', 'ma', 'rinawasavobevitexto', 'cethikukiteh', 'xofuvijaq']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_5",
    "sat": "def sat(s: str, strings=['ducawyjyjodemat', 'lovaloluhotu', 'badynexokoj', 'n', 'cyfytyxonar', 'chethatukyzitex', 'chix', 'quanowulujixy', 'vonyfyhanaru', 'pycytextujechykahe']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['ducawyjyjodemat', 'lovaloluhotu', 'badynexokoj', 'n', 'cyfytyxonar', 'chethatukyzitex', 'chix', 'quanowulujixy', 'vonyfyhanaru', 'pycytextujechykahe']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_6",
    "sat": "def sat(s: str, strings=['thydogim', 'zuquith', 'cimin', 'pucogoxidebicoduth', 'gidaforepatex', 'chyxethunuradyque', 'my', 'caboquidyt', 'cedarem', 'gygetoxicututik']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['thydogim', 'zuquith', 'cimin', 'pucogoxidebicoduth', 'gidaforepatex', 'chyxethunuradyque', 'my', 'caboquidyt', 'cedarem', 'gygetoxicututik']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_7",
    "sat": "def sat(s: str, strings=['quafo', 'suwuch', 'pawovow', 'zadolibacituludotido', 'zathebova', 'notimirogizyn', 'ryko', 'hyzuchikinukako', 'duvopof', 'vosybelawihyxyzyqui']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['quafo', 'suwuch', 'pawovow', 'zadolibacituludotido', 'zathebova', 'notimirogizyn', 'ryko', 'hyzuchikinukako', 'duvopof', 'vosybelawihyxyzyqui']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_8",
    "sat": "def sat(s: str, strings=['tihumehudew', 'dibuwuchytextej', 'm', 'nepoquexapubemikoceg', 'jychokykyzote', 'chymib', 'rumajychyderu', 'bixicifegit', 'chytothujazude', 'text']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['tihumehudew', 'dibuwuchytextej', 'm', 'nepoquexapubemikoceg', 'jychokykyzote', 'chymib', 'rumajychyderu', 'bixicifegit', 'chytothujazude', 'text']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateString_9",
    "sat": "def sat(s: str, strings=['hezezesunib', 'cofovofuthiw', 'textoramowuchiris', 'vechajochofid', 'kyt', 'sac', 'tubiwacab', 'hazahapezamitex', 'cothichizijychu', 'vyxetextithi']):\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum(t > s for t in strings) == 1",
    "sols": [
      "def sol(strings=['hezezesunib', 'cofovofuthiw', 'textoramowuchiris', 'vechajochofid', 'kyt', 'sac', 'tubiwacab', 'hazahapezamitex', 'cothichizijychu', 'vyxetextithi']):\n    return sorted(strings)[-2]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_0",
    "sat": "def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_1",
    "sat": "def sat(s: str, strings=['waby', 'hajelywywocyt', 'xynakopaquafybetev', 'xagegolosuxivuzefit', 'ji', 'syfulutextedazok', 'rorexonumuchycica', 'myk', 'xebonipi', 'dadobevocite']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['waby', 'hajelywywocyt', 'xynakopaquafybetev', 'xagegolosuxivuzefit', 'ji', 'syfulutextedazok', 'rorexonumuchycica', 'myk', 'xebonipi', 'dadobevocite']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_2",
    "sat": "def sat(s: str, strings=['thutecafixywedapy', 'kokatextuxokuzejucyv', 'quazequegethoxafak', 'butuzyloxoru', 'wytextyryzuvi', 'hythutedithisujolu', 'dodycabocesono', 'quulisat', 'vychach', 'fe']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['thutecafixywedapy', 'kokatextuxokuzejucyv', 'quazequegethoxafak', 'butuzyloxoru', 'wytextyryzuvi', 'hythutedithisujolu', 'dodycabocesono', 'quulisat', 'vychach', 'fe']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_3",
    "sat": "def sat(s: str, strings=['wutha', 'nixowugipyzocycibo', 'letextiv', 'her', 'kisomuchobaq', 'wohywytizoxy', 'doloxazohyfoby', 'th', 'nevofy', 'thafomasymofywa']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['wutha', 'nixowugipyzocycibo', 'letextiv', 'her', 'kisomuchobaq', 'wohywytizoxy', 'doloxazohyfoby', 'th', 'nevofy', 'thafomasymofywa']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_4",
    "sat": "def sat(s: str, strings=['texteponurupakefataz', 'kefupochocypususu', 'jo', 'bazywivog', 'lepirowathehezofet', 'quomysyvig', 'thabeg', 'porujalipaku', 'norysyxypegihapifu', 'kecofos']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['texteponurupakefataz', 'kefupochocypususu', 'jo', 'bazywivog', 'lepirowathehezofet', 'quomysyvig', 'thabeg', 'porujalipaku', 'norysyxypegihapifu', 'kecofos']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_5",
    "sat": "def sat(s: str, strings=['quipibutextypagydi', 'quethanujozypom', 'bedomatu', 'wachobi', 'fybyquixidexuquen', 'nochyhekaha', 'nejo', 'fovor', 'zin', 'wesujadomomuzihekut']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['quipibutextypagydi', 'quethanujozypom', 'bedomatu', 'wachobi', 'fybyquixidexuquen', 'nochyhekaha', 'nejo', 'fovor', 'zin', 'wesujadomomuzihekut']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_6",
    "sat": "def sat(s: str, strings=['homozupatibely', 'l', 'zypetuvajepiquihe', 'sibe', 'gawetext', 'textumythyvyxe', 'fyfewatextequike', 'xetysymohujequewop', 'lazusum', 'xasethupyhyve']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['homozupatibely', 'l', 'zypetuvajepiquihe', 'sibe', 'gawetext', 'textumythyvyxe', 'fyfewatextequike', 'xetysymohujequewop', 'lazusum', 'xasethupyhyve']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_7",
    "sat": "def sat(s: str, strings=['nidibylywyful', 'wupikojohetyjo', 'poquetextirylabipim', 'lotujofyleresajahy', 'rysululitux', 'ponakydikethywujod', 'mocojunalulazel', 'xyzynuh', 'fequy', 'balutextilet']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['nidibylywyful', 'wupikojohetyjo', 'poquetextirylabipim', 'lotujofyleresajahy', 'rysululitux', 'ponakydikethywujod', 'mocojunalulazel', 'xyzynuh', 'fequy', 'balutextilet']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_8",
    "sat": "def sat(s: str, strings=['xydate', 'thetiluchaxop', 'vudawalow', 'quafutosyrequife', 'wopujizutext', 'hekuric', 'fywatonure', 'te', 'nathoxikosyxipygygig', 'gydijowexe']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['xydate', 'thetiluchaxop', 'vudawalow', 'quafutosyrequife', 'wopujizutext', 'hekuric', 'fywatonure', 'te', 'nathoxikosyxipygygig', 'gydijowexe']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "PenultimateRevString_9",
    "sat": "def sat(s: str, strings=['puxotawalumefoh', 'zaputycosarejitu', 'jalycete', 'cuquitinyf', 'xazupyket', 'chychequixahotuzyp', 'negaxohethiveduch', 'rete', 'rypihyc', 'bugisydipicukat']):\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "sols": [
      "def sol(strings=['puxotawalumefoh', 'zaputycosarejitu', 'jalycete', 'cuquitinyf', 'xazupyket', 'chychequixahotuzyp', 'negaxohethiveduch', 'rete', 'rypihyc', 'bugisydipicukat']):\n    return sorted(strings)[1][::-1]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_0",
    "sat": "def sat(s: str, target=\"foobarbazwow\", length=6):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"foobarbazwow\", length=6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_1",
    "sat": "def sat(s: str, target=\"thytykohu\", length=7):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"thytykohu\", length=7):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_2",
    "sat": "def sat(s: str, target=\"fugasepyfavybarutex\", length=16):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"fugasepyfavybarutex\", length=16):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_3",
    "sat": "def sat(s: str, target=\"si\", length=2):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"si\", length=2):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_4",
    "sat": "def sat(s: str, target=\"duquothygecadomyt\", length=1):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"duquothygecadomyt\", length=1):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_5",
    "sat": "def sat(s: str, target=\"kej\", length=3):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"kej\", length=3):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_6",
    "sat": "def sat(s: str, target=\"majajy\", length=6):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"majajy\", length=6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_7",
    "sat": "def sat(s: str, target=\"quojydy\", length=3):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"quojydy\", length=3):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_8",
    "sat": "def sat(s: str, target=\"varalucheni\", length=4):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"varalucheni\", length=4):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "CenteredString_9",
    "sat": "def sat(s: str, target=\"nusivythu\", length=8):\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "sols": [
      "def sol(target=\"nusivythu\", length=8):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_0",
    "sat": "def sat(substring: str, string=\"moooboooofasd\", count=2):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"moooboooofasd\", count=2):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_1",
    "sat": "def sat(substring: str, string=\"chesechewyzecapuwatextudicoxezethabazefuvu\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"chesechewyzecapuwatextudicoxezethabazefuvu\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_2",
    "sat": "def sat(substring: str, string=\"rigygijofodydyxixylybychodypusachodefenupyzatexto\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"rigygijofodydyxixylybychodypusachodefenupyzatexto\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_3",
    "sat": "def sat(substring: str, string=\"witextimohapogucutextutextoquoquova\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"witextimohapogucutextutextoquoquova\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_4",
    "sat": "def sat(substring: str, string=\"jehowadutocifazebahazycuchifonuthonuthesum\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"jehowadutocifazebahazycuchifonuthonuthesum\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_5",
    "sat": "def sat(substring: str, string=\"chozequomuteketextirowycatatextotatextegoheridatexticotusesivivuvilavufysuth\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"chozequomuteketextirowycatatextotatextegoheridatexticotusesivivuvilavufysuth\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_6",
    "sat": "def sat(substring: str, string=\"quawuthusypucybimakybachyvixithirorahukybyrozodasawagumowukedutextytykytextapipemebacocut\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"quawuthusypucybimakybachyvixithirorahukybyrozodasawagumowukedutextytykytextapipemebacocut\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_7",
    "sat": "def sat(substring: str, string=\"supitextutexucychenepukutezybycixejaridusyfiwutyp\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"supitextutexucychenepukutezybycixejaridusyfiwutyp\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_8",
    "sat": "def sat(substring: str, string=\"textaquacuzegabiquygequyxazofichikihevyzitextehivupuhefu\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"textaquacuzegabiquygequyxazofichikihevyzitextehivupuhefu\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "SubstrCount_9",
    "sat": "def sat(substring: str, string=\"thojotextojubasyduraquyhemamycaquuvamejotextatamerojepikakavysov\", count=3):\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count",
    "sols": [
      "def sol(string=\"thojotextojubasyduraquyhemamycaquuvamejotextatamerojepikakavysov\", count=3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic"
  },
  {
    "name": "EightQueensOrFewer_0",
    "sat": "def sat(squares: List[List[int]], m=8, n=8):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=8, n=8):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_1",
    "sat": "def sat(squares: List[List[int]], m=37, n=8):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=37, n=8):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_2",
    "sat": "def sat(squares: List[List[int]], m=6, n=93):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=6, n=93):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_3",
    "sat": "def sat(squares: List[List[int]], m=9, n=6):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=9, n=6):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_4",
    "sat": "def sat(squares: List[List[int]], m=6, n=88):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=6, n=88):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_5",
    "sat": "def sat(squares: List[List[int]], m=82, n=7):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=82, n=7):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_6",
    "sat": "def sat(squares: List[List[int]], m=9, n=8):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=9, n=8):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_7",
    "sat": "def sat(squares: List[List[int]], m=7, n=4):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=7, n=4):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_8",
    "sat": "def sat(squares: List[List[int]], m=7, n=58):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=7, n=58):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "EightQueensOrFewer_9",
    "sat": "def sat(squares: List[List[int]], m=4, n=5):\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "sols": [
      "def sol(m=4, n=5):  # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_0",
    "sat": "def sat(squares: List[List[int]], m=9, n=9):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=9, n=9):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_1",
    "sat": "def sat(squares: List[List[int]], m=76, n=9):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=76, n=9):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_2",
    "sat": "def sat(squares: List[List[int]], m=35, n=30):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=35, n=30):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_3",
    "sat": "def sat(squares: List[List[int]], m=75, n=14):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=75, n=14):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_4",
    "sat": "def sat(squares: List[List[int]], m=47, n=33):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=47, n=33):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_5",
    "sat": "def sat(squares: List[List[int]], m=65, n=22):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=65, n=22):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_6",
    "sat": "def sat(squares: List[List[int]], m=12, n=43):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=12, n=43):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_7",
    "sat": "def sat(squares: List[List[int]], m=78, n=81):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=78, n=81):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_8",
    "sat": "def sat(squares: List[List[int]], m=44, n=44):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=44, n=44):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "MoreQueens_9",
    "sat": "def sat(squares: List[List[int]], m=9, n=87):\n    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "sols": [
      "def sol(m=9, n=87):\n    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_0",
    "sat": "def sat(tour: List[List[int]], m=8, n=8):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=8, n=8):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_1",
    "sat": "def sat(tour: List[List[int]], m=9, n=9):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=9, n=9):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_2",
    "sat": "def sat(tour: List[List[int]], m=7, n=7):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=7, n=7):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_3",
    "sat": "def sat(tour: List[List[int]], m=6, n=6):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=6, n=6):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_4",
    "sat": "def sat(tour: List[List[int]], m=5, n=5):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=5, n=5):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_5",
    "sat": "def sat(tour: List[List[int]], m=10, n=10):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=10, n=10):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_6",
    "sat": "def sat(tour: List[List[int]], m=11, n=11):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=11, n=11):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_7",
    "sat": "def sat(tour: List[List[int]], m=12, n=12):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=12, n=12):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_8",
    "sat": "def sat(tour: List[List[int]], m=13, n=13):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=13, n=13):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "KnightsTour_9",
    "sat": "def sat(tour: List[List[int]], m=14, n=14):\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "sols": [
      "def sol(m=14, n=14):  # using Warnsdorff's heuristic, breaking ties randomly \n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_0",
    "sat": "def sat(path: List[List[int]], m=8, n=8, target=35):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_1",
    "sat": "def sat(path: List[List[int]], m=3, n=3, target=2):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_2",
    "sat": "def sat(path: List[List[int]], m=4, n=4, target=5):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_3",
    "sat": "def sat(path: List[List[int]], m=5, n=5, target=10):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_4",
    "sat": "def sat(path: List[List[int]], m=6, n=6, target=17):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_5",
    "sat": "def sat(path: List[List[int]], m=7, n=7, target=24):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_6",
    "sat": "def sat(path: List[List[int]], m=9, n=9, target=47):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_7",
    "sat": "def sat(path: List[List[int]], m=10, n=10, target=61):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_8",
    "sat": "def sat(path: List[List[int]], m=11, n=11, target=76):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UncrossedKnightsPath_9",
    "sat": "def sat(path: List[List[int]], m=12, n=12, target=94):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_0",
    "sat": "def sat(path: List[List[int]], m=8, n=8, target=35):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_1",
    "sat": "def sat(path: List[List[int]], m=3, n=3, target=3):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_2",
    "sat": "def sat(path: List[List[int]], m=4, n=4, target=6):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_3",
    "sat": "def sat(path: List[List[int]], m=5, n=5, target=11):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_4",
    "sat": "def sat(path: List[List[int]], m=6, n=6, target=18):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_5",
    "sat": "def sat(path: List[List[int]], m=7, n=7, target=25):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_6",
    "sat": "def sat(path: List[List[int]], m=8, n=8, target=36):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_7",
    "sat": "def sat(path: List[List[int]], m=9, n=9, target=48):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_8",
    "sat": "def sat(path: List[List[int]], m=10, n=10, target=62):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath_9",
    "sat": "def sat(path: List[List[int]], m=11, n=11, target=77):\n    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "sols": [],
    "module": "chess"
  },
  {
    "name": "LZW_0",
    "sat": "def sat(seq: List[int], compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_1",
    "sat": "def sat(seq: List[int], compressed_len=0, text=\"\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=0, text=\"\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_2",
    "sat": "def sat(seq: List[int], compressed_len=45, text=\"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=45, text=\"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_3",
    "sat": "def sat(seq: List[int], compressed_len=9, text=\"zokelilek\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=9, text=\"zokelilek\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_4",
    "sat": "def sat(seq: List[int], compressed_len=352, text=\"budykesomykojegipetithycyvuchoroquijotextywytekuwutextuhydaquyxacychejesychowasopytathavytikecukoquuvopiwetextajyjugaxiquahasybigotegymiwubuchuzalinyhygujesythithygyhithitochikidezezothethunozyhabuwahyxataquikazyponufuwekinysuquugatujipajesubisygicapucacoryfiwigykachucebadukakatisyrobadotachufewyciraquybosakomofyginuzytextohaquoquohuryrogisoxofafuchevoquitextulirynynopuchulakadybivanuquonudythytheripowymocachysykaremutextogachivysytextomepukychonepithosaqueracynabugimiquivyxethafomowulysochibybatextejupatorylamikequozytextojithepodedomakesudajagytoth\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=352, text=\"budykesomykojegipetithycyvuchoroquijotextywytekuwutextuhydaquyxacychejesychowasopytathavytikecukoquuvopiwetextajyjugaxiquahasybigotegymiwubuchuzalinyhygujesythithygyhithitochikidezezothethunozyhabuwahyxataquikazyponufuwekinysuquugatujipajesubisygicapucacoryfiwigykachucebadukakatisyrobadotachufewyciraquybosakomofyginuzytextohaquoquohuryrogisoxofafuchevoquitextulirynynopuchulakadybivanuquonudythytheripowymocachysykaremutextogachivysytextomepukychonepithosaqueracynabugimiquivyxethafomowulysochibybatextejupatorylamikequozytextojithepodedomakesudajagytoth\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_5",
    "sat": "def sat(seq: List[int], compressed_len=20, text=\"kyjuthucafylitopobyn\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=20, text=\"kyjuthucafylitopobyn\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_6",
    "sat": "def sat(seq: List[int], compressed_len=2, text=\"qu\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=2, text=\"qu\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_7",
    "sat": "def sat(seq: List[int], compressed_len=1, text=\"v\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=1, text=\"v\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_8",
    "sat": "def sat(seq: List[int], compressed_len=234, text=\"hotextexuchaxahyfathehuguchosylajedechatextetihynipitextochivynechapahenasethyguzejequunocykyluhovytextuquakupasogabobucirichohukajasathyquykufogywocycuchyhepogodulojenesebepiquuthyquodyjulubotextyduvysiduvubyrimequozywatextanudothutextobacerigazakythytextihuryhajywuquemotuhubatextohamimuthotyhixifuhyjevawuzysutextewuvuchynyvaruchywothadunozetextumuquoquivich\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=234, text=\"hotextexuchaxahyfathehuguchosylajedechatextetihynipitextochivynechapahenasethyguzejequunocykyluhovytextuquakupasogabobucirichohukajasathyquykufogywocycuchyhepogodulojenesebepiquuthyquodyjulubotextyduvysiduvubyrimequozywatextanudothutextobacerigazakythytextihuryhajywuquemotuhubatextohamimuthotyhixifuhyjevawuzysutextewuvuchynyvaruchywothadunozetextumuquoquivich\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_9",
    "sat": "def sat(seq: List[int], compressed_len=6, text=\"xaxohe\"):\n    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "sols": [
      "def sol(compressed_len=6, text=\"xaxohe\"):  # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_0",
    "sat": "def sat(text: str, seq=[72, 101, 108, 108, 111, 32, 119, 111, 114, 100, 262, 264, 266, 263, 265, 33]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[72, 101, 108, 108, 111, 32, 119, 111, 114, 100, 262, 264, 266, 263, 265, 33]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_1",
    "sat": "def sat(text: str, seq: List[int]=[]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_2",
    "sat": "def sat(text: str, seq=[97]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[97]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_3",
    "sat": "def sat(text: str, seq=[98, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 265]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[98, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 265]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_4",
    "sat": "def sat(text: str, seq=[97, 98, 257, 259, 258, 261, 260, 263, 262, 265, 264, 267, 266, 269, 268, 271, 270, 273, 272, 275, 274, 277, 276, 279, 278, 281, 280, 283, 282, 285, 284, 287, 286, 289, 288, 291, 290, 293, 292, 295, 294, 297, 296, 299, 298, 301, 300, 303, 302, 305, 304, 307, 306, 309, 308, 311, 310, 313, 312, 315, 314, 317, 316, 319, 318, 321, 320, 323, 322, 325, 324, 327, 326, 329, 328, 331, 330, 333, 332, 335, 334, 337, 336, 339, 338, 341, 340, 343, 293, 33]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[97, 98, 257, 259, 258, 261, 260, 263, 262, 265, 264, 267, 266, 269, 268, 271, 270, 273, 272, 275, 274, 277, 276, 279, 278, 281, 280, 283, 282, 285, 284, 287, 286, 289, 288, 291, 290, 293, 292, 295, 294, 297, 296, 299, 298, 301, 300, 303, 302, 305, 304, 307, 306, 309, 308, 311, 310, 313, 312, 315, 314, 317, 316, 319, 318, 321, 320, 323, 322, 325, 324, 327, 326, 329, 328, 331, 330, 333, 332, 335, 334, 337, 336, 339, 338, 341, 340, 343, 293, 33]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_5",
    "sat": "def sat(text: str, seq=[98, 111, 110, 97, 99, 104, 101, 122, 111, 104, 117, 104, 121, 115]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[98, 111, 110, 97, 99, 104, 101, 122, 111, 104, 117, 104, 121, 115]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_6",
    "sat": "def sat(text: str, seq=[110, 111, 109, 101, 110]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[110, 111, 109, 101, 110]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_7",
    "sat": "def sat(text: str, seq=[113, 117, 105, 116, 104, 111, 257, 97, 260, 117, 115, 117, 118, 101, 112, 111, 114, 121, 103, 97, 119, 97, 114, 105, 108, 121, 122, 121, 116, 117, 120, 105, 104, 276, 121, 100, 117, 99, 97, 115, 101, 110, 121, 98, 111, 112, 97, 118, 272, 105, 294, 104, 105, 114, 117, 102, 309, 105, 106, 117, 110, 97, 98, 295, 101, 114, 111, 100, 278, 323, 301, 101, 109, 105, 110, 286, 101, 106, 101, 99, 121, 279, 120, 97, 298, 319, 277, 294, 102, 301, 264, 308, 103, 111, 122, 350, 328, 121, 109, 264, 101, 120, 116, 354, 333, 101, 116, 314, 121, 99, 104, 117, 109, 111, 107, 306, 101, 277, 104, 274, 301, 105, 107, 117, 322, 257, 328, 259, 261, 116, 357, 359, 108, 117, 319, 112, 316, 121, 334, 329, 119, 111, 102, 101, 300, 331, 102, 380, 101, 107, 111, 386, 358, 321, 284, 121, 345, 366, 362, 289, 260, 97, 275, 366, 121, 108, 407, 385, 117, 351, 257, 368, 412, 357, 111, 108, 400, 105, 257, 299, 318, 335, 121, 118, 105, 122, 347, 105, 392, 345, 103, 117, 427, 99, 353, 102, 97, 120, 368, 105, 100, 101, 115, 105, 115, 418, 400, 272, 97, 302, 298, 110, 101, 389, 109, 121, 289, 317, 331, 107, 97, 107, 284, 387, 293, 356, 409, 408, 363, 112, 299, 301, 439, 335, 104, 333, 460, 380, 448, 117, 101, 382, 260, 272, 495, 407, 387, 314, 431, 314, 495, 121, 461, 119, 284, 111, 349, 484, 111, 98, 293, 308, 120, 497, 117, 97, 102, 354, 431, 423, 472, 347, 101, 447, 112, 456, 522, 347, 365, 465, 262, 521, 366, 501, 440, 334, 484, 101, 312, 459, 484, 117, 397, 98, 394, 101, 457, 427, 119, 390, 323, 335, 266, 306, 289, 367, 369, 302, 531, 263, 550, 287, 296, 484, 259, 335, 460, 105, 452, 310, 112, 552, 469, 309, 101, 518, 560, 282, 453, 522, 105, 118, 284, 308, 379, 100, 105, 109, 390, 477, 301, 117, 103, 121, 519, 300, 292, 292, 459, 312, 417, 427, 523, 510, 269, 116, 350, 479, 122, 587, 311, 321, 111, 110, 280, 280, 97, 106, 423, 537, 400, 362, 365, 270, 295, 318, 390, 291, 441, 111, 367, 382, 588, 543, 281, 308, 435, 100, 365, 372, 382, 292, 392, 543, 397, 539, 294, 300, 420, 107, 438, 414, 382, 420, 273, 339, 310, 656, 329, 351, 447, 324, 468, 550, 461, 432, 484, 589, 495, 574, 581, 111, 277, 322, 397, 624, 519, 279, 369, 322, 375, 119, 456, 309, 548, 362, 387, 97, 414, 363, 298, 308, 271, 414, 334, 106, 600, 330, 117, 570, 685, 121, 302, 673, 611, 482, 285, 366, 97, 592, 310, 98, 378, 394, 421, 439, 117, 281, 592, 257, 370, 712, 97, 289, 389, 389, 120, 619, 537, 560, 423, 259]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[113, 117, 105, 116, 104, 111, 257, 97, 260, 117, 115, 117, 118, 101, 112, 111, 114, 121, 103, 97, 119, 97, 114, 105, 108, 121, 122, 121, 116, 117, 120, 105, 104, 276, 121, 100, 117, 99, 97, 115, 101, 110, 121, 98, 111, 112, 97, 118, 272, 105, 294, 104, 105, 114, 117, 102, 309, 105, 106, 117, 110, 97, 98, 295, 101, 114, 111, 100, 278, 323, 301, 101, 109, 105, 110, 286, 101, 106, 101, 99, 121, 279, 120, 97, 298, 319, 277, 294, 102, 301, 264, 308, 103, 111, 122, 350, 328, 121, 109, 264, 101, 120, 116, 354, 333, 101, 116, 314, 121, 99, 104, 117, 109, 111, 107, 306, 101, 277, 104, 274, 301, 105, 107, 117, 322, 257, 328, 259, 261, 116, 357, 359, 108, 117, 319, 112, 316, 121, 334, 329, 119, 111, 102, 101, 300, 331, 102, 380, 101, 107, 111, 386, 358, 321, 284, 121, 345, 366, 362, 289, 260, 97, 275, 366, 121, 108, 407, 385, 117, 351, 257, 368, 412, 357, 111, 108, 400, 105, 257, 299, 318, 335, 121, 118, 105, 122, 347, 105, 392, 345, 103, 117, 427, 99, 353, 102, 97, 120, 368, 105, 100, 101, 115, 105, 115, 418, 400, 272, 97, 302, 298, 110, 101, 389, 109, 121, 289, 317, 331, 107, 97, 107, 284, 387, 293, 356, 409, 408, 363, 112, 299, 301, 439, 335, 104, 333, 460, 380, 448, 117, 101, 382, 260, 272, 495, 407, 387, 314, 431, 314, 495, 121, 461, 119, 284, 111, 349, 484, 111, 98, 293, 308, 120, 497, 117, 97, 102, 354, 431, 423, 472, 347, 101, 447, 112, 456, 522, 347, 365, 465, 262, 521, 366, 501, 440, 334, 484, 101, 312, 459, 484, 117, 397, 98, 394, 101, 457, 427, 119, 390, 323, 335, 266, 306, 289, 367, 369, 302, 531, 263, 550, 287, 296, 484, 259, 335, 460, 105, 452, 310, 112, 552, 469, 309, 101, 518, 560, 282, 453, 522, 105, 118, 284, 308, 379, 100, 105, 109, 390, 477, 301, 117, 103, 121, 519, 300, 292, 292, 459, 312, 417, 427, 523, 510, 269, 116, 350, 479, 122, 587, 311, 321, 111, 110, 280, 280, 97, 106, 423, 537, 400, 362, 365, 270, 295, 318, 390, 291, 441, 111, 367, 382, 588, 543, 281, 308, 435, 100, 365, 372, 382, 292, 392, 543, 397, 539, 294, 300, 420, 107, 438, 414, 382, 420, 273, 339, 310, 656, 329, 351, 447, 324, 468, 550, 461, 432, 484, 589, 495, 574, 581, 111, 277, 322, 397, 624, 519, 279, 369, 322, 375, 119, 456, 309, 548, 362, 387, 97, 414, 363, 298, 308, 271, 414, 334, 106, 600, 330, 117, 570, 685, 121, 302, 673, 611, 482, 285, 366, 97, 592, 310, 98, 378, 394, 421, 439, 117, 281, 592, 257, 370, 712, 97, 289, 389, 389, 120, 619, 537, 560, 423, 259]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_8",
    "sat": "def sat(text: str, seq=[116, 101, 122, 101, 106, 121, 107, 105, 98, 105, 104, 101, 116, 104, 105, 109, 105, 113, 117, 121, 112, 111, 257, 120, 116, 111, 119, 121, 103, 111, 106, 97, 116, 97, 274, 105, 102, 105, 279, 116, 264, 97, 98, 117, 296, 99, 101, 274, 121, 110, 97, 287, 107, 121, 102, 101, 311, 283, 119, 111, 115, 290, 117, 288, 101, 280, 117, 99, 267, 119, 97, 277, 269, 101, 324, 105, 119, 117, 274, 278, 104, 121, 295, 101, 98, 121, 118, 307, 111, 98, 111, 103, 273, 275, 107, 101, 108, 282, 294, 320, 280, 332, 117, 114, 105, 108, 292, 117, 103, 327, 111, 120, 105, 324, 117, 112, 97, 120, 121, 370, 368, 269, 288, 270, 98, 101, 112, 121, 381, 351, 289, 109, 101, 103, 321, 336, 367, 323, 278, 321, 116, 121, 104, 111, 112, 268, 396, 105]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[116, 101, 122, 101, 106, 121, 107, 105, 98, 105, 104, 101, 116, 104, 105, 109, 105, 113, 117, 121, 112, 111, 257, 120, 116, 111, 119, 121, 103, 111, 106, 97, 116, 97, 274, 105, 102, 105, 279, 116, 264, 97, 98, 117, 296, 99, 101, 274, 121, 110, 97, 287, 107, 121, 102, 101, 311, 283, 119, 111, 115, 290, 117, 288, 101, 280, 117, 99, 267, 119, 97, 277, 269, 101, 324, 105, 119, 117, 274, 278, 104, 121, 295, 101, 98, 121, 118, 307, 111, 98, 111, 103, 273, 275, 107, 101, 108, 282, 294, 320, 280, 332, 117, 114, 105, 108, 292, 117, 103, 327, 111, 120, 105, 324, 117, 112, 97, 120, 121, 370, 368, 269, 288, 270, 98, 101, 112, 121, 381, 351, 289, 109, 101, 103, 321, 336, 367, 323, 278, 321, 116, 121, 104, 111, 112, 268, 396, 105]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "LZW_decompress_9",
    "sat": "def sat(text: str, seq=[118, 117, 110, 101, 116, 101, 120, 116, 111]):\n    \"\"\"\n    Find a string that compresses to the target sequence for the provided implementation of the\n    Lempel-Ziv algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"\n    index = {chr(i): i for i in range(256)}\n    seq2 = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq2.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq2.append(index[buffer])\n\n    return seq2 == seq",
    "sols": [
      "def sol(seq=[118, 117, 110, 101, 116, 101, 120, 116, 111]):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append(pieces[-1] + pieces[-1][0] if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces)"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_0",
    "sat": "def sat(words: List[str], num=100, bits=100, dist=34):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=100, bits=100, dist=34):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_1",
    "sat": "def sat(words: List[str], num=7, bits=54, dist=19):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=7, bits=54, dist=19):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_2",
    "sat": "def sat(words: List[str], num=88, bits=49, dist=12):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=88, bits=49, dist=12):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_3",
    "sat": "def sat(words: List[str], num=98, bits=61, dist=15):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=98, bits=61, dist=15):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_4",
    "sat": "def sat(words: List[str], num=85, bits=99, dist=31):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=85, bits=99, dist=31):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_5",
    "sat": "def sat(words: List[str], num=5, bits=8, dist=1):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=5, bits=8, dist=1):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_6",
    "sat": "def sat(words: List[str], num=7, bits=8, dist=1):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=7, bits=8, dist=1):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_7",
    "sat": "def sat(words: List[str], num=8, bits=87, dist=32):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=8, bits=87, dist=32):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_8",
    "sat": "def sat(words: List[str], num=6, bits=9, dist=1):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=6, bits=9, dist=1):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "PackingHam_9",
    "sat": "def sat(words: List[str], num=5, bits=32, dist=9):\n    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "sols": [
      "def sol(num=5, bits=32, dist=9):\n    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression"
  },
  {
    "name": "Oscillators_0",
    "sat": "def sat(init: List[List[int]], period=3):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [
      "def sol(period=3):  # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_1",
    "sat": "def sat(init: List[List[int]], period=1):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [
      "def sol(period=1):  # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_2",
    "sat": "def sat(init: List[List[int]], period=2):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [
      "def sol(period=2):  # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_3",
    "sat": "def sat(init: List[List[int]], period=4):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_4",
    "sat": "def sat(init: List[List[int]], period=5):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_5",
    "sat": "def sat(init: List[List[int]], period=6):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_6",
    "sat": "def sat(init: List[List[int]], period=7):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_7",
    "sat": "def sat(init: List[List[int]], period=8):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_8",
    "sat": "def sat(init: List[List[int]], period=9):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Oscillators_9",
    "sat": "def sat(init: List[List[int]], period=10):\n    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_0",
    "sat": "def sat(position: List[List[int]], target=[[1, 3], [1, 4], [2, 5]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[1, 3], [1, 4], [2, 5]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_1",
    "sat": "def sat(position: List[List[int]], target: List[List[int]]=[]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_2",
    "sat": "def sat(position: List[List[int]], target=[[-6, 1], [-5, 1], [-4, 1]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[-6, 1], [-5, 1], [-4, 1]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_3",
    "sat": "def sat(position: List[List[int]], target=[[-4, -1], [-4, 0], [-4, 1], [-3, -1], [-3, 0], [-3, 1]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[-4, -1], [-4, 0], [-4, 1], [-3, -1], [-3, 0], [-3, 1]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_4",
    "sat": "def sat(position: List[List[int]], target=[[-2, 0]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[-2, 0]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_5",
    "sat": "def sat(position: List[List[int]], target=[[1, -1], [1, 0]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[1, -1], [1, 0]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_6",
    "sat": "def sat(position: List[List[int]], target=[[0, 2], [0, 3], [1, 1], [1, 3], [3, 1]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[0, 2], [0, 3], [1, 1], [1, 3], [3, 1]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_7",
    "sat": "def sat(position: List[List[int]], target=[[2, -1], [2, 0], [2, 1]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[2, -1], [2, 0], [2, 1]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_8",
    "sat": "def sat(position: List[List[int]], target=[[3, -3], [3, -2], [4, -3], [4, -2]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[3, -3], [3, -2], [4, -3], [4, -2]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "ReverseLifeStep_9",
    "sat": "def sat(position: List[List[int]], target=[[-3, -1], [-3, 0], [-3, 1], [-2, 1]]):\n    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "sols": [
      "def sol(target=[[-3, -1], [-3, 0], [-3, 1], [-2, 1]]):  # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_0",
    "sat": "def sat(init: List[List[int]], period=4):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_1",
    "sat": "def sat(init: List[List[int]], period=2):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_2",
    "sat": "def sat(init: List[List[int]], period=3):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_3",
    "sat": "def sat(init: List[List[int]], period=5):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_4",
    "sat": "def sat(init: List[List[int]], period=6):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_5",
    "sat": "def sat(init: List[List[int]], period=7):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_6",
    "sat": "def sat(init: List[List[int]], period=8):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_7",
    "sat": "def sat(init: List[List[int]], period=9):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_8",
    "sat": "def sat(init: List[List[int]], period=10):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Spaceship_9",
    "sat": "def sat(init: List[List[int]], period=11):\n    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "sols": [],
    "module": "conways_game_of_life"
  },
  {
    "name": "Nim_0",
    "sat": "def sat(cert: List[List[int]], heaps=[5, 9]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_1",
    "sat": "def sat(cert: List[List[int]], heaps=[6, 1, 3, 5, 3]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 3, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_2",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_3",
    "sat": "def sat(cert: List[List[int]], heaps=[8, 8, 1, 7]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_4",
    "sat": "def sat(cert: List[List[int]], heaps=[9, 2]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_5",
    "sat": "def sat(cert: List[List[int]], heaps=[5, 2, 7, 9]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_6",
    "sat": "def sat(cert: List[List[int]], heaps=[6, 3, 7, 8, 6, 1]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 7, 8, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_7",
    "sat": "def sat(cert: List[List[int]], heaps=[6, 2, 8, 8]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_8",
    "sat": "def sat(cert: List[List[int]], heaps=[8]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Nim_9",
    "sat": "def sat(cert: List[List[int]], heaps=[1]):\n    \"\"\"\n    Compute optimal play in Nim, a two-player game involving a number of heaps of objects. Players alternate,\n    in each turn removing one or more objects from a single non-empty heap. The player who takes the last object\n    wins. The initial board state is represented by heaps, a list of numbers of objects in each heap.\n    The optimal play is certified by a list of \"winning leaves\" which are themselves lists of heap sizes\n    that, with optimal play, are winning if you leave your opponent with those numbers of objects.\n    \"\"\"\n\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    init_leave = tuple(heaps)\n    return is_good_leave(init_leave) == (init_leave in good_leaves)",
    "sols": [
      "def sol(heaps=[1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "module": "games"
  },
  {
    "name": "Mastermind_0",
    "sat": "def sat(transcripts: List[str], max_moves=10):\n    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    ```\n    AABB 11\n    ABCD 21\n    ABDC\n    ```\n    This is the transcript as the game is in progress. The complete transcript might be:\n    ```\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n    ```\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "sols": [
      "def sol(max_moves=10):\n    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "module": "games"
  },
  {
    "name": "Mastermind_1",
    "sat": "def sat(transcripts: List[str], max_moves=6):\n    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    ```\n    AABB 11\n    ABCD 21\n    ABDC\n    ```\n    This is the transcript as the game is in progress. The complete transcript might be:\n    ```\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n    ```\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "sols": [
      "def sol(max_moves=6):\n    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "module": "games"
  },
  {
    "name": "Mastermind_2",
    "sat": "def sat(transcripts: List[str], max_moves=8):\n    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    ```\n    AABB 11\n    ABCD 21\n    ABDC\n    ```\n    This is the transcript as the game is in progress. The complete transcript might be:\n    ```\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n    ```\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "sols": [
      "def sol(max_moves=8):\n    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "module": "games"
  },
  {
    "name": "TicTacToeX_0",
    "sat": "def sat(good_boards: List[str]):\n    \"\"\"\n    Compute a strategy for X (first player) in tic-tac-toe that guarantees a tie. That is a strategy for X that,\n    no matter what the opponent does, X does not lose.\n\n    A board is represented as a 9-char string like an X in the middle would be \"....X....\" and a\n    move is an integer 0-8. The answer is a list of \"good boards\" that X aims for, so no matter what O does there\n    is always good board that X can get to with a single move.\n    \"\"\"\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.\n        x |= 1 << [i for i in range(9) if (x | (1 << i), o) in board_bit_reps][0]\n        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))\n\n    return tie(0, 0)",
    "sols": [
      "def sol():\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[o]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and o_move(x | (1 << i), o):\n                good_boards.append(\"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + (i == j)] for j in range(9)))\n                return True\n        return False  # O wins\n\n    def o_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[x] or x | o == 511: # full board\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not x_move(x, o | (1 << i)):\n                return False\n        return True  # O wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"
    ],
    "module": "games"
  },
  {
    "name": "TicTacToeO_0",
    "sat": "def sat(good_boards: List[str]):\n    \"\"\"\n    Compute a strategy for O (second player) in tic-tac-toe that guarantees a tie. That is a strategy for O that,\n    no matter what the opponent does, O does not lose.\n\n    A board is represented as a 9-char string like an X in the middle would be \"....X....\" and a\n    move is an integer 0-8. The answer is a list of \"good boards\" that O aims for, so no matter what X does there\n    is always good board that O can get to with a single move.\n    \"\"\"\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.\n        if o | x != 511: # complete board\n            o |= 1 << [i for i in range(9) if (x, o | (1 << i)) in board_bit_reps][0]\n        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))\n\n    return all(tie(1 << i, 0) for i in range(9))",
    "sols": [
      "def sol():\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if o wins or ties, x's turn to move\n        if win[o] or x | o == 511: # full board\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not o_move(x | (1 << i), o):\n                return False\n        return True  # O wins/ties\n\n    def o_move(x, o):  # returns True if o wins or ties, o's turn to move\n        if win[x]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and x_move(x, o | (1 << i)):\n                good_boards.append(\n                    \"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + 2 * (i == j)] for j in range(9)))\n                return True\n        return False  # X wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"
    ],
    "module": "games"
  },
  {
    "name": "RockPaperScissors_0",
    "sat": "def sat(probs: List[float]):\n    \"\"\"Find optimal probabilities for playing Rock-Paper-Scissors zero-sum game, with best worst-case guarantee\"\"\"\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6",
    "sols": [
      "def sol():\n    return [1 / 3] * 3"
    ],
    "module": "games"
  },
  {
    "name": "Nash_0",
    "sat": "def sat(strategies: List[List[float]], A=[[-1.0, -3.0], [0.0, -2.0]], B=[[-1.0, 0.0], [-3.0, -2.0]], eps=0.01):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [
      "def sol(A=[[-1.0, -3.0], [0.0, -2.0]], B=[[-1.0, 0.0], [-3.0, -2.0]], eps=0.01):\n    NUM_ATTEMPTS = 100\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"
    ],
    "module": "game_theory"
  },
  {
    "name": "Nash_1",
    "sat": "def sat(strategies: List[List[float]], A=[[0.7485264382661345, 0.9298531672503509, 0.4319545905928802, 0.5906803638760482, 0.009769472404732027, 0.16830415718347502], [0.3907538227867029, 0.08565221106001208, 0.7341327745986795, 0.37980987717164694, 0.8272841370766646, 0.5988905861483632], [0.15819156783123312, 0.6037563138999644, 0.35871304868931075, 0.3838369318277003, 0.2403223101620504, 0.5255049983197273]], B=[[0.9840134427407278, 0.22778622901079015, 0.7706024590713557, 0.7806665226411371, 0.6864764376251131, 0.7548902824964548], [0.44532123453987604, 0.43294446322732283, 0.2622270852362303, 0.0004136268547570987, 0.3985971177986455, 0.3877358769311272], [0.39795816599716216, 0.9583993178279521, 0.34801710469332947, 0.6707010486967526, 0.7338344055737935, 0.2846593022898719]], eps=0.01):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [],
    "module": "game_theory"
  },
  {
    "name": "Nash_2",
    "sat": "def sat(strategies: List[List[float]], A=[[0.8886040972178669, 0.7722897951304988, 0.8747935197680075, 0.28980626720844804, 0.022969368762921105], [0.06096814014574736, 0.5048086724109689, 0.9941510467361251, 0.6660741974898959, 0.6096188496272028], [0.48236012065138545, 0.365898680413125, 0.28733192383578676, 0.8405693050545849, 0.00686679983498506], [0.4811261326867833, 0.17064426378465236, 0.05048233421150261, 0.48000205490364956, 0.8985702154183391]], B=[[0.82346342698757, 0.3750383610833249, 0.7716396365624453, 0.03468789690201568, 0.024890528792576028], [0.5074434792373976, 0.533054933696081, 0.8224824897323729, 0.9435179352271852, 0.23494464785543911], [0.8323619759221134, 0.9962265112100903, 0.20963173493559606, 0.7623980043031792, 0.43221444449752133], [0.5599603621418388, 0.21255923592635417, 0.07474805216902924, 0.9578845027058732, 0.6513817053543565]], eps=0.5):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.8886040972178669, 0.7722897951304988, 0.8747935197680075, 0.28980626720844804, 0.022969368762921105], [0.06096814014574736, 0.5048086724109689, 0.9941510467361251, 0.6660741974898959, 0.6096188496272028], [0.48236012065138545, 0.365898680413125, 0.28733192383578676, 0.8405693050545849, 0.00686679983498506], [0.4811261326867833, 0.17064426378465236, 0.05048233421150261, 0.48000205490364956, 0.8985702154183391]], B=[[0.82346342698757, 0.3750383610833249, 0.7716396365624453, 0.03468789690201568, 0.024890528792576028], [0.5074434792373976, 0.533054933696081, 0.8224824897323729, 0.9435179352271852, 0.23494464785543911], [0.8323619759221134, 0.9962265112100903, 0.20963173493559606, 0.7623980043031792, 0.43221444449752133], [0.5599603621418388, 0.21255923592635417, 0.07474805216902924, 0.9578845027058732, 0.6513817053543565]], eps=0.5):\n    NUM_ATTEMPTS = 100\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"
    ],
    "module": "game_theory"
  },
  {
    "name": "Nash_3",
    "sat": "def sat(strategies: List[List[float]], A=[[0.3971471601838128, 0.8815392015194308], [0.8846678092440173, 0.41166720188435624]], B=[[0.05044902124198403, 0.021626456485041023], [0.7375685157960941, 0.7259901195440779]], eps=0.5):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.3971471601838128, 0.8815392015194308], [0.8846678092440173, 0.41166720188435624]], B=[[0.05044902124198403, 0.021626456485041023], [0.7375685157960941, 0.7259901195440779]], eps=0.5):\n    NUM_ATTEMPTS = 100\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"
    ],
    "module": "game_theory"
  },
  {
    "name": "Nash_4",
    "sat": "def sat(strategies: List[List[float]], A=[[0.5717701057366342, 0.7198340516688575, 0.5048071687277489, 0.26048306611208916, 0.28376504285081416, 0.10680022435849479], [0.8344129518829808, 0.6038464255404058, 0.6466301644856546, 0.6661880902707118, 0.725850821988206, 0.22268956792589445], [0.6480203164468618, 0.9283000034784162, 0.6941539815153529, 0.388267183798119, 0.16549991505166717, 0.3326402587473174], [0.7679315654390944, 0.7711876620744738, 0.2551223720406327, 0.39343224010908284, 0.7511815225259844, 0.4529866402353663], [0.2062758053247179, 0.6365402931449154, 0.9578625912322607, 0.6962536549236567, 0.543699069968495, 0.011729398759902865], [0.19369138539948572, 0.1654027577642554, 0.1176345457714314, 0.6299551793101357, 0.20312633906633903, 0.491787731417068], [0.2798912312737474, 0.13235017128618598, 0.9221826465780643, 0.7144265646969055, 0.4326640526941766, 0.7353102328111651], [0.9565695220744007, 0.9195201032497269, 0.14129776655817172, 0.5309247931135578, 0.2985556724223507, 0.6073671049474825]], B=[[0.22423749967386053, 0.8113117353533502, 0.9523770250564866, 0.5852571497348197, 0.6765593893629129, 0.020554435291938677], [0.6863969102557747, 0.9592416507787452, 0.15136265255407555, 0.43322690112625706, 0.5089226822382722, 0.5883478830296549], [0.3192131097168378, 0.37122366616447944, 0.8504237720700842, 0.15494509124007294, 0.483973703328056, 0.39511782866138523], [0.48640735370238697, 0.570133662509227, 0.8657747451076262, 0.4112192810467874, 0.07093091098483117, 0.5180078822404305], [0.8746733029483773, 0.8909062347375092, 0.5928027077729808, 0.19079641264030078, 0.038102558978307166, 0.561937472516656], [0.28918980007374717, 0.3762205458551613, 0.5314010332425648, 0.02263453740677479, 0.8392060551735949, 0.7201621929439836], [0.5065209652222794, 0.5130458811630886, 0.7085090284584656, 0.7024347390584272, 0.9134505388416448, 0.4394978180394624], [0.41809967518791713, 0.7812409983851211, 0.7680459473131223, 0.4220436326882857, 0.9318919200978709, 0.5771709709716888]], eps=0.1):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [],
    "module": "game_theory"
  },
  {
    "name": "Nash_5",
    "sat": "def sat(strategies: List[List[float]], A=[[0.6109136546166071, 0.18002564354839523, 0.8635803909611692, 0.1689508978835026], [0.11511487618687, 0.0807270021648856, 0.6078559785013409, 0.5134851936690272], [0.9562815756018906, 0.6412291823365484, 0.07378650769528505, 0.4991568065696098], [0.8290782289767092, 0.4422059043654971, 0.5438844069493263, 0.36950246624514016], [0.11208174411471017, 0.15635009487803497, 0.5664900744957233, 0.78689777404465], [0.7840181386324955, 0.7772243218185158, 0.6156432904296982, 0.15130154097111215], [0.9370390940655191, 0.64012576582116, 0.7656528390665351, 0.519777569234388], [0.6651035087660839, 0.09284127564982725, 0.581708916002352, 0.1785845069447093]], B=[[0.029089757284169515, 0.5535001891314958, 0.5221052827771917, 0.1402815568047091], [0.9497057303225872, 0.8527894254074887, 0.35808343938933607, 0.8552760548885743], [0.040121170071127144, 0.1573302217147622, 0.11530840443445889, 0.3542500283318395], [0.5933132297875275, 0.2569731217158632, 0.24464842492103478, 0.26895252308979944], [0.29964721260882077, 0.7524286704016262, 0.4902755005840417, 0.44658497669515307], [0.2665371347824399, 0.563988055448697, 0.4478282564318232, 0.5783989272614684], [0.06162054645268611, 0.5911091481184562, 0.44470300667667384, 0.5754940948227039], [0.1343155642639754, 0.9567634765672901, 0.7834383356540163, 0.5696323013244348]], eps=0.01):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [],
    "module": "game_theory"
  },
  {
    "name": "Nash_6",
    "sat": "def sat(strategies: List[List[float]], A=[[0.503745122121491, 0.2489928787239465, 0.2586593847701786, 0.8714889295708362, 0.9626183880789638], [0.023574598685105808, 0.33805678025483543, 0.12278061499234405, 0.5089194073245604, 0.4853097378598181], [0.32160055106118646, 0.5444834465068987, 0.6918248616208577, 0.2212262349040499, 0.4547258070819523], [0.3527519000383532, 0.6089439234100906, 0.2804604362793657, 0.3002540535396987, 0.22711527252846375]], B=[[0.7806133704882108, 0.5991849045533887, 0.8846958290322406, 0.6025101421222069, 0.35126304815329146], [0.5169197456328587, 0.7888776448714996, 0.7251425347025834, 0.12951548258910195, 0.8787718498545047], [0.5037169273285153, 0.5808850199591395, 0.10071772088787945, 0.5533555642187823, 0.45954922282854493], [0.40744518236237304, 0.31275612796369545, 0.20754605799235037, 0.9359864132040129, 0.11992135756619438]], eps=0.1):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.503745122121491, 0.2489928787239465, 0.2586593847701786, 0.8714889295708362, 0.9626183880789638], [0.023574598685105808, 0.33805678025483543, 0.12278061499234405, 0.5089194073245604, 0.4853097378598181], [0.32160055106118646, 0.5444834465068987, 0.6918248616208577, 0.2212262349040499, 0.4547258070819523], [0.3527519000383532, 0.6089439234100906, 0.2804604362793657, 0.3002540535396987, 0.22711527252846375]], B=[[0.7806133704882108, 0.5991849045533887, 0.8846958290322406, 0.6025101421222069, 0.35126304815329146], [0.5169197456328587, 0.7888776448714996, 0.7251425347025834, 0.12951548258910195, 0.8787718498545047], [0.5037169273285153, 0.5808850199591395, 0.10071772088787945, 0.5533555642187823, 0.45954922282854493], [0.40744518236237304, 0.31275612796369545, 0.20754605799235037, 0.9359864132040129, 0.11992135756619438]], eps=0.1):\n    NUM_ATTEMPTS = 100\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"
    ],
    "module": "game_theory"
  },
  {
    "name": "Nash_7",
    "sat": "def sat(strategies: List[List[float]], A=[[0.20345739375049898, 0.7891657894710764], [0.7021580674823465, 0.009262241793984272], [0.3169975389981833, 0.3436344820692814], [0.6210429860677162, 0.6940366506759023], [0.9651155184985053, 0.6187335593064085], [0.8315065885782903, 0.30480547471562325], [0.6410808984891743, 0.47671776211258876], [0.8817310854929793, 0.9619356927004993]], B=[[0.5907180648905613, 0.503624275945328], [0.7138379640231513, 0.29660748184876884], [0.00044367976919812424, 0.21280466854849545], [0.3742076022045443, 0.1128496123607553], [0.6096287390667162, 0.5653745627720035], [0.4392439662382408, 0.8508183610643454], [0.6508292539191237, 0.29383851579507303], [0.163440822031498, 0.09883665146137854]], eps=0.1):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.20345739375049898, 0.7891657894710764], [0.7021580674823465, 0.009262241793984272], [0.3169975389981833, 0.3436344820692814], [0.6210429860677162, 0.6940366506759023], [0.9651155184985053, 0.6187335593064085], [0.8315065885782903, 0.30480547471562325], [0.6410808984891743, 0.47671776211258876], [0.8817310854929793, 0.9619356927004993]], B=[[0.5907180648905613, 0.503624275945328], [0.7138379640231513, 0.29660748184876884], [0.00044367976919812424, 0.21280466854849545], [0.3742076022045443, 0.1128496123607553], [0.6096287390667162, 0.5653745627720035], [0.4392439662382408, 0.8508183610643454], [0.6508292539191237, 0.29383851579507303], [0.163440822031498, 0.09883665146137854]], eps=0.1):\n    NUM_ATTEMPTS = 100\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"
    ],
    "module": "game_theory"
  },
  {
    "name": "Nash_8",
    "sat": "def sat(strategies: List[List[float]], A=[[0.4554282525672326, 0.9275962112020281, 0.6690502597997625, 0.3429358009616643, 0.9813218628685824, 0.6089611068133924, 0.8680931141324126, 0.21170199040040316, 0.13879891583295723], [0.061297439367196005, 0.7962709086496244, 0.11216422196869258, 0.24932842655509946, 0.46859708536039735, 0.6800789571597079, 0.17883401345516703, 0.003779411890875939, 0.9371064613310495], [0.2382786812935097, 0.8189856688594409, 0.20583124888261106, 0.00598280708731147, 0.8138422163764174, 0.35068403609119914, 0.4336711350280864, 0.016943554721231657, 0.40871784578873793], [0.43991413843597527, 0.706917221051512, 0.79992825314772, 0.12618185960179096, 0.39638481027351047, 0.7466083918204833, 0.20219227464292344, 0.9679478365761939, 0.9641979902606203], [0.23780097992293991, 0.4200828081735627, 0.7015985607259408, 0.5497512133717033, 0.8421326699355727, 0.716822980610246, 0.6372190928847935, 0.9937997075643976, 0.9409017094816768], [0.06706392639980907, 0.7707194960135519, 0.4853828938708419, 0.02019737248720488, 0.347436503480014, 0.16263037637451772, 0.056020260773506414, 0.9823162951033018, 0.8981721353315972]], B=[[0.3828876409175731, 0.6611429909234143, 0.8756377531523039, 0.425853589920304, 0.35699018280632777, 0.5152913966988215, 0.49690667439250213, 0.0015460931171384917, 0.22893888216617608], [0.9737832037339318, 0.15828390168872264, 0.9835158111084799, 0.1321770862045475, 0.546586263538245, 0.2780917435247342, 0.22043834642446702, 0.9929138928859156, 0.8837791089872566], [0.6147361338541908, 0.8343925335333335, 0.32109643371246044, 0.9662957065955367, 0.12951165629397776, 0.2616849275209514, 0.5289695302344081, 0.9625853354291635, 0.4215392985177471], [0.19499610723893046, 0.6663469454522825, 0.37120101830959085, 0.9102517076043298, 0.49195236767352823, 0.8854364015878813, 0.10398055910698756, 0.16839799186451265, 0.10878509398037595], [0.022839889216592968, 0.11134704103745807, 0.3201648130049398, 0.19306787158202288, 0.9597135260332842, 0.20849521831559747, 0.02563562799448904, 0.08585189867348586, 0.44650353724048675], [0.7912509951187425, 0.02841203455682495, 0.7580371606111864, 0.5196129871792563, 0.4952835203727265, 0.19633331151739908, 0.21876041991315298, 0.22694142891862745, 0.17191361817438866]], eps=0.1):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [],
    "module": "game_theory"
  },
  {
    "name": "Nash_9",
    "sat": "def sat(strategies: List[List[float]], A=[[0.6193532723890484, 0.053849653930963304, 0.5137044349084453, 0.7479057010189193, 0.5698371481266441, 0.7117514385166926, 0.32764074355430695], [0.45817567580806573, 0.9767832667274997, 0.031648984851259665, 0.3413107007542058, 0.6484892511372913, 0.054116747946723276, 0.3222349014964294], [0.5264473875168703, 0.48655747706276997, 0.3655585063327238, 0.7024969535411586, 0.7270743694943488, 0.09959816495865059, 0.16089209883728284], [0.8227594592755901, 0.4392656009800977, 0.5303094089805285, 0.4066730739019325, 0.2137956077108798, 0.3663711932959568, 0.764650790613495], [0.1277005123564695, 0.3429472670375593, 0.9732761887358456, 0.3363209787351582, 0.6755278358923644, 0.1628713488626954, 0.32302830002091265], [0.6597857209622927, 0.23633686558666167, 0.9034018509360223, 0.6704145557631249, 0.9891941350710622, 0.546310778554123, 0.6155111180456896]], B=[[0.41944479664849743, 0.05644533749747449, 0.10274780043922616, 0.06644707914799408, 0.982420730236563, 0.3119325045606314, 0.9263957315491643], [0.11105204273484603, 0.31048862219966955, 0.5750445635453594, 0.5713421071825573, 0.6111782810106269, 0.8691360596886083, 0.3054587851834546], [0.5467328498371717, 0.08482625746252814, 0.4320728324208104, 0.6664413168695057, 0.6870350715467404, 0.704549477174621, 0.6078686245981182], [0.35506531205835223, 0.2364992791979571, 0.6953773659220349, 0.35768365910355293, 0.6251555253753183, 0.08441244432965456, 0.6901841915851848], [0.48356309776826956, 0.35359477216240254, 0.6766443139462835, 0.7715753733479798, 0.05053194115551185, 0.9609707891061894, 0.6799975914783862], [0.8522695542212512, 0.5525945019123009, 0.40402435390277325, 0.4490368175034136, 0.6693793296572882, 0.9239243805691824, 0.5066724091266167]], eps=0.01):  # error tolerance\n    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n    A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "sols": [],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_0",
    "sat": "def sat(strategies: List[List[float]], A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_1",
    "sat": "def sat(strategies: List[List[float]], A=[[0.8965192169316094, 0.6149651085585971, 0.9591316892972456, 0.9762498563119051], [0.006269692912282854, 0.15807123400918655, 0.6492813041905258, 0.8130734460526896], [0.27159782417117906, 0.838108303626403, 0.2991097663060761, 0.5349817622814617], [0.04596091286979598, 0.7302567330527334, 0.005011780702214752, 0.8387834525246827], [0.1340587366621495, 0.2541775872682761, 0.28860819436246654, 0.8838039226835798]], eps=0.01):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.8965192169316094, 0.6149651085585971, 0.9591316892972456, 0.9762498563119051], [0.006269692912282854, 0.15807123400918655, 0.6492813041905258, 0.8130734460526896], [0.27159782417117906, 0.838108303626403, 0.2991097663060761, 0.5349817622814617], [0.04596091286979598, 0.7302567330527334, 0.005011780702214752, 0.8387834525246827], [0.1340587366621495, 0.2541775872682761, 0.28860819436246654, 0.8838039226835798]], eps=0.01):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_2",
    "sat": "def sat(strategies: List[List[float]], A=[[0.7132434574064977, 0.953388452793271], [0.7712760256482974, 0.2863920083264173], [0.6835333316077065, 0.03917343698875109], [0.904754194500498, 0.5738390848881585], [0.5841307783383004, 0.5267411624752001]], eps=0.1):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.7132434574064977, 0.953388452793271], [0.7712760256482974, 0.2863920083264173], [0.6835333316077065, 0.03917343698875109], [0.904754194500498, 0.5738390848881585], [0.5841307783383004, 0.5267411624752001]], eps=0.1):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_3",
    "sat": "def sat(strategies: List[List[float]], A=[[0.6095888640576287, 0.29022804061847507, 0.21590247390837258, 0.8475229468781795, 0.7458845887713007, 0.031885774264074906], [0.09247538569055969, 0.7860063726715327, 0.8009923512951856, 0.2945498417823289, 0.5532265045258861, 0.19960014098990753], [0.3724607848352569, 0.7196495828840703, 0.3547813131679516, 0.06262271075289194, 0.8461501884748531, 0.3950863171301038], [0.740635764729548, 0.6028041975170099, 0.27060017378755685, 0.600009569507228, 0.6548953451680408, 0.2716500279992188], [0.1772828107164207, 0.32808835785745727, 0.07521274102559217, 0.7632577652570776, 0.32210354785683304, 0.6701345603493679], [0.6158382507870118, 0.027299626110720676, 0.6311887055604789, 0.0810190739864094, 0.15715235264251348, 0.2968487378414]], eps=0.5):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.6095888640576287, 0.29022804061847507, 0.21590247390837258, 0.8475229468781795, 0.7458845887713007, 0.031885774264074906], [0.09247538569055969, 0.7860063726715327, 0.8009923512951856, 0.2945498417823289, 0.5532265045258861, 0.19960014098990753], [0.3724607848352569, 0.7196495828840703, 0.3547813131679516, 0.06262271075289194, 0.8461501884748531, 0.3950863171301038], [0.740635764729548, 0.6028041975170099, 0.27060017378755685, 0.600009569507228, 0.6548953451680408, 0.2716500279992188], [0.1772828107164207, 0.32808835785745727, 0.07521274102559217, 0.7632577652570776, 0.32210354785683304, 0.6701345603493679], [0.6158382507870118, 0.027299626110720676, 0.6311887055604789, 0.0810190739864094, 0.15715235264251348, 0.2968487378414]], eps=0.5):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_4",
    "sat": "def sat(strategies: List[List[float]], A=[[0.09767354834399611, 0.8554896294317268, 0.9276752986662848, 0.5295247941481526, 0.6752966473787784, 0.08799618512682794, 0.38905538110965243, 0.30632275033911316, 0.13429914241673513], [0.6238527207437002, 0.30012397180835326, 0.1309409036158795, 0.18432272971280772, 0.5391858730966589, 0.40149930885794927, 0.00935796970873104, 0.5282139909169075, 0.3688208764821217], [0.08355375312137658, 0.29406559790453946, 0.5037238254269701, 0.7632690482254268, 0.34777074707993094, 0.8514662206732494, 0.1509351879817653, 0.11715193149252268, 0.9909842386436386], [0.24637783314509365, 0.7374314816141829, 0.39367844926929807, 0.04067265850322088, 0.8509874649797038, 0.6051172871720885, 0.16698150309840543, 0.06658343393747324, 0.6762111193460623], [0.3872367537980079, 0.04533955962419989, 0.3628649802563424, 0.7300018749684144, 0.7295278351068317, 0.7283837597240896, 0.3927194641308148, 0.5477042352411865, 0.5622030428746169], [0.8223837833943712, 0.7645959838567685, 0.6610571618509056, 0.5904952119429836, 0.4680252031352631, 0.21961760695126675, 0.5548567809105489, 0.6799071917602524, 0.46020838872500236], [0.8928487373862994, 0.8798020120531774, 0.026660532252151037, 0.11023757199227502, 0.047732069731323046, 0.8424611996453204, 0.19823329035115544, 0.3531369515281184, 0.32352812675216436], [0.7017163136958606, 0.4018960263152458, 0.8207107513752155, 0.5973794639899603, 0.46556202090149423, 0.5012407202185755, 0.22005986848086034, 0.496309104538855, 0.5251038813609945], [0.5874279738197098, 0.5980389278342992, 0.03500862301028562, 0.19524665575653366, 0.3065603950596648, 0.9578338797173563, 0.5774448357520767, 0.8858642082748915, 0.8073185845898649]], eps=0.1):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.09767354834399611, 0.8554896294317268, 0.9276752986662848, 0.5295247941481526, 0.6752966473787784, 0.08799618512682794, 0.38905538110965243, 0.30632275033911316, 0.13429914241673513], [0.6238527207437002, 0.30012397180835326, 0.1309409036158795, 0.18432272971280772, 0.5391858730966589, 0.40149930885794927, 0.00935796970873104, 0.5282139909169075, 0.3688208764821217], [0.08355375312137658, 0.29406559790453946, 0.5037238254269701, 0.7632690482254268, 0.34777074707993094, 0.8514662206732494, 0.1509351879817653, 0.11715193149252268, 0.9909842386436386], [0.24637783314509365, 0.7374314816141829, 0.39367844926929807, 0.04067265850322088, 0.8509874649797038, 0.6051172871720885, 0.16698150309840543, 0.06658343393747324, 0.6762111193460623], [0.3872367537980079, 0.04533955962419989, 0.3628649802563424, 0.7300018749684144, 0.7295278351068317, 0.7283837597240896, 0.3927194641308148, 0.5477042352411865, 0.5622030428746169], [0.8223837833943712, 0.7645959838567685, 0.6610571618509056, 0.5904952119429836, 0.4680252031352631, 0.21961760695126675, 0.5548567809105489, 0.6799071917602524, 0.46020838872500236], [0.8928487373862994, 0.8798020120531774, 0.026660532252151037, 0.11023757199227502, 0.047732069731323046, 0.8424611996453204, 0.19823329035115544, 0.3531369515281184, 0.32352812675216436], [0.7017163136958606, 0.4018960263152458, 0.8207107513752155, 0.5973794639899603, 0.46556202090149423, 0.5012407202185755, 0.22005986848086034, 0.496309104538855, 0.5251038813609945], [0.5874279738197098, 0.5980389278342992, 0.03500862301028562, 0.19524665575653366, 0.3065603950596648, 0.9578338797173563, 0.5774448357520767, 0.8858642082748915, 0.8073185845898649]], eps=0.1):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_5",
    "sat": "def sat(strategies: List[List[float]], A=[[0.5153425970003502, 0.2349714064326256, 0.16599989337172305, 0.5116853530528619, 0.17940776676203096], [0.39909578962308234, 0.24365378150654937, 0.5191301711883458, 0.7525632735957777, 0.7787332804999644], [0.7585120235915664, 0.510902931833435, 0.7686739192282094, 0.5130421075034027, 0.422200597224766], [0.2701332116230677, 0.82180444689898, 0.5123941219979173, 0.988351161966126, 0.937221068730963], [0.9144293018824602, 0.3418175880383223, 0.7511954469094947, 0.21391387711531518, 0.8389892019039729], [0.24717892161577615, 0.40419520290155486, 0.03369741170785567, 0.19339435732858323, 0.4473478084201953]], eps=0.5):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.5153425970003502, 0.2349714064326256, 0.16599989337172305, 0.5116853530528619, 0.17940776676203096], [0.39909578962308234, 0.24365378150654937, 0.5191301711883458, 0.7525632735957777, 0.7787332804999644], [0.7585120235915664, 0.510902931833435, 0.7686739192282094, 0.5130421075034027, 0.422200597224766], [0.2701332116230677, 0.82180444689898, 0.5123941219979173, 0.988351161966126, 0.937221068730963], [0.9144293018824602, 0.3418175880383223, 0.7511954469094947, 0.21391387711531518, 0.8389892019039729], [0.24717892161577615, 0.40419520290155486, 0.03369741170785567, 0.19339435732858323, 0.4473478084201953]], eps=0.5):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_6",
    "sat": "def sat(strategies: List[List[float]], A=[[0.94367417936229, 0.8162103067633563, 0.4252975532003205, 0.013501071819604027, 0.7466534683532189, 0.8866713102821682], [0.7544573217806646, 0.16575088823932727, 0.6305756215049262, 0.601964199558915, 0.30053133181806946, 0.466008819859117], [0.326145063692729, 0.19156768988872763, 0.07241131070975959, 0.5260930092059202, 0.11176073025169952, 0.12019815132575218], [0.38440636179670573, 0.774049900630539, 0.011436087626236824, 0.7297990235988828, 0.37425665456448154, 0.23148396790117076], [0.8827000146636579, 0.3083434292742232, 0.16253017248719104, 0.4490725081165845, 0.09531427002435611, 0.7553916762446392], [0.3358168269596872, 0.3978990410400788, 0.5044580565568163, 0.7608207934716755, 0.0396764792463713, 0.3587082004415647], [0.27240653138271664, 0.14574715965506357, 0.6232013986834886, 0.4851583888033061, 0.8036970920581198, 0.6392226399108549], [0.3834252336449865, 0.3149185999507851, 0.7894403205339072, 0.9596851289106552, 0.9218997713293329, 0.8680285659474297]], eps=0.01):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.94367417936229, 0.8162103067633563, 0.4252975532003205, 0.013501071819604027, 0.7466534683532189, 0.8866713102821682], [0.7544573217806646, 0.16575088823932727, 0.6305756215049262, 0.601964199558915, 0.30053133181806946, 0.466008819859117], [0.326145063692729, 0.19156768988872763, 0.07241131070975959, 0.5260930092059202, 0.11176073025169952, 0.12019815132575218], [0.38440636179670573, 0.774049900630539, 0.011436087626236824, 0.7297990235988828, 0.37425665456448154, 0.23148396790117076], [0.8827000146636579, 0.3083434292742232, 0.16253017248719104, 0.4490725081165845, 0.09531427002435611, 0.7553916762446392], [0.3358168269596872, 0.3978990410400788, 0.5044580565568163, 0.7608207934716755, 0.0396764792463713, 0.3587082004415647], [0.27240653138271664, 0.14574715965506357, 0.6232013986834886, 0.4851583888033061, 0.8036970920581198, 0.6392226399108549], [0.3834252336449865, 0.3149185999507851, 0.7894403205339072, 0.9596851289106552, 0.9218997713293329, 0.8680285659474297]], eps=0.01):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_7",
    "sat": "def sat(strategies: List[List[float]], A=[[0.6067978095703914, 0.5416527600302137, 0.20484202542292584, 0.06490973144386758], [0.7037233889749165, 0.07317753292045781, 0.3367511317151627, 0.533099019434172], [0.8342402096444618, 0.45481474260227184, 0.01877106470262213, 0.6725323781011926]], eps=0.5):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.6067978095703914, 0.5416527600302137, 0.20484202542292584, 0.06490973144386758], [0.7037233889749165, 0.07317753292045781, 0.3367511317151627, 0.533099019434172], [0.8342402096444618, 0.45481474260227184, 0.01877106470262213, 0.6725323781011926]], eps=0.5):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_8",
    "sat": "def sat(strategies: List[List[float]], A=[[0.5246088783570769, 0.040535594474037095, 0.6231539989543265, 0.9209790281572046, 0.49463887557284714, 0.6906107677339214], [0.06758653688929472, 0.4475104178474588, 0.038609129448381796, 0.7881999808669713, 0.6075505500888911, 0.06212150013659756], [0.2726182421106519, 0.6831685152042557, 0.033068041680726745, 0.932329932622509, 0.18686252132141445, 0.18244200169102365], [0.7796162478164239, 0.09760059132952115, 0.4452006280295161, 0.35963408606616776, 0.525355761728597, 0.9415992938723561], [0.30821282652890136, 0.7251023218640262, 0.6000030536640607, 0.4868745373436031, 0.2757229108839917, 0.8131733246492889], [0.3844265918980936, 0.8006995024833593, 0.47636318907626163, 0.496744086226778, 0.05740047645380986, 0.77163098726727], [0.6753717498346644, 0.34417495553856636, 0.675576872046044, 0.7002280484057912, 0.8630218683970656, 0.19751719995742922]], eps=0.1):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.5246088783570769, 0.040535594474037095, 0.6231539989543265, 0.9209790281572046, 0.49463887557284714, 0.6906107677339214], [0.06758653688929472, 0.4475104178474588, 0.038609129448381796, 0.7881999808669713, 0.6075505500888911, 0.06212150013659756], [0.2726182421106519, 0.6831685152042557, 0.033068041680726745, 0.932329932622509, 0.18686252132141445, 0.18244200169102365], [0.7796162478164239, 0.09760059132952115, 0.4452006280295161, 0.35963408606616776, 0.525355761728597, 0.9415992938723561], [0.30821282652890136, 0.7251023218640262, 0.6000030536640607, 0.4868745373436031, 0.2757229108839917, 0.8131733246492889], [0.3844265918980936, 0.8006995024833593, 0.47636318907626163, 0.496744086226778, 0.05740047645380986, 0.77163098726727], [0.6753717498346644, 0.34417495553856636, 0.675576872046044, 0.7002280484057912, 0.8630218683970656, 0.19751719995742922]], eps=0.1):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "ZeroSum_9",
    "sat": "def sat(strategies: List[List[float]], A=[[0.8762716593538137, 0.638156100031706, 0.02825806941970954, 0.28812355710239324], [0.28697053116253923, 0.4902046651793279, 0.4600386796513256, 0.1352414774004761], [0.167397327646863, 0.25735821722401886, 0.7804342067933655, 0.030339823771774355], [0.42038876867569286, 0.3267747474924706, 0.7223629667134825, 0.2582107438302348]], eps=0.01):\n    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "sols": [
      "def sol(A=[[0.8762716593538137, 0.638156100031706, 0.02825806941970954, 0.28812355710239324], [0.28697053116253923, 0.4902046651793279, 0.4600386796513256, 0.1352414774004761], [0.167397327646863, 0.25735821722401886, 0.7804342067933655, 0.030339823771774355], [0.42038876867569286, 0.3267747474924706, 0.7223629667134825, 0.2582107438302348]], eps=0.01):\n    MAX_ITER = 10**4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "game_theory"
  },
  {
    "name": "Conway99_0",
    "sat": "def sat(edges: List[List[int]]):\n    \"\"\"\n    Find an undirected graph with 99 vertices, in which each two adjacent vertices have exactly one common\n    neighbor, and in which each two non-adjacent vertices have exactly two common neighbors.\n    \"\"\"\n    # first compute neighbors sets, N:\n    N = {i: {j for j in range(99) if j != i and ([i, j] in edges or [j, i] in edges)} for i in range(99)}\n    return all(len(N[i].intersection(N[j])) == (1 if j in N[i] else 2) for i in range(99) for j in range(i))",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_0",
    "sat": "def sat(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_1",
    "sat": "def sat(e: List[int], edges=[[6, 19], [67, 34], [91, 29], [37, 15], [39, 0], [10, 9], [17, 41], [60, 20], [54, 86], [17, 94], [3, 73], [16, 74], [0, 78], [25, 82], [47, 61], [44, 83], [50, 24], [27, 15], [51, 40], [59, 11], [54, 93], [32, 74], [21, 34], [47, 95], [56, 90], [72, 54], [55, 1], [22, 3], [41, 63], [18, 36], [83, 85], [45, 68], [76, 55], [70, 24], [11, 31], [30, 29], [73, 82], [68, 68], [90, 91], [31, 61], [33, 71], [71, 34], [11, 63], [10, 94], [54, 14], [71, 0], [73, 62], [68, 23], [91, 33], [30, 60], [74, 2], [90, 8], [49, 8], [83, 46], [8, 3], [60, 61], [12, 76], [19, 16], [47, 93], [25, 30], [2, 67], [80, 66], [32, 54], [55, 85], [29, 92], [6, 17], [59, 52], [11, 88], [56, 39], [31, 70], [66, 46], [85, 92], [58, 22], [61, 46], [80, 16], [64, 37], [16, 0], [17, 27], [57, 91], [58, 48], [15, 22], [25, 51], [91, 28], [56, 7], [69, 14], [56, 82], [80, 28], [10, 87], [94, 72], [41, 71], [51, 10], [7, 30], [4, 49], [91, 32], [35, 95], [30, 76], [8, 12], [22, 36], [77, 55], [28, 92], [36, 42], [70, 76], [95, 38], [90, 68], [72, 50], [70, 0], [80, 4], [64, 4], [37, 12], [23, 78], [67, 88], [63, 25], [76, 50], [23, 22], [29, 86], [60, 82], [23, 5], [8, 77], [54, 75], [2, 26], [40, 30], [32, 46], [0, 86], [25, 23], [37, 70], [64, 14], [32, 71], [26, 65], [83, 90], [91, 69], [27, 25], [94, 54], [59, 76], [91, 3], [37, 47], [63, 30], [16, 64], [46, 10], [8, 59], [90, 42], [31, 12], [93, 13], [74, 78], [43, 93], [15, 20], [30, 80], [19, 95], [31, 40], [14, 42], [67, 21], [18, 77], [59, 89], [18, 49], [4, 9], [94, 26], [75, 51], [10, 49], [11, 87], [44, 39], [31, 23], [69, 80], [29, 78], [8, 37], [77, 45], [90, 67], [26, 54], [75, 84], [21, 43], [50, 26], [64, 58], [63, 34], [73, 30], [78, 66], [59, 81], [45, 29], [22, 47], [71, 46], [35, 8], [85, 63], [24, 85], [70, 69], [80, 47], [76, 16], [93, 34], [50, 66], [84, 51], [4, 35], [44, 59], [56, 24], [68, 36], [10, 21], [95, 80], [14, 80], [77, 39], [86, 15], [54, 56], [84, 81], [7, 24], [7, 27], [68, 74], [63, 51], [49, 46], [95, 0], [80, 27], [54, 34], [94, 73], [72, 48], [24, 78], [91, 58], [49, 74], [84, 16], [49, 84], [12, 22], [45, 94], [76, 41], [6, 85], [77, 5], [46, 42], [94, 41], [56, 54], [69, 94], [76, 92], [57, 79], [94, 85], [48, 64], [85, 71], [69, 33], [21, 14], [30, 88], [85, 33], [34, 61], [67, 29], [62, 71], [15, 85], [35, 66], [46, 32], [4, 56], [80, 88], [67, 60], [25, 71], [32, 84], [25, 37], [89, 74], [77, 41], [67, 89], [55, 5], [5, 24], [85, 68], [26, 91], [84, 58], [77, 29], [31, 25], [48, 18], [53, 77], [1, 79], [86, 57], [10, 16], [4, 89], [67, 69], [44, 37], [16, 9], [53, 21], [60, 90], [64, 46], [27, 12], [76, 54], [80, 91], [88, 47], [36, 45], [23, 7], [91, 45], [34, 12], [57, 22], [23, 9], [69, 60], [33, 16], [36, 27], [57, 94], [3, 93], [53, 79], [40, 59], [52, 28], [49, 43], [43, 31], [91, 78], [65, 50], [33, 21], [27, 79], [87, 27], [74, 83], [51, 8], [44, 35], [20, 63], [74, 55], [26, 61], [42, 66], [75, 8], [4, 69], [52, 43], [16, 92], [95, 71], [67, 53], [12, 6], [85, 29], [39, 95], [94, 75], [46, 93], [6, 13], [4, 15], [67, 23], [82, 95], [76, 31], [6, 26], [81, 26], [41, 14], [26, 72], [71, 47], [72, 0], [9, 58], [16, 53], [21, 12], [31, 28], [90, 41], [12, 70], [73, 60], [28, 27], [80, 23], [95, 81], [91, 24], [83, 14], [25, 58], [63, 81], [62, 86], [58, 75], [56, 66], [0, 12], [45, 79], [59, 45], [45, 59], [6, 27], [7, 7], [1, 82], [61, 2], [61, 52], [23, 14], [70, 79], [85, 39], [12, 89], [40, 38], [93, 1], [22, 28], [5, 68], [20, 59], [68, 56], [3, 68], [11, 69], [78, 13], [88, 64], [14, 55], [6, 54], [80, 37], [27, 32], [62, 84], [81, 50], [72, 44], [64, 88], [50, 83], [13, 63], [53, 40], [38, 21], [91, 18], [3, 60], [43, 14], [93, 67], [78, 65], [33, 35], [46, 83], [67, 91], [75, 28], [19, 53], [91, 15], [76, 7], [42, 76], [24, 37], [3, 89], [95, 44], [69, 15], [46, 84], [59, 59], [44, 79], [88, 36], [5, 52], [58, 85], [41, 67], [51, 55], [55, 4], [24, 40], [65, 24], [93, 14], [12, 39], [2, 89], [10, 38], [30, 59], [17, 79], [12, 77], [5, 81], [26, 34], [49, 22], [86, 36], [95, 26], [8, 10], [20, 38], [0, 70], [28, 64], [9, 3], [28, 53], [85, 54], [16, 19], [13, 4], [77, 21], [69, 42], [43, 34], [44, 0], [43, 89], [51, 23], [45, 83], [46, 24], [74, 40], [40, 83], [20, 39], [17, 1], [28, 36], [60, 41], [45, 87], [35, 87], [63, 75], [17, 93], [6, 68], [52, 34], [12, 65], [19, 36], [44, 62], [93, 90], [53, 10], [47, 5], [18, 39], [38, 46], [32, 47], [5, 66], [52, 81], [66, 18], [35, 53], [66, 92], [46, 85], [23, 83], [74, 80], [11, 55], [71, 38], [47, 32], [8, 51], [45, 90], [84, 75], [68, 58], [18, 71], [26, 57], [78, 6], [69, 71], [67, 70], [55, 72], [78, 3], [95, 78], [35, 70], [18, 12], [94, 7], [15, 6], [56, 84], [28, 41], [15, 33], [0, 66], [8, 85], [95, 40], [38, 82], [75, 36], [50, 91], [2, 40], [3, 56]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[6, 19], [67, 34], [91, 29], [37, 15], [39, 0], [10, 9], [17, 41], [60, 20], [54, 86], [17, 94], [3, 73], [16, 74], [0, 78], [25, 82], [47, 61], [44, 83], [50, 24], [27, 15], [51, 40], [59, 11], [54, 93], [32, 74], [21, 34], [47, 95], [56, 90], [72, 54], [55, 1], [22, 3], [41, 63], [18, 36], [83, 85], [45, 68], [76, 55], [70, 24], [11, 31], [30, 29], [73, 82], [68, 68], [90, 91], [31, 61], [33, 71], [71, 34], [11, 63], [10, 94], [54, 14], [71, 0], [73, 62], [68, 23], [91, 33], [30, 60], [74, 2], [90, 8], [49, 8], [83, 46], [8, 3], [60, 61], [12, 76], [19, 16], [47, 93], [25, 30], [2, 67], [80, 66], [32, 54], [55, 85], [29, 92], [6, 17], [59, 52], [11, 88], [56, 39], [31, 70], [66, 46], [85, 92], [58, 22], [61, 46], [80, 16], [64, 37], [16, 0], [17, 27], [57, 91], [58, 48], [15, 22], [25, 51], [91, 28], [56, 7], [69, 14], [56, 82], [80, 28], [10, 87], [94, 72], [41, 71], [51, 10], [7, 30], [4, 49], [91, 32], [35, 95], [30, 76], [8, 12], [22, 36], [77, 55], [28, 92], [36, 42], [70, 76], [95, 38], [90, 68], [72, 50], [70, 0], [80, 4], [64, 4], [37, 12], [23, 78], [67, 88], [63, 25], [76, 50], [23, 22], [29, 86], [60, 82], [23, 5], [8, 77], [54, 75], [2, 26], [40, 30], [32, 46], [0, 86], [25, 23], [37, 70], [64, 14], [32, 71], [26, 65], [83, 90], [91, 69], [27, 25], [94, 54], [59, 76], [91, 3], [37, 47], [63, 30], [16, 64], [46, 10], [8, 59], [90, 42], [31, 12], [93, 13], [74, 78], [43, 93], [15, 20], [30, 80], [19, 95], [31, 40], [14, 42], [67, 21], [18, 77], [59, 89], [18, 49], [4, 9], [94, 26], [75, 51], [10, 49], [11, 87], [44, 39], [31, 23], [69, 80], [29, 78], [8, 37], [77, 45], [90, 67], [26, 54], [75, 84], [21, 43], [50, 26], [64, 58], [63, 34], [73, 30], [78, 66], [59, 81], [45, 29], [22, 47], [71, 46], [35, 8], [85, 63], [24, 85], [70, 69], [80, 47], [76, 16], [93, 34], [50, 66], [84, 51], [4, 35], [44, 59], [56, 24], [68, 36], [10, 21], [95, 80], [14, 80], [77, 39], [86, 15], [54, 56], [84, 81], [7, 24], [7, 27], [68, 74], [63, 51], [49, 46], [95, 0], [80, 27], [54, 34], [94, 73], [72, 48], [24, 78], [91, 58], [49, 74], [84, 16], [49, 84], [12, 22], [45, 94], [76, 41], [6, 85], [77, 5], [46, 42], [94, 41], [56, 54], [69, 94], [76, 92], [57, 79], [94, 85], [48, 64], [85, 71], [69, 33], [21, 14], [30, 88], [85, 33], [34, 61], [67, 29], [62, 71], [15, 85], [35, 66], [46, 32], [4, 56], [80, 88], [67, 60], [25, 71], [32, 84], [25, 37], [89, 74], [77, 41], [67, 89], [55, 5], [5, 24], [85, 68], [26, 91], [84, 58], [77, 29], [31, 25], [48, 18], [53, 77], [1, 79], [86, 57], [10, 16], [4, 89], [67, 69], [44, 37], [16, 9], [53, 21], [60, 90], [64, 46], [27, 12], [76, 54], [80, 91], [88, 47], [36, 45], [23, 7], [91, 45], [34, 12], [57, 22], [23, 9], [69, 60], [33, 16], [36, 27], [57, 94], [3, 93], [53, 79], [40, 59], [52, 28], [49, 43], [43, 31], [91, 78], [65, 50], [33, 21], [27, 79], [87, 27], [74, 83], [51, 8], [44, 35], [20, 63], [74, 55], [26, 61], [42, 66], [75, 8], [4, 69], [52, 43], [16, 92], [95, 71], [67, 53], [12, 6], [85, 29], [39, 95], [94, 75], [46, 93], [6, 13], [4, 15], [67, 23], [82, 95], [76, 31], [6, 26], [81, 26], [41, 14], [26, 72], [71, 47], [72, 0], [9, 58], [16, 53], [21, 12], [31, 28], [90, 41], [12, 70], [73, 60], [28, 27], [80, 23], [95, 81], [91, 24], [83, 14], [25, 58], [63, 81], [62, 86], [58, 75], [56, 66], [0, 12], [45, 79], [59, 45], [45, 59], [6, 27], [7, 7], [1, 82], [61, 2], [61, 52], [23, 14], [70, 79], [85, 39], [12, 89], [40, 38], [93, 1], [22, 28], [5, 68], [20, 59], [68, 56], [3, 68], [11, 69], [78, 13], [88, 64], [14, 55], [6, 54], [80, 37], [27, 32], [62, 84], [81, 50], [72, 44], [64, 88], [50, 83], [13, 63], [53, 40], [38, 21], [91, 18], [3, 60], [43, 14], [93, 67], [78, 65], [33, 35], [46, 83], [67, 91], [75, 28], [19, 53], [91, 15], [76, 7], [42, 76], [24, 37], [3, 89], [95, 44], [69, 15], [46, 84], [59, 59], [44, 79], [88, 36], [5, 52], [58, 85], [41, 67], [51, 55], [55, 4], [24, 40], [65, 24], [93, 14], [12, 39], [2, 89], [10, 38], [30, 59], [17, 79], [12, 77], [5, 81], [26, 34], [49, 22], [86, 36], [95, 26], [8, 10], [20, 38], [0, 70], [28, 64], [9, 3], [28, 53], [85, 54], [16, 19], [13, 4], [77, 21], [69, 42], [43, 34], [44, 0], [43, 89], [51, 23], [45, 83], [46, 24], [74, 40], [40, 83], [20, 39], [17, 1], [28, 36], [60, 41], [45, 87], [35, 87], [63, 75], [17, 93], [6, 68], [52, 34], [12, 65], [19, 36], [44, 62], [93, 90], [53, 10], [47, 5], [18, 39], [38, 46], [32, 47], [5, 66], [52, 81], [66, 18], [35, 53], [66, 92], [46, 85], [23, 83], [74, 80], [11, 55], [71, 38], [47, 32], [8, 51], [45, 90], [84, 75], [68, 58], [18, 71], [26, 57], [78, 6], [69, 71], [67, 70], [55, 72], [78, 3], [95, 78], [35, 70], [18, 12], [94, 7], [15, 6], [56, 84], [28, 41], [15, 33], [0, 66], [8, 85], [95, 40], [38, 82], [75, 36], [50, 91], [2, 40], [3, 56]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_2",
    "sat": "def sat(e: List[int], edges=[[4, 10], [8, 4], [1, 0], [3, 2], [4, 1], [11, 5], [10, 3], [8, 2], [5, 2], [10, 12], [7, 5], [14, 5], [14, 15], [3, 4], [13, 10], [15, 12], [3, 13], [13, 14], [12, 10], [4, 4], [11, 11], [0, 4], [13, 13], [8, 1], [15, 8], [12, 0], [13, 2], [1, 7], [5, 7], [7, 4], [11, 9], [7, 1], [0, 0], [6, 5], [14, 6], [7, 9], [6, 7], [15, 1], [7, 7], [1, 14], [2, 11], [10, 0], [14, 7], [7, 8], [14, 12], [4, 2], [7, 10], [8, 9], [14, 14], [12, 1], [5, 1]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[4, 10], [8, 4], [1, 0], [3, 2], [4, 1], [11, 5], [10, 3], [8, 2], [5, 2], [10, 12], [7, 5], [14, 5], [14, 15], [3, 4], [13, 10], [15, 12], [3, 13], [13, 14], [12, 10], [4, 4], [11, 11], [0, 4], [13, 13], [8, 1], [15, 8], [12, 0], [13, 2], [1, 7], [5, 7], [7, 4], [11, 9], [7, 1], [0, 0], [6, 5], [14, 6], [7, 9], [6, 7], [15, 1], [7, 7], [1, 14], [2, 11], [10, 0], [14, 7], [7, 8], [14, 12], [4, 2], [7, 10], [8, 9], [14, 14], [12, 1], [5, 1]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_3",
    "sat": "def sat(e: List[int], edges=[[1, 2], [0, 1], [2, 3], [2, 2], [0, 0], [1, 1]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[1, 2], [0, 1], [2, 3], [2, 2], [0, 0], [1, 1]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_4",
    "sat": "def sat(e: List[int], edges=[[1, 0], [0, 1], [1, 1]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[1, 0], [0, 1], [1, 1]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_5",
    "sat": "def sat(e: List[int], edges=[[0, 2]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[0, 2]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_6",
    "sat": "def sat(e: List[int], edges=[[20, 40], [38, 21], [30, 33], [2, 43], [39, 19], [30, 23], [3, 46], [32, 22], [22, 17], [30, 43], [2, 0], [8, 9], [14, 28], [41, 2], [26, 17], [0, 6], [14, 17], [5, 11], [32, 14], [4, 33], [14, 23], [15, 14], [41, 36], [0, 34], [29, 1], [3, 40], [14, 8], [17, 17], [44, 32], [33, 5], [39, 15], [11, 46], [36, 2], [1, 46], [20, 10], [42, 40], [5, 34], [32, 18], [16, 18], [44, 21], [36, 16], [37, 22], [4, 46], [13, 27], [6, 11], [1, 20], [40, 32], [16, 16], [17, 15], [28, 38], [39, 24], [38, 20], [10, 9], [8, 19], [40, 41], [23, 41], [12, 15], [45, 8], [27, 15], [20, 36], [1, 32], [22, 15], [24, 15], [24, 43], [0, 31], [41, 20], [17, 11], [5, 1], [34, 17], [4, 2], [24, 10], [7, 20], [20, 15], [33, 35], [42, 38], [1, 8], [15, 12], [44, 23], [46, 29], [36, 21], [25, 2], [22, 45], [19, 18], [2, 41], [26, 19], [43, 21], [4, 5], [7, 28], [45, 15], [27, 16], [19, 40], [10, 19], [37, 2], [26, 6], [15, 23], [26, 23], [21, 30], [14, 16], [19, 25], [12, 44], [16, 40], [43, 16], [32, 16], [22, 8], [20, 29], [19, 10], [35, 20], [29, 10], [28, 24], [32, 11], [43, 29], [23, 40], [3, 37], [34, 33], [9, 3], [36, 44], [34, 23], [21, 27], [8, 29], [11, 17], [41, 25], [31, 28], [34, 19], [16, 7], [44, 44], [44, 42], [12, 0], [11, 19], [5, 31], [6, 43], [15, 44], [8, 16], [30, 8], [35, 15], [46, 34], [44, 17], [34, 7], [17, 33], [44, 25], [41, 17], [35, 37], [4, 3], [9, 1], [1, 22], [28, 34], [16, 43], [34, 0], [2, 42], [44, 14], [23, 43], [8, 43], [29, 29], [15, 20], [46, 25], [40, 44], [42, 25], [42, 29], [27, 11], [23, 1], [46, 26], [2, 21], [39, 32], [19, 46], [0, 12], [20, 0], [5, 45], [16, 23], [23, 3], [31, 18], [7, 43], [21, 10], [29, 21], [11, 12], [19, 8], [12, 35], [42, 15], [24, 13], [17, 19], [1, 39], [30, 31], [28, 5], [20, 45], [13, 26], [38, 17], [6, 42], [45, 18], [4, 27], [5, 38], [8, 5], [31, 0], [17, 36], [12, 30], [9, 16], [29, 18], [32, 30], [46, 13], [11, 39], [33, 30], [20, 42], [3, 0], [28, 14], [0, 25], [12, 10], [43, 44], [43, 7], [27, 5], [45, 6], [2, 7], [16, 21], [43, 13], [12, 46], [41, 29], [10, 17], [30, 1], [46, 9], [40, 1], [23, 16], [11, 35], [5, 18], [46, 23], [7, 29], [46, 3], [10, 2], [15, 13], [28, 39], [37, 44], [5, 23], [22, 23], [24, 11], [5, 17], [33, 37], [10, 8], [23, 29], [2, 27], [32, 46], [43, 43], [40, 7], [23, 34], [30, 45], [26, 45], [36, 24], [30, 3], [35, 36], [25, 22], [25, 41], [21, 0], [14, 40], [29, 12], [6, 1], [36, 37], [46, 44], [0, 19], [16, 19], [41, 28], [32, 36], [36, 22], [0, 27], [25, 44], [13, 32], [29, 17], [29, 24], [20, 43], [31, 19], [44, 19], [2, 4], [32, 13], [13, 0], [42, 19], [43, 45], [8, 44], [17, 40], [1, 44], [43, 3], [28, 26], [33, 24], [0, 45], [9, 9], [45, 22], [19, 33], [6, 41], [10, 33], [7, 19], [30, 40], [27, 8], [39, 40], [31, 13], [45, 7], [23, 32], [18, 5], [20, 2], [28, 45]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[20, 40], [38, 21], [30, 33], [2, 43], [39, 19], [30, 23], [3, 46], [32, 22], [22, 17], [30, 43], [2, 0], [8, 9], [14, 28], [41, 2], [26, 17], [0, 6], [14, 17], [5, 11], [32, 14], [4, 33], [14, 23], [15, 14], [41, 36], [0, 34], [29, 1], [3, 40], [14, 8], [17, 17], [44, 32], [33, 5], [39, 15], [11, 46], [36, 2], [1, 46], [20, 10], [42, 40], [5, 34], [32, 18], [16, 18], [44, 21], [36, 16], [37, 22], [4, 46], [13, 27], [6, 11], [1, 20], [40, 32], [16, 16], [17, 15], [28, 38], [39, 24], [38, 20], [10, 9], [8, 19], [40, 41], [23, 41], [12, 15], [45, 8], [27, 15], [20, 36], [1, 32], [22, 15], [24, 15], [24, 43], [0, 31], [41, 20], [17, 11], [5, 1], [34, 17], [4, 2], [24, 10], [7, 20], [20, 15], [33, 35], [42, 38], [1, 8], [15, 12], [44, 23], [46, 29], [36, 21], [25, 2], [22, 45], [19, 18], [2, 41], [26, 19], [43, 21], [4, 5], [7, 28], [45, 15], [27, 16], [19, 40], [10, 19], [37, 2], [26, 6], [15, 23], [26, 23], [21, 30], [14, 16], [19, 25], [12, 44], [16, 40], [43, 16], [32, 16], [22, 8], [20, 29], [19, 10], [35, 20], [29, 10], [28, 24], [32, 11], [43, 29], [23, 40], [3, 37], [34, 33], [9, 3], [36, 44], [34, 23], [21, 27], [8, 29], [11, 17], [41, 25], [31, 28], [34, 19], [16, 7], [44, 44], [44, 42], [12, 0], [11, 19], [5, 31], [6, 43], [15, 44], [8, 16], [30, 8], [35, 15], [46, 34], [44, 17], [34, 7], [17, 33], [44, 25], [41, 17], [35, 37], [4, 3], [9, 1], [1, 22], [28, 34], [16, 43], [34, 0], [2, 42], [44, 14], [23, 43], [8, 43], [29, 29], [15, 20], [46, 25], [40, 44], [42, 25], [42, 29], [27, 11], [23, 1], [46, 26], [2, 21], [39, 32], [19, 46], [0, 12], [20, 0], [5, 45], [16, 23], [23, 3], [31, 18], [7, 43], [21, 10], [29, 21], [11, 12], [19, 8], [12, 35], [42, 15], [24, 13], [17, 19], [1, 39], [30, 31], [28, 5], [20, 45], [13, 26], [38, 17], [6, 42], [45, 18], [4, 27], [5, 38], [8, 5], [31, 0], [17, 36], [12, 30], [9, 16], [29, 18], [32, 30], [46, 13], [11, 39], [33, 30], [20, 42], [3, 0], [28, 14], [0, 25], [12, 10], [43, 44], [43, 7], [27, 5], [45, 6], [2, 7], [16, 21], [43, 13], [12, 46], [41, 29], [10, 17], [30, 1], [46, 9], [40, 1], [23, 16], [11, 35], [5, 18], [46, 23], [7, 29], [46, 3], [10, 2], [15, 13], [28, 39], [37, 44], [5, 23], [22, 23], [24, 11], [5, 17], [33, 37], [10, 8], [23, 29], [2, 27], [32, 46], [43, 43], [40, 7], [23, 34], [30, 45], [26, 45], [36, 24], [30, 3], [35, 36], [25, 22], [25, 41], [21, 0], [14, 40], [29, 12], [6, 1], [36, 37], [46, 44], [0, 19], [16, 19], [41, 28], [32, 36], [36, 22], [0, 27], [25, 44], [13, 32], [29, 17], [29, 24], [20, 43], [31, 19], [44, 19], [2, 4], [32, 13], [13, 0], [42, 19], [43, 45], [8, 44], [17, 40], [1, 44], [43, 3], [28, 26], [33, 24], [0, 45], [9, 9], [45, 22], [19, 33], [6, 41], [10, 33], [7, 19], [30, 40], [27, 8], [39, 40], [31, 13], [45, 7], [23, 32], [18, 5], [20, 2], [28, 45]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_7",
    "sat": "def sat(e: List[int], edges=[[0, 27], [27, 29], [4, 24], [5, 26], [11, 26], [25, 12], [7, 7], [3, 21], [23, 31], [27, 22], [12, 27], [30, 14], [31, 4], [12, 25], [17, 23], [15, 8], [8, 18], [0, 3], [0, 19], [10, 2], [16, 4], [13, 13], [1, 6], [7, 18], [12, 21], [21, 6], [22, 30], [22, 25], [27, 20], [23, 1], [2, 13], [25, 10], [10, 30], [17, 1], [18, 19], [29, 13], [31, 14], [0, 4], [12, 3], [13, 25], [11, 25], [31, 20], [9, 6], [14, 24], [14, 5], [8, 1], [8, 14], [20, 11], [12, 22], [25, 29], [15, 23], [16, 31], [3, 7], [4, 5], [9, 24], [9, 15], [29, 3], [7, 9], [15, 4], [30, 17], [11, 17], [28, 25], [7, 19], [6, 30], [4, 17], [14, 31], [30, 13], [14, 26], [1, 7], [0, 17], [6, 4], [19, 6], [9, 18], [9, 9], [23, 15], [20, 6], [22, 6], [29, 15], [3, 30], [16, 26], [3, 20], [8, 25], [24, 27], [14, 21], [4, 26], [12, 14], [6, 2], [1, 20], [21, 15], [15, 25], [11, 9], [1, 22], [7, 14], [5, 4], [3, 24], [14, 17], [25, 11], [31, 27], [20, 23], [30, 3], [4, 22], [21, 11], [3, 12], [0, 5], [29, 4], [5, 13], [15, 12], [14, 10], [2, 17], [16, 25], [7, 24], [17, 25], [23, 10], [10, 29], [25, 8], [22, 24], [15, 29], [5, 2], [1, 8], [23, 19], [20, 30], [24, 10], [10, 28], [7, 8], [21, 9], [8, 27], [14, 18], [17, 22], [7, 28], [29, 1], [4, 11], [10, 19], [8, 19], [29, 31], [24, 19], [27, 1], [2, 24], [2, 30], [5, 11], [22, 17], [25, 2], [5, 20], [15, 10], [27, 30], [27, 10], [13, 4], [15, 5], [0, 15], [26, 1], [3, 26], [18, 2], [6, 27], [10, 31], [14, 15], [27, 12], [26, 6], [10, 16], [25, 9], [3, 19], [28, 0], [9, 25], [3, 0], [1, 9], [10, 26], [6, 23], [4, 6], [21, 2], [21, 17], [31, 5], [27, 2], [0, 25], [15, 15], [11, 4], [12, 20], [11, 29], [19, 25], [22, 2], [5, 18], [6, 12], [28, 17], [25, 22], [31, 19], [12, 18], [28, 2], [7, 4], [9, 17], [0, 9], [13, 27], [24, 6], [17, 13], [12, 28], [20, 10], [26, 16], [4, 2], [9, 3], [0, 22], [5, 30], [26, 10], [16, 18], [23, 8], [24, 1], [21, 3], [8, 13], [14, 9], [19, 21], [28, 7], [12, 5], [0, 28], [19, 24], [0, 31], [8, 26], [21, 10], [18, 30], [5, 25], [19, 23], [7, 30], [23, 28], [3, 14], [9, 13], [9, 20], [14, 1], [26, 18], [16, 9], [24, 16], [27, 19], [14, 20], [11, 2], [13, 11], [29, 30], [11, 3]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[0, 27], [27, 29], [4, 24], [5, 26], [11, 26], [25, 12], [7, 7], [3, 21], [23, 31], [27, 22], [12, 27], [30, 14], [31, 4], [12, 25], [17, 23], [15, 8], [8, 18], [0, 3], [0, 19], [10, 2], [16, 4], [13, 13], [1, 6], [7, 18], [12, 21], [21, 6], [22, 30], [22, 25], [27, 20], [23, 1], [2, 13], [25, 10], [10, 30], [17, 1], [18, 19], [29, 13], [31, 14], [0, 4], [12, 3], [13, 25], [11, 25], [31, 20], [9, 6], [14, 24], [14, 5], [8, 1], [8, 14], [20, 11], [12, 22], [25, 29], [15, 23], [16, 31], [3, 7], [4, 5], [9, 24], [9, 15], [29, 3], [7, 9], [15, 4], [30, 17], [11, 17], [28, 25], [7, 19], [6, 30], [4, 17], [14, 31], [30, 13], [14, 26], [1, 7], [0, 17], [6, 4], [19, 6], [9, 18], [9, 9], [23, 15], [20, 6], [22, 6], [29, 15], [3, 30], [16, 26], [3, 20], [8, 25], [24, 27], [14, 21], [4, 26], [12, 14], [6, 2], [1, 20], [21, 15], [15, 25], [11, 9], [1, 22], [7, 14], [5, 4], [3, 24], [14, 17], [25, 11], [31, 27], [20, 23], [30, 3], [4, 22], [21, 11], [3, 12], [0, 5], [29, 4], [5, 13], [15, 12], [14, 10], [2, 17], [16, 25], [7, 24], [17, 25], [23, 10], [10, 29], [25, 8], [22, 24], [15, 29], [5, 2], [1, 8], [23, 19], [20, 30], [24, 10], [10, 28], [7, 8], [21, 9], [8, 27], [14, 18], [17, 22], [7, 28], [29, 1], [4, 11], [10, 19], [8, 19], [29, 31], [24, 19], [27, 1], [2, 24], [2, 30], [5, 11], [22, 17], [25, 2], [5, 20], [15, 10], [27, 30], [27, 10], [13, 4], [15, 5], [0, 15], [26, 1], [3, 26], [18, 2], [6, 27], [10, 31], [14, 15], [27, 12], [26, 6], [10, 16], [25, 9], [3, 19], [28, 0], [9, 25], [3, 0], [1, 9], [10, 26], [6, 23], [4, 6], [21, 2], [21, 17], [31, 5], [27, 2], [0, 25], [15, 15], [11, 4], [12, 20], [11, 29], [19, 25], [22, 2], [5, 18], [6, 12], [28, 17], [25, 22], [31, 19], [12, 18], [28, 2], [7, 4], [9, 17], [0, 9], [13, 27], [24, 6], [17, 13], [12, 28], [20, 10], [26, 16], [4, 2], [9, 3], [0, 22], [5, 30], [26, 10], [16, 18], [23, 8], [24, 1], [21, 3], [8, 13], [14, 9], [19, 21], [28, 7], [12, 5], [0, 28], [19, 24], [0, 31], [8, 26], [21, 10], [18, 30], [5, 25], [19, 23], [7, 30], [23, 28], [3, 14], [9, 13], [9, 20], [14, 1], [26, 18], [16, 9], [24, 16], [27, 19], [14, 20], [11, 2], [13, 11], [29, 30], [11, 3]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_8",
    "sat": "def sat(e: List[int], edges=[[3, 63], [77, 54], [68, 64], [75, 25], [82, 43], [75, 56], [54, 4], [39, 16], [46, 89], [43, 61], [28, 75], [70, 61], [79, 41], [3, 22], [23, 15], [74, 2], [6, 86], [30, 48], [8, 52], [18, 68], [68, 3], [58, 76], [44, 26], [82, 82], [54, 19], [19, 89], [62, 21], [39, 82], [91, 9], [35, 12], [7, 82], [68, 60], [54, 63], [10, 37], [63, 43], [65, 22], [62, 7], [72, 18], [54, 6], [58, 25], [33, 81], [69, 61], [20, 71], [59, 69], [30, 70], [81, 53], [74, 45], [48, 48], [10, 72], [26, 67], [54, 12], [41, 3], [9, 43], [63, 25], [79, 45], [80, 12], [85, 65], [65, 70], [77, 7], [14, 14], [30, 29], [11, 32], [64, 82], [42, 2], [72, 81], [43, 16], [30, 87], [19, 28], [3, 10], [83, 14], [75, 43], [39, 32], [88, 50], [51, 65], [38, 70], [38, 66], [16, 80], [40, 18], [11, 47], [43, 39], [56, 39], [17, 88], [31, 47], [37, 54], [58, 9], [8, 64], [2, 16], [2, 70], [13, 90], [64, 38], [21, 31], [55, 86], [8, 49], [27, 30], [38, 75], [13, 34], [48, 18], [84, 71], [59, 20], [36, 8], [11, 62], [90, 29], [72, 52], [61, 8], [26, 15], [27, 37], [60, 43], [66, 36], [7, 60], [67, 35], [14, 44], [5, 26], [58, 86], [65, 34], [47, 84], [80, 3], [50, 83], [6, 35], [16, 20], [31, 78], [25, 57], [16, 33], [58, 10], [85, 50], [68, 20], [32, 64], [79, 18], [44, 77], [72, 40], [7, 21], [66, 62], [73, 38], [49, 68], [80, 45], [21, 15], [67, 86], [61, 90], [33, 48], [43, 69], [1, 41], [25, 81], [27, 23], [3, 6], [60, 87], [57, 2], [48, 17], [26, 10], [86, 79], [40, 19], [86, 39], [24, 36], [34, 36], [87, 60], [86, 25], [9, 75], [63, 45], [44, 64], [39, 40], [51, 16], [51, 82], [64, 71], [42, 70], [71, 47], [72, 84], [27, 89], [57, 68], [70, 52], [23, 62], [38, 13], [62, 19], [16, 8], [8, 76], [84, 44], [87, 28], [39, 50], [70, 56], [87, 33], [70, 68], [52, 84], [49, 53], [20, 17], [56, 89], [62, 90], [91, 71], [70, 89], [50, 65], [89, 5], [16, 84], [85, 81], [61, 13], [63, 85], [40, 0], [18, 22], [34, 45], [65, 37], [40, 25], [59, 88], [62, 8], [19, 58], [22, 6], [18, 60], [57, 31], [88, 16], [33, 46], [8, 55], [50, 52], [56, 57], [77, 32], [90, 41], [69, 7], [28, 2], [11, 80], [59, 68], [17, 59], [27, 56], [60, 68], [53, 23], [85, 11], [68, 65], [17, 14], [9, 40], [2, 67], [15, 13], [90, 66], [42, 41], [22, 52], [38, 43], [35, 90], [22, 70], [7, 17], [43, 85], [12, 30], [69, 75], [13, 41], [88, 88], [55, 8], [66, 84], [6, 85], [65, 54], [71, 56], [34, 34], [17, 33], [88, 27], [22, 35], [22, 5], [4, 54], [5, 52], [60, 48], [51, 57], [30, 16], [90, 71], [12, 81], [0, 25], [52, 3], [79, 34], [70, 26], [13, 22], [44, 27], [19, 48], [9, 6], [43, 46], [25, 20], [67, 52], [72, 70], [21, 82], [45, 16], [22, 62], [36, 36], [69, 77], [66, 81], [73, 66], [75, 62], [2, 15], [1, 49], [76, 89], [76, 78], [83, 48], [26, 9], [57, 91], [69, 91], [65, 71], [65, 47], [61, 45], [66, 46], [71, 21], [49, 44], [82, 14], [7, 63], [56, 14], [89, 60], [5, 2], [89, 51], [18, 29], [71, 59], [14, 75], [55, 73], [50, 82], [89, 33], [74, 31], [6, 30], [44, 91], [35, 79], [40, 49], [59, 75], [15, 39], [3, 47], [3, 74], [54, 31], [79, 4], [35, 61], [39, 60], [53, 70], [36, 18], [73, 57], [74, 56], [87, 48], [48, 87], [81, 55], [42, 43], [88, 80], [84, 41], [56, 45], [38, 1], [60, 39], [57, 37], [8, 36], [13, 14], [79, 7], [41, 41], [3, 58], [26, 73], [71, 44], [35, 22], [37, 22], [27, 85], [46, 49], [46, 12], [81, 8], [55, 18], [36, 90], [10, 46], [15, 27], [30, 50], [88, 74], [44, 75], [55, 0], [60, 26], [60, 57], [86, 13], [37, 90], [79, 44], [10, 69], [43, 5], [20, 67], [8, 58], [87, 54], [6, 76], [85, 26], [18, 64], [83, 40], [23, 7], [50, 54], [23, 76], [2, 83], [16, 37], [46, 65], [52, 1], [34, 58], [39, 47], [90, 70], [90, 36], [80, 71], [43, 27], [57, 70], [10, 47], [50, 68], [60, 80], [42, 8], [12, 61], [77, 5], [46, 75], [69, 49], [16, 83], [84, 91], [43, 58], [23, 12], [0, 64], [69, 20], [48, 84], [61, 74], [16, 4], [4, 42], [41, 49], [76, 87], [87, 75], [56, 28], [28, 46], [28, 1], [81, 24], [29, 90], [26, 48], [13, 21], [39, 27], [86, 31], [18, 27], [79, 11], [76, 51], [52, 90], [4, 83], [30, 61], [89, 64], [53, 6], [21, 10], [10, 56], [45, 48], [26, 74], [2, 1], [3, 49], [58, 47], [15, 11], [9, 27], [63, 30], [40, 71], [27, 63], [89, 8], [40, 3], [48, 71], [3, 7], [61, 75], [52, 65], [19, 5], [19, 56], [79, 31], [29, 67], [56, 24], [88, 75], [2, 26], [77, 75], [62, 17], [68, 12], [26, 59], [55, 25], [35, 28], [54, 0], [46, 9], [79, 36], [60, 53], [37, 41], [66, 74], [24, 69], [76, 4], [68, 21], [11, 45], [6, 66], [86, 63], [88, 77], [26, 39], [5, 13], [28, 76], [59, 36], [20, 30], [11, 28], [22, 49], [58, 79], [85, 74], [89, 17], [64, 47], [66, 27], [86, 8], [45, 88], [15, 55], [43, 45], [17, 39], [34, 47], [85, 6], [29, 42], [1, 72], [76, 6], [57, 0], [88, 23], [66, 16], [4, 28], [12, 32], [76, 81], [0, 24], [5, 1], [10, 71], [60, 64], [82, 16], [14, 78], [0, 53], [67, 62], [57, 52], [47, 43], [88, 11], [64, 88], [13, 61], [60, 10], [4, 15], [47, 68], [9, 82], [84, 23], [40, 53], [62, 56], [50, 38], [19, 60], [56, 29], [55, 67], [32, 34], [11, 87], [63, 59], [89, 61], [8, 29], [16, 11], [8, 12], [61, 60], [30, 44], [45, 8], [8, 33], [57, 23], [42, 88], [65, 38], [30, 89], [11, 64], [36, 85], [72, 51], [7, 55], [76, 82], [7, 2], [26, 40], [82, 20], [81, 37], [55, 65], [34, 19], [58, 16], [7, 52], [81, 65], [1, 4], [11, 84], [91, 7], [33, 19], [27, 81], [0, 23], [69, 58], [12, 91], [34, 66], [42, 76], [65, 35], [24, 32], [38, 55], [32, 53], [70, 87], [71, 65], [55, 30], [45, 75], [75, 72], [58, 73], [74, 60], [41, 26], [62, 72], [6, 61], [66, 85], [59, 66], [83, 35], [91, 85], [52, 32], [62, 86], [57, 86], [35, 5], [27, 66], [25, 79], [71, 76], [26, 21], [62, 79], [37, 79], [28, 88], [50, 12], [34, 60], [88, 51], [74, 61], [3, 84], [90, 5], [52, 49], [81, 62], [62, 45], [0, 58], [20, 59], [64, 3], [80, 52], [15, 41], [68, 89], [44, 9], [64, 83], [1, 31], [63, 86], [78, 62], [59, 57], [47, 37], [15, 23], [83, 18], [35, 13], [56, 11], [26, 77], [14, 50], [73, 22], [26, 68], [25, 0], [3, 54], [45, 53], [66, 49], [18, 21], [73, 3], [58, 87], [70, 28], [29, 84], [68, 32], [19, 57], [16, 66], [21, 57], [47, 39], [41, 70], [76, 83], [43, 43], [8, 69], [63, 47], [34, 51], [13, 20], [46, 70], [18, 11], [27, 47], [12, 76], [35, 53], [47, 55], [21, 90], [42, 6], [49, 19], [60, 44], [47, 86], [24, 29], [73, 60], [75, 45]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[3, 63], [77, 54], [68, 64], [75, 25], [82, 43], [75, 56], [54, 4], [39, 16], [46, 89], [43, 61], [28, 75], [70, 61], [79, 41], [3, 22], [23, 15], [74, 2], [6, 86], [30, 48], [8, 52], [18, 68], [68, 3], [58, 76], [44, 26], [82, 82], [54, 19], [19, 89], [62, 21], [39, 82], [91, 9], [35, 12], [7, 82], [68, 60], [54, 63], [10, 37], [63, 43], [65, 22], [62, 7], [72, 18], [54, 6], [58, 25], [33, 81], [69, 61], [20, 71], [59, 69], [30, 70], [81, 53], [74, 45], [48, 48], [10, 72], [26, 67], [54, 12], [41, 3], [9, 43], [63, 25], [79, 45], [80, 12], [85, 65], [65, 70], [77, 7], [14, 14], [30, 29], [11, 32], [64, 82], [42, 2], [72, 81], [43, 16], [30, 87], [19, 28], [3, 10], [83, 14], [75, 43], [39, 32], [88, 50], [51, 65], [38, 70], [38, 66], [16, 80], [40, 18], [11, 47], [43, 39], [56, 39], [17, 88], [31, 47], [37, 54], [58, 9], [8, 64], [2, 16], [2, 70], [13, 90], [64, 38], [21, 31], [55, 86], [8, 49], [27, 30], [38, 75], [13, 34], [48, 18], [84, 71], [59, 20], [36, 8], [11, 62], [90, 29], [72, 52], [61, 8], [26, 15], [27, 37], [60, 43], [66, 36], [7, 60], [67, 35], [14, 44], [5, 26], [58, 86], [65, 34], [47, 84], [80, 3], [50, 83], [6, 35], [16, 20], [31, 78], [25, 57], [16, 33], [58, 10], [85, 50], [68, 20], [32, 64], [79, 18], [44, 77], [72, 40], [7, 21], [66, 62], [73, 38], [49, 68], [80, 45], [21, 15], [67, 86], [61, 90], [33, 48], [43, 69], [1, 41], [25, 81], [27, 23], [3, 6], [60, 87], [57, 2], [48, 17], [26, 10], [86, 79], [40, 19], [86, 39], [24, 36], [34, 36], [87, 60], [86, 25], [9, 75], [63, 45], [44, 64], [39, 40], [51, 16], [51, 82], [64, 71], [42, 70], [71, 47], [72, 84], [27, 89], [57, 68], [70, 52], [23, 62], [38, 13], [62, 19], [16, 8], [8, 76], [84, 44], [87, 28], [39, 50], [70, 56], [87, 33], [70, 68], [52, 84], [49, 53], [20, 17], [56, 89], [62, 90], [91, 71], [70, 89], [50, 65], [89, 5], [16, 84], [85, 81], [61, 13], [63, 85], [40, 0], [18, 22], [34, 45], [65, 37], [40, 25], [59, 88], [62, 8], [19, 58], [22, 6], [18, 60], [57, 31], [88, 16], [33, 46], [8, 55], [50, 52], [56, 57], [77, 32], [90, 41], [69, 7], [28, 2], [11, 80], [59, 68], [17, 59], [27, 56], [60, 68], [53, 23], [85, 11], [68, 65], [17, 14], [9, 40], [2, 67], [15, 13], [90, 66], [42, 41], [22, 52], [38, 43], [35, 90], [22, 70], [7, 17], [43, 85], [12, 30], [69, 75], [13, 41], [88, 88], [55, 8], [66, 84], [6, 85], [65, 54], [71, 56], [34, 34], [17, 33], [88, 27], [22, 35], [22, 5], [4, 54], [5, 52], [60, 48], [51, 57], [30, 16], [90, 71], [12, 81], [0, 25], [52, 3], [79, 34], [70, 26], [13, 22], [44, 27], [19, 48], [9, 6], [43, 46], [25, 20], [67, 52], [72, 70], [21, 82], [45, 16], [22, 62], [36, 36], [69, 77], [66, 81], [73, 66], [75, 62], [2, 15], [1, 49], [76, 89], [76, 78], [83, 48], [26, 9], [57, 91], [69, 91], [65, 71], [65, 47], [61, 45], [66, 46], [71, 21], [49, 44], [82, 14], [7, 63], [56, 14], [89, 60], [5, 2], [89, 51], [18, 29], [71, 59], [14, 75], [55, 73], [50, 82], [89, 33], [74, 31], [6, 30], [44, 91], [35, 79], [40, 49], [59, 75], [15, 39], [3, 47], [3, 74], [54, 31], [79, 4], [35, 61], [39, 60], [53, 70], [36, 18], [73, 57], [74, 56], [87, 48], [48, 87], [81, 55], [42, 43], [88, 80], [84, 41], [56, 45], [38, 1], [60, 39], [57, 37], [8, 36], [13, 14], [79, 7], [41, 41], [3, 58], [26, 73], [71, 44], [35, 22], [37, 22], [27, 85], [46, 49], [46, 12], [81, 8], [55, 18], [36, 90], [10, 46], [15, 27], [30, 50], [88, 74], [44, 75], [55, 0], [60, 26], [60, 57], [86, 13], [37, 90], [79, 44], [10, 69], [43, 5], [20, 67], [8, 58], [87, 54], [6, 76], [85, 26], [18, 64], [83, 40], [23, 7], [50, 54], [23, 76], [2, 83], [16, 37], [46, 65], [52, 1], [34, 58], [39, 47], [90, 70], [90, 36], [80, 71], [43, 27], [57, 70], [10, 47], [50, 68], [60, 80], [42, 8], [12, 61], [77, 5], [46, 75], [69, 49], [16, 83], [84, 91], [43, 58], [23, 12], [0, 64], [69, 20], [48, 84], [61, 74], [16, 4], [4, 42], [41, 49], [76, 87], [87, 75], [56, 28], [28, 46], [28, 1], [81, 24], [29, 90], [26, 48], [13, 21], [39, 27], [86, 31], [18, 27], [79, 11], [76, 51], [52, 90], [4, 83], [30, 61], [89, 64], [53, 6], [21, 10], [10, 56], [45, 48], [26, 74], [2, 1], [3, 49], [58, 47], [15, 11], [9, 27], [63, 30], [40, 71], [27, 63], [89, 8], [40, 3], [48, 71], [3, 7], [61, 75], [52, 65], [19, 5], [19, 56], [79, 31], [29, 67], [56, 24], [88, 75], [2, 26], [77, 75], [62, 17], [68, 12], [26, 59], [55, 25], [35, 28], [54, 0], [46, 9], [79, 36], [60, 53], [37, 41], [66, 74], [24, 69], [76, 4], [68, 21], [11, 45], [6, 66], [86, 63], [88, 77], [26, 39], [5, 13], [28, 76], [59, 36], [20, 30], [11, 28], [22, 49], [58, 79], [85, 74], [89, 17], [64, 47], [66, 27], [86, 8], [45, 88], [15, 55], [43, 45], [17, 39], [34, 47], [85, 6], [29, 42], [1, 72], [76, 6], [57, 0], [88, 23], [66, 16], [4, 28], [12, 32], [76, 81], [0, 24], [5, 1], [10, 71], [60, 64], [82, 16], [14, 78], [0, 53], [67, 62], [57, 52], [47, 43], [88, 11], [64, 88], [13, 61], [60, 10], [4, 15], [47, 68], [9, 82], [84, 23], [40, 53], [62, 56], [50, 38], [19, 60], [56, 29], [55, 67], [32, 34], [11, 87], [63, 59], [89, 61], [8, 29], [16, 11], [8, 12], [61, 60], [30, 44], [45, 8], [8, 33], [57, 23], [42, 88], [65, 38], [30, 89], [11, 64], [36, 85], [72, 51], [7, 55], [76, 82], [7, 2], [26, 40], [82, 20], [81, 37], [55, 65], [34, 19], [58, 16], [7, 52], [81, 65], [1, 4], [11, 84], [91, 7], [33, 19], [27, 81], [0, 23], [69, 58], [12, 91], [34, 66], [42, 76], [65, 35], [24, 32], [38, 55], [32, 53], [70, 87], [71, 65], [55, 30], [45, 75], [75, 72], [58, 73], [74, 60], [41, 26], [62, 72], [6, 61], [66, 85], [59, 66], [83, 35], [91, 85], [52, 32], [62, 86], [57, 86], [35, 5], [27, 66], [25, 79], [71, 76], [26, 21], [62, 79], [37, 79], [28, 88], [50, 12], [34, 60], [88, 51], [74, 61], [3, 84], [90, 5], [52, 49], [81, 62], [62, 45], [0, 58], [20, 59], [64, 3], [80, 52], [15, 41], [68, 89], [44, 9], [64, 83], [1, 31], [63, 86], [78, 62], [59, 57], [47, 37], [15, 23], [83, 18], [35, 13], [56, 11], [26, 77], [14, 50], [73, 22], [26, 68], [25, 0], [3, 54], [45, 53], [66, 49], [18, 21], [73, 3], [58, 87], [70, 28], [29, 84], [68, 32], [19, 57], [16, 66], [21, 57], [47, 39], [41, 70], [76, 83], [43, 43], [8, 69], [63, 47], [34, 51], [13, 20], [46, 70], [18, 11], [27, 47], [12, 76], [35, 53], [47, 55], [21, 90], [42, 6], [49, 19], [60, 44], [47, 86], [24, 29], [73, 60], [75, 45]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyEdge_9",
    "sat": "def sat(e: List[int], edges=[[17, 15], [38, 8], [9, 6], [27, 9], [34, 18], [40, 48], [30, 6], [13, 28], [14, 30], [50, 25], [3, 44], [34, 47], [2, 41], [25, 1], [15, 36], [33, 6], [49, 10], [36, 45], [19, 1], [11, 36], [43, 13], [33, 37], [46, 11], [19, 18], [49, 54], [50, 42], [7, 3], [18, 16], [24, 35], [15, 1], [11, 0], [24, 2], [51, 35], [42, 52], [49, 16], [15, 15], [22, 8], [52, 29], [16, 2], [22, 28], [7, 10], [53, 45], [1, 53], [21, 11], [16, 30], [4, 32], [51, 28], [51, 7], [32, 39], [54, 9], [36, 52], [35, 13], [41, 50], [50, 2], [8, 23], [42, 34], [24, 30], [11, 16], [4, 22], [20, 35], [44, 0], [9, 40], [8, 26], [39, 43], [39, 37], [8, 6], [50, 27], [22, 32], [23, 2], [51, 32], [12, 20], [21, 53], [16, 25], [1, 13], [18, 9], [31, 52], [38, 48], [18, 2], [41, 40], [44, 54], [1, 26], [51, 6], [25, 27], [39, 54], [50, 35], [19, 19], [39, 31], [9, 32], [24, 11], [51, 9], [8, 53], [11, 45], [22, 12], [39, 6], [39, 12], [13, 9], [50, 19], [49, 39], [46, 48], [23, 21], [15, 18], [34, 40], [23, 40], [44, 48], [23, 7], [25, 38], [54, 35], [20, 10], [45, 25], [35, 31], [23, 30], [26, 53], [50, 28], [18, 47], [15, 42], [18, 41], [39, 33], [41, 9], [34, 0], [7, 52], [40, 19], [4, 4], [15, 19], [52, 9], [11, 46], [44, 7], [27, 23], [38, 27], [52, 20], [52, 40], [43, 35], [38, 41], [6, 15], [22, 48], [0, 47], [18, 46], [28, 15], [46, 23], [36, 32], [45, 38], [26, 7], [13, 34], [28, 17], [2, 44], [9, 18], [25, 37], [50, 51], [20, 3], [27, 0], [52, 46], [18, 24], [47, 53], [0, 8], [49, 26], [8, 37], [53, 52], [15, 16], [29, 21], [18, 48], [2, 52], [19, 46], [44, 53], [48, 1], [44, 12], [35, 38], [17, 6], [37, 31], [42, 43], [11, 50], [26, 46], [5, 50], [54, 13], [19, 39], [49, 33], [4, 16], [4, 52], [21, 28], [18, 15], [44, 52], [36, 41], [28, 50], [33, 24], [23, 25], [34, 42], [53, 29], [20, 33], [25, 36], [24, 51], [49, 18], [19, 23], [31, 14], [4, 23], [48, 3], [3, 29], [52, 38], [53, 44], [29, 48], [12, 2], [53, 31], [8, 21], [14, 50], [40, 49], [9, 26], [51, 0], [51, 20], [51, 3], [13, 50], [29, 40], [48, 32], [31, 17], [40, 20], [43, 20], [14, 0], [43, 45], [43, 36], [47, 17], [20, 23], [25, 50], [38, 24], [34, 35], [41, 41], [20, 43], [30, 44], [15, 9], [22, 4], [31, 10], [47, 27], [31, 49], [33, 51], [4, 18], [35, 32], [4, 42], [8, 15], [42, 26], [34, 12], [6, 39], [10, 43], [52, 50], [20, 14], [15, 53], [33, 41], [52, 7], [20, 6], [13, 3], [14, 5], [34, 4], [4, 33], [54, 15], [6, 2], [15, 22], [20, 48], [48, 52], [34, 16], [3, 24], [37, 54], [53, 15], [26, 22], [1, 54], [45, 15], [22, 3], [12, 21], [46, 53], [45, 28], [15, 24], [30, 22], [1, 7], [9, 25], [53, 51], [45, 6], [12, 51], [5, 47], [3, 33], [49, 0], [31, 28], [27, 42], [29, 53], [1, 2], [46, 38], [12, 12], [21, 18], [20, 40], [54, 8], [2, 50], [20, 29], [48, 8], [46, 47], [53, 9], [33, 15], [20, 47], [10, 29], [6, 17], [11, 51], [36, 39], [23, 0], [44, 27], [1, 3], [4, 20], [53, 5], [39, 29], [24, 50], [7, 5], [48, 24], [33, 54], [36, 40], [0, 22], [48, 54], [34, 51], [45, 33], [38, 36], [39, 20], [43, 16], [32, 48], [1, 18], [0, 25], [28, 0], [25, 25], [22, 1], [43, 10], [10, 25], [15, 39], [51, 29], [47, 42], [8, 48], [20, 19], [29, 35], [53, 40], [6, 26], [29, 10], [51, 26], [42, 4], [1, 29], [32, 24], [27, 4], [35, 26], [34, 28], [40, 7], [34, 46], [44, 29], [37, 5], [15, 21], [23, 48], [51, 12], [44, 38], [45, 4], [54, 53], [26, 14], [4, 53], [8, 13], [24, 42], [5, 45], [28, 54], [51, 4], [5, 12], [31, 36], [3, 14], [22, 26], [0, 39], [37, 52], [35, 7], [27, 16], [20, 25], [43, 38], [18, 52], [41, 23], [42, 38], [47, 19], [6, 4], [49, 17], [39, 22], [11, 19], [51, 51], [42, 1], [13, 24], [31, 9], [35, 50], [47, 52], [45, 23], [20, 31], [52, 24], [27, 5], [21, 8], [23, 24], [4, 54], [1, 19], [32, 18], [7, 15], [42, 11], [23, 46], [44, 21], [10, 5], [3, 10], [50, 12], [17, 43], [39, 34], [0, 48], [45, 20], [38, 22], [37, 18], [9, 7], [10, 13], [14, 52], [52, 47], [30, 28], [43, 49], [47, 41], [13, 42], [31, 35], [43, 30], [5, 26], [17, 23], [18, 32], [28, 14], [40, 22], [51, 31], [2, 31], [2, 3], [2, 12], [18, 30], [26, 18], [49, 29], [28, 48], [27, 41], [37, 19], [21, 40], [3, 30], [10, 23], [32, 44], [29, 39], [22, 14], [15, 13], [5, 44], [7, 11], [40, 44], [12, 27], [25, 41], [33, 35], [30, 2], [19, 20], [35, 27], [5, 49], [15, 7], [1, 17], [42, 14], [41, 15], [3, 47], [52, 16], [13, 54], [37, 41], [36, 34], [17, 50], [10, 16], [11, 25], [13, 36], [44, 15], [16, 21], [53, 54], [40, 29], [40, 11], [11, 39], [9, 15], [4, 44], [13, 32], [2, 37], [25, 51], [15, 17], [1, 28], [29, 5], [38, 2], [14, 32]]):\n    \"\"\"Find any edge in edges.\"\"\"\n    return e in edges",
    "sols": [
      "def sol(edges=[[17, 15], [38, 8], [9, 6], [27, 9], [34, 18], [40, 48], [30, 6], [13, 28], [14, 30], [50, 25], [3, 44], [34, 47], [2, 41], [25, 1], [15, 36], [33, 6], [49, 10], [36, 45], [19, 1], [11, 36], [43, 13], [33, 37], [46, 11], [19, 18], [49, 54], [50, 42], [7, 3], [18, 16], [24, 35], [15, 1], [11, 0], [24, 2], [51, 35], [42, 52], [49, 16], [15, 15], [22, 8], [52, 29], [16, 2], [22, 28], [7, 10], [53, 45], [1, 53], [21, 11], [16, 30], [4, 32], [51, 28], [51, 7], [32, 39], [54, 9], [36, 52], [35, 13], [41, 50], [50, 2], [8, 23], [42, 34], [24, 30], [11, 16], [4, 22], [20, 35], [44, 0], [9, 40], [8, 26], [39, 43], [39, 37], [8, 6], [50, 27], [22, 32], [23, 2], [51, 32], [12, 20], [21, 53], [16, 25], [1, 13], [18, 9], [31, 52], [38, 48], [18, 2], [41, 40], [44, 54], [1, 26], [51, 6], [25, 27], [39, 54], [50, 35], [19, 19], [39, 31], [9, 32], [24, 11], [51, 9], [8, 53], [11, 45], [22, 12], [39, 6], [39, 12], [13, 9], [50, 19], [49, 39], [46, 48], [23, 21], [15, 18], [34, 40], [23, 40], [44, 48], [23, 7], [25, 38], [54, 35], [20, 10], [45, 25], [35, 31], [23, 30], [26, 53], [50, 28], [18, 47], [15, 42], [18, 41], [39, 33], [41, 9], [34, 0], [7, 52], [40, 19], [4, 4], [15, 19], [52, 9], [11, 46], [44, 7], [27, 23], [38, 27], [52, 20], [52, 40], [43, 35], [38, 41], [6, 15], [22, 48], [0, 47], [18, 46], [28, 15], [46, 23], [36, 32], [45, 38], [26, 7], [13, 34], [28, 17], [2, 44], [9, 18], [25, 37], [50, 51], [20, 3], [27, 0], [52, 46], [18, 24], [47, 53], [0, 8], [49, 26], [8, 37], [53, 52], [15, 16], [29, 21], [18, 48], [2, 52], [19, 46], [44, 53], [48, 1], [44, 12], [35, 38], [17, 6], [37, 31], [42, 43], [11, 50], [26, 46], [5, 50], [54, 13], [19, 39], [49, 33], [4, 16], [4, 52], [21, 28], [18, 15], [44, 52], [36, 41], [28, 50], [33, 24], [23, 25], [34, 42], [53, 29], [20, 33], [25, 36], [24, 51], [49, 18], [19, 23], [31, 14], [4, 23], [48, 3], [3, 29], [52, 38], [53, 44], [29, 48], [12, 2], [53, 31], [8, 21], [14, 50], [40, 49], [9, 26], [51, 0], [51, 20], [51, 3], [13, 50], [29, 40], [48, 32], [31, 17], [40, 20], [43, 20], [14, 0], [43, 45], [43, 36], [47, 17], [20, 23], [25, 50], [38, 24], [34, 35], [41, 41], [20, 43], [30, 44], [15, 9], [22, 4], [31, 10], [47, 27], [31, 49], [33, 51], [4, 18], [35, 32], [4, 42], [8, 15], [42, 26], [34, 12], [6, 39], [10, 43], [52, 50], [20, 14], [15, 53], [33, 41], [52, 7], [20, 6], [13, 3], [14, 5], [34, 4], [4, 33], [54, 15], [6, 2], [15, 22], [20, 48], [48, 52], [34, 16], [3, 24], [37, 54], [53, 15], [26, 22], [1, 54], [45, 15], [22, 3], [12, 21], [46, 53], [45, 28], [15, 24], [30, 22], [1, 7], [9, 25], [53, 51], [45, 6], [12, 51], [5, 47], [3, 33], [49, 0], [31, 28], [27, 42], [29, 53], [1, 2], [46, 38], [12, 12], [21, 18], [20, 40], [54, 8], [2, 50], [20, 29], [48, 8], [46, 47], [53, 9], [33, 15], [20, 47], [10, 29], [6, 17], [11, 51], [36, 39], [23, 0], [44, 27], [1, 3], [4, 20], [53, 5], [39, 29], [24, 50], [7, 5], [48, 24], [33, 54], [36, 40], [0, 22], [48, 54], [34, 51], [45, 33], [38, 36], [39, 20], [43, 16], [32, 48], [1, 18], [0, 25], [28, 0], [25, 25], [22, 1], [43, 10], [10, 25], [15, 39], [51, 29], [47, 42], [8, 48], [20, 19], [29, 35], [53, 40], [6, 26], [29, 10], [51, 26], [42, 4], [1, 29], [32, 24], [27, 4], [35, 26], [34, 28], [40, 7], [34, 46], [44, 29], [37, 5], [15, 21], [23, 48], [51, 12], [44, 38], [45, 4], [54, 53], [26, 14], [4, 53], [8, 13], [24, 42], [5, 45], [28, 54], [51, 4], [5, 12], [31, 36], [3, 14], [22, 26], [0, 39], [37, 52], [35, 7], [27, 16], [20, 25], [43, 38], [18, 52], [41, 23], [42, 38], [47, 19], [6, 4], [49, 17], [39, 22], [11, 19], [51, 51], [42, 1], [13, 24], [31, 9], [35, 50], [47, 52], [45, 23], [20, 31], [52, 24], [27, 5], [21, 8], [23, 24], [4, 54], [1, 19], [32, 18], [7, 15], [42, 11], [23, 46], [44, 21], [10, 5], [3, 10], [50, 12], [17, 43], [39, 34], [0, 48], [45, 20], [38, 22], [37, 18], [9, 7], [10, 13], [14, 52], [52, 47], [30, 28], [43, 49], [47, 41], [13, 42], [31, 35], [43, 30], [5, 26], [17, 23], [18, 32], [28, 14], [40, 22], [51, 31], [2, 31], [2, 3], [2, 12], [18, 30], [26, 18], [49, 29], [28, 48], [27, 41], [37, 19], [21, 40], [3, 30], [10, 23], [32, 44], [29, 39], [22, 14], [15, 13], [5, 44], [7, 11], [40, 44], [12, 27], [25, 41], [33, 35], [30, 2], [19, 20], [35, 27], [5, 49], [15, 7], [1, 17], [42, 14], [41, 15], [3, 47], [52, 16], [13, 54], [37, 41], [36, 34], [17, 50], [10, 16], [11, 25], [13, 36], [44, 15], [16, 21], [53, 54], [40, 29], [40, 11], [11, 39], [9, 15], [4, 44], [13, 32], [2, 37], [25, 51], [15, 17], [1, 28], [29, 5], [38, 2], [14, 32]]):\n    return edges[0]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_0",
    "sat": "def sat(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_1",
    "sat": "def sat(tri: List[int], edges=[[77, 73], [11, 60], [7, 63], [59, 24], [49, 42], [46, 42], [70, 44], [51, 69], [19, 19], [37, 70], [56, 37], [34, 61], [43, 39], [66, 24], [68, 57], [10, 31], [43, 45], [58, 65], [77, 32], [60, 74], [7, 1], [12, 76], [78, 56], [49, 30], [51, 50], [43, 8], [48, 7], [14, 36], [46, 7], [80, 49], [3, 60], [0, 33], [49, 43], [29, 26], [23, 60], [31, 79], [2, 13], [4, 49], [52, 38], [55, 20], [78, 65], [27, 10], [26, 35], [77, 80], [77, 14], [53, 33], [55, 14], [42, 79], [66, 44], [55, 62], [35, 53], [78, 71], [11, 36], [24, 21], [26, 12], [16, 20], [43, 25], [6, 48], [24, 34], [14, 69], [75, 61], [74, 43], [49, 68], [38, 11], [11, 52], [40, 3], [6, 33], [31, 21], [22, 52], [72, 65], [56, 26], [40, 44], [48, 40], [43, 12], [5, 45], [20, 32], [12, 19], [48, 11], [78, 55], [34, 63], [55, 8], [65, 66], [15, 33], [42, 33], [27, 3], [66, 29], [13, 27], [32, 47], [29, 78], [51, 38], [54, 69], [32, 56], [80, 61], [79, 31], [6, 28], [39, 4], [9, 13], [0, 10], [74, 36], [9, 47], [11, 57], [45, 1], [65, 42], [6, 45], [74, 55], [79, 28], [31, 4], [22, 54], [33, 46], [1, 73], [72, 48], [33, 58], [20, 62], [47, 59], [77, 3], [41, 58], [55, 52], [76, 18], [80, 11], [10, 32], [11, 15], [41, 15], [50, 78], [80, 46], [49, 80], [45, 29], [55, 33], [8, 38], [30, 63], [47, 44], [78, 44], [5, 76], [76, 26], [76, 51], [65, 60], [2, 21], [63, 38], [61, 44], [54, 23], [35, 47], [0, 41], [27, 15], [31, 13], [65, 32], [80, 10], [65, 38], [30, 12], [60, 10], [44, 21], [13, 79], [4, 34], [50, 65], [58, 22], [52, 51], [10, 60], [18, 56], [36, 21], [59, 2], [5, 74], [7, 67], [68, 21], [34, 15], [54, 25], [0, 35], [77, 24], [23, 20], [25, 41], [57, 68], [13, 73], [17, 45], [52, 53], [6, 18], [74, 61], [51, 68], [17, 36], [80, 63], [52, 12], [29, 20], [27, 60], [70, 67], [27, 8], [59, 14], [37, 69], [70, 80], [17, 12], [38, 72], [13, 75], [8, 11], [2, 42], [59, 44], [61, 22], [62, 14], [1, 18], [12, 80], [56, 76], [11, 35], [36, 45], [63, 33], [72, 2], [50, 5], [18, 61], [58, 14], [32, 38], [56, 0], [20, 6], [0, 34], [73, 5], [27, 53], [44, 41], [29, 8], [80, 50], [4, 9], [44, 52], [34, 41], [50, 17], [3, 3], [57, 12], [57, 66], [6, 65], [68, 50], [38, 59], [72, 3], [49, 1], [13, 10], [18, 64], [20, 46], [39, 53], [70, 74], [26, 40], [14, 18], [10, 9], [48, 15], [54, 6], [76, 78], [51, 36], [80, 21], [25, 77], [40, 75], [0, 71], [11, 34], [8, 66], [51, 33], [75, 13], [42, 18], [49, 62], [39, 70], [6, 31], [65, 24], [28, 70], [46, 18], [1, 4], [8, 0], [44, 10], [59, 59], [41, 12], [13, 65], [65, 33], [8, 59], [25, 27], [7, 28], [45, 61], [24, 76], [53, 40], [75, 24], [68, 39], [8, 33], [21, 56], [25, 75], [65, 72], [22, 23], [49, 51], [17, 6], [70, 79], [42, 66], [4, 40], [74, 28], [72, 7], [29, 9], [15, 5], [5, 30], [71, 36], [67, 55], [30, 26], [59, 40], [70, 16], [69, 44], [57, 71], [61, 5], [22, 57], [54, 39], [66, 25], [61, 73], [39, 79], [41, 47], [43, 72], [42, 31], [47, 51], [26, 6], [0, 53], [27, 26], [23, 6], [49, 4], [3, 64], [10, 28], [14, 72], [79, 67], [77, 31], [48, 66], [5, 14], [3, 34], [36, 1], [4, 6], [56, 71], [2, 65], [18, 39], [45, 19], [64, 73], [75, 77], [6, 17], [51, 1], [10, 1], [10, 41], [17, 61], [28, 62], [77, 44], [53, 2], [8, 40], [62, 38], [40, 33], [12, 50], [35, 0], [37, 45], [72, 55], [21, 78], [76, 37], [4, 45], [41, 31], [42, 46], [8, 18], [39, 19], [49, 33], [1, 15], [38, 25], [57, 8], [1, 3], [68, 71], [40, 37], [13, 63], [6, 24], [45, 21], [57, 57], [56, 52], [62, 44], [76, 29], [27, 30], [54, 34], [37, 80], [24, 5], [64, 66], [58, 4], [21, 33], [45, 38], [40, 65], [20, 61], [4, 12], [32, 59], [75, 78], [36, 54], [61, 0], [11, 30], [15, 15], [70, 6], [43, 55], [68, 51], [64, 70], [69, 49], [36, 57], [6, 16], [11, 2], [37, 2], [51, 70], [17, 9], [50, 64], [8, 24], [15, 21], [79, 36], [54, 78], [28, 40], [41, 57], [2, 48], [44, 31], [55, 75], [25, 7], [54, 68], [3, 16], [70, 54], [46, 67], [53, 20], [31, 70], [34, 64], [42, 11], [10, 65], [43, 24], [75, 25], [0, 60], [16, 64], [22, 45], [41, 1], [51, 5], [1, 71], [50, 47], [77, 79], [70, 75], [12, 72], [78, 69], [15, 3], [68, 41], [29, 64], [48, 54], [49, 59], [73, 9], [25, 62], [10, 13], [62, 40], [71, 14], [47, 25], [18, 33], [68, 80], [80, 9], [58, 54], [2, 46], [68, 22], [48, 9], [10, 36], [17, 72], [5, 21], [8, 3], [76, 65], [63, 39], [47, 65], [68, 55], [79, 62], [57, 70], [12, 41], [16, 3], [68, 6], [4, 68], [36, 77], [79, 69], [66, 72], [50, 20], [74, 31], [77, 70], [53, 18], [46, 25], [41, 74], [13, 39], [38, 28], [50, 79], [55, 79], [77, 68], [66, 39], [63, 65], [25, 61], [48, 78], [66, 40], [64, 26], [21, 42], [0, 39], [48, 35], [76, 44], [34, 51], [26, 51], [79, 65], [77, 72], [37, 43], [57, 36], [40, 62], [44, 70], [16, 43], [73, 55], [46, 3], [1, 58], [77, 29], [41, 17], [19, 8], [9, 78], [61, 34], [28, 54], [35, 44], [22, 4], [15, 27], [68, 64], [18, 44], [24, 30], [9, 3], [41, 64], [51, 52], [44, 53], [45, 36], [45, 73], [33, 34], [72, 67], [4, 79], [22, 30], [60, 18], [39, 61], [74, 3], [16, 49], [77, 45], [1, 40], [55, 80], [63, 67], [14, 66], [79, 17], [6, 50], [53, 21], [38, 31], [9, 63], [13, 26], [63, 19], [22, 49], [5, 13], [40, 5], [22, 43], [71, 29], [46, 46], [51, 51], [30, 68], [10, 26], [2, 71], [45, 33], [28, 73], [40, 26], [18, 31], [55, 72], [13, 36], [13, 7], [73, 58], [2, 51], [52, 21], [11, 1], [32, 52], [42, 39], [70, 29], [78, 76], [80, 67], [10, 38], [11, 14], [52, 57], [79, 6], [16, 11], [16, 51], [68, 62], [59, 10], [80, 23], [58, 61], [39, 52], [64, 11], [0, 38], [46, 34], [28, 13], [41, 56], [12, 43], [7, 59], [14, 19], [79, 73], [29, 29], [43, 18], [57, 62], [4, 76], [7, 39], [70, 53], [19, 77], [78, 4], [71, 41], [11, 54], [31, 26], [28, 67], [38, 19], [59, 11], [55, 4], [43, 35], [51, 26], [80, 13], [12, 24], [70, 62], [20, 56], [41, 52], [22, 65], [76, 2], [9, 79], [40, 10], [50, 11], [48, 24], [55, 67], [31, 16], [15, 79], [66, 79], [24, 16], [30, 0], [70, 39], [40, 7], [29, 44], [69, 10], [33, 28], [66, 35], [44, 72], [52, 22], [10, 72], [30, 21], [17, 18], [59, 22], [57, 32], [2, 57], [43, 44], [78, 39], [30, 17], [43, 41], [38, 56], [20, 11], [17, 7], [19, 45], [38, 68], [66, 27], [74, 46], [19, 15], [14, 48], [73, 6], [72, 59], [63, 45], [7, 25], [41, 24], [24, 80], [7, 31], [41, 26], [74, 21], [39, 25], [51, 20], [63, 13], [76, 76], [38, 20], [9, 16], [15, 52], [12, 73], [79, 68], [15, 45], [32, 65], [65, 39], [49, 15], [33, 27], [28, 6], [78, 75], [58, 74], [45, 55], [47, 71], [50, 68], [64, 52], [79, 13], [26, 41], [12, 37], [47, 2], [9, 6], [62, 72], [68, 47], [55, 53], [21, 13], [54, 29], [67, 76], [47, 18], [65, 78], [44, 25], [14, 56], [27, 7], [77, 34], [67, 63], [19, 20], [3, 25], [0, 40], [32, 78], [74, 67]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[77, 73], [11, 60], [7, 63], [59, 24], [49, 42], [46, 42], [70, 44], [51, 69], [19, 19], [37, 70], [56, 37], [34, 61], [43, 39], [66, 24], [68, 57], [10, 31], [43, 45], [58, 65], [77, 32], [60, 74], [7, 1], [12, 76], [78, 56], [49, 30], [51, 50], [43, 8], [48, 7], [14, 36], [46, 7], [80, 49], [3, 60], [0, 33], [49, 43], [29, 26], [23, 60], [31, 79], [2, 13], [4, 49], [52, 38], [55, 20], [78, 65], [27, 10], [26, 35], [77, 80], [77, 14], [53, 33], [55, 14], [42, 79], [66, 44], [55, 62], [35, 53], [78, 71], [11, 36], [24, 21], [26, 12], [16, 20], [43, 25], [6, 48], [24, 34], [14, 69], [75, 61], [74, 43], [49, 68], [38, 11], [11, 52], [40, 3], [6, 33], [31, 21], [22, 52], [72, 65], [56, 26], [40, 44], [48, 40], [43, 12], [5, 45], [20, 32], [12, 19], [48, 11], [78, 55], [34, 63], [55, 8], [65, 66], [15, 33], [42, 33], [27, 3], [66, 29], [13, 27], [32, 47], [29, 78], [51, 38], [54, 69], [32, 56], [80, 61], [79, 31], [6, 28], [39, 4], [9, 13], [0, 10], [74, 36], [9, 47], [11, 57], [45, 1], [65, 42], [6, 45], [74, 55], [79, 28], [31, 4], [22, 54], [33, 46], [1, 73], [72, 48], [33, 58], [20, 62], [47, 59], [77, 3], [41, 58], [55, 52], [76, 18], [80, 11], [10, 32], [11, 15], [41, 15], [50, 78], [80, 46], [49, 80], [45, 29], [55, 33], [8, 38], [30, 63], [47, 44], [78, 44], [5, 76], [76, 26], [76, 51], [65, 60], [2, 21], [63, 38], [61, 44], [54, 23], [35, 47], [0, 41], [27, 15], [31, 13], [65, 32], [80, 10], [65, 38], [30, 12], [60, 10], [44, 21], [13, 79], [4, 34], [50, 65], [58, 22], [52, 51], [10, 60], [18, 56], [36, 21], [59, 2], [5, 74], [7, 67], [68, 21], [34, 15], [54, 25], [0, 35], [77, 24], [23, 20], [25, 41], [57, 68], [13, 73], [17, 45], [52, 53], [6, 18], [74, 61], [51, 68], [17, 36], [80, 63], [52, 12], [29, 20], [27, 60], [70, 67], [27, 8], [59, 14], [37, 69], [70, 80], [17, 12], [38, 72], [13, 75], [8, 11], [2, 42], [59, 44], [61, 22], [62, 14], [1, 18], [12, 80], [56, 76], [11, 35], [36, 45], [63, 33], [72, 2], [50, 5], [18, 61], [58, 14], [32, 38], [56, 0], [20, 6], [0, 34], [73, 5], [27, 53], [44, 41], [29, 8], [80, 50], [4, 9], [44, 52], [34, 41], [50, 17], [3, 3], [57, 12], [57, 66], [6, 65], [68, 50], [38, 59], [72, 3], [49, 1], [13, 10], [18, 64], [20, 46], [39, 53], [70, 74], [26, 40], [14, 18], [10, 9], [48, 15], [54, 6], [76, 78], [51, 36], [80, 21], [25, 77], [40, 75], [0, 71], [11, 34], [8, 66], [51, 33], [75, 13], [42, 18], [49, 62], [39, 70], [6, 31], [65, 24], [28, 70], [46, 18], [1, 4], [8, 0], [44, 10], [59, 59], [41, 12], [13, 65], [65, 33], [8, 59], [25, 27], [7, 28], [45, 61], [24, 76], [53, 40], [75, 24], [68, 39], [8, 33], [21, 56], [25, 75], [65, 72], [22, 23], [49, 51], [17, 6], [70, 79], [42, 66], [4, 40], [74, 28], [72, 7], [29, 9], [15, 5], [5, 30], [71, 36], [67, 55], [30, 26], [59, 40], [70, 16], [69, 44], [57, 71], [61, 5], [22, 57], [54, 39], [66, 25], [61, 73], [39, 79], [41, 47], [43, 72], [42, 31], [47, 51], [26, 6], [0, 53], [27, 26], [23, 6], [49, 4], [3, 64], [10, 28], [14, 72], [79, 67], [77, 31], [48, 66], [5, 14], [3, 34], [36, 1], [4, 6], [56, 71], [2, 65], [18, 39], [45, 19], [64, 73], [75, 77], [6, 17], [51, 1], [10, 1], [10, 41], [17, 61], [28, 62], [77, 44], [53, 2], [8, 40], [62, 38], [40, 33], [12, 50], [35, 0], [37, 45], [72, 55], [21, 78], [76, 37], [4, 45], [41, 31], [42, 46], [8, 18], [39, 19], [49, 33], [1, 15], [38, 25], [57, 8], [1, 3], [68, 71], [40, 37], [13, 63], [6, 24], [45, 21], [57, 57], [56, 52], [62, 44], [76, 29], [27, 30], [54, 34], [37, 80], [24, 5], [64, 66], [58, 4], [21, 33], [45, 38], [40, 65], [20, 61], [4, 12], [32, 59], [75, 78], [36, 54], [61, 0], [11, 30], [15, 15], [70, 6], [43, 55], [68, 51], [64, 70], [69, 49], [36, 57], [6, 16], [11, 2], [37, 2], [51, 70], [17, 9], [50, 64], [8, 24], [15, 21], [79, 36], [54, 78], [28, 40], [41, 57], [2, 48], [44, 31], [55, 75], [25, 7], [54, 68], [3, 16], [70, 54], [46, 67], [53, 20], [31, 70], [34, 64], [42, 11], [10, 65], [43, 24], [75, 25], [0, 60], [16, 64], [22, 45], [41, 1], [51, 5], [1, 71], [50, 47], [77, 79], [70, 75], [12, 72], [78, 69], [15, 3], [68, 41], [29, 64], [48, 54], [49, 59], [73, 9], [25, 62], [10, 13], [62, 40], [71, 14], [47, 25], [18, 33], [68, 80], [80, 9], [58, 54], [2, 46], [68, 22], [48, 9], [10, 36], [17, 72], [5, 21], [8, 3], [76, 65], [63, 39], [47, 65], [68, 55], [79, 62], [57, 70], [12, 41], [16, 3], [68, 6], [4, 68], [36, 77], [79, 69], [66, 72], [50, 20], [74, 31], [77, 70], [53, 18], [46, 25], [41, 74], [13, 39], [38, 28], [50, 79], [55, 79], [77, 68], [66, 39], [63, 65], [25, 61], [48, 78], [66, 40], [64, 26], [21, 42], [0, 39], [48, 35], [76, 44], [34, 51], [26, 51], [79, 65], [77, 72], [37, 43], [57, 36], [40, 62], [44, 70], [16, 43], [73, 55], [46, 3], [1, 58], [77, 29], [41, 17], [19, 8], [9, 78], [61, 34], [28, 54], [35, 44], [22, 4], [15, 27], [68, 64], [18, 44], [24, 30], [9, 3], [41, 64], [51, 52], [44, 53], [45, 36], [45, 73], [33, 34], [72, 67], [4, 79], [22, 30], [60, 18], [39, 61], [74, 3], [16, 49], [77, 45], [1, 40], [55, 80], [63, 67], [14, 66], [79, 17], [6, 50], [53, 21], [38, 31], [9, 63], [13, 26], [63, 19], [22, 49], [5, 13], [40, 5], [22, 43], [71, 29], [46, 46], [51, 51], [30, 68], [10, 26], [2, 71], [45, 33], [28, 73], [40, 26], [18, 31], [55, 72], [13, 36], [13, 7], [73, 58], [2, 51], [52, 21], [11, 1], [32, 52], [42, 39], [70, 29], [78, 76], [80, 67], [10, 38], [11, 14], [52, 57], [79, 6], [16, 11], [16, 51], [68, 62], [59, 10], [80, 23], [58, 61], [39, 52], [64, 11], [0, 38], [46, 34], [28, 13], [41, 56], [12, 43], [7, 59], [14, 19], [79, 73], [29, 29], [43, 18], [57, 62], [4, 76], [7, 39], [70, 53], [19, 77], [78, 4], [71, 41], [11, 54], [31, 26], [28, 67], [38, 19], [59, 11], [55, 4], [43, 35], [51, 26], [80, 13], [12, 24], [70, 62], [20, 56], [41, 52], [22, 65], [76, 2], [9, 79], [40, 10], [50, 11], [48, 24], [55, 67], [31, 16], [15, 79], [66, 79], [24, 16], [30, 0], [70, 39], [40, 7], [29, 44], [69, 10], [33, 28], [66, 35], [44, 72], [52, 22], [10, 72], [30, 21], [17, 18], [59, 22], [57, 32], [2, 57], [43, 44], [78, 39], [30, 17], [43, 41], [38, 56], [20, 11], [17, 7], [19, 45], [38, 68], [66, 27], [74, 46], [19, 15], [14, 48], [73, 6], [72, 59], [63, 45], [7, 25], [41, 24], [24, 80], [7, 31], [41, 26], [74, 21], [39, 25], [51, 20], [63, 13], [76, 76], [38, 20], [9, 16], [15, 52], [12, 73], [79, 68], [15, 45], [32, 65], [65, 39], [49, 15], [33, 27], [28, 6], [78, 75], [58, 74], [45, 55], [47, 71], [50, 68], [64, 52], [79, 13], [26, 41], [12, 37], [47, 2], [9, 6], [62, 72], [68, 47], [55, 53], [21, 13], [54, 29], [67, 76], [47, 18], [65, 78], [44, 25], [14, 56], [27, 7], [77, 34], [67, 63], [19, 20], [3, 25], [0, 40], [32, 78], [74, 67]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_2",
    "sat": "def sat(tri: List[int], edges=[[66, 30], [33, 62], [6, 20], [19, 92], [7, 89], [12, 5], [66, 79], [47, 27], [40, 82], [85, 20], [81, 53], [14, 41], [8, 73], [21, 57], [51, 85], [99, 44], [16, 85], [23, 86], [54, 86], [65, 85], [81, 29], [33, 72], [97, 90], [27, 59], [16, 33], [14, 38], [53, 1], [36, 78], [38, 44], [15, 60], [63, 76], [26, 88], [48, 37], [9, 8], [74, 67], [25, 13], [3, 41], [96, 31], [5, 44], [38, 97], [27, 3], [89, 11], [70, 61], [24, 23], [1, 61], [47, 62], [10, 68], [48, 45], [68, 27], [76, 23], [24, 48], [16, 16], [16, 42], [62, 61], [50, 58], [59, 74], [34, 33], [66, 32], [49, 40], [94, 28], [42, 47], [21, 13], [65, 16], [47, 24], [44, 31], [5, 16], [75, 63], [97, 70], [10, 80], [49, 58], [76, 58], [43, 25], [89, 43], [38, 56], [23, 16], [42, 79], [64, 28], [67, 5], [75, 68], [7, 25], [23, 55], [24, 27], [74, 88], [10, 62], [57, 21], [62, 81], [6, 59], [61, 95], [41, 81], [23, 66], [93, 85], [80, 59], [70, 52], [18, 76], [34, 89], [81, 98], [16, 41], [93, 95], [67, 38], [95, 98], [91, 33], [87, 16], [66, 20], [34, 91], [9, 87], [7, 76], [21, 20], [61, 68], [67, 46], [26, 94], [19, 83], [75, 29], [21, 49], [63, 34], [69, 74], [20, 64], [62, 93], [58, 55], [38, 54], [19, 8], [57, 53], [90, 64], [76, 29], [16, 50], [60, 83], [33, 58], [65, 76], [71, 74], [3, 56], [74, 37], [15, 73], [15, 19], [54, 16], [60, 15], [17, 44], [35, 37], [38, 88], [43, 45], [16, 59], [77, 92], [31, 64], [10, 43], [87, 48], [67, 85], [32, 37], [88, 48], [3, 97], [71, 31], [62, 79], [52, 44], [62, 27], [9, 63], [97, 88], [50, 7], [74, 35], [23, 91], [20, 30], [12, 17], [52, 0], [13, 25], [17, 96], [89, 14], [21, 48], [55, 60], [71, 37], [69, 94], [38, 95], [10, 87], [98, 54], [68, 31], [60, 86], [39, 84], [14, 11], [91, 81], [12, 83], [15, 85], [9, 69], [29, 6], [90, 73], [44, 54], [91, 1], [48, 94], [71, 49], [67, 45], [4, 74], [85, 44], [27, 57], [11, 32], [70, 49], [94, 20], [25, 91], [48, 83], [86, 62], [90, 59], [34, 75], [18, 3], [54, 19], [32, 5], [94, 53], [57, 92], [47, 64], [28, 5], [25, 52], [98, 79], [97, 98], [38, 31], [82, 36], [12, 74], [2, 48], [31, 79], [47, 4], [42, 42], [79, 57], [20, 57], [58, 49], [56, 45], [65, 96], [26, 61], [28, 11], [22, 95], [72, 73], [70, 80], [49, 35], [4, 49], [4, 57], [21, 31], [15, 84], [64, 32], [61, 22], [22, 28], [29, 98], [51, 82], [24, 62], [95, 62], [15, 95], [60, 24], [20, 39], [31, 5], [13, 53], [66, 15], [16, 21], [46, 94], [52, 22], [14, 61], [75, 53], [34, 95], [83, 10], [95, 92], [81, 30], [21, 29], [50, 26], [10, 5], [86, 69], [72, 70], [24, 29], [42, 29], [25, 6], [32, 12], [80, 17], [19, 86], [99, 38], [36, 22], [48, 35], [47, 63], [11, 1], [83, 99], [50, 67], [64, 43], [45, 11], [40, 31], [65, 42], [82, 81], [11, 13], [67, 98], [26, 53], [90, 46], [36, 77], [81, 54], [62, 78], [98, 78], [87, 85], [12, 77], [48, 67], [91, 44], [16, 74], [95, 25], [9, 24], [77, 5], [98, 56], [31, 63], [85, 31], [41, 56], [66, 40], [35, 56], [35, 59], [20, 3], [3, 45], [23, 73], [2, 33], [98, 0], [90, 93], [19, 12], [14, 31], [19, 50], [49, 51], [6, 24], [97, 65], [78, 90], [37, 82], [2, 30], [5, 28], [77, 71], [60, 70], [3, 70], [65, 77], [31, 0], [91, 32], [21, 12], [45, 57], [21, 19], [66, 96], [19, 48], [98, 36], [35, 52], [68, 35], [66, 72], [88, 65], [41, 97], [69, 99], [73, 50], [70, 71], [8, 55], [90, 81], [54, 66], [7, 80], [54, 61], [29, 52], [44, 16], [57, 49], [2, 2], [72, 17], [75, 12], [12, 97], [17, 37], [70, 79], [77, 49], [13, 27], [5, 95], [82, 90], [44, 53], [31, 21], [52, 49], [86, 82], [57, 48], [41, 44], [30, 47], [22, 24], [47, 37], [58, 65], [18, 97], [46, 35], [36, 26], [57, 45], [69, 20], [54, 15], [42, 55], [19, 49], [0, 8], [16, 39], [69, 54], [33, 18], [51, 23], [72, 84], [28, 24], [90, 54], [23, 83], [63, 51], [22, 96], [56, 62], [7, 85], [59, 41], [92, 64], [59, 92], [64, 73], [45, 71], [48, 38], [98, 84], [93, 15], [32, 64], [43, 75], [78, 0], [63, 92], [56, 48], [98, 27], [70, 83], [68, 14], [77, 87], [1, 96], [62, 32], [72, 4], [79, 27], [24, 80], [3, 11], [15, 28], [96, 11], [37, 1], [73, 6], [27, 28], [87, 70], [16, 53], [83, 17], [78, 30], [48, 21], [60, 17], [55, 47], [73, 91], [87, 29], [61, 9], [48, 86], [24, 39], [9, 0], [78, 72], [96, 26], [39, 44], [82, 77], [63, 36], [84, 21], [34, 99], [90, 90], [64, 61], [91, 9], [95, 8], [50, 79], [61, 99], [40, 39], [29, 38], [29, 50], [62, 30], [65, 64], [24, 90], [10, 53], [97, 94], [0, 65], [55, 52], [13, 41], [99, 22], [89, 91], [72, 6], [12, 59], [68, 95], [50, 3], [34, 6], [44, 3], [24, 55], [46, 40], [18, 32], [26, 69], [35, 97], [62, 13], [90, 48], [70, 67], [9, 34], [18, 67], [8, 18], [99, 58], [70, 94], [17, 52], [13, 73], [10, 65], [2, 22], [89, 97], [66, 58], [22, 58], [0, 69], [96, 59], [37, 27], [79, 84], [71, 46], [32, 92], [40, 76], [61, 41], [54, 87], [51, 43], [67, 88], [24, 91], [96, 44], [46, 51], [74, 24], [10, 48], [44, 72], [83, 40], [86, 91], [27, 16], [36, 98], [26, 10], [95, 95], [73, 68], [7, 72], [6, 93], [17, 32], [67, 84], [29, 95], [96, 16], [89, 84], [87, 36], [63, 59], [0, 62], [19, 20], [33, 89], [11, 12], [25, 60], [82, 83], [33, 56], [52, 84], [75, 15], [45, 45], [88, 36], [49, 6], [82, 34], [86, 96], [29, 36], [85, 76], [47, 90], [49, 29], [66, 35], [76, 10], [68, 58], [73, 93], [40, 20], [20, 58], [32, 71], [11, 40], [25, 31], [20, 82], [21, 2], [97, 96], [56, 16], [51, 93], [6, 74], [57, 62], [94, 9], [13, 60], [1, 6], [7, 65], [89, 99], [45, 37], [26, 7], [69, 25], [80, 76], [41, 98], [71, 9], [88, 94], [52, 88], [11, 76], [77, 15], [39, 76], [42, 3], [56, 79], [20, 74], [5, 41], [39, 62], [33, 64], [18, 95], [83, 85], [57, 69], [30, 63], [42, 20], [74, 7], [90, 32], [44, 69], [84, 13], [47, 65], [96, 82], [41, 93], [40, 98], [48, 14], [5, 7], [47, 25], [30, 18], [18, 68], [23, 5], [54, 82], [53, 43], [11, 47], [68, 33], [66, 66], [84, 66], [45, 25], [14, 87], [85, 91], [43, 71], [13, 10], [64, 63], [76, 42], [97, 69], [56, 88], [8, 33], [12, 66], [38, 49], [64, 2], [67, 15], [35, 57], [39, 56], [38, 50], [63, 4], [95, 67], [2, 26], [98, 8], [25, 15], [70, 90], [84, 51], [85, 18], [17, 15], [19, 45], [92, 50], [27, 43], [53, 8], [98, 20], [92, 14], [63, 22], [38, 48], [6, 40], [95, 50], [78, 71], [31, 4], [59, 39], [43, 87], [57, 72], [78, 58], [17, 56], [27, 4], [43, 86], [23, 9], [51, 12], [51, 41], [83, 98], [44, 75], [34, 62], [45, 60], [22, 18], [84, 44], [79, 4], [29, 42], [95, 5], [57, 33], [41, 37], [32, 68], [35, 75], [96, 74], [38, 7], [33, 96], [97, 51], [79, 28], [88, 87], [1, 54], [50, 48], [86, 50], [9, 93], [94, 83], [63, 75], [11, 75], [98, 45], [73, 71], [36, 30], [39, 47], [26, 44], [37, 87], [69, 53], [3, 47], [30, 20], [53, 11], [70, 54], [37, 92], [7, 70], [71, 59], [20, 77], [76, 30], [86, 93], [67, 30], [46, 16], [45, 92], [4, 50], [53, 21], [24, 84], [88, 30], [49, 19], [80, 68], [14, 81], [0, 37], [39, 90], [63, 97], [96, 56], [62, 38], [51, 97], [23, 50], [2, 83], [99, 86], [7, 34], [99, 80], [80, 1], [41, 49], [66, 89], [88, 82], [43, 90], [68, 43], [30, 3], [2, 21], [65, 63], [47, 10], [43, 53], [67, 60], [44, 56], [34, 97], [50, 83], [59, 21], [8, 63], [16, 32], [74, 1], [12, 81], [83, 24], [41, 65], [3, 3], [19, 30], [22, 92], [85, 46], [53, 66], [1, 94], [86, 45], [10, 13], [52, 33], [90, 43], [43, 30], [99, 48], [16, 99], [45, 65], [51, 84], [14, 82], [41, 84], [91, 25], [89, 53], [63, 98], [0, 36], [54, 40], [25, 95], [87, 54], [99, 47], [10, 59], [8, 51], [76, 57], [92, 77], [41, 72], [98, 63], [25, 20], [66, 54], [56, 76], [63, 52], [85, 86], [57, 15], [40, 86], [78, 2], [87, 4], [65, 58], [93, 71], [57, 78], [81, 5], [44, 0], [11, 3], [58, 4], [26, 50], [56, 12], [37, 34], [88, 49], [17, 11], [1, 51], [88, 42], [98, 5], [27, 56], [29, 26], [20, 71], [25, 42], [82, 6], [70, 27], [40, 90], [91, 95], [80, 84], [77, 17], [84, 9], [22, 1], [20, 40], [19, 41], [7, 38], [87, 23], [75, 21], [43, 50], [34, 41], [21, 51], [51, 38], [2, 77], [95, 89], [22, 7], [37, 86], [7, 79], [46, 52], [60, 0]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[66, 30], [33, 62], [6, 20], [19, 92], [7, 89], [12, 5], [66, 79], [47, 27], [40, 82], [85, 20], [81, 53], [14, 41], [8, 73], [21, 57], [51, 85], [99, 44], [16, 85], [23, 86], [54, 86], [65, 85], [81, 29], [33, 72], [97, 90], [27, 59], [16, 33], [14, 38], [53, 1], [36, 78], [38, 44], [15, 60], [63, 76], [26, 88], [48, 37], [9, 8], [74, 67], [25, 13], [3, 41], [96, 31], [5, 44], [38, 97], [27, 3], [89, 11], [70, 61], [24, 23], [1, 61], [47, 62], [10, 68], [48, 45], [68, 27], [76, 23], [24, 48], [16, 16], [16, 42], [62, 61], [50, 58], [59, 74], [34, 33], [66, 32], [49, 40], [94, 28], [42, 47], [21, 13], [65, 16], [47, 24], [44, 31], [5, 16], [75, 63], [97, 70], [10, 80], [49, 58], [76, 58], [43, 25], [89, 43], [38, 56], [23, 16], [42, 79], [64, 28], [67, 5], [75, 68], [7, 25], [23, 55], [24, 27], [74, 88], [10, 62], [57, 21], [62, 81], [6, 59], [61, 95], [41, 81], [23, 66], [93, 85], [80, 59], [70, 52], [18, 76], [34, 89], [81, 98], [16, 41], [93, 95], [67, 38], [95, 98], [91, 33], [87, 16], [66, 20], [34, 91], [9, 87], [7, 76], [21, 20], [61, 68], [67, 46], [26, 94], [19, 83], [75, 29], [21, 49], [63, 34], [69, 74], [20, 64], [62, 93], [58, 55], [38, 54], [19, 8], [57, 53], [90, 64], [76, 29], [16, 50], [60, 83], [33, 58], [65, 76], [71, 74], [3, 56], [74, 37], [15, 73], [15, 19], [54, 16], [60, 15], [17, 44], [35, 37], [38, 88], [43, 45], [16, 59], [77, 92], [31, 64], [10, 43], [87, 48], [67, 85], [32, 37], [88, 48], [3, 97], [71, 31], [62, 79], [52, 44], [62, 27], [9, 63], [97, 88], [50, 7], [74, 35], [23, 91], [20, 30], [12, 17], [52, 0], [13, 25], [17, 96], [89, 14], [21, 48], [55, 60], [71, 37], [69, 94], [38, 95], [10, 87], [98, 54], [68, 31], [60, 86], [39, 84], [14, 11], [91, 81], [12, 83], [15, 85], [9, 69], [29, 6], [90, 73], [44, 54], [91, 1], [48, 94], [71, 49], [67, 45], [4, 74], [85, 44], [27, 57], [11, 32], [70, 49], [94, 20], [25, 91], [48, 83], [86, 62], [90, 59], [34, 75], [18, 3], [54, 19], [32, 5], [94, 53], [57, 92], [47, 64], [28, 5], [25, 52], [98, 79], [97, 98], [38, 31], [82, 36], [12, 74], [2, 48], [31, 79], [47, 4], [42, 42], [79, 57], [20, 57], [58, 49], [56, 45], [65, 96], [26, 61], [28, 11], [22, 95], [72, 73], [70, 80], [49, 35], [4, 49], [4, 57], [21, 31], [15, 84], [64, 32], [61, 22], [22, 28], [29, 98], [51, 82], [24, 62], [95, 62], [15, 95], [60, 24], [20, 39], [31, 5], [13, 53], [66, 15], [16, 21], [46, 94], [52, 22], [14, 61], [75, 53], [34, 95], [83, 10], [95, 92], [81, 30], [21, 29], [50, 26], [10, 5], [86, 69], [72, 70], [24, 29], [42, 29], [25, 6], [32, 12], [80, 17], [19, 86], [99, 38], [36, 22], [48, 35], [47, 63], [11, 1], [83, 99], [50, 67], [64, 43], [45, 11], [40, 31], [65, 42], [82, 81], [11, 13], [67, 98], [26, 53], [90, 46], [36, 77], [81, 54], [62, 78], [98, 78], [87, 85], [12, 77], [48, 67], [91, 44], [16, 74], [95, 25], [9, 24], [77, 5], [98, 56], [31, 63], [85, 31], [41, 56], [66, 40], [35, 56], [35, 59], [20, 3], [3, 45], [23, 73], [2, 33], [98, 0], [90, 93], [19, 12], [14, 31], [19, 50], [49, 51], [6, 24], [97, 65], [78, 90], [37, 82], [2, 30], [5, 28], [77, 71], [60, 70], [3, 70], [65, 77], [31, 0], [91, 32], [21, 12], [45, 57], [21, 19], [66, 96], [19, 48], [98, 36], [35, 52], [68, 35], [66, 72], [88, 65], [41, 97], [69, 99], [73, 50], [70, 71], [8, 55], [90, 81], [54, 66], [7, 80], [54, 61], [29, 52], [44, 16], [57, 49], [2, 2], [72, 17], [75, 12], [12, 97], [17, 37], [70, 79], [77, 49], [13, 27], [5, 95], [82, 90], [44, 53], [31, 21], [52, 49], [86, 82], [57, 48], [41, 44], [30, 47], [22, 24], [47, 37], [58, 65], [18, 97], [46, 35], [36, 26], [57, 45], [69, 20], [54, 15], [42, 55], [19, 49], [0, 8], [16, 39], [69, 54], [33, 18], [51, 23], [72, 84], [28, 24], [90, 54], [23, 83], [63, 51], [22, 96], [56, 62], [7, 85], [59, 41], [92, 64], [59, 92], [64, 73], [45, 71], [48, 38], [98, 84], [93, 15], [32, 64], [43, 75], [78, 0], [63, 92], [56, 48], [98, 27], [70, 83], [68, 14], [77, 87], [1, 96], [62, 32], [72, 4], [79, 27], [24, 80], [3, 11], [15, 28], [96, 11], [37, 1], [73, 6], [27, 28], [87, 70], [16, 53], [83, 17], [78, 30], [48, 21], [60, 17], [55, 47], [73, 91], [87, 29], [61, 9], [48, 86], [24, 39], [9, 0], [78, 72], [96, 26], [39, 44], [82, 77], [63, 36], [84, 21], [34, 99], [90, 90], [64, 61], [91, 9], [95, 8], [50, 79], [61, 99], [40, 39], [29, 38], [29, 50], [62, 30], [65, 64], [24, 90], [10, 53], [97, 94], [0, 65], [55, 52], [13, 41], [99, 22], [89, 91], [72, 6], [12, 59], [68, 95], [50, 3], [34, 6], [44, 3], [24, 55], [46, 40], [18, 32], [26, 69], [35, 97], [62, 13], [90, 48], [70, 67], [9, 34], [18, 67], [8, 18], [99, 58], [70, 94], [17, 52], [13, 73], [10, 65], [2, 22], [89, 97], [66, 58], [22, 58], [0, 69], [96, 59], [37, 27], [79, 84], [71, 46], [32, 92], [40, 76], [61, 41], [54, 87], [51, 43], [67, 88], [24, 91], [96, 44], [46, 51], [74, 24], [10, 48], [44, 72], [83, 40], [86, 91], [27, 16], [36, 98], [26, 10], [95, 95], [73, 68], [7, 72], [6, 93], [17, 32], [67, 84], [29, 95], [96, 16], [89, 84], [87, 36], [63, 59], [0, 62], [19, 20], [33, 89], [11, 12], [25, 60], [82, 83], [33, 56], [52, 84], [75, 15], [45, 45], [88, 36], [49, 6], [82, 34], [86, 96], [29, 36], [85, 76], [47, 90], [49, 29], [66, 35], [76, 10], [68, 58], [73, 93], [40, 20], [20, 58], [32, 71], [11, 40], [25, 31], [20, 82], [21, 2], [97, 96], [56, 16], [51, 93], [6, 74], [57, 62], [94, 9], [13, 60], [1, 6], [7, 65], [89, 99], [45, 37], [26, 7], [69, 25], [80, 76], [41, 98], [71, 9], [88, 94], [52, 88], [11, 76], [77, 15], [39, 76], [42, 3], [56, 79], [20, 74], [5, 41], [39, 62], [33, 64], [18, 95], [83, 85], [57, 69], [30, 63], [42, 20], [74, 7], [90, 32], [44, 69], [84, 13], [47, 65], [96, 82], [41, 93], [40, 98], [48, 14], [5, 7], [47, 25], [30, 18], [18, 68], [23, 5], [54, 82], [53, 43], [11, 47], [68, 33], [66, 66], [84, 66], [45, 25], [14, 87], [85, 91], [43, 71], [13, 10], [64, 63], [76, 42], [97, 69], [56, 88], [8, 33], [12, 66], [38, 49], [64, 2], [67, 15], [35, 57], [39, 56], [38, 50], [63, 4], [95, 67], [2, 26], [98, 8], [25, 15], [70, 90], [84, 51], [85, 18], [17, 15], [19, 45], [92, 50], [27, 43], [53, 8], [98, 20], [92, 14], [63, 22], [38, 48], [6, 40], [95, 50], [78, 71], [31, 4], [59, 39], [43, 87], [57, 72], [78, 58], [17, 56], [27, 4], [43, 86], [23, 9], [51, 12], [51, 41], [83, 98], [44, 75], [34, 62], [45, 60], [22, 18], [84, 44], [79, 4], [29, 42], [95, 5], [57, 33], [41, 37], [32, 68], [35, 75], [96, 74], [38, 7], [33, 96], [97, 51], [79, 28], [88, 87], [1, 54], [50, 48], [86, 50], [9, 93], [94, 83], [63, 75], [11, 75], [98, 45], [73, 71], [36, 30], [39, 47], [26, 44], [37, 87], [69, 53], [3, 47], [30, 20], [53, 11], [70, 54], [37, 92], [7, 70], [71, 59], [20, 77], [76, 30], [86, 93], [67, 30], [46, 16], [45, 92], [4, 50], [53, 21], [24, 84], [88, 30], [49, 19], [80, 68], [14, 81], [0, 37], [39, 90], [63, 97], [96, 56], [62, 38], [51, 97], [23, 50], [2, 83], [99, 86], [7, 34], [99, 80], [80, 1], [41, 49], [66, 89], [88, 82], [43, 90], [68, 43], [30, 3], [2, 21], [65, 63], [47, 10], [43, 53], [67, 60], [44, 56], [34, 97], [50, 83], [59, 21], [8, 63], [16, 32], [74, 1], [12, 81], [83, 24], [41, 65], [3, 3], [19, 30], [22, 92], [85, 46], [53, 66], [1, 94], [86, 45], [10, 13], [52, 33], [90, 43], [43, 30], [99, 48], [16, 99], [45, 65], [51, 84], [14, 82], [41, 84], [91, 25], [89, 53], [63, 98], [0, 36], [54, 40], [25, 95], [87, 54], [99, 47], [10, 59], [8, 51], [76, 57], [92, 77], [41, 72], [98, 63], [25, 20], [66, 54], [56, 76], [63, 52], [85, 86], [57, 15], [40, 86], [78, 2], [87, 4], [65, 58], [93, 71], [57, 78], [81, 5], [44, 0], [11, 3], [58, 4], [26, 50], [56, 12], [37, 34], [88, 49], [17, 11], [1, 51], [88, 42], [98, 5], [27, 56], [29, 26], [20, 71], [25, 42], [82, 6], [70, 27], [40, 90], [91, 95], [80, 84], [77, 17], [84, 9], [22, 1], [20, 40], [19, 41], [7, 38], [87, 23], [75, 21], [43, 50], [34, 41], [21, 51], [51, 38], [2, 77], [95, 89], [22, 7], [37, 86], [7, 79], [46, 52], [60, 0]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_3",
    "sat": "def sat(tri: List[int], edges=[[1, 2], [2, 2], [2, 0], [1, 1], [0, 0], [0, 1], [2, 1]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[1, 2], [2, 2], [2, 0], [1, 1], [0, 0], [0, 1], [2, 1]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_4",
    "sat": "def sat(tri: List[int], edges=[[0, 1], [1, 3], [0, 0], [2, 2], [2, 1], [1, 1], [3, 3], [1, 0], [3, 0], [0, 3], [2, 0], [1, 2]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[0, 1], [1, 3], [0, 0], [2, 2], [2, 1], [1, 1], [3, 3], [1, 0], [3, 0], [0, 3], [2, 0], [1, 2]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_5",
    "sat": "def sat(tri: List[int], edges=[[53, 60], [66, 66], [35, 73], [27, 19], [26, 13], [69, 36], [23, 34], [64, 2], [44, 0], [42, 45], [16, 51], [3, 4], [15, 46], [27, 43], [54, 0], [5, 52], [24, 55], [68, 36], [21, 0], [64, 23], [21, 69], [41, 26], [5, 49], [60, 67], [42, 17], [16, 74], [65, 72], [37, 23], [32, 17], [33, 3], [14, 71], [61, 2], [44, 72], [38, 58], [69, 51], [60, 64], [5, 41], [21, 54], [33, 45], [45, 12], [40, 62], [37, 21], [15, 49], [5, 24], [39, 17], [8, 22], [6, 24], [29, 6], [3, 5], [51, 23], [5, 21], [66, 44], [62, 42], [14, 4], [32, 44], [66, 73], [36, 4], [26, 41], [66, 45], [10, 16], [1, 0], [69, 68], [30, 68], [7, 18], [55, 37], [31, 14], [63, 15], [44, 14], [21, 26], [10, 53], [39, 47], [17, 23], [26, 73], [54, 15], [66, 37], [7, 16], [40, 46], [62, 69], [56, 36], [45, 0], [66, 48], [60, 25], [10, 11], [43, 23], [36, 13], [52, 17], [47, 8], [18, 35], [1, 35], [26, 10], [18, 33], [63, 47], [43, 9], [35, 60], [74, 27], [66, 7], [69, 21], [70, 62], [37, 15], [59, 0], [1, 11], [30, 42], [29, 57], [58, 16], [54, 20], [18, 40], [8, 43], [38, 71], [61, 62], [64, 13], [52, 44], [28, 56], [68, 51], [8, 16], [39, 9], [24, 38], [53, 67], [22, 40], [43, 17], [2, 58], [56, 70], [50, 23], [35, 38], [47, 52], [27, 57], [9, 48], [68, 19], [5, 9], [43, 24], [64, 8], [20, 21], [4, 67], [17, 59], [40, 43], [28, 49], [27, 11], [29, 2], [44, 73], [21, 36], [73, 25], [33, 50], [60, 58], [53, 48], [4, 36], [64, 69], [70, 4], [45, 33], [4, 54], [14, 37], [28, 39], [7, 33], [17, 22], [45, 48], [34, 55], [73, 24], [16, 1], [52, 49], [32, 73], [30, 2], [20, 32], [13, 65], [24, 48], [17, 73], [24, 19], [60, 14], [0, 18], [26, 44], [2, 18], [51, 18], [40, 34], [48, 57], [18, 21], [48, 44], [27, 20], [70, 8], [31, 49], [59, 1], [55, 57], [37, 26], [67, 13], [2, 22], [34, 19], [38, 46], [53, 37], [25, 27], [31, 7], [7, 15], [55, 65], [5, 27], [63, 16], [17, 70], [33, 20], [35, 33], [27, 49], [26, 45], [63, 23], [71, 14], [19, 71], [28, 52], [2, 47], [45, 41], [49, 67], [70, 40], [32, 48], [69, 14], [20, 63], [35, 6], [50, 69], [43, 58], [55, 20], [61, 8], [47, 44], [73, 2], [25, 18], [68, 7], [54, 67], [47, 57], [39, 63], [65, 66], [33, 48], [58, 19], [57, 2], [13, 33], [12, 15], [42, 25], [26, 26], [25, 59], [64, 59], [66, 9], [23, 7], [73, 72], [21, 50], [38, 35], [67, 60], [73, 66], [35, 54], [45, 4], [71, 56], [60, 55], [39, 28], [0, 17], [60, 6], [25, 1], [51, 57], [62, 41], [13, 32], [33, 34], [18, 71], [51, 12], [62, 29], [6, 59], [73, 36], [2, 0], [22, 37], [18, 56], [10, 48], [35, 42], [55, 53], [5, 5], [65, 62], [58, 22], [15, 70], [26, 72], [72, 48], [42, 56], [73, 7], [50, 27], [44, 17], [13, 39], [37, 48], [32, 51], [51, 44], [60, 24], [27, 26], [44, 62], [58, 48], [71, 43], [57, 62], [53, 0], [14, 69], [73, 5], [25, 53], [33, 36], [6, 53], [26, 3], [31, 12], [26, 39], [64, 32], [4, 66], [3, 51], [67, 24], [16, 3], [58, 55], [46, 44], [67, 62], [59, 36], [21, 51], [11, 34], [68, 24], [2, 56], [25, 19], [66, 13], [60, 59], [7, 20], [16, 18], [50, 64], [6, 60], [37, 71], [71, 4], [67, 43], [39, 24], [37, 5], [31, 2], [27, 40], [40, 40], [65, 1], [19, 18], [34, 45], [40, 36], [18, 65], [14, 30], [45, 36], [6, 19], [57, 53], [49, 36], [38, 5], [7, 29], [32, 70], [60, 18], [21, 63], [6, 23], [17, 56], [36, 2], [34, 26], [60, 45], [67, 17], [9, 27], [4, 68], [49, 70], [0, 56], [22, 24], [68, 67], [2, 49], [65, 24], [41, 50], [1, 4], [50, 51], [39, 35], [11, 25], [49, 30], [71, 41], [35, 68], [37, 57], [55, 58], [69, 10], [62, 60], [61, 18], [39, 67], [58, 57], [74, 15], [10, 68], [60, 61], [46, 56], [49, 73], [18, 2], [57, 13], [60, 70], [68, 2], [24, 35], [73, 52], [16, 27], [42, 48], [26, 68], [15, 56], [29, 20], [56, 59], [40, 10], [45, 58], [18, 50], [29, 40], [23, 61], [0, 12], [41, 12], [69, 25], [50, 30], [42, 68], [52, 66], [16, 43], [39, 19], [29, 36], [54, 33], [36, 44], [55, 67], [32, 67], [4, 33], [0, 9], [5, 23], [4, 73], [21, 18], [35, 2], [53, 50], [43, 21], [43, 27], [32, 4], [20, 19], [30, 57], [4, 1], [52, 59], [6, 34], [48, 0], [6, 9], [22, 73], [38, 48], [20, 59], [48, 25], [7, 50], [40, 41], [64, 18], [12, 12], [4, 22], [47, 31], [1, 51], [66, 6], [10, 24], [51, 72], [57, 70], [17, 14], [39, 34], [13, 21], [19, 45], [12, 23], [41, 53], [58, 60], [59, 41], [68, 43], [59, 51], [58, 20], [50, 74], [14, 5], [29, 4], [1, 62], [12, 38], [54, 43], [22, 61], [6, 57], [45, 11], [38, 59], [59, 42], [61, 33], [10, 69], [56, 43], [32, 7], [54, 19], [52, 71], [38, 62], [72, 16], [36, 8], [24, 47], [71, 24], [46, 5], [62, 28], [29, 74], [67, 74], [8, 13], [16, 14], [29, 52], [36, 56], [5, 25], [61, 23], [23, 35], [50, 33], [69, 32], [22, 4], [19, 22], [44, 66], [23, 10], [73, 30], [64, 61], [22, 20], [29, 33], [57, 43], [53, 73], [0, 53], [11, 47], [1, 43], [4, 35], [26, 8], [64, 74], [69, 64], [71, 45], [38, 63], [58, 47], [64, 21], [52, 38], [31, 53], [39, 46], [58, 59], [15, 55], [41, 10], [33, 46], [33, 1], [18, 48], [62, 52], [9, 9], [55, 52], [2, 38], [71, 48], [56, 73], [66, 41], [57, 27], [14, 50], [5, 71], [14, 23], [70, 17], [74, 2], [45, 57], [72, 12], [31, 64], [69, 61], [19, 67], [43, 44], [39, 36], [44, 57], [44, 19], [1, 39], [64, 48], [48, 68], [34, 65], [46, 70], [55, 7], [42, 49], [9, 12], [60, 13], [68, 69], [71, 39], [58, 2], [50, 45], [29, 70], [10, 40], [22, 13], [25, 54], [23, 56], [34, 29], [44, 64], [50, 14], [62, 50], [52, 32], [32, 33], [13, 60], [12, 72], [14, 22], [71, 49], [58, 4], [46, 10], [35, 0], [43, 60], [33, 57], [42, 69], [42, 41], [4, 10], [12, 62], [14, 9], [16, 15], [11, 38], [63, 40], [40, 21], [24, 54], [58, 72], [3, 35], [9, 58], [73, 8], [58, 43], [69, 37], [44, 43], [23, 29], [23, 33], [67, 51], [21, 29], [30, 24], [63, 37], [1, 24], [66, 57], [30, 58], [74, 57], [33, 54], [61, 32], [46, 11], [44, 49], [50, 40], [70, 20], [2, 1], [65, 18], [25, 55], [22, 3], [71, 50], [62, 23], [60, 57], [73, 0], [68, 56], [16, 24], [5, 36], [62, 49], [51, 35], [52, 42], [67, 30], [58, 11], [26, 42], [8, 34], [7, 17], [65, 43], [32, 38], [57, 73], [27, 18]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[53, 60], [66, 66], [35, 73], [27, 19], [26, 13], [69, 36], [23, 34], [64, 2], [44, 0], [42, 45], [16, 51], [3, 4], [15, 46], [27, 43], [54, 0], [5, 52], [24, 55], [68, 36], [21, 0], [64, 23], [21, 69], [41, 26], [5, 49], [60, 67], [42, 17], [16, 74], [65, 72], [37, 23], [32, 17], [33, 3], [14, 71], [61, 2], [44, 72], [38, 58], [69, 51], [60, 64], [5, 41], [21, 54], [33, 45], [45, 12], [40, 62], [37, 21], [15, 49], [5, 24], [39, 17], [8, 22], [6, 24], [29, 6], [3, 5], [51, 23], [5, 21], [66, 44], [62, 42], [14, 4], [32, 44], [66, 73], [36, 4], [26, 41], [66, 45], [10, 16], [1, 0], [69, 68], [30, 68], [7, 18], [55, 37], [31, 14], [63, 15], [44, 14], [21, 26], [10, 53], [39, 47], [17, 23], [26, 73], [54, 15], [66, 37], [7, 16], [40, 46], [62, 69], [56, 36], [45, 0], [66, 48], [60, 25], [10, 11], [43, 23], [36, 13], [52, 17], [47, 8], [18, 35], [1, 35], [26, 10], [18, 33], [63, 47], [43, 9], [35, 60], [74, 27], [66, 7], [69, 21], [70, 62], [37, 15], [59, 0], [1, 11], [30, 42], [29, 57], [58, 16], [54, 20], [18, 40], [8, 43], [38, 71], [61, 62], [64, 13], [52, 44], [28, 56], [68, 51], [8, 16], [39, 9], [24, 38], [53, 67], [22, 40], [43, 17], [2, 58], [56, 70], [50, 23], [35, 38], [47, 52], [27, 57], [9, 48], [68, 19], [5, 9], [43, 24], [64, 8], [20, 21], [4, 67], [17, 59], [40, 43], [28, 49], [27, 11], [29, 2], [44, 73], [21, 36], [73, 25], [33, 50], [60, 58], [53, 48], [4, 36], [64, 69], [70, 4], [45, 33], [4, 54], [14, 37], [28, 39], [7, 33], [17, 22], [45, 48], [34, 55], [73, 24], [16, 1], [52, 49], [32, 73], [30, 2], [20, 32], [13, 65], [24, 48], [17, 73], [24, 19], [60, 14], [0, 18], [26, 44], [2, 18], [51, 18], [40, 34], [48, 57], [18, 21], [48, 44], [27, 20], [70, 8], [31, 49], [59, 1], [55, 57], [37, 26], [67, 13], [2, 22], [34, 19], [38, 46], [53, 37], [25, 27], [31, 7], [7, 15], [55, 65], [5, 27], [63, 16], [17, 70], [33, 20], [35, 33], [27, 49], [26, 45], [63, 23], [71, 14], [19, 71], [28, 52], [2, 47], [45, 41], [49, 67], [70, 40], [32, 48], [69, 14], [20, 63], [35, 6], [50, 69], [43, 58], [55, 20], [61, 8], [47, 44], [73, 2], [25, 18], [68, 7], [54, 67], [47, 57], [39, 63], [65, 66], [33, 48], [58, 19], [57, 2], [13, 33], [12, 15], [42, 25], [26, 26], [25, 59], [64, 59], [66, 9], [23, 7], [73, 72], [21, 50], [38, 35], [67, 60], [73, 66], [35, 54], [45, 4], [71, 56], [60, 55], [39, 28], [0, 17], [60, 6], [25, 1], [51, 57], [62, 41], [13, 32], [33, 34], [18, 71], [51, 12], [62, 29], [6, 59], [73, 36], [2, 0], [22, 37], [18, 56], [10, 48], [35, 42], [55, 53], [5, 5], [65, 62], [58, 22], [15, 70], [26, 72], [72, 48], [42, 56], [73, 7], [50, 27], [44, 17], [13, 39], [37, 48], [32, 51], [51, 44], [60, 24], [27, 26], [44, 62], [58, 48], [71, 43], [57, 62], [53, 0], [14, 69], [73, 5], [25, 53], [33, 36], [6, 53], [26, 3], [31, 12], [26, 39], [64, 32], [4, 66], [3, 51], [67, 24], [16, 3], [58, 55], [46, 44], [67, 62], [59, 36], [21, 51], [11, 34], [68, 24], [2, 56], [25, 19], [66, 13], [60, 59], [7, 20], [16, 18], [50, 64], [6, 60], [37, 71], [71, 4], [67, 43], [39, 24], [37, 5], [31, 2], [27, 40], [40, 40], [65, 1], [19, 18], [34, 45], [40, 36], [18, 65], [14, 30], [45, 36], [6, 19], [57, 53], [49, 36], [38, 5], [7, 29], [32, 70], [60, 18], [21, 63], [6, 23], [17, 56], [36, 2], [34, 26], [60, 45], [67, 17], [9, 27], [4, 68], [49, 70], [0, 56], [22, 24], [68, 67], [2, 49], [65, 24], [41, 50], [1, 4], [50, 51], [39, 35], [11, 25], [49, 30], [71, 41], [35, 68], [37, 57], [55, 58], [69, 10], [62, 60], [61, 18], [39, 67], [58, 57], [74, 15], [10, 68], [60, 61], [46, 56], [49, 73], [18, 2], [57, 13], [60, 70], [68, 2], [24, 35], [73, 52], [16, 27], [42, 48], [26, 68], [15, 56], [29, 20], [56, 59], [40, 10], [45, 58], [18, 50], [29, 40], [23, 61], [0, 12], [41, 12], [69, 25], [50, 30], [42, 68], [52, 66], [16, 43], [39, 19], [29, 36], [54, 33], [36, 44], [55, 67], [32, 67], [4, 33], [0, 9], [5, 23], [4, 73], [21, 18], [35, 2], [53, 50], [43, 21], [43, 27], [32, 4], [20, 19], [30, 57], [4, 1], [52, 59], [6, 34], [48, 0], [6, 9], [22, 73], [38, 48], [20, 59], [48, 25], [7, 50], [40, 41], [64, 18], [12, 12], [4, 22], [47, 31], [1, 51], [66, 6], [10, 24], [51, 72], [57, 70], [17, 14], [39, 34], [13, 21], [19, 45], [12, 23], [41, 53], [58, 60], [59, 41], [68, 43], [59, 51], [58, 20], [50, 74], [14, 5], [29, 4], [1, 62], [12, 38], [54, 43], [22, 61], [6, 57], [45, 11], [38, 59], [59, 42], [61, 33], [10, 69], [56, 43], [32, 7], [54, 19], [52, 71], [38, 62], [72, 16], [36, 8], [24, 47], [71, 24], [46, 5], [62, 28], [29, 74], [67, 74], [8, 13], [16, 14], [29, 52], [36, 56], [5, 25], [61, 23], [23, 35], [50, 33], [69, 32], [22, 4], [19, 22], [44, 66], [23, 10], [73, 30], [64, 61], [22, 20], [29, 33], [57, 43], [53, 73], [0, 53], [11, 47], [1, 43], [4, 35], [26, 8], [64, 74], [69, 64], [71, 45], [38, 63], [58, 47], [64, 21], [52, 38], [31, 53], [39, 46], [58, 59], [15, 55], [41, 10], [33, 46], [33, 1], [18, 48], [62, 52], [9, 9], [55, 52], [2, 38], [71, 48], [56, 73], [66, 41], [57, 27], [14, 50], [5, 71], [14, 23], [70, 17], [74, 2], [45, 57], [72, 12], [31, 64], [69, 61], [19, 67], [43, 44], [39, 36], [44, 57], [44, 19], [1, 39], [64, 48], [48, 68], [34, 65], [46, 70], [55, 7], [42, 49], [9, 12], [60, 13], [68, 69], [71, 39], [58, 2], [50, 45], [29, 70], [10, 40], [22, 13], [25, 54], [23, 56], [34, 29], [44, 64], [50, 14], [62, 50], [52, 32], [32, 33], [13, 60], [12, 72], [14, 22], [71, 49], [58, 4], [46, 10], [35, 0], [43, 60], [33, 57], [42, 69], [42, 41], [4, 10], [12, 62], [14, 9], [16, 15], [11, 38], [63, 40], [40, 21], [24, 54], [58, 72], [3, 35], [9, 58], [73, 8], [58, 43], [69, 37], [44, 43], [23, 29], [23, 33], [67, 51], [21, 29], [30, 24], [63, 37], [1, 24], [66, 57], [30, 58], [74, 57], [33, 54], [61, 32], [46, 11], [44, 49], [50, 40], [70, 20], [2, 1], [65, 18], [25, 55], [22, 3], [71, 50], [62, 23], [60, 57], [73, 0], [68, 56], [16, 24], [5, 36], [62, 49], [51, 35], [52, 42], [67, 30], [58, 11], [26, 42], [8, 34], [7, 17], [65, 43], [32, 38], [57, 73], [27, 18]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_6",
    "sat": "def sat(tri: List[int], edges=[[3, 5], [1, 0], [4, 3], [0, 3], [3, 2], [4, 5], [5, 2], [5, 1], [4, 1], [2, 3], [2, 5], [3, 3], [0, 2], [3, 1], [1, 2], [0, 0], [5, 4], [0, 4], [0, 5]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[3, 5], [1, 0], [4, 3], [0, 3], [3, 2], [4, 5], [5, 2], [5, 1], [4, 1], [2, 3], [2, 5], [3, 3], [0, 2], [3, 1], [1, 2], [0, 0], [5, 4], [0, 4], [0, 5]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_7",
    "sat": "def sat(tri: List[int], edges=[[9, 73], [21, 51], [48, 57], [47, 9], [39, 11], [29, 50], [36, 8], [31, 77], [80, 83], [83, 4], [4, 35], [27, 50], [43, 36], [0, 27], [83, 56], [47, 52], [12, 60], [82, 14], [69, 22], [64, 32], [24, 41], [48, 51], [33, 63], [53, 45], [58, 49], [16, 39], [56, 20], [9, 80], [18, 63], [12, 41], [10, 41], [37, 79], [70, 44], [57, 67], [29, 15], [81, 16], [23, 65], [39, 79], [82, 73], [45, 79], [77, 52], [6, 10], [30, 12], [38, 54], [19, 52], [72, 38], [57, 45], [48, 47], [36, 19], [44, 20], [82, 54], [72, 8], [7, 46], [36, 15], [27, 17], [46, 35], [12, 65], [61, 69], [67, 60], [28, 65], [14, 43], [19, 11], [65, 38], [54, 44], [41, 14], [76, 64], [2, 53], [76, 74], [38, 23], [0, 33], [47, 17], [39, 64], [20, 26], [69, 38], [77, 50], [5, 25], [10, 30], [72, 79], [39, 9], [0, 84], [5, 6], [41, 83], [69, 57], [52, 13], [42, 25], [60, 69], [54, 68], [49, 69], [26, 51], [30, 72], [8, 79], [3, 34], [33, 62], [50, 29], [15, 70], [28, 12], [81, 31], [30, 6], [21, 67], [26, 5], [77, 44], [68, 3], [38, 8], [48, 12], [61, 60], [17, 64], [46, 46], [7, 61], [76, 34], [67, 46], [27, 28], [44, 57], [44, 13], [60, 20], [51, 38], [12, 16], [39, 7], [30, 8], [41, 4], [75, 50], [11, 67], [12, 4], [22, 59], [29, 81], [73, 70], [11, 53], [62, 83], [72, 58], [17, 12], [60, 58], [0, 25], [43, 76], [11, 22], [74, 82], [55, 22], [13, 63], [13, 84], [48, 68], [70, 62], [12, 74], [33, 49], [27, 62], [79, 61], [33, 13], [0, 72], [60, 77], [5, 49], [12, 76], [48, 31], [10, 47], [19, 30], [75, 74], [70, 81], [30, 43], [9, 36], [57, 43], [71, 46], [80, 68], [61, 76], [37, 32], [3, 44], [48, 36], [56, 58], [52, 50], [57, 5], [77, 16], [6, 25], [58, 48], [66, 58], [15, 31], [20, 48], [72, 75], [23, 19], [35, 7], [53, 68], [33, 54], [30, 11], [21, 34], [41, 56], [20, 4], [40, 73], [75, 63], [84, 57], [7, 56], [24, 76], [0, 66], [12, 40], [70, 35], [14, 83], [84, 73], [70, 16], [78, 19], [57, 77], [39, 67], [77, 36], [47, 5], [75, 46], [72, 27], [42, 75], [66, 12], [81, 47], [9, 41], [70, 9], [46, 36], [37, 61], [50, 24], [19, 28], [20, 24], [49, 6], [58, 25], [2, 6], [51, 43], [41, 79], [41, 24], [55, 74], [77, 81], [28, 46], [78, 68], [84, 80], [30, 35], [79, 13], [2, 82], [5, 54], [36, 20], [22, 7], [6, 16], [78, 38], [44, 19], [67, 26], [35, 32], [22, 15], [60, 40], [23, 62], [20, 75], [11, 3], [14, 70], [17, 9], [35, 20], [80, 11], [4, 80], [25, 15], [73, 16], [50, 15], [45, 59], [38, 18], [54, 42], [31, 34], [23, 46], [76, 75], [25, 29], [66, 13], [53, 72], [7, 3], [7, 25], [66, 32], [4, 43], [81, 44], [12, 54], [26, 34], [57, 70], [79, 32], [63, 6], [27, 24], [32, 67], [66, 84], [12, 52], [7, 54], [51, 83], [71, 42], [36, 6], [44, 59], [17, 30], [30, 20], [24, 74], [47, 34], [15, 83], [45, 15], [38, 58], [66, 21], [54, 59], [48, 28], [47, 75], [60, 35], [67, 19], [19, 10], [84, 14], [69, 77], [41, 13], [48, 42], [40, 0], [80, 8], [1, 37], [13, 28], [18, 11], [40, 20], [16, 45], [2, 20], [46, 79], [7, 71], [64, 13], [12, 64], [68, 82], [78, 59], [19, 68], [46, 2], [1, 45], [61, 64], [6, 34], [41, 58], [48, 82], [72, 39], [73, 75], [46, 72], [61, 63], [54, 12], [60, 75], [71, 39], [67, 54], [56, 16]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[9, 73], [21, 51], [48, 57], [47, 9], [39, 11], [29, 50], [36, 8], [31, 77], [80, 83], [83, 4], [4, 35], [27, 50], [43, 36], [0, 27], [83, 56], [47, 52], [12, 60], [82, 14], [69, 22], [64, 32], [24, 41], [48, 51], [33, 63], [53, 45], [58, 49], [16, 39], [56, 20], [9, 80], [18, 63], [12, 41], [10, 41], [37, 79], [70, 44], [57, 67], [29, 15], [81, 16], [23, 65], [39, 79], [82, 73], [45, 79], [77, 52], [6, 10], [30, 12], [38, 54], [19, 52], [72, 38], [57, 45], [48, 47], [36, 19], [44, 20], [82, 54], [72, 8], [7, 46], [36, 15], [27, 17], [46, 35], [12, 65], [61, 69], [67, 60], [28, 65], [14, 43], [19, 11], [65, 38], [54, 44], [41, 14], [76, 64], [2, 53], [76, 74], [38, 23], [0, 33], [47, 17], [39, 64], [20, 26], [69, 38], [77, 50], [5, 25], [10, 30], [72, 79], [39, 9], [0, 84], [5, 6], [41, 83], [69, 57], [52, 13], [42, 25], [60, 69], [54, 68], [49, 69], [26, 51], [30, 72], [8, 79], [3, 34], [33, 62], [50, 29], [15, 70], [28, 12], [81, 31], [30, 6], [21, 67], [26, 5], [77, 44], [68, 3], [38, 8], [48, 12], [61, 60], [17, 64], [46, 46], [7, 61], [76, 34], [67, 46], [27, 28], [44, 57], [44, 13], [60, 20], [51, 38], [12, 16], [39, 7], [30, 8], [41, 4], [75, 50], [11, 67], [12, 4], [22, 59], [29, 81], [73, 70], [11, 53], [62, 83], [72, 58], [17, 12], [60, 58], [0, 25], [43, 76], [11, 22], [74, 82], [55, 22], [13, 63], [13, 84], [48, 68], [70, 62], [12, 74], [33, 49], [27, 62], [79, 61], [33, 13], [0, 72], [60, 77], [5, 49], [12, 76], [48, 31], [10, 47], [19, 30], [75, 74], [70, 81], [30, 43], [9, 36], [57, 43], [71, 46], [80, 68], [61, 76], [37, 32], [3, 44], [48, 36], [56, 58], [52, 50], [57, 5], [77, 16], [6, 25], [58, 48], [66, 58], [15, 31], [20, 48], [72, 75], [23, 19], [35, 7], [53, 68], [33, 54], [30, 11], [21, 34], [41, 56], [20, 4], [40, 73], [75, 63], [84, 57], [7, 56], [24, 76], [0, 66], [12, 40], [70, 35], [14, 83], [84, 73], [70, 16], [78, 19], [57, 77], [39, 67], [77, 36], [47, 5], [75, 46], [72, 27], [42, 75], [66, 12], [81, 47], [9, 41], [70, 9], [46, 36], [37, 61], [50, 24], [19, 28], [20, 24], [49, 6], [58, 25], [2, 6], [51, 43], [41, 79], [41, 24], [55, 74], [77, 81], [28, 46], [78, 68], [84, 80], [30, 35], [79, 13], [2, 82], [5, 54], [36, 20], [22, 7], [6, 16], [78, 38], [44, 19], [67, 26], [35, 32], [22, 15], [60, 40], [23, 62], [20, 75], [11, 3], [14, 70], [17, 9], [35, 20], [80, 11], [4, 80], [25, 15], [73, 16], [50, 15], [45, 59], [38, 18], [54, 42], [31, 34], [23, 46], [76, 75], [25, 29], [66, 13], [53, 72], [7, 3], [7, 25], [66, 32], [4, 43], [81, 44], [12, 54], [26, 34], [57, 70], [79, 32], [63, 6], [27, 24], [32, 67], [66, 84], [12, 52], [7, 54], [51, 83], [71, 42], [36, 6], [44, 59], [17, 30], [30, 20], [24, 74], [47, 34], [15, 83], [45, 15], [38, 58], [66, 21], [54, 59], [48, 28], [47, 75], [60, 35], [67, 19], [19, 10], [84, 14], [69, 77], [41, 13], [48, 42], [40, 0], [80, 8], [1, 37], [13, 28], [18, 11], [40, 20], [16, 45], [2, 20], [46, 79], [7, 71], [64, 13], [12, 64], [68, 82], [78, 59], [19, 68], [46, 2], [1, 45], [61, 64], [6, 34], [41, 58], [48, 82], [72, 39], [73, 75], [46, 72], [61, 63], [54, 12], [60, 75], [71, 39], [67, 54], [56, 16]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_8",
    "sat": "def sat(tri: List[int], edges=[[19, 3], [31, 31], [2, 2], [10, 41], [32, 45], [45, 41], [13, 34], [8, 31], [41, 17], [0, 15], [29, 19], [13, 13], [8, 23], [5, 24], [28, 16], [14, 7], [14, 3], [25, 39], [37, 41], [44, 4], [13, 3], [30, 40], [35, 12], [1, 5], [23, 24], [5, 20], [19, 28], [33, 3], [34, 42], [26, 16], [37, 10], [16, 13], [43, 34], [11, 28], [36, 26], [41, 3], [4, 9], [24, 0], [36, 44], [36, 39], [17, 7], [43, 8], [36, 27], [6, 23], [32, 30], [34, 14], [39, 34], [11, 27], [17, 18], [38, 26], [19, 22], [34, 21], [5, 3], [19, 37], [38, 7], [0, 12], [42, 20], [31, 10], [23, 39], [11, 13], [4, 45], [12, 33], [37, 14], [42, 19], [28, 14], [38, 42], [0, 28], [1, 21], [5, 42], [8, 13], [32, 21], [38, 41], [27, 1], [15, 23], [32, 24], [15, 36], [4, 7], [30, 38], [0, 6], [27, 40], [43, 39], [33, 2], [24, 22], [43, 21], [10, 0], [6, 41], [35, 42], [38, 35], [42, 33], [19, 13], [35, 3], [20, 19], [31, 16], [4, 27], [37, 43], [20, 4], [4, 39], [17, 25], [4, 17], [5, 39], [8, 11], [26, 13], [6, 14], [22, 7], [5, 30], [1, 23], [38, 10], [8, 18], [24, 39], [6, 36], [31, 4], [13, 35], [18, 4], [36, 30], [23, 2], [9, 36], [14, 21], [2, 21], [31, 12], [7, 2], [42, 13], [29, 8], [5, 33], [34, 45], [8, 10], [20, 36], [28, 28], [22, 17], [3, 44], [42, 10], [23, 37], [39, 36], [18, 17], [33, 14], [36, 45]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[19, 3], [31, 31], [2, 2], [10, 41], [32, 45], [45, 41], [13, 34], [8, 31], [41, 17], [0, 15], [29, 19], [13, 13], [8, 23], [5, 24], [28, 16], [14, 7], [14, 3], [25, 39], [37, 41], [44, 4], [13, 3], [30, 40], [35, 12], [1, 5], [23, 24], [5, 20], [19, 28], [33, 3], [34, 42], [26, 16], [37, 10], [16, 13], [43, 34], [11, 28], [36, 26], [41, 3], [4, 9], [24, 0], [36, 44], [36, 39], [17, 7], [43, 8], [36, 27], [6, 23], [32, 30], [34, 14], [39, 34], [11, 27], [17, 18], [38, 26], [19, 22], [34, 21], [5, 3], [19, 37], [38, 7], [0, 12], [42, 20], [31, 10], [23, 39], [11, 13], [4, 45], [12, 33], [37, 14], [42, 19], [28, 14], [38, 42], [0, 28], [1, 21], [5, 42], [8, 13], [32, 21], [38, 41], [27, 1], [15, 23], [32, 24], [15, 36], [4, 7], [30, 38], [0, 6], [27, 40], [43, 39], [33, 2], [24, 22], [43, 21], [10, 0], [6, 41], [35, 42], [38, 35], [42, 33], [19, 13], [35, 3], [20, 19], [31, 16], [4, 27], [37, 43], [20, 4], [4, 39], [17, 25], [4, 17], [5, 39], [8, 11], [26, 13], [6, 14], [22, 7], [5, 30], [1, 23], [38, 10], [8, 18], [24, 39], [6, 36], [31, 4], [13, 35], [18, 4], [36, 30], [23, 2], [9, 36], [14, 21], [2, 21], [31, 12], [7, 2], [42, 13], [29, 8], [5, 33], [34, 45], [8, 10], [20, 36], [28, 28], [22, 17], [3, 44], [42, 10], [23, 37], [39, 36], [18, 17], [33, 14], [36, 45]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyTriangle_9",
    "sat": "def sat(tri: List[int], edges=[[0, 0], [0, 2], [3, 6], [4, 1], [6, 0], [3, 0], [0, 1], [2, 1], [3, 2], [5, 6], [5, 4], [1, 3], [3, 3], [2, 2], [5, 5], [4, 6], [1, 0]]):\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "sols": [
      "def sol(edges=[[0, 0], [0, 2], [3, 6], [4, 1], [6, 0], [3, 0], [0, 1], [2, 1], [3, 2], [5, 6], [5, 4], [1, 3], [3, 3], [2, 2], [5, 5], [4, 6], [1, 0]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_0",
    "sat": "def sat(nodes: List[int], size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_1",
    "sat": "def sat(nodes: List[int], size=12, edges=[[12, 21], [12, 30], [22, 15], [3, 37], [0, 23], [16, 31], [1, 8], [14, 15], [37, 23], [16, 5], [15, 35], [37, 16], [34, 24], [32, 20], [8, 9], [27, 25], [32, 27], [16, 23], [9, 1], [7, 14], [21, 2], [35, 20], [31, 20], [11, 13], [14, 5], [14, 18], [8, 16], [18, 3], [15, 20], [13, 34], [14, 20], [27, 7], [7, 35], [30, 30], [16, 29], [31, 6], [2, 35], [29, 0], [12, 36], [34, 11], [7, 25], [15, 8], [15, 5], [30, 35], [32, 16], [29, 7], [32, 14], [25, 10], [35, 15], [32, 29], [27, 34], [32, 23], [13, 23], [16, 7], [21, 3], [14, 35], [25, 32], [27, 14], [15, 27], [4, 11], [13, 7], [24, 6], [21, 15], [20, 7], [5, 25], [5, 9], [9, 25], [17, 3], [25, 22], [16, 25], [14, 24], [8, 29], [22, 21], [29, 25], [18, 4], [29, 24], [21, 29], [16, 3], [31, 23], [22, 19], [37, 27], [7, 7], [22, 31], [7, 15], [31, 22], [6, 1], [25, 15], [22, 11], [4, 2], [5, 8], [22, 22], [23, 6], [4, 10], [14, 33], [20, 5], [27, 20], [11, 8], [30, 16], [7, 2], [5, 22], [30, 15], [26, 24], [32, 22], [8, 7], [5, 36], [16, 11], [29, 20], [15, 10], [20, 22], [20, 25], [16, 22], [29, 27], [37, 10], [19, 2], [34, 2], [20, 16], [7, 6], [25, 3], [3, 30], [32, 7], [5, 29], [14, 29], [14, 25], [35, 7], [2, 4], [29, 15], [12, 19], [22, 35], [22, 27], [23, 12], [23, 35], [25, 35], [27, 16], [28, 15], [34, 18], [9, 30], [34, 30], [5, 32], [32, 10], [17, 27], [20, 8], [35, 32], [22, 28], [5, 35], [0, 15], [19, 31], [32, 9], [35, 23], [32, 25], [8, 25], [4, 9], [27, 35], [10, 3], [32, 30], [14, 16], [36, 5], [13, 29], [16, 15], [16, 30], [11, 21], [22, 12], [7, 22], [29, 22], [35, 16], [24, 26], [15, 32], [24, 23], [23, 15], [9, 33], [2, 19], [29, 9], [0, 28], [11, 24], [12, 15], [10, 26], [33, 11], [27, 15], [29, 31], [35, 29], [5, 14], [25, 28], [18, 20], [5, 7], [32, 31], [34, 15], [25, 14], [34, 21], [21, 36], [27, 36], [27, 5], [16, 36], [22, 14], [9, 5], [37, 9]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_2",
    "sat": "def sat(nodes: List[int], size=0, edges=[[0, 2], [1, 2], [0, 0], [2, 2], [1, 1]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=0, edges=[[0, 2], [1, 2], [0, 0], [2, 2], [1, 1]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_3",
    "sat": "def sat(nodes: List[int], size=19, edges=[[74, 77], [21, 14], [18, 59], [21, 55], [55, 44], [38, 12], [74, 12], [2, 38], [77, 32], [44, 2], [74, 21], [21, 59], [21, 77], [49, 2], [20, 2], [67, 59], [37, 58], [67, 77], [67, 12], [55, 66], [49, 59], [59, 64], [49, 12], [48, 58], [55, 38], [11, 27], [38, 21], [68, 64], [35, 10], [44, 12], [18, 63], [74, 68], [2, 77], [49, 68], [21, 66], [66, 12], [47, 71], [32, 68], [18, 64], [40, 23], [28, 80], [12, 77], [73, 18], [44, 21], [66, 32], [68, 77], [18, 2], [77, 13], [65, 52], [73, 74], [55, 54], [21, 2], [59, 2], [19, 56], [44, 63], [70, 55], [55, 49], [29, 12], [14, 66], [66, 74], [14, 68], [6, 50], [12, 63], [25, 15], [68, 18], [39, 8], [75, 75], [12, 68], [14, 67], [59, 63], [58, 68], [44, 77], [14, 59], [63, 49], [63, 14], [14, 32], [36, 67], [67, 68], [2, 68], [55, 14], [77, 64], [38, 14], [77, 2], [63, 38], [59, 73], [63, 67], [64, 67], [67, 17], [19, 40], [73, 32], [21, 68], [44, 32], [66, 64], [73, 21], [29, 58], [17, 27], [66, 63], [77, 66], [55, 79], [38, 67], [2, 73], [50, 47], [73, 14], [49, 14], [14, 46], [64, 63], [18, 12], [20, 76], [18, 44], [66, 67], [38, 66], [74, 18], [64, 55], [18, 49], [44, 73], [38, 18], [55, 63], [48, 8], [74, 55], [4, 50], [31, 62], [38, 17], [15, 5], [32, 74], [79, 40], [64, 49], [2, 64], [33, 47], [73, 68], [75, 34], [73, 63], [14, 2], [73, 66], [38, 64], [47, 75], [32, 63], [2, 12], [67, 44], [64, 73], [63, 74], [49, 44], [32, 40], [12, 32], [41, 42], [14, 77], [47, 51], [30, 1], [59, 32], [14, 18], [32, 18], [14, 64], [21, 32], [29, 70], [18, 31], [73, 77], [44, 64], [38, 49], [51, 53], [74, 49], [68, 55], [37, 70], [38, 44], [55, 18], [77, 55], [9, 35], [64, 74], [49, 37], [63, 2], [57, 2], [21, 12], [21, 67], [2, 67], [44, 74], [56, 66], [21, 18], [40, 13], [16, 44], [32, 64], [74, 14], [12, 55], [59, 38], [77, 18], [66, 44], [49, 21], [63, 77], [68, 38], [74, 59], [53, 30], [59, 66], [12, 73], [64, 12], [38, 32], [32, 2], [63, 21], [68, 66], [38, 77], [38, 74], [14, 12], [49, 67], [63, 68], [2, 74], [59, 12], [68, 59], [66, 2], [16, 64], [77, 49], [30, 64], [76, 12], [33, 78], [44, 14], [67, 73], [18, 66], [67, 74], [64, 21], [32, 67], [2, 55], [58, 21], [60, 59], [59, 55], [59, 44], [47, 2], [82, 19], [73, 38], [18, 67], [55, 67], [49, 32], [73, 55], [59, 77], [68, 44], [32, 55], [55, 69], [73, 49], [11, 32], [66, 49]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_4",
    "sat": "def sat(nodes: List[int], size=2, edges=[[2, 1], [2, 2], [3, 3], [1, 0], [0, 0], [3, 0], [0, 1], [1, 1], [2, 0], [0, 3]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=2, edges=[[2, 1], [2, 2], [3, 3], [1, 0], [0, 0], [3, 0], [0, 1], [1, 1], [2, 0], [0, 3]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_5",
    "sat": "def sat(nodes: List[int], size=0, edges=[[1, 0], [0, 0], [1, 1], [2, 1], [2, 2], [0, 1]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=0, edges=[[1, 0], [0, 0], [1, 1], [2, 1], [2, 2], [0, 1]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_6",
    "sat": "def sat(nodes: List[int], size=1, edges=[[2, 0], [1, 2], [2, 2], [2, 1], [0, 1], [0, 2]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=1, edges=[[2, 0], [1, 2], [2, 2], [2, 1], [0, 1], [0, 2]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_7",
    "sat": "def sat(nodes: List[int], size=10, edges=[[0, 13], [15, 13], [10, 4], [16, 3], [12, 9], [5, 4], [16, 16], [1, 15], [11, 13], [10, 8], [11, 11], [9, 16], [9, 14], [0, 10], [1, 10], [12, 4], [3, 10], [4, 9], [1, 5], [3, 6], [0, 12], [4, 2], [13, 1], [13, 5], [3, 0], [4, 0], [0, 15], [9, 4], [10, 14], [7, 14], [12, 14], [6, 5], [6, 3], [13, 9], [16, 15], [13, 11], [0, 0], [2, 12], [13, 4], [11, 0], [1, 14], [7, 0], [8, 7], [8, 13], [12, 8], [16, 0], [12, 7], [10, 15], [10, 2], [9, 8], [11, 15], [15, 4], [2, 3], [3, 11], [15, 1], [9, 11], [16, 12], [15, 14], [9, 12], [5, 1], [6, 9], [14, 4], [13, 2], [11, 7], [3, 2], [11, 12], [11, 8], [5, 16], [4, 11], [10, 12], [1, 1], [4, 3], [16, 7], [7, 2], [11, 10], [16, 14], [11, 1], [6, 10], [10, 11], [9, 15], [5, 10], [7, 8], [12, 11], [11, 9], [11, 2], [15, 9], [2, 15], [5, 14], [13, 12], [7, 6], [0, 9], [16, 10], [2, 6], [9, 3], [12, 2], [12, 13], [3, 13], [3, 15], [3, 12], [6, 7], [12, 0], [10, 6], [16, 11], [2, 1], [9, 0], [10, 9], [8, 0], [13, 10], [1, 16], [10, 5], [2, 9], [0, 3], [12, 5], [1, 11], [12, 3], [12, 15], [1, 2], [0, 11], [5, 11], [2, 5], [8, 12], [5, 0], [6, 13], [13, 8], [11, 14], [4, 15], [2, 0], [0, 7], [7, 1], [8, 11], [3, 8], [1, 9], [6, 14], [14, 10]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=10, edges=[[0, 13], [15, 13], [10, 4], [16, 3], [12, 9], [5, 4], [16, 16], [1, 15], [11, 13], [10, 8], [11, 11], [9, 16], [9, 14], [0, 10], [1, 10], [12, 4], [3, 10], [4, 9], [1, 5], [3, 6], [0, 12], [4, 2], [13, 1], [13, 5], [3, 0], [4, 0], [0, 15], [9, 4], [10, 14], [7, 14], [12, 14], [6, 5], [6, 3], [13, 9], [16, 15], [13, 11], [0, 0], [2, 12], [13, 4], [11, 0], [1, 14], [7, 0], [8, 7], [8, 13], [12, 8], [16, 0], [12, 7], [10, 15], [10, 2], [9, 8], [11, 15], [15, 4], [2, 3], [3, 11], [15, 1], [9, 11], [16, 12], [15, 14], [9, 12], [5, 1], [6, 9], [14, 4], [13, 2], [11, 7], [3, 2], [11, 12], [11, 8], [5, 16], [4, 11], [10, 12], [1, 1], [4, 3], [16, 7], [7, 2], [11, 10], [16, 14], [11, 1], [6, 10], [10, 11], [9, 15], [5, 10], [7, 8], [12, 11], [11, 9], [11, 2], [15, 9], [2, 15], [5, 14], [13, 12], [7, 6], [0, 9], [16, 10], [2, 6], [9, 3], [12, 2], [12, 13], [3, 13], [3, 15], [3, 12], [6, 7], [12, 0], [10, 6], [16, 11], [2, 1], [9, 0], [10, 9], [8, 0], [13, 10], [1, 16], [10, 5], [2, 9], [0, 3], [12, 5], [1, 11], [12, 3], [12, 15], [1, 2], [0, 11], [5, 11], [2, 5], [8, 12], [5, 0], [6, 13], [13, 8], [11, 14], [4, 15], [2, 0], [0, 7], [7, 1], [8, 11], [3, 8], [1, 9], [6, 14], [14, 10]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_8",
    "sat": "def sat(nodes: List[int], size=3, edges=[[5, 4], [4, 5], [0, 5], [0, 4]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [
      "def sol(size=3, edges=[[5, 4], [4, 5], [0, 5], [0, 4]]):  # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs"
  },
  {
    "name": "PlantedClique_9",
    "sat": "def sat(nodes: List[int], size=16, edges=[[52, 0], [69, 64], [98, 15], [39, 4], [77, 87], [1, 14], [94, 70], [68, 15], [79, 4], [15, 8], [66, 49], [7, 92], [47, 18], [45, 61], [45, 22], [23, 84], [86, 33], [36, 36], [55, 22], [68, 14], [0, 86], [46, 86], [56, 90], [49, 44], [43, 79], [18, 12], [23, 7], [73, 78], [17, 43], [13, 45], [54, 63], [84, 38], [22, 56], [21, 79], [32, 83], [93, 11], [95, 72], [56, 68], [67, 64], [49, 23], [56, 67], [54, 71], [71, 61], [22, 88], [32, 1], [89, 69], [59, 83], [34, 81], [47, 76], [45, 81], [11, 45], [71, 86], [14, 54], [77, 54], [80, 93], [53, 52], [51, 60], [65, 41], [26, 44], [0, 55], [16, 9], [52, 44], [94, 22], [81, 42], [12, 26], [40, 70], [70, 1], [29, 17], [22, 4], [70, 53], [23, 59], [61, 91], [55, 42], [94, 76], [13, 24], [60, 6], [11, 53], [33, 26], [19, 21], [20, 22], [34, 57], [75, 34], [55, 70], [81, 54], [26, 41], [35, 56], [36, 26], [55, 53], [98, 28], [33, 38], [92, 38], [19, 49], [64, 48], [16, 96], [26, 16], [84, 64], [81, 96], [22, 20], [24, 3], [55, 6], [60, 43], [42, 55], [89, 36], [92, 95], [52, 43], [27, 53], [3, 86], [80, 64], [85, 60], [91, 30], [36, 61], [63, 89], [72, 14], [35, 64], [5, 7], [3, 89], [2, 19], [53, 54], [49, 22], [84, 32], [88, 86], [27, 74], [85, 59], [9, 70], [73, 41], [81, 84], [4, 74], [19, 25], [81, 61], [85, 5], [79, 25], [33, 78], [65, 45], [18, 80], [62, 69], [60, 65], [2, 93], [70, 42], [15, 57], [94, 91], [24, 22], [15, 75], [95, 55], [98, 93], [79, 41], [13, 61], [98, 74], [6, 51], [14, 89], [68, 2], [81, 51], [43, 4], [24, 40], [22, 6], [94, 61], [95, 35], [73, 56], [20, 42], [15, 44], [71, 34], [14, 44], [53, 75], [14, 11], [72, 45], [62, 82], [18, 15], [48, 18], [90, 10], [89, 2], [16, 81], [28, 72], [29, 38], [23, 2], [13, 13], [62, 27], [16, 93], [88, 2], [69, 80], [3, 31], [22, 74], [97, 0], [93, 89], [28, 30], [13, 16], [80, 3], [61, 17], [8, 53], [88, 24], [37, 30], [29, 82], [9, 11], [69, 22], [60, 21], [31, 17], [78, 39], [95, 70], [81, 55], [13, 97], [9, 49], [22, 16], [45, 68], [94, 25], [11, 21], [85, 17], [39, 78], [63, 33], [4, 86], [98, 17], [4, 71], [58, 11], [96, 38], [53, 9], [84, 87], [16, 64], [15, 27], [40, 36], [22, 92], [26, 24], [37, 51], [11, 79], [6, 16], [67, 51], [12, 93], [64, 32], [27, 26], [13, 28], [93, 48], [3, 92], [74, 23], [89, 84], [43, 49], [93, 77], [43, 81], [75, 62], [79, 27], [6, 26], [50, 19], [57, 3], [14, 30], [20, 37], [0, 34], [38, 31], [85, 19], [20, 40], [2, 84], [3, 41], [4, 8], [8, 98], [43, 78], [92, 66], [26, 81], [32, 45], [67, 21], [52, 35], [50, 97], [52, 95], [24, 65], [80, 71], [59, 27], [78, 71], [42, 68], [10, 47], [1, 31], [60, 35], [34, 62], [55, 26], [47, 22], [56, 40], [19, 92], [23, 87], [49, 45], [85, 76], [59, 24], [50, 59], [44, 68], [45, 66], [95, 75], [90, 76], [59, 17], [42, 22], [29, 24], [5, 22], [8, 38], [96, 20], [58, 2], [79, 72], [67, 28], [57, 23], [17, 29], [76, 34], [79, 59], [9, 34], [36, 42], [43, 14], [46, 7], [90, 80], [6, 76], [92, 19], [16, 42], [42, 70], [17, 81], [61, 21], [12, 97], [74, 45], [65, 64], [90, 87], [13, 64], [50, 50], [52, 8], [47, 29], [83, 6], [66, 51], [86, 61], [37, 57], [49, 7], [6, 35], [85, 66], [22, 40], [96, 35], [61, 98], [35, 76], [84, 9], [64, 5], [46, 29], [34, 3], [40, 32], [24, 15], [90, 31], [19, 20], [20, 61], [13, 41], [68, 20], [97, 75], [22, 68], [57, 71], [81, 40], [61, 70], [56, 96], [41, 17], [49, 24], [52, 33], [68, 96], [62, 43], [70, 24], [61, 1], [79, 70], [24, 16], [27, 22], [73, 37], [29, 36], [87, 92], [41, 62], [24, 81], [13, 51], [29, 26], [94, 19], [38, 18], [33, 65], [80, 62], [81, 13], [45, 98], [65, 95], [69, 95], [17, 77], [58, 43], [5, 1], [20, 33], [85, 85], [45, 34], [57, 92], [24, 27], [71, 13], [67, 7], [7, 93], [64, 61], [75, 95], [55, 88], [31, 9], [26, 14], [83, 41], [84, 33], [33, 91], [29, 77], [96, 40], [90, 59], [43, 93], [8, 30], [45, 46], [98, 51], [97, 26], [24, 68], [55, 17], [62, 96], [39, 80], [65, 15], [16, 45], [65, 91], [20, 69], [16, 94], [86, 87], [40, 54], [29, 96], [55, 56], [80, 10], [47, 83], [48, 9], [60, 80], [55, 13], [95, 50], [91, 6], [5, 85], [22, 81], [47, 0], [6, 20], [49, 89], [42, 6], [88, 11], [4, 25], [60, 51], [51, 97], [38, 75], [98, 63], [49, 56], [16, 39], [60, 62], [77, 16], [49, 97], [32, 21], [82, 73], [48, 8], [6, 70], [56, 45], [24, 90], [88, 79], [79, 12], [47, 49], [80, 24], [60, 97], [50, 40], [13, 76], [87, 38], [60, 67], [51, 41], [77, 80], [80, 43], [19, 33], [87, 86], [83, 7], [16, 50], [26, 36], [33, 41], [10, 25], [64, 66], [44, 91], [48, 1], [15, 82], [57, 77], [36, 78], [86, 88], [58, 77], [33, 0], [37, 66], [47, 46], [67, 1], [46, 9], [34, 31], [45, 82], [7, 89], [71, 22], [49, 42], [87, 1], [78, 7], [78, 1], [15, 60], [75, 3], [1, 36], [81, 28], [55, 81], [94, 49], [0, 38], [4, 22], [92, 68], [25, 66], [76, 57], [55, 59], [6, 24], [37, 15], [20, 0], [38, 33], [20, 56], [39, 91], [2, 18], [17, 80], [11, 30], [23, 46], [43, 63], [73, 82], [46, 45], [25, 19], [55, 68], [1, 38], [42, 38], [70, 93], [2, 36], [55, 16], [10, 46], [74, 98], [59, 9], [76, 19], [74, 36], [54, 50], [39, 8], [19, 66], [95, 11], [19, 19], [35, 42], [16, 35], [53, 39], [29, 63], [8, 33], [42, 93], [54, 32], [9, 30], [98, 19], [96, 6], [53, 91], [97, 2], [1, 44], [15, 85], [96, 13], [22, 12], [22, 50], [88, 71], [91, 58], [22, 96], [25, 42], [0, 24], [34, 35], [52, 78], [42, 73], [52, 69], [72, 25], [39, 28], [67, 29], [40, 92], [37, 67], [79, 38], [84, 15], [28, 32], [57, 68], [38, 69], [62, 78], [80, 33], [12, 7], [27, 60], [89, 57], [55, 45], [13, 22], [81, 6], [81, 18], [39, 5], [20, 81], [82, 77], [35, 24], [68, 35], [51, 3], [45, 24], [13, 6], [41, 93], [52, 62], [13, 56], [74, 50], [41, 98], [11, 23], [8, 40], [96, 45], [93, 50], [86, 63], [76, 95], [23, 28], [68, 81], [45, 74], [3, 0], [3, 81], [24, 96], [62, 32], [89, 65], [82, 78], [54, 11], [79, 0], [84, 30], [90, 9], [38, 1], [58, 70], [66, 77], [2, 43], [73, 58], [61, 8], [69, 87], [65, 42], [34, 73], [14, 31], [45, 35], [18, 45], [32, 88], [94, 17], [95, 64], [31, 55], [13, 33], [37, 13], [54, 96], [77, 24], [3, 72], [43, 31], [89, 15], [88, 61], [17, 34], [24, 94], [57, 89], [86, 27], [68, 56], [70, 81], [5, 74], [25, 21], [81, 4], [78, 8], [63, 81], [35, 23], [22, 1], [22, 70], [46, 18], [24, 84], [9, 80], [20, 35], [87, 69], [63, 52], [41, 55], [35, 13], [85, 77], [11, 89], [53, 65], [85, 58], [86, 62], [1, 53], [6, 54], [80, 27], [0, 8], [40, 55], [18, 54], [70, 56], [20, 85], [71, 15], [37, 78], [18, 92], [19, 62], [56, 24], [77, 96], [85, 35], [91, 68], [58, 65], [90, 74], [32, 55], [19, 57], [83, 17], [50, 48], [55, 90], [66, 37], [61, 6], [73, 70], [40, 0], [28, 51], [83, 12], [6, 85], [24, 20], [59, 67], [16, 68], [26, 40], [50, 39], [13, 31], [96, 70], [81, 49], [16, 90], [29, 12], [26, 34], [55, 0], [44, 92], [87, 11], [0, 96], [35, 55], [46, 76], [36, 96], [84, 93], [18, 75], [15, 30], [68, 90], [81, 43], [11, 7], [37, 54], [96, 55], [98, 31], [78, 33], [66, 80], [66, 45], [70, 68], [15, 34], [40, 17], [19, 24], [5, 6], [19, 27], [89, 35], [87, 28], [81, 19], [11, 27], [8, 41], [53, 44], [42, 2], [54, 33], [55, 65], [2, 85], [97, 9], [19, 39], [54, 64], [7, 10], [81, 86], [81, 9], [58, 0], [9, 21], [4, 58], [30, 48], [0, 14], [13, 42], [89, 54], [14, 83], [80, 21], [70, 45], [25, 46], [44, 20], [39, 87], [70, 35], [93, 85], [34, 32], [75, 28], [95, 88], [84, 76], [3, 8], [7, 47], [82, 4], [5, 89], [64, 79], [6, 56], [10, 72], [43, 16], [20, 16], [46, 22], [16, 2], [24, 67], [24, 7], [5, 47], [41, 49], [4, 2], [56, 26], [53, 43], [63, 94], [7, 85], [68, 45], [14, 80], [15, 92], [78, 77], [88, 98], [16, 24], [92, 41], [50, 69], [6, 68], [24, 55], [77, 50], [17, 44], [35, 73], [75, 96], [42, 45], [1, 80], [6, 40], [25, 74], [45, 20], [84, 37], [84, 98], [8, 71], [91, 27], [69, 72], [93, 83], [69, 77], [23, 35], [20, 13], [26, 10], [95, 77], [45, 6], [55, 20], [96, 47], [30, 38], [49, 93], [51, 74], [46, 69], [93, 71], [52, 10], [59, 32], [64, 58], [32, 18], [62, 14], [60, 75], [76, 67], [13, 40], [48, 96], [22, 90], [73, 60], [54, 25], [48, 70], [94, 14], [77, 32], [36, 40], [9, 1], [41, 46], [39, 98], [38, 83], [48, 98], [40, 35], [28, 47], [10, 65], [33, 90], [42, 40], [7, 71], [84, 18], [60, 10], [26, 38], [89, 21], [57, 2], [30, 15], [91, 39], [26, 4], [80, 29], [6, 27], [85, 62], [38, 84], [30, 57], [37, 82], [72, 31], [38, 70], [62, 67], [47, 72], [56, 82], [40, 68], [96, 77], [76, 6], [13, 70], [70, 16], [74, 74], [78, 82], [5, 49], [21, 15], [52, 36], [23, 18], [61, 90], [79, 78], [14, 67], [12, 35], [1, 83], [41, 78], [13, 68], [5, 0], [27, 35], [45, 40], [92, 54], [31, 51], [30, 21], [86, 67], [3, 63], [69, 92], [34, 6], [72, 90], [83, 62], [64, 57], [4, 0], [70, 10], [11, 29], [44, 7], [66, 36], [68, 68], [22, 62], [74, 92], [27, 34], [48, 61], [10, 90], [50, 80], [57, 93], [73, 28], [48, 16], [75, 27], [47, 52], [52, 21], [70, 40], [35, 22], [96, 42], [44, 95], [98, 32], [63, 27], [64, 0], [65, 73], [61, 44], [54, 87], [1, 5], [65, 31], [70, 36], [96, 64], [55, 76], [2, 44], [97, 25], [55, 54], [82, 86], [97, 93], [71, 5], [40, 16], [69, 89], [47, 88], [94, 54], [92, 98], [72, 89], [14, 24], [2, 2], [41, 45], [24, 42], [10, 26], [76, 33], [53, 36], [70, 20], [39, 35], [24, 85], [90, 47], [45, 71], [77, 35], [64, 62], [32, 91], [78, 65], [1, 27], [38, 92], [12, 19], [50, 7], [53, 15], [92, 21], [35, 81], [89, 16], [76, 29], [52, 67], [26, 88], [42, 56], [16, 56], [81, 70], [32, 68], [56, 15], [60, 26], [56, 70], [15, 79], [40, 71], [50, 14], [74, 56], [58, 56], [57, 64], [70, 95], [28, 73], [20, 28], [23, 54], [3, 28], [48, 82], [40, 61], [36, 28], [16, 51], [81, 56], [47, 12], [84, 56], [36, 23], [40, 63], [88, 55], [95, 45], [44, 0], [59, 30], [84, 74], [3, 25], [98, 76], [41, 92], [16, 26], [26, 45]]):\n    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_0",
    "sat": "def sat(path: List[int], weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_1",
    "sat": "def sat(path: List[int], weights=[{20: 444, 18: 742, 24: 186, 5: 600}, {21: 275, 20: 60, 2: 254, 3: 908}, {}, {12: 257, 0: 254, 17: 49, 9: 376}, {12: 140, 7: 123}, {13: 97, 1: 423, 18: 324}, {19: 979, 28: 35}, {11: 787, 29: 526}, {10: 16, 13: 20}, {26: 590, 23: 143, 6: 126}, {21: 892}, {27: 259, 26: 483, 18: 889, 14: 496}, {16: 521, 14: 891, 1: 193}, {}, {5: 376}, {26: 760, 17: 301}, {28: 191, 26: 366}, {5: 158}, {16: 603}, {2: 392, 14: 449, 15: 260}, {21: 821, 1: 36, 11: 193, 19: 764, 15: 80}, {24: 827, 27: 596}, {19: 858, 1: 541, 9: 433}, {8: 805, 3: 878}, {25: 126, 22: 610, 27: 919}, {5: 583}, {28: 7}, {13: 578, 15: 495}, {23: 770, 28: 120}, {5: 446, 3: 565}, {2: 437, 23: 344}], bound=480):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{20: 444, 18: 742, 24: 186, 5: 600}, {21: 275, 20: 60, 2: 254, 3: 908}, {}, {12: 257, 0: 254, 17: 49, 9: 376}, {12: 140, 7: 123}, {13: 97, 1: 423, 18: 324}, {19: 979, 28: 35}, {11: 787, 29: 526}, {10: 16, 13: 20}, {26: 590, 23: 143, 6: 126}, {21: 892}, {27: 259, 26: 483, 18: 889, 14: 496}, {16: 521, 14: 891, 1: 193}, {}, {5: 376}, {26: 760, 17: 301}, {28: 191, 26: 366}, {5: 158}, {16: 603}, {2: 392, 14: 449, 15: 260}, {21: 821, 1: 36, 11: 193, 19: 764, 15: 80}, {24: 827, 27: 596}, {19: 858, 1: 541, 9: 433}, {8: 805, 3: 878}, {25: 126, 22: 610, 27: 919}, {5: 583}, {28: 7}, {13: 578, 15: 495}, {23: 770, 28: 120}, {5: 446, 3: 565}, {2: 437, 23: 344}], bound=480):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_2",
    "sat": "def sat(path: List[int], weights=[{3: 26, 35: 259, 8: 575, 64: 314}, {49: 934, 57: 392, 62: 437, 50: 540, 52: 748}, {27: 741, 2: 86, 9: 243, 66: 956, 14: 795, 31: 887, 11: 765}, {59: 17, 12: 820, 3: 807, 53: 888, 56: 897, 26: 889, 22: 932}, {16: 431, 35: 707, 66: 133, 37: 267, 54: 575}, {2: 399, 60: 178}, {62: 341, 10: 342, 56: 155, 50: 122, 33: 532, 44: 414, 4: 229}, {9: 226, 30: 621, 5: 970, 49: 33}, {63: 328, 62: 641, 67: 509, 0: 302, 61: 150, 55: 121}, {17: 103}, {62: 952, 66: 655, 14: 66, 64: 160, 34: 256}, {11: 117, 19: 873, 52: 155}, {68: 855, 13: 496}, {60: 687, 45: 153, 21: 756}, {6: 386, 27: 761, 39: 609, 66: 315, 32: 990}, {38: 84, 22: 517}, {0: 236, 10: 361}, {7: 258, 43: 17}, {23: 387, 6: 211, 66: 808, 68: 301, 50: 6, 46: 184, 41: 179}, {9: 469, 62: 3, 19: 256, 0: 274, 5: 407, 2: 855, 42: 298}, {51: 14, 68: 745}, {9: 677, 13: 926, 63: 953, 27: 59}, {62: 664, 37: 740, 21: 603, 20: 715, 4: 118, 56: 367, 39: 749}, {15: 439, 66: 267, 47: 608, 64: 860, 10: 575}, {8: 236, 68: 231, 3: 800}, {}, {58: 941, 12: 86, 1: 903}, {46: 187, 64: 300, 18: 280, 36: 817, 57: 417, 68: 706}, {38: 193, 26: 557, 67: 917}, {52: 958, 9: 759}, {39: 20, 18: 939, 21: 835, 57: 436, 9: 480, 27: 646}, {63: 829, 67: 864, 65: 408, 68: 917}, {22: 799, 45: 366, 64: 72, 30: 359}, {59: 23, 22: 501, 67: 364, 35: 52}, {50: 430, 26: 224, 34: 85, 40: 575}, {6: 817, 31: 758, 32: 140, 58: 719}, {16: 816, 45: 50, 40: 867}, {}, {50: 17, 29: 150, 47: 562, 36: 738, 65: 901, 22: 229, 13: 848, 63: 618}, {62: 594, 16: 550, 14: 581, 6: 309}, {24: 826}, {15: 984, 61: 928, 5: 260, 4: 865, 12: 172}, {7: 916, 2: 315}, {61: 204, 54: 355, 59: 539, 16: 769, 53: 607}, {23: 678, 30: 204, 62: 992, 21: 697, 19: 684}, {13: 661, 21: 873, 37: 694, 20: 19, 45: 701, 36: 664, 46: 268, 29: 271}, {63: 433, 45: 948, 14: 430, 15: 482, 51: 605}, {31: 103, 7: 320, 61: 441}, {66: 761, 60: 172, 54: 687}, {40: 901, 15: 894, 19: 756}, {66: 454, 64: 870, 55: 985, 8: 912, 21: 87}, {22: 591, 12: 37, 67: 871}, {14: 433, 58: 111}, {61: 835, 34: 110, 30: 94}, {10: 480, 52: 416, 47: 341, 58: 220, 27: 965, 65: 458}, {68: 936, 1: 84, 3: 611, 2: 934, 54: 720, 66: 679}, {57: 504, 41: 893}, {54: 812, 8: 979}, {47: 623, 43: 981}, {33: 383, 4: 330, 50: 200}, {12: 676}, {18: 499, 66: 978, 20: 692, 30: 425, 0: 479, 60: 25, 42: 520}, {28: 160, 55: 873, 30: 765, 21: 179, 31: 317, 0: 75, 67: 633, 25: 721, 17: 436}, {62: 472, 12: 791, 55: 800, 42: 34}, {47: 91, 65: 382, 23: 957, 56: 41}, {0: 127, 21: 861, 52: 356, 53: 730, 34: 43}, {64: 856, 17: 228, 38: 11, 56: 24, 8: 244}, {0: 441, 41: 151, 24: 517, 52: 54, 27: 954, 13: 68}, {9: 628, 47: 87, 40: 604}], bound=780):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{3: 26, 35: 259, 8: 575, 64: 314}, {49: 934, 57: 392, 62: 437, 50: 540, 52: 748}, {27: 741, 2: 86, 9: 243, 66: 956, 14: 795, 31: 887, 11: 765}, {59: 17, 12: 820, 3: 807, 53: 888, 56: 897, 26: 889, 22: 932}, {16: 431, 35: 707, 66: 133, 37: 267, 54: 575}, {2: 399, 60: 178}, {62: 341, 10: 342, 56: 155, 50: 122, 33: 532, 44: 414, 4: 229}, {9: 226, 30: 621, 5: 970, 49: 33}, {63: 328, 62: 641, 67: 509, 0: 302, 61: 150, 55: 121}, {17: 103}, {62: 952, 66: 655, 14: 66, 64: 160, 34: 256}, {11: 117, 19: 873, 52: 155}, {68: 855, 13: 496}, {60: 687, 45: 153, 21: 756}, {6: 386, 27: 761, 39: 609, 66: 315, 32: 990}, {38: 84, 22: 517}, {0: 236, 10: 361}, {7: 258, 43: 17}, {23: 387, 6: 211, 66: 808, 68: 301, 50: 6, 46: 184, 41: 179}, {9: 469, 62: 3, 19: 256, 0: 274, 5: 407, 2: 855, 42: 298}, {51: 14, 68: 745}, {9: 677, 13: 926, 63: 953, 27: 59}, {62: 664, 37: 740, 21: 603, 20: 715, 4: 118, 56: 367, 39: 749}, {15: 439, 66: 267, 47: 608, 64: 860, 10: 575}, {8: 236, 68: 231, 3: 800}, {}, {58: 941, 12: 86, 1: 903}, {46: 187, 64: 300, 18: 280, 36: 817, 57: 417, 68: 706}, {38: 193, 26: 557, 67: 917}, {52: 958, 9: 759}, {39: 20, 18: 939, 21: 835, 57: 436, 9: 480, 27: 646}, {63: 829, 67: 864, 65: 408, 68: 917}, {22: 799, 45: 366, 64: 72, 30: 359}, {59: 23, 22: 501, 67: 364, 35: 52}, {50: 430, 26: 224, 34: 85, 40: 575}, {6: 817, 31: 758, 32: 140, 58: 719}, {16: 816, 45: 50, 40: 867}, {}, {50: 17, 29: 150, 47: 562, 36: 738, 65: 901, 22: 229, 13: 848, 63: 618}, {62: 594, 16: 550, 14: 581, 6: 309}, {24: 826}, {15: 984, 61: 928, 5: 260, 4: 865, 12: 172}, {7: 916, 2: 315}, {61: 204, 54: 355, 59: 539, 16: 769, 53: 607}, {23: 678, 30: 204, 62: 992, 21: 697, 19: 684}, {13: 661, 21: 873, 37: 694, 20: 19, 45: 701, 36: 664, 46: 268, 29: 271}, {63: 433, 45: 948, 14: 430, 15: 482, 51: 605}, {31: 103, 7: 320, 61: 441}, {66: 761, 60: 172, 54: 687}, {40: 901, 15: 894, 19: 756}, {66: 454, 64: 870, 55: 985, 8: 912, 21: 87}, {22: 591, 12: 37, 67: 871}, {14: 433, 58: 111}, {61: 835, 34: 110, 30: 94}, {10: 480, 52: 416, 47: 341, 58: 220, 27: 965, 65: 458}, {68: 936, 1: 84, 3: 611, 2: 934, 54: 720, 66: 679}, {57: 504, 41: 893}, {54: 812, 8: 979}, {47: 623, 43: 981}, {33: 383, 4: 330, 50: 200}, {12: 676}, {18: 499, 66: 978, 20: 692, 30: 425, 0: 479, 60: 25, 42: 520}, {28: 160, 55: 873, 30: 765, 21: 179, 31: 317, 0: 75, 67: 633, 25: 721, 17: 436}, {62: 472, 12: 791, 55: 800, 42: 34}, {47: 91, 65: 382, 23: 957, 56: 41}, {0: 127, 21: 861, 52: 356, 53: 730, 34: 43}, {64: 856, 17: 228, 38: 11, 56: 24, 8: 244}, {0: 441, 41: 151, 24: 517, 52: 54, 27: 954, 13: 68}, {9: 628, 47: 87, 40: 604}], bound=780):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_3",
    "sat": "def sat(path: List[int], weights=[{1: 798, 2: 790, 3: 961}, {4: 423, 2: 117}, {5: 572, 4: 310, 2: 60, 0: 41}, {2: 648, 0: 25, 5: 58, 4: 155}, {1: 657, 5: 709, 0: 497, 2: 844, 4: 28}, {4: 739, 1: 885, 0: 242}], bound=798):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{1: 798, 2: 790, 3: 961}, {4: 423, 2: 117}, {5: 572, 4: 310, 2: 60, 0: 41}, {2: 648, 0: 25, 5: 58, 4: 155}, {1: 657, 5: 709, 0: 497, 2: 844, 4: 28}, {4: 739, 1: 885, 0: 242}], bound=798):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_4",
    "sat": "def sat(path: List[int], weights=[{10: 838, 4: 885}, {5: 284}, {9: 177, 2: 493, 7: 986}, {3: 484, 0: 69}, {4: 261, 7: 290}, {8: 646, 7: 64, 1: 848, 0: 790, 9: 287}, {7: 261, 2: 207, 10: 299, 1: 257}, {0: 859, 1: 442, 5: 739, 6: 626}, {3: 867}, {3: 5, 2: 801, 5: 316}, {5: 432, 2: 568, 10: 699, 6: 334}], bound=1429):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{10: 838, 4: 885}, {5: 284}, {9: 177, 2: 493, 7: 986}, {3: 484, 0: 69}, {4: 261, 7: 290}, {8: 646, 7: 64, 1: 848, 0: 790, 9: 287}, {7: 261, 2: 207, 10: 299, 1: 257}, {0: 859, 1: 442, 5: 739, 6: 626}, {3: 867}, {3: 5, 2: 801, 5: 316}, {5: 432, 2: 568, 10: 699, 6: 334}], bound=1429):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_5",
    "sat": "def sat(path: List[int], weights=[{15: 688, 5: 755, 16: 383, 17: 466, 4: 659, 7: 872, 8: 612}, {10: 476, 0: 547, 3: 434, 7: 869, 13: 701, 5: 844, 14: 134}, {18: 131, 15: 707, 13: 541, 8: 777}, {11: 288, 2: 628, 17: 149}, {18: 183, 12: 403, 11: 130}, {5: 116, 6: 567, 9: 252, 1: 968}, {15: 891}, {18: 23, 16: 511}, {13: 116}, {10: 272, 3: 705, 16: 31, 11: 286, 5: 539}, {1: 84, 3: 790, 15: 812}, {12: 363, 9: 154, 16: 803, 14: 998}, {17: 522, 12: 566, 13: 691, 7: 582, 4: 386, 1: 652}, {6: 113, 4: 97, 18: 984}, {9: 629, 14: 627, 16: 520}, {8: 273, 4: 976, 0: 496, 10: 722, 11: 862}, {18: 23, 0: 491, 6: 182, 17: 651, 3: 247}, {4: 418, 12: 100, 8: 449}, {2: 849, 17: 224, 5: 472, 6: 739, 18: 125, 10: 25, 14: 723}], bound=515):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{15: 688, 5: 755, 16: 383, 17: 466, 4: 659, 7: 872, 8: 612}, {10: 476, 0: 547, 3: 434, 7: 869, 13: 701, 5: 844, 14: 134}, {18: 131, 15: 707, 13: 541, 8: 777}, {11: 288, 2: 628, 17: 149}, {18: 183, 12: 403, 11: 130}, {5: 116, 6: 567, 9: 252, 1: 968}, {15: 891}, {18: 23, 16: 511}, {13: 116}, {10: 272, 3: 705, 16: 31, 11: 286, 5: 539}, {1: 84, 3: 790, 15: 812}, {12: 363, 9: 154, 16: 803, 14: 998}, {17: 522, 12: 566, 13: 691, 7: 582, 4: 386, 1: 652}, {6: 113, 4: 97, 18: 984}, {9: 629, 14: 627, 16: 520}, {8: 273, 4: 976, 0: 496, 10: 722, 11: 862}, {18: 23, 0: 491, 6: 182, 17: 651, 3: 247}, {4: 418, 12: 100, 8: 449}, {2: 849, 17: 224, 5: 472, 6: 739, 18: 125, 10: 25, 14: 723}], bound=515):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_6",
    "sat": "def sat(path: List[int], weights=[{4: 494, 1: 812, 5: 630, 0: 223}, {2: 335, 5: 885, 0: 840, 4: 58}, {0: 379, 4: 580, 3: 987}, {0: 881, 4: 484}, {0: 230, 5: 869}, {0: 890, 4: 199, 5: 585, 2: 601, 3: 336}], bound=812):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{4: 494, 1: 812, 5: 630, 0: 223}, {2: 335, 5: 885, 0: 840, 4: 58}, {0: 379, 4: 580, 3: 987}, {0: 881, 4: 484}, {0: 230, 5: 869}, {0: 890, 4: 199, 5: 585, 2: 601, 3: 336}], bound=812):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_7",
    "sat": "def sat(path: List[int], weights=[{12: 314, 14: 904}, {11: 430}, {4: 794}, {6: 513, 8: 408, 4: 628, 5: 626, 0: 666, 7: 514, 10: 808}, {8: 857, 3: 81, 5: 991, 7: 270}, {6: 720, 2: 460}, {4: 671, 5: 592, 0: 604}, {8: 603, 10: 971, 12: 604, 7: 112}, {2: 577, 4: 55, 5: 710, 9: 254}, {1: 693, 10: 48}, {3: 443, 2: 294, 14: 511, 13: 187, 4: 496, 9: 891}, {5: 958, 9: 360, 12: 62}, {14: 866, 0: 677, 1: 341}, {0: 506, 10: 572, 14: 79, 9: 616}, {10: 785, 9: 200, 13: 343, 4: 388, 0: 809}, {3: 44, 2: 150, 14: 502, 6: 457, 13: 129}], bound=655):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{12: 314, 14: 904}, {11: 430}, {4: 794}, {6: 513, 8: 408, 4: 628, 5: 626, 0: 666, 7: 514, 10: 808}, {8: 857, 3: 81, 5: 991, 7: 270}, {6: 720, 2: 460}, {4: 671, 5: 592, 0: 604}, {8: 603, 10: 971, 12: 604, 7: 112}, {2: 577, 4: 55, 5: 710, 9: 254}, {1: 693, 10: 48}, {3: 443, 2: 294, 14: 511, 13: 187, 4: 496, 9: 891}, {5: 958, 9: 360, 12: 62}, {14: 866, 0: 677, 1: 341}, {0: 506, 10: 572, 14: 79, 9: 616}, {10: 785, 9: 200, 13: 343, 4: 388, 0: 809}, {3: 44, 2: 150, 14: 502, 6: 457, 13: 129}], bound=655):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_8",
    "sat": "def sat(path: List[int], weights=[{2: 837, 0: 329, 6: 630, 5: 942}, {2: 131}, {4: 945, 1: 35, 2: 947}, {2: 646, 1: 864, 0: 177, 3: 584}, {}, {4: 94, 6: 584, 5: 485}, {2: 801, 1: 680, 3: 420, 4: 647}], bound=872):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{2: 837, 0: 329, 6: 630, 5: 942}, {2: 131}, {4: 945, 1: 35, 2: 947}, {2: 646, 1: 864, 0: 177, 3: 584}, {}, {4: 94, 6: 584, 5: 485}, {2: 801, 1: 680, 3: 420, 4: 647}], bound=872):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "ShortestPath_9",
    "sat": "def sat(path: List[int], weights=[{44: 402, 71: 164, 9: 731}, {}, {23: 605, 36: 761}, {}, {}, {73: 499, 51: 365}, {2: 171, 53: 506}, {73: 181, 7: 884}, {44: 57, 56: 863, 0: 959}, {28: 254}, {12: 37, 73: 683}, {74: 770, 0: 249, 70: 285}, {}, {68: 785, 55: 766}, {}, {60: 411, 8: 969, 51: 189}, {23: 343}, {33: 936, 20: 420, 18: 373}, {}, {60: 309, 47: 131}, {36: 918}, {61: 293, 67: 442}, {59: 73, 42: 446, 19: 202}, {26: 873, 8: 450}, {}, {12: 75}, {17: 332, 73: 253}, {34: 177}, {31: 746, 8: 248}, {59: 190}, {13: 803}, {54: 769}, {56: 50, 62: 890}, {20: 342, 50: 497}, {}, {38: 890, 36: 59}, {31: 693}, {}, {37: 348}, {1: 154, 62: 363, 19: 61}, {37: 626, 39: 782}, {3: 265}, {34: 857, 11: 291}, {66: 499, 64: 615, 22: 5}, {}, {46: 952}, {}, {17: 33, 24: 535}, {}, {}, {59: 923}, {71: 509, 7: 111, 14: 937}, {1: 512, 41: 629, 50: 447}, {}, {}, {1: 481}, {71: 733}, {52: 937, 55: 324}, {22: 727, 69: 21, 70: 434}, {12: 167}, {24: 884, 25: 27}, {}, {20: 549, 4: 60}, {70: 105}, {}, {37: 103}, {24: 426, 27: 3, 20: 629}, {8: 655, 65: 370}, {63: 518}, {}, {}, {1: 477, 13: 270, 73: 352}, {6: 163}, {12: 517, 14: 676}, {}], bound=641):\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "sols": [
      "def sol(weights=[{44: 402, 71: 164, 9: 731}, {}, {23: 605, 36: 761}, {}, {}, {73: 499, 51: 365}, {2: 171, 53: 506}, {73: 181, 7: 884}, {44: 57, 56: 863, 0: 959}, {28: 254}, {12: 37, 73: 683}, {74: 770, 0: 249, 70: 285}, {}, {68: 785, 55: 766}, {}, {60: 411, 8: 969, 51: 189}, {23: 343}, {33: 936, 20: 420, 18: 373}, {}, {60: 309, 47: 131}, {36: 918}, {61: 293, 67: 442}, {59: 73, 42: 446, 19: 202}, {26: 873, 8: 450}, {}, {12: 75}, {17: 332, 73: 253}, {34: 177}, {31: 746, 8: 248}, {59: 190}, {13: 803}, {54: 769}, {56: 50, 62: 890}, {20: 342, 50: 497}, {}, {38: 890, 36: 59}, {31: 693}, {}, {37: 348}, {1: 154, 62: 363, 19: 61}, {37: 626, 39: 782}, {3: 265}, {34: 857, 11: 291}, {66: 499, 64: 615, 22: 5}, {}, {46: 952}, {}, {17: 33, 24: 535}, {}, {}, {59: 923}, {71: 509, 7: 111, 14: 937}, {1: 512, 41: 629, 50: 447}, {}, {}, {1: 481}, {71: 733}, {52: 937, 55: 324}, {22: 727, 69: 21, 70: 434}, {12: 167}, {24: 884, 25: 27}, {}, {20: 549, 4: 60}, {70: 105}, {}, {37: 103}, {24: 426, 27: 3, 20: 629}, {8: 655, 65: 370}, {63: 518}, {}, {}, {1: 477, 13: 270, 73: 352}, {6: 163}, {12: 517, 14: 676}, {}], bound=641):  # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_0",
    "sat": "def sat(path: List[int], edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_1",
    "sat": "def sat(path: List[int], edges=[[0, 1], [1, 4], [6, 9], [4, 3], [7, 8], [7, 2], [0, 8], [8, 2], [2, 5], [2, 2], [1, 7], [4, 2], [3, 4], [2, 9], [6, 5], [7, 5], [7, 6], [3, 8], [5, 9], [7, 7], [8, 6], [7, 9], [2, 7], [5, 6], [5, 5], [2, 8], [3, 3], [1, 3], [4, 9], [3, 6], [6, 4], [6, 6], [0, 7], [7, 3], [9, 7], [1, 0]], u=2, v=3, bound=3):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[0, 1], [1, 4], [6, 9], [4, 3], [7, 8], [7, 2], [0, 8], [8, 2], [2, 5], [2, 2], [1, 7], [4, 2], [3, 4], [2, 9], [6, 5], [7, 5], [7, 6], [3, 8], [5, 9], [7, 7], [8, 6], [7, 9], [2, 7], [5, 6], [5, 5], [2, 8], [3, 3], [1, 3], [4, 9], [3, 6], [6, 4], [6, 6], [0, 7], [7, 3], [9, 7], [1, 0]], u=2, v=3, bound=3):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_2",
    "sat": "def sat(path: List[int], edges=[[39, 62], [31, 22], [53, 12], [60, 23], [19, 2], [20, 15], [40, 59], [47, 36], [42, 38], [24, 57], [31, 7], [52, 53], [58, 27], [53, 18], [21, 62], [65, 41], [11, 24], [52, 50], [16, 41], [34, 29], [27, 39], [9, 35], [13, 33], [3, 64], [49, 39], [4, 41], [33, 15], [41, 61], [18, 14], [2, 59], [2, 15], [56, 2], [19, 22], [29, 22], [52, 23], [36, 61], [11, 14], [63, 55], [46, 47], [45, 3], [50, 45], [8, 43], [17, 42], [54, 47], [4, 3], [7, 18], [14, 18], [26, 49], [35, 57], [50, 25], [49, 53], [20, 38], [56, 5], [34, 45], [18, 53], [63, 5], [53, 0], [34, 7], [23, 3], [37, 36], [35, 8], [6, 29], [24, 49], [14, 47], [10, 27], [64, 47], [18, 43], [44, 27], [52, 61], [48, 7], [3, 2], [7, 8], [6, 32], [23, 18], [37, 65], [6, 58], [45, 13], [21, 63], [11, 27], [16, 18], [19, 38], [28, 57], [56, 25], [32, 37], [23, 40], [48, 34], [37, 29], [26, 60], [14, 57], [52, 65], [13, 54], [13, 52], [18, 12], [15, 2], [15, 27], [24, 59], [22, 41], [53, 53], [56, 23], [58, 57], [29, 12], [14, 10], [51, 11], [13, 5], [57, 27], [31, 62], [38, 0], [0, 26], [51, 8], [17, 35], [35, 50], [9, 64], [21, 59], [59, 15], [61, 27], [44, 42], [20, 20], [21, 60], [32, 51], [36, 16], [58, 25], [31, 9], [35, 46], [21, 61], [60, 34], [60, 59], [60, 3], [27, 45], [64, 34], [11, 30], [56, 53], [43, 20], [32, 49], [1, 23], [50, 16], [54, 43], [17, 27], [7, 15], [36, 25], [0, 33], [32, 13], [7, 30], [64, 40], [59, 64], [14, 59], [60, 63], [29, 40], [58, 12], [38, 9], [46, 48], [37, 30], [35, 1], [9, 12], [61, 40], [10, 14], [43, 5], [63, 24], [21, 14], [65, 58], [61, 28], [56, 11], [29, 64], [25, 50], [55, 46], [26, 42], [44, 39], [14, 1], [30, 7], [43, 7], [65, 46], [36, 53], [64, 41], [10, 25], [28, 22], [11, 37], [3, 19], [22, 16], [19, 50], [62, 42], [13, 44], [62, 20], [20, 59], [57, 54], [26, 24], [32, 65], [23, 25], [14, 22], [39, 20], [9, 60], [7, 2], [12, 20], [63, 62], [46, 14], [60, 57], [16, 11], [0, 47], [23, 47], [2, 5], [6, 33], [53, 57], [12, 39], [48, 2], [42, 9], [42, 4], [9, 61], [64, 10], [35, 48], [29, 21], [19, 35], [24, 63], [43, 11], [2, 17], [55, 27], [43, 65], [49, 51], [27, 42], [49, 19], [65, 65], [49, 44], [24, 5], [3, 9], [65, 4], [36, 27], [59, 7], [57, 17], [62, 0], [60, 53], [61, 13], [1, 62], [14, 65], [43, 9], [52, 36], [33, 52], [32, 30], [52, 13], [10, 56], [53, 51], [50, 19], [37, 11], [23, 52], [22, 45], [39, 19], [30, 24], [12, 22], [21, 30], [43, 51], [46, 26], [30, 54], [19, 32], [43, 12], [52, 12], [35, 20], [52, 5], [18, 20], [35, 59], [31, 13], [48, 58], [30, 50], [35, 23], [52, 15], [28, 45], [44, 62], [45, 31], [37, 22], [25, 38], [40, 52], [8, 59], [34, 46], [44, 53], [32, 43], [17, 51], [3, 3], [5, 13], [40, 45], [4, 62], [53, 13], [42, 46], [37, 12], [3, 21], [10, 0], [22, 48], [57, 60], [5, 27], [16, 39], [1, 29], [52, 54], [47, 52], [63, 36], [29, 11], [41, 51], [60, 21], [52, 6], [65, 59], [47, 54], [11, 62], [30, 5], [10, 57], [16, 56], [30, 40], [17, 16], [63, 56], [45, 18], [60, 4], [0, 37], [23, 4], [19, 15], [37, 57], [8, 50], [51, 21], [60, 20], [39, 17], [65, 38], [24, 35], [62, 34]], u=20, v=50, bound=5):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[39, 62], [31, 22], [53, 12], [60, 23], [19, 2], [20, 15], [40, 59], [47, 36], [42, 38], [24, 57], [31, 7], [52, 53], [58, 27], [53, 18], [21, 62], [65, 41], [11, 24], [52, 50], [16, 41], [34, 29], [27, 39], [9, 35], [13, 33], [3, 64], [49, 39], [4, 41], [33, 15], [41, 61], [18, 14], [2, 59], [2, 15], [56, 2], [19, 22], [29, 22], [52, 23], [36, 61], [11, 14], [63, 55], [46, 47], [45, 3], [50, 45], [8, 43], [17, 42], [54, 47], [4, 3], [7, 18], [14, 18], [26, 49], [35, 57], [50, 25], [49, 53], [20, 38], [56, 5], [34, 45], [18, 53], [63, 5], [53, 0], [34, 7], [23, 3], [37, 36], [35, 8], [6, 29], [24, 49], [14, 47], [10, 27], [64, 47], [18, 43], [44, 27], [52, 61], [48, 7], [3, 2], [7, 8], [6, 32], [23, 18], [37, 65], [6, 58], [45, 13], [21, 63], [11, 27], [16, 18], [19, 38], [28, 57], [56, 25], [32, 37], [23, 40], [48, 34], [37, 29], [26, 60], [14, 57], [52, 65], [13, 54], [13, 52], [18, 12], [15, 2], [15, 27], [24, 59], [22, 41], [53, 53], [56, 23], [58, 57], [29, 12], [14, 10], [51, 11], [13, 5], [57, 27], [31, 62], [38, 0], [0, 26], [51, 8], [17, 35], [35, 50], [9, 64], [21, 59], [59, 15], [61, 27], [44, 42], [20, 20], [21, 60], [32, 51], [36, 16], [58, 25], [31, 9], [35, 46], [21, 61], [60, 34], [60, 59], [60, 3], [27, 45], [64, 34], [11, 30], [56, 53], [43, 20], [32, 49], [1, 23], [50, 16], [54, 43], [17, 27], [7, 15], [36, 25], [0, 33], [32, 13], [7, 30], [64, 40], [59, 64], [14, 59], [60, 63], [29, 40], [58, 12], [38, 9], [46, 48], [37, 30], [35, 1], [9, 12], [61, 40], [10, 14], [43, 5], [63, 24], [21, 14], [65, 58], [61, 28], [56, 11], [29, 64], [25, 50], [55, 46], [26, 42], [44, 39], [14, 1], [30, 7], [43, 7], [65, 46], [36, 53], [64, 41], [10, 25], [28, 22], [11, 37], [3, 19], [22, 16], [19, 50], [62, 42], [13, 44], [62, 20], [20, 59], [57, 54], [26, 24], [32, 65], [23, 25], [14, 22], [39, 20], [9, 60], [7, 2], [12, 20], [63, 62], [46, 14], [60, 57], [16, 11], [0, 47], [23, 47], [2, 5], [6, 33], [53, 57], [12, 39], [48, 2], [42, 9], [42, 4], [9, 61], [64, 10], [35, 48], [29, 21], [19, 35], [24, 63], [43, 11], [2, 17], [55, 27], [43, 65], [49, 51], [27, 42], [49, 19], [65, 65], [49, 44], [24, 5], [3, 9], [65, 4], [36, 27], [59, 7], [57, 17], [62, 0], [60, 53], [61, 13], [1, 62], [14, 65], [43, 9], [52, 36], [33, 52], [32, 30], [52, 13], [10, 56], [53, 51], [50, 19], [37, 11], [23, 52], [22, 45], [39, 19], [30, 24], [12, 22], [21, 30], [43, 51], [46, 26], [30, 54], [19, 32], [43, 12], [52, 12], [35, 20], [52, 5], [18, 20], [35, 59], [31, 13], [48, 58], [30, 50], [35, 23], [52, 15], [28, 45], [44, 62], [45, 31], [37, 22], [25, 38], [40, 52], [8, 59], [34, 46], [44, 53], [32, 43], [17, 51], [3, 3], [5, 13], [40, 45], [4, 62], [53, 13], [42, 46], [37, 12], [3, 21], [10, 0], [22, 48], [57, 60], [5, 27], [16, 39], [1, 29], [52, 54], [47, 52], [63, 36], [29, 11], [41, 51], [60, 21], [52, 6], [65, 59], [47, 54], [11, 62], [30, 5], [10, 57], [16, 56], [30, 40], [17, 16], [63, 56], [45, 18], [60, 4], [0, 37], [23, 4], [19, 15], [37, 57], [8, 50], [51, 21], [60, 20], [39, 17], [65, 38], [24, 35], [62, 34]], u=20, v=50, bound=5):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_3",
    "sat": "def sat(path: List[int], edges=[[3, 8], [8, 7], [0, 7], [7, 8], [1, 2], [1, 4], [2, 3], [4, 3], [6, 1], [3, 4], [6, 7], [6, 8], [3, 1], [6, 6], [4, 0], [8, 0], [1, 5], [0, 5], [0, 1], [2, 5], [4, 8], [2, 8], [1, 6], [4, 1], [3, 5], [8, 1], [0, 3], [5, 7], [8, 5], [5, 4], [8, 2], [8, 3], [8, 8], [5, 2]], u=3, v=4, bound=2):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[3, 8], [8, 7], [0, 7], [7, 8], [1, 2], [1, 4], [2, 3], [4, 3], [6, 1], [3, 4], [6, 7], [6, 8], [3, 1], [6, 6], [4, 0], [8, 0], [1, 5], [0, 5], [0, 1], [2, 5], [4, 8], [2, 8], [1, 6], [4, 1], [3, 5], [8, 1], [0, 3], [5, 7], [8, 5], [5, 4], [8, 2], [8, 3], [8, 8], [5, 2]], u=3, v=4, bound=2):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_4",
    "sat": "def sat(path: List[int], edges=[[2, 3], [4, 4], [0, 1], [6, 2], [0, 0], [2, 1], [6, 4], [1, 2], [3, 3], [0, 3], [5, 0], [3, 2], [3, 5], [3, 4], [5, 3], [5, 5], [5, 1], [1, 3], [4, 1], [6, 0], [2, 2], [1, 1]], u=3, v=2, bound=2):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[2, 3], [4, 4], [0, 1], [6, 2], [0, 0], [2, 1], [6, 4], [1, 2], [3, 3], [0, 3], [5, 0], [3, 2], [3, 5], [3, 4], [5, 3], [5, 5], [5, 1], [1, 3], [4, 1], [6, 0], [2, 2], [1, 1]], u=3, v=2, bound=2):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_5",
    "sat": "def sat(path: List[int], edges=[[6, 1], [0, 6], [1, 5], [6, 0], [3, 7], [7, 8], [9, 6], [1, 10], [5, 4], [4, 0], [8, 8], [4, 8], [2, 4], [5, 10], [10, 8], [5, 6], [2, 3], [1, 7], [6, 7], [3, 8], [9, 8], [2, 1], [2, 0], [6, 3], [10, 1], [3, 9], [6, 9], [6, 5], [8, 9], [4, 9], [3, 10], [2, 10], [5, 7], [9, 2], [2, 2], [8, 7], [3, 4], [9, 9], [2, 8], [9, 0], [1, 3], [4, 6], [5, 0]], u=8, v=1, bound=4):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[6, 1], [0, 6], [1, 5], [6, 0], [3, 7], [7, 8], [9, 6], [1, 10], [5, 4], [4, 0], [8, 8], [4, 8], [2, 4], [5, 10], [10, 8], [5, 6], [2, 3], [1, 7], [6, 7], [3, 8], [9, 8], [2, 1], [2, 0], [6, 3], [10, 1], [3, 9], [6, 9], [6, 5], [8, 9], [4, 9], [3, 10], [2, 10], [5, 7], [9, 2], [2, 2], [8, 7], [3, 4], [9, 9], [2, 8], [9, 0], [1, 3], [4, 6], [5, 0]], u=8, v=1, bound=4):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_6",
    "sat": "def sat(path: List[int], edges=[[11, 1], [12, 9], [7, 10], [7, 6], [2, 10], [10, 4], [9, 10], [0, 11], [7, 0], [5, 4], [0, 2], [2, 4], [8, 4], [4, 5], [3, 11], [10, 1], [2, 0], [8, 1], [10, 3], [5, 1], [5, 7], [5, 0], [7, 1], [6, 4], [0, 3], [0, 5], [9, 1], [6, 10], [3, 9], [2, 9], [3, 2], [6, 9], [12, 5], [0, 6], [4, 0], [1, 6], [3, 4], [1, 10], [1, 2], [6, 1], [12, 8], [0, 0], [6, 5], [11, 0], [11, 11], [6, 6], [8, 2], [4, 10], [3, 5]], u=6, v=0, bound=3):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[11, 1], [12, 9], [7, 10], [7, 6], [2, 10], [10, 4], [9, 10], [0, 11], [7, 0], [5, 4], [0, 2], [2, 4], [8, 4], [4, 5], [3, 11], [10, 1], [2, 0], [8, 1], [10, 3], [5, 1], [5, 7], [5, 0], [7, 1], [6, 4], [0, 3], [0, 5], [9, 1], [6, 10], [3, 9], [2, 9], [3, 2], [6, 9], [12, 5], [0, 6], [4, 0], [1, 6], [3, 4], [1, 10], [1, 2], [6, 1], [12, 8], [0, 0], [6, 5], [11, 0], [11, 11], [6, 6], [8, 2], [4, 10], [3, 5]], u=6, v=0, bound=3):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_7",
    "sat": "def sat(path: List[int], edges=[[2, 5], [2, 7], [4, 6], [6, 6], [0, 6], [5, 3], [0, 2], [1, 6], [3, 4], [4, 2], [0, 3], [0, 1], [6, 5], [7, 0], [6, 3], [4, 0], [3, 2], [2, 1], [3, 7], [3, 0], [5, 7], [6, 0], [6, 1], [2, 6], [1, 3], [7, 6]], u=5, v=6, bound=3):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[2, 5], [2, 7], [4, 6], [6, 6], [0, 6], [5, 3], [0, 2], [1, 6], [3, 4], [4, 2], [0, 3], [0, 1], [6, 5], [7, 0], [6, 3], [4, 0], [3, 2], [2, 1], [3, 7], [3, 0], [5, 7], [6, 0], [6, 1], [2, 6], [1, 3], [7, 6]], u=5, v=6, bound=3):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_8",
    "sat": "def sat(path: List[int], edges=[[6, 7], [3, 7], [2, 3], [5, 1], [0, 6], [1, 6], [4, 2], [4, 6], [3, 6], [7, 7], [3, 5], [3, 3], [7, 6], [6, 5], [2, 0], [2, 5], [0, 0], [1, 5], [5, 4], [7, 2], [0, 2], [4, 4], [6, 3], [4, 1], [1, 3], [5, 7], [5, 5], [7, 4]], u=3, v=3, bound=1):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[6, 7], [3, 7], [2, 3], [5, 1], [0, 6], [1, 6], [4, 2], [4, 6], [3, 6], [7, 7], [3, 5], [3, 3], [7, 6], [6, 5], [2, 0], [2, 5], [0, 0], [1, 5], [5, 4], [7, 2], [0, 2], [4, 4], [6, 3], [4, 1], [1, 3], [5, 7], [5, 5], [7, 4]], u=3, v=3, bound=1):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "UnweightedShortestPath_9",
    "sat": "def sat(path: List[int], edges=[[2, 5], [5, 0], [0, 5], [4, 7], [3, 3], [7, 3], [10, 3], [9, 0], [7, 8], [0, 3], [9, 5], [6, 2], [5, 2], [5, 6], [8, 9], [1, 6], [6, 4], [5, 8], [8, 3], [10, 1], [8, 6], [6, 10], [8, 1], [3, 8], [5, 1], [1, 4], [6, 6], [10, 5], [4, 5], [2, 6], [3, 9], [8, 7], [10, 2], [7, 6], [6, 3], [3, 0], [4, 1], [2, 0], [6, 1]], u=5, v=7, bound=3):\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "sols": [
      "def sol(edges=[[2, 5], [5, 0], [0, 5], [4, 7], [3, 3], [7, 3], [10, 3], [9, 0], [7, 8], [0, 3], [9, 5], [6, 2], [5, 2], [5, 6], [8, 9], [1, 6], [6, 4], [5, 8], [8, 3], [10, 1], [8, 6], [6, 10], [8, 1], [3, 8], [5, 1], [1, 4], [6, 6], [10, 5], [4, 5], [2, 6], [3, 9], [8, 7], [10, 2], [7, 6], [6, 3], [3, 0], [4, 1], [2, 0], [6, 1]], u=5, v=7, bound=3):  # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_0",
    "sat": "def sat(path: List[int], edges=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_1",
    "sat": "def sat(path: List[int], edges=[[0, 4], [1, 3], [5, 2], [2, 4], [4, 2], [3, 5], [5, 1], [2, 3], [5, 4], [0, 2], [0, 0], [5, 5]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[0, 4], [1, 3], [5, 2], [2, 4], [4, 2], [3, 5], [5, 1], [2, 3], [5, 4], [0, 2], [0, 0], [5, 5]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_2",
    "sat": "def sat(path: List[int], edges=[[0, 7], [4, 7], [4, 1], [3, 3], [0, 6], [7, 4], [3, 0], [8, 4], [1, 8], [1, 0], [2, 0], [7, 6], [8, 7], [5, 2], [4, 6], [4, 3]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[0, 7], [4, 7], [4, 1], [3, 3], [0, 6], [7, 4], [3, 0], [8, 4], [1, 8], [1, 0], [2, 0], [7, 6], [8, 7], [5, 2], [4, 6], [4, 3]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_3",
    "sat": "def sat(path: List[int], edges=[[1, 6], [3, 7], [4, 1], [3, 6], [6, 5], [4, 4], [4, 3], [6, 2], [0, 1], [1, 2], [0, 2], [6, 4], [5, 4], [1, 4]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[1, 6], [3, 7], [4, 1], [3, 6], [6, 5], [4, 4], [4, 3], [6, 2], [0, 1], [1, 2], [0, 2], [6, 4], [5, 4], [1, 4]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_4",
    "sat": "def sat(path: List[int], edges=[[15, 5], [24, 28], [24, 3], [14, 33], [1, 19], [38, 3], [6, 39], [20, 6], [2, 12], [3, 16], [20, 15], [19, 21], [37, 25], [0, 3], [2, 20], [34, 24], [1, 36], [11, 23], [4, 15], [12, 24], [12, 25], [29, 28], [18, 2], [4, 22], [8, 32], [22, 29], [33, 12], [30, 19], [15, 13], [35, 29], [29, 31], [20, 37], [0, 12], [13, 25], [25, 14], [0, 14], [34, 31], [36, 18], [36, 31], [30, 37], [25, 31], [18, 20], [38, 20], [11, 4], [8, 18], [21, 8], [35, 35], [14, 5], [16, 0], [39, 14], [28, 1], [15, 32], [23, 3], [5, 36], [6, 36], [33, 38], [11, 24], [37, 38], [21, 34], [17, 37], [0, 8], [29, 15], [33, 16], [21, 16], [30, 33], [0, 24], [22, 23], [18, 4], [26, 8], [39, 26], [9, 8], [38, 1], [33, 8], [22, 17], [24, 7], [6, 6], [19, 37], [0, 36], [17, 8]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[15, 5], [24, 28], [24, 3], [14, 33], [1, 19], [38, 3], [6, 39], [20, 6], [2, 12], [3, 16], [20, 15], [19, 21], [37, 25], [0, 3], [2, 20], [34, 24], [1, 36], [11, 23], [4, 15], [12, 24], [12, 25], [29, 28], [18, 2], [4, 22], [8, 32], [22, 29], [33, 12], [30, 19], [15, 13], [35, 29], [29, 31], [20, 37], [0, 12], [13, 25], [25, 14], [0, 14], [34, 31], [36, 18], [36, 31], [30, 37], [25, 31], [18, 20], [38, 20], [11, 4], [8, 18], [21, 8], [35, 35], [14, 5], [16, 0], [39, 14], [28, 1], [15, 32], [23, 3], [5, 36], [6, 36], [33, 38], [11, 24], [37, 38], [21, 34], [17, 37], [0, 8], [29, 15], [33, 16], [21, 16], [30, 33], [0, 24], [22, 23], [18, 4], [26, 8], [39, 26], [9, 8], [38, 1], [33, 8], [22, 17], [24, 7], [6, 6], [19, 37], [0, 36], [17, 8]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_5",
    "sat": "def sat(path: List[int], edges=[[0, 1], [2, 1], [1, 1], [0, 0], [0, 2]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[0, 1], [2, 1], [1, 1], [0, 0], [0, 2]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_6",
    "sat": "def sat(path: List[int], edges=[[7, 6], [3, 2], [2, 5], [3, 7], [6, 6], [2, 8], [4, 8], [7, 8], [8, 3], [6, 1], [2, 3], [0, 0], [5, 4], [4, 7], [0, 2], [3, 0]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[7, 6], [3, 2], [2, 5], [3, 7], [6, 6], [2, 8], [4, 8], [7, 8], [8, 3], [6, 1], [2, 3], [0, 0], [5, 4], [4, 7], [0, 2], [3, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_7",
    "sat": "def sat(path: List[int], edges=[[2, 1], [0, 2], [1, 1], [2, 0]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[2, 1], [0, 2], [1, 1], [2, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_8",
    "sat": "def sat(path: List[int], edges=[[37, 7], [0, 37], [32, 2], [9, 29], [5, 13], [5, 35], [11, 16], [25, 41], [47, 16], [1, 13], [36, 48], [37, 8], [23, 34], [46, 15], [3, 26], [22, 46], [42, 10], [21, 25], [22, 24], [9, 3], [28, 9], [26, 48], [47, 42], [26, 7], [28, 16], [20, 20], [34, 34], [45, 39], [3, 3], [44, 4], [15, 13], [9, 24], [27, 43], [34, 13], [37, 30], [26, 38], [37, 20], [47, 28], [0, 32], [22, 6], [22, 15], [7, 24], [14, 24], [12, 45], [29, 5], [19, 8], [29, 9], [41, 41], [2, 25], [32, 1], [41, 42], [21, 24], [23, 33], [9, 14], [46, 21], [14, 21], [33, 48], [42, 5], [6, 48], [22, 8], [6, 4], [5, 26], [8, 11], [11, 3], [0, 48], [9, 12], [37, 33], [36, 46], [18, 39], [24, 2], [23, 46], [16, 26], [24, 21], [29, 16], [33, 4], [39, 3], [14, 0], [3, 41], [17, 13], [20, 12], [37, 5], [1, 42], [8, 37], [47, 3], [30, 28], [26, 1], [11, 7], [39, 25], [7, 41], [39, 24], [30, 11], [13, 38], [44, 15], [1, 17]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[37, 7], [0, 37], [32, 2], [9, 29], [5, 13], [5, 35], [11, 16], [25, 41], [47, 16], [1, 13], [36, 48], [37, 8], [23, 34], [46, 15], [3, 26], [22, 46], [42, 10], [21, 25], [22, 24], [9, 3], [28, 9], [26, 48], [47, 42], [26, 7], [28, 16], [20, 20], [34, 34], [45, 39], [3, 3], [44, 4], [15, 13], [9, 24], [27, 43], [34, 13], [37, 30], [26, 38], [37, 20], [47, 28], [0, 32], [22, 6], [22, 15], [7, 24], [14, 24], [12, 45], [29, 5], [19, 8], [29, 9], [41, 41], [2, 25], [32, 1], [41, 42], [21, 24], [23, 33], [9, 14], [46, 21], [14, 21], [33, 48], [42, 5], [6, 48], [22, 8], [6, 4], [5, 26], [8, 11], [11, 3], [0, 48], [9, 12], [37, 33], [36, 46], [18, 39], [24, 2], [23, 46], [16, 26], [24, 21], [29, 16], [33, 4], [39, 3], [14, 0], [3, 41], [17, 13], [20, 12], [37, 5], [1, 42], [8, 37], [47, 3], [30, 28], [26, 1], [11, 7], [39, 25], [7, 41], [39, 24], [30, 11], [13, 38], [44, 15], [1, 17]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "AnyPath_9",
    "sat": "def sat(path: List[int], edges=[[0, 0]]):\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "sols": [
      "def sol(edges=[[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_0",
    "sat": "def sat(path: List[int], edges=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[0, 2], [0, 1], [2, 1], [2, 3], [1, 3]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_1",
    "sat": "def sat(path: List[int], edges=[[16, 11], [27, 28], [30, 4], [18, 10], [25, 16], [15, 18], [30, 20], [12, 29], [19, 11], [8, 3], [4, 29], [27, 4], [3, 11], [30, 12], [11, 18], [9, 0], [31, 1], [1, 17], [3, 25], [15, 8], [29, 28], [21, 5], [4, 1], [18, 19], [6, 11], [17, 14], [2, 27], [12, 3], [11, 13], [4, 2], [19, 3], [7, 5], [31, 26], [20, 30], [13, 4], [1, 3], [17, 31], [17, 4], [27, 19], [10, 5], [0, 17], [29, 7], [25, 30], [23, 10], [2, 1], [20, 25], [10, 12], [23, 22], [17, 12], [21, 11], [10, 20], [26, 22], [18, 9], [16, 2], [14, 17], [3, 13], [9, 3], [11, 11], [5, 13], [25, 14], [11, 14]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[16, 11], [27, 28], [30, 4], [18, 10], [25, 16], [15, 18], [30, 20], [12, 29], [19, 11], [8, 3], [4, 29], [27, 4], [3, 11], [30, 12], [11, 18], [9, 0], [31, 1], [1, 17], [3, 25], [15, 8], [29, 28], [21, 5], [4, 1], [18, 19], [6, 11], [17, 14], [2, 27], [12, 3], [11, 13], [4, 2], [19, 3], [7, 5], [31, 26], [20, 30], [13, 4], [1, 3], [17, 31], [17, 4], [27, 19], [10, 5], [0, 17], [29, 7], [25, 30], [23, 10], [2, 1], [20, 25], [10, 12], [23, 22], [17, 12], [21, 11], [10, 20], [26, 22], [18, 9], [16, 2], [14, 17], [3, 13], [9, 3], [11, 11], [5, 13], [25, 14], [11, 14]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_2",
    "sat": "def sat(path: List[int], edges=[[59, 22], [13, 49], [27, 69], [59, 45], [20, 8], [65, 31], [55, 62], [29, 48], [30, 19], [0, 6], [43, 15], [36, 33], [51, 13], [25, 17], [57, 18], [40, 12], [62, 58], [31, 40], [37, 35], [45, 41], [1, 66], [28, 26], [15, 52], [10, 53], [8, 6], [53, 18], [46, 40], [29, 49], [33, 20], [37, 42], [16, 40], [55, 38], [25, 63], [50, 30], [50, 39], [34, 44], [24, 50], [4, 54], [4, 61], [45, 69], [1, 12], [30, 46], [66, 52], [21, 65], [32, 35], [29, 33], [46, 19], [22, 2], [40, 67], [8, 66], [54, 45], [19, 56], [60, 57], [59, 66], [62, 48], [49, 36], [1, 10], [17, 47], [41, 13], [26, 19], [4, 11], [53, 12], [54, 69], [2, 39], [52, 58], [49, 58], [26, 38], [51, 35], [38, 64], [2, 14], [53, 55], [58, 69], [64, 35], [54, 39], [29, 64], [3, 54], [48, 61], [52, 23], [66, 40], [24, 17], [29, 16], [55, 63], [64, 29], [10, 45], [51, 45], [61, 27], [67, 0], [27, 62], [60, 25], [19, 12], [4, 10], [13, 43], [12, 4], [33, 9], [55, 25], [4, 38], [4, 23], [43, 25], [52, 30], [63, 2], [68, 7], [39, 60], [35, 38], [23, 23], [40, 11], [24, 32], [56, 66], [48, 33], [48, 39], [41, 9], [23, 69], [10, 63], [23, 0], [32, 39], [67, 29], [22, 48], [55, 42], [33, 57], [9, 40], [13, 55], [61, 20], [50, 22], [5, 1], [58, 17], [6, 68], [18, 16], [0, 38], [22, 33], [12, 34], [8, 39], [14, 0], [47, 19], [11, 67], [1, 20], [64, 18], [33, 35], [61, 61]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[59, 22], [13, 49], [27, 69], [59, 45], [20, 8], [65, 31], [55, 62], [29, 48], [30, 19], [0, 6], [43, 15], [36, 33], [51, 13], [25, 17], [57, 18], [40, 12], [62, 58], [31, 40], [37, 35], [45, 41], [1, 66], [28, 26], [15, 52], [10, 53], [8, 6], [53, 18], [46, 40], [29, 49], [33, 20], [37, 42], [16, 40], [55, 38], [25, 63], [50, 30], [50, 39], [34, 44], [24, 50], [4, 54], [4, 61], [45, 69], [1, 12], [30, 46], [66, 52], [21, 65], [32, 35], [29, 33], [46, 19], [22, 2], [40, 67], [8, 66], [54, 45], [19, 56], [60, 57], [59, 66], [62, 48], [49, 36], [1, 10], [17, 47], [41, 13], [26, 19], [4, 11], [53, 12], [54, 69], [2, 39], [52, 58], [49, 58], [26, 38], [51, 35], [38, 64], [2, 14], [53, 55], [58, 69], [64, 35], [54, 39], [29, 64], [3, 54], [48, 61], [52, 23], [66, 40], [24, 17], [29, 16], [55, 63], [64, 29], [10, 45], [51, 45], [61, 27], [67, 0], [27, 62], [60, 25], [19, 12], [4, 10], [13, 43], [12, 4], [33, 9], [55, 25], [4, 38], [4, 23], [43, 25], [52, 30], [63, 2], [68, 7], [39, 60], [35, 38], [23, 23], [40, 11], [24, 32], [56, 66], [48, 33], [48, 39], [41, 9], [23, 69], [10, 63], [23, 0], [32, 39], [67, 29], [22, 48], [55, 42], [33, 57], [9, 40], [13, 55], [61, 20], [50, 22], [5, 1], [58, 17], [6, 68], [18, 16], [0, 38], [22, 33], [12, 34], [8, 39], [14, 0], [47, 19], [11, 67], [1, 20], [64, 18], [33, 35], [61, 61]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_3",
    "sat": "def sat(path: List[int], edges=[[0, 9], [5, 7], [5, 4], [4, 9], [1, 4], [4, 8], [8, 6], [8, 2], [6, 5], [6, 9], [1, 3], [6, 3], [7, 9], [6, 2], [7, 7], [5, 1]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[0, 9], [5, 7], [5, 4], [4, 9], [1, 4], [4, 8], [8, 6], [8, 2], [6, 5], [6, 9], [1, 3], [6, 3], [7, 9], [6, 2], [7, 7], [5, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_4",
    "sat": "def sat(path: List[int], edges=[[0, 1], [9, 21], [47, 53], [57, 57], [18, 4], [59, 35], [23, 48], [30, 53], [18, 27], [26, 35], [59, 57], [16, 39], [28, 2], [25, 1], [14, 44], [47, 14], [58, 11], [50, 47], [18, 35], [59, 59], [14, 9], [25, 7], [5, 3], [23, 51], [55, 60], [2, 40], [12, 41], [20, 46], [6, 15], [19, 40], [1, 34], [41, 10], [38, 29], [29, 34], [15, 9], [25, 3], [40, 25], [37, 56], [7, 20], [7, 49], [29, 21], [30, 9], [24, 53], [41, 57], [59, 34], [52, 30], [33, 12], [45, 33], [49, 15], [30, 15], [1, 59], [51, 54], [33, 7], [0, 0], [39, 52], [38, 9], [56, 53], [31, 15], [16, 0], [56, 45], [52, 38], [29, 40], [52, 29], [2, 57], [43, 2], [10, 45], [51, 30], [5, 46], [13, 53], [21, 49], [4, 11], [3, 17], [2, 52], [20, 34], [33, 38], [32, 48], [20, 0], [26, 42], [22, 10], [50, 25], [41, 17], [43, 52], [14, 54], [44, 54], [9, 2], [53, 9], [48, 47], [17, 8], [12, 15], [33, 44], [9, 15], [10, 26], [30, 21], [46, 52], [16, 21], [55, 1], [47, 7], [52, 36], [55, 55], [25, 44], [54, 5], [39, 15], [50, 34], [34, 17], [15, 12], [56, 0], [5, 24], [17, 51], [45, 52], [22, 4], [46, 57], [19, 51], [54, 0], [12, 55], [1, 31], [41, 45], [46, 17], [25, 20], [27, 20], [47, 35]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[0, 1], [9, 21], [47, 53], [57, 57], [18, 4], [59, 35], [23, 48], [30, 53], [18, 27], [26, 35], [59, 57], [16, 39], [28, 2], [25, 1], [14, 44], [47, 14], [58, 11], [50, 47], [18, 35], [59, 59], [14, 9], [25, 7], [5, 3], [23, 51], [55, 60], [2, 40], [12, 41], [20, 46], [6, 15], [19, 40], [1, 34], [41, 10], [38, 29], [29, 34], [15, 9], [25, 3], [40, 25], [37, 56], [7, 20], [7, 49], [29, 21], [30, 9], [24, 53], [41, 57], [59, 34], [52, 30], [33, 12], [45, 33], [49, 15], [30, 15], [1, 59], [51, 54], [33, 7], [0, 0], [39, 52], [38, 9], [56, 53], [31, 15], [16, 0], [56, 45], [52, 38], [29, 40], [52, 29], [2, 57], [43, 2], [10, 45], [51, 30], [5, 46], [13, 53], [21, 49], [4, 11], [3, 17], [2, 52], [20, 34], [33, 38], [32, 48], [20, 0], [26, 42], [22, 10], [50, 25], [41, 17], [43, 52], [14, 54], [44, 54], [9, 2], [53, 9], [48, 47], [17, 8], [12, 15], [33, 44], [9, 15], [10, 26], [30, 21], [46, 52], [16, 21], [55, 1], [47, 7], [52, 36], [55, 55], [25, 44], [54, 5], [39, 15], [50, 34], [34, 17], [15, 12], [56, 0], [5, 24], [17, 51], [45, 52], [22, 4], [46, 57], [19, 51], [54, 0], [12, 55], [1, 31], [41, 45], [46, 17], [25, 20], [27, 20], [47, 35]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_5",
    "sat": "def sat(path: List[int], edges=[[3, 1], [4, 2], [5, 3], [6, 4], [2, 1], [6, 2], [0, 4], [0, 5], [2, 4], [4, 1], [1, 6], [4, 0], [3, 3]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[3, 1], [4, 2], [5, 3], [6, 4], [2, 1], [6, 2], [0, 4], [0, 5], [2, 4], [4, 1], [1, 6], [4, 0], [3, 3]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_6",
    "sat": "def sat(path: List[int], edges=[[1, 0], [1, 1], [0, 1], [0, 0]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[1, 0], [1, 1], [0, 1], [0, 0]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_7",
    "sat": "def sat(path: List[int], edges=[[0, 2], [2, 0], [0, 0], [0, 1]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[0, 2], [2, 0], [0, 0], [0, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_8",
    "sat": "def sat(path: List[int], edges=[[54, 2], [34, 83], [1, 42], [66, 65], [68, 35], [35, 48], [32, 80], [83, 1], [76, 31], [25, 39], [41, 59], [41, 17], [7, 80], [17, 45], [56, 39], [41, 55], [35, 72], [41, 6], [67, 46], [80, 32], [54, 38], [46, 28], [11, 72], [76, 28], [38, 54], [39, 9], [80, 9], [14, 78], [58, 89], [55, 4], [91, 6], [4, 82], [52, 84], [71, 29], [43, 0], [21, 44], [74, 51], [24, 67], [0, 59], [35, 49], [13, 62], [37, 30], [28, 22], [68, 12], [88, 27], [68, 78], [59, 90], [35, 59], [74, 61], [3, 70], [21, 80], [90, 6], [28, 35], [84, 12], [58, 2], [89, 89], [39, 0], [23, 88], [75, 81], [31, 40], [5, 77], [15, 79], [80, 74], [62, 7], [24, 48], [88, 29], [3, 16], [84, 74], [73, 30], [16, 77], [57, 37], [18, 84], [35, 71], [47, 79], [5, 20], [83, 64], [62, 74], [29, 29], [61, 3], [86, 89], [39, 59], [47, 17], [45, 46], [3, 34], [11, 52], [91, 31], [76, 14], [4, 8], [81, 37], [39, 42], [0, 77], [57, 42], [11, 42], [1, 63], [45, 17], [2, 35], [1, 18], [25, 55], [83, 74], [49, 44], [61, 58], [2, 79], [68, 54], [3, 29], [59, 15], [34, 75], [49, 22], [26, 89], [38, 79], [10, 20], [87, 76], [36, 14], [15, 22], [57, 64], [40, 57], [5, 52], [33, 1], [0, 57], [64, 31], [69, 18], [17, 79], [83, 67], [0, 31], [13, 60], [82, 84], [87, 1], [37, 54], [23, 70], [62, 82], [42, 91], [2, 65], [11, 89], [0, 33], [48, 71], [24, 10], [56, 1], [55, 17], [18, 29], [79, 21], [60, 30], [70, 18], [53, 18], [91, 72], [19, 25], [34, 34], [86, 49], [32, 62], [41, 29], [75, 74], [15, 41], [44, 69], [65, 49], [13, 10], [9, 26], [79, 56], [87, 63], [15, 72], [47, 30], [56, 54], [40, 42], [19, 63], [9, 36], [85, 75], [5, 7], [0, 61], [89, 1], [68, 5], [15, 31], [57, 11], [83, 15], [24, 63], [34, 26], [78, 14], [75, 76], [48, 59], [42, 1], [2, 67], [60, 85], [21, 84], [40, 60], [91, 21]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[54, 2], [34, 83], [1, 42], [66, 65], [68, 35], [35, 48], [32, 80], [83, 1], [76, 31], [25, 39], [41, 59], [41, 17], [7, 80], [17, 45], [56, 39], [41, 55], [35, 72], [41, 6], [67, 46], [80, 32], [54, 38], [46, 28], [11, 72], [76, 28], [38, 54], [39, 9], [80, 9], [14, 78], [58, 89], [55, 4], [91, 6], [4, 82], [52, 84], [71, 29], [43, 0], [21, 44], [74, 51], [24, 67], [0, 59], [35, 49], [13, 62], [37, 30], [28, 22], [68, 12], [88, 27], [68, 78], [59, 90], [35, 59], [74, 61], [3, 70], [21, 80], [90, 6], [28, 35], [84, 12], [58, 2], [89, 89], [39, 0], [23, 88], [75, 81], [31, 40], [5, 77], [15, 79], [80, 74], [62, 7], [24, 48], [88, 29], [3, 16], [84, 74], [73, 30], [16, 77], [57, 37], [18, 84], [35, 71], [47, 79], [5, 20], [83, 64], [62, 74], [29, 29], [61, 3], [86, 89], [39, 59], [47, 17], [45, 46], [3, 34], [11, 52], [91, 31], [76, 14], [4, 8], [81, 37], [39, 42], [0, 77], [57, 42], [11, 42], [1, 63], [45, 17], [2, 35], [1, 18], [25, 55], [83, 74], [49, 44], [61, 58], [2, 79], [68, 54], [3, 29], [59, 15], [34, 75], [49, 22], [26, 89], [38, 79], [10, 20], [87, 76], [36, 14], [15, 22], [57, 64], [40, 57], [5, 52], [33, 1], [0, 57], [64, 31], [69, 18], [17, 79], [83, 67], [0, 31], [13, 60], [82, 84], [87, 1], [37, 54], [23, 70], [62, 82], [42, 91], [2, 65], [11, 89], [0, 33], [48, 71], [24, 10], [56, 1], [55, 17], [18, 29], [79, 21], [60, 30], [70, 18], [53, 18], [91, 72], [19, 25], [34, 34], [86, 49], [32, 62], [41, 29], [75, 74], [15, 41], [44, 69], [65, 49], [13, 10], [9, 26], [79, 56], [87, 63], [15, 72], [47, 30], [56, 54], [40, 42], [19, 63], [9, 36], [85, 75], [5, 7], [0, 61], [89, 1], [68, 5], [15, 31], [57, 11], [83, 15], [24, 63], [34, 26], [78, 14], [75, 76], [48, 59], [42, 1], [2, 67], [60, 85], [21, 84], [40, 60], [91, 21]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "EvenPath_9",
    "sat": "def sat(path: List[int], edges=[[44, 62], [2, 32], [25, 0], [8, 42], [73, 20], [83, 43], [8, 82], [25, 68], [57, 50], [5, 78], [28, 9], [54, 80], [12, 14], [53, 20], [83, 40], [5, 40], [38, 36], [20, 4], [49, 75], [2, 19], [24, 35], [78, 57], [80, 79], [14, 38], [38, 12], [16, 33], [18, 18], [62, 34], [22, 2], [76, 41], [32, 38], [73, 29], [38, 28], [42, 41], [43, 82], [35, 1], [74, 62], [7, 32], [3, 10], [72, 43], [80, 36], [62, 70], [67, 19], [6, 36], [2, 53], [66, 8], [13, 66], [30, 34], [26, 2], [19, 32], [35, 15], [42, 46], [51, 43], [58, 35], [25, 59], [54, 56], [44, 53], [30, 25], [60, 2], [26, 10], [18, 35], [40, 11], [16, 22], [16, 19], [52, 66], [13, 22], [48, 58], [36, 14], [15, 53], [39, 34], [30, 40], [57, 27], [16, 75], [9, 22], [76, 31], [1, 74], [66, 14], [21, 75], [41, 53], [76, 76], [0, 12], [52, 49], [30, 41], [15, 25], [15, 54], [24, 63], [59, 49], [39, 81], [66, 64], [0, 47], [54, 14], [51, 68], [63, 77], [72, 16], [77, 76], [7, 1], [44, 0], [11, 63], [29, 29], [34, 3], [7, 25], [83, 19], [19, 74], [56, 70], [11, 14], [57, 32], [78, 52], [25, 83], [80, 80], [83, 62], [24, 46], [38, 30], [82, 68], [28, 39], [77, 14], [53, 14], [56, 67], [42, 38], [3, 11], [22, 15], [0, 39], [18, 13], [36, 25], [61, 32], [79, 4], [66, 9], [83, 82], [82, 21], [57, 54], [40, 83], [53, 3], [41, 45], [31, 7], [18, 41], [46, 5], [29, 40], [75, 67], [1, 1], [35, 40], [24, 56], [38, 7], [66, 39], [22, 55], [68, 78], [9, 47], [19, 75], [4, 80], [16, 29], [55, 31], [67, 56], [11, 49], [12, 3], [63, 59], [47, 0], [11, 56], [24, 6], [45, 54], [7, 28], [39, 45], [68, 69], [43, 44], [24, 41], [27, 16], [75, 26], [30, 24], [36, 46]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "sols": [
      "def sol(edges=[[44, 62], [2, 32], [25, 0], [8, 42], [73, 20], [83, 43], [8, 82], [25, 68], [57, 50], [5, 78], [28, 9], [54, 80], [12, 14], [53, 20], [83, 40], [5, 40], [38, 36], [20, 4], [49, 75], [2, 19], [24, 35], [78, 57], [80, 79], [14, 38], [38, 12], [16, 33], [18, 18], [62, 34], [22, 2], [76, 41], [32, 38], [73, 29], [38, 28], [42, 41], [43, 82], [35, 1], [74, 62], [7, 32], [3, 10], [72, 43], [80, 36], [62, 70], [67, 19], [6, 36], [2, 53], [66, 8], [13, 66], [30, 34], [26, 2], [19, 32], [35, 15], [42, 46], [51, 43], [58, 35], [25, 59], [54, 56], [44, 53], [30, 25], [60, 2], [26, 10], [18, 35], [40, 11], [16, 22], [16, 19], [52, 66], [13, 22], [48, 58], [36, 14], [15, 53], [39, 34], [30, 40], [57, 27], [16, 75], [9, 22], [76, 31], [1, 74], [66, 14], [21, 75], [41, 53], [76, 76], [0, 12], [52, 49], [30, 41], [15, 25], [15, 54], [24, 63], [59, 49], [39, 81], [66, 64], [0, 47], [54, 14], [51, 68], [63, 77], [72, 16], [77, 76], [7, 1], [44, 0], [11, 63], [29, 29], [34, 3], [7, 25], [83, 19], [19, 74], [56, 70], [11, 14], [57, 32], [78, 52], [25, 83], [80, 80], [83, 62], [24, 46], [38, 30], [82, 68], [28, 39], [77, 14], [53, 14], [56, 67], [42, 38], [3, 11], [22, 15], [0, 39], [18, 13], [36, 25], [61, 32], [79, 4], [66, 9], [83, 82], [82, 21], [57, 54], [40, 83], [53, 3], [41, 45], [31, 7], [18, 41], [46, 5], [29, 40], [75, 67], [1, 1], [35, 40], [24, 56], [38, 7], [66, 39], [22, 55], [68, 78], [9, 47], [19, 75], [4, 80], [16, 29], [55, 31], [67, 56], [11, 49], [12, 3], [63, 59], [47, 0], [11, 56], [24, 6], [45, 54], [7, 28], [39, 45], [68, 69], [43, 44], [24, 41], [27, 16], [75, 26], [30, 24], [36, 46]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_0",
    "sat": "def sat(p: List[int], edges=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[0, 1], [0, 2], [1, 2], [3, 1], [2, 3]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_1",
    "sat": "def sat(p: List[int], edges=[[26, 42], [33, 49], [4, 28], [55, 8], [39, 10], [63, 40], [22, 7], [32, 18], [58, 56], [1, 57], [66, 21], [34, 47], [17, 70], [38, 18], [47, 66], [0, 64], [40, 7], [66, 39], [71, 47], [27, 37], [9, 64], [34, 24], [70, 41], [16, 3], [32, 10], [59, 11], [46, 13], [28, 25], [32, 53], [33, 36], [1, 62], [4, 72], [14, 18], [54, 6], [23, 37], [2, 44], [14, 46], [17, 13], [55, 25], [68, 51], [32, 62], [53, 73], [58, 2], [5, 12], [16, 70], [33, 29], [56, 59], [53, 54], [34, 43], [19, 31], [18, 26], [3, 11], [45, 20], [66, 22], [10, 42], [42, 36], [72, 67], [18, 2], [41, 28], [54, 42], [36, 16], [8, 54], [47, 8], [12, 38], [10, 4], [66, 6], [14, 9], [13, 39], [60, 5], [60, 73], [0, 46], [12, 0], [58, 45], [42, 33], [54, 13], [16, 48], [60, 1], [38, 33], [52, 26], [49, 1], [16, 27], [8, 26], [6, 69], [29, 23], [58, 14], [35, 29], [69, 34], [13, 31], [29, 69], [12, 55], [47, 57], [29, 46], [37, 29], [9, 68], [8, 16], [58, 5], [53, 12], [19, 24], [16, 58], [23, 51], [65, 35], [41, 12], [23, 46], [57, 27], [15, 5], [36, 27], [9, 70], [49, 4], [0, 55], [49, 60], [21, 45], [30, 30], [72, 25], [60, 53], [14, 7], [59, 70], [38, 12], [14, 1], [58, 32], [45, 63], [43, 32], [46, 70], [27, 27], [11, 57], [9, 73], [59, 13], [7, 2], [24, 33], [52, 4], [17, 59], [71, 40], [50, 22], [63, 47], [2, 28], [71, 45], [62, 21], [71, 55], [44, 15], [34, 4], [42, 72], [37, 55], [43, 64], [20, 46], [37, 40], [31, 60], [26, 3]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[26, 42], [33, 49], [4, 28], [55, 8], [39, 10], [63, 40], [22, 7], [32, 18], [58, 56], [1, 57], [66, 21], [34, 47], [17, 70], [38, 18], [47, 66], [0, 64], [40, 7], [66, 39], [71, 47], [27, 37], [9, 64], [34, 24], [70, 41], [16, 3], [32, 10], [59, 11], [46, 13], [28, 25], [32, 53], [33, 36], [1, 62], [4, 72], [14, 18], [54, 6], [23, 37], [2, 44], [14, 46], [17, 13], [55, 25], [68, 51], [32, 62], [53, 73], [58, 2], [5, 12], [16, 70], [33, 29], [56, 59], [53, 54], [34, 43], [19, 31], [18, 26], [3, 11], [45, 20], [66, 22], [10, 42], [42, 36], [72, 67], [18, 2], [41, 28], [54, 42], [36, 16], [8, 54], [47, 8], [12, 38], [10, 4], [66, 6], [14, 9], [13, 39], [60, 5], [60, 73], [0, 46], [12, 0], [58, 45], [42, 33], [54, 13], [16, 48], [60, 1], [38, 33], [52, 26], [49, 1], [16, 27], [8, 26], [6, 69], [29, 23], [58, 14], [35, 29], [69, 34], [13, 31], [29, 69], [12, 55], [47, 57], [29, 46], [37, 29], [9, 68], [8, 16], [58, 5], [53, 12], [19, 24], [16, 58], [23, 51], [65, 35], [41, 12], [23, 46], [57, 27], [15, 5], [36, 27], [9, 70], [49, 4], [0, 55], [49, 60], [21, 45], [30, 30], [72, 25], [60, 53], [14, 7], [59, 70], [38, 12], [14, 1], [58, 32], [45, 63], [43, 32], [46, 70], [27, 27], [11, 57], [9, 73], [59, 13], [7, 2], [24, 33], [52, 4], [17, 59], [71, 40], [50, 22], [63, 47], [2, 28], [71, 45], [62, 21], [71, 55], [44, 15], [34, 4], [42, 72], [37, 55], [43, 64], [20, 46], [37, 40], [31, 60], [26, 3]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_2",
    "sat": "def sat(p: List[int], edges=[[28, 82], [34, 65], [36, 1], [50, 7], [83, 2], [24, 47], [68, 24], [4, 38], [38, 51], [77, 75], [50, 37], [81, 56], [17, 72], [80, 57], [45, 64], [33, 70], [34, 37], [2, 61], [28, 58], [71, 79], [42, 22], [74, 50], [56, 61], [52, 78], [35, 3], [39, 1], [30, 83], [74, 85], [51, 78], [53, 57], [63, 54], [14, 34], [44, 63], [13, 31], [54, 21], [20, 66], [40, 16], [74, 84], [14, 58], [81, 64], [48, 27], [17, 4], [66, 63], [45, 46], [63, 51], [76, 84], [69, 83], [15, 2], [5, 60], [59, 2], [64, 18], [17, 39], [22, 67], [56, 41], [74, 30], [10, 24], [6, 1], [48, 26], [1, 72], [43, 43], [68, 67], [8, 60], [4, 77], [63, 41], [23, 23], [83, 73], [21, 38], [60, 78], [73, 50], [61, 6], [80, 84], [8, 58], [82, 67], [64, 71], [4, 8], [57, 80], [84, 48], [40, 57], [5, 21], [0, 66], [47, 4], [51, 44], [58, 17], [55, 15], [9, 4], [58, 39], [69, 74], [57, 6], [60, 5], [50, 17], [64, 57], [38, 59], [7, 84], [80, 48], [70, 27], [67, 12], [9, 75], [83, 58], [8, 2], [29, 19], [73, 30], [11, 44], [43, 40], [71, 32], [58, 53], [53, 69], [74, 72], [28, 76], [7, 25], [60, 70], [30, 79], [59, 15], [37, 59], [35, 64], [40, 84], [69, 18], [80, 74], [54, 66], [31, 22], [60, 2], [61, 5], [12, 41], [79, 35], [28, 83], [43, 72], [44, 19], [71, 65], [56, 45], [74, 37], [1, 69], [9, 42], [50, 75], [55, 3], [61, 69], [83, 11], [82, 51], [65, 5], [43, 66], [72, 52], [11, 76], [19, 26], [25, 57], [4, 21], [1, 41], [53, 33], [17, 5], [7, 20], [33, 11], [17, 49], [2, 45], [76, 25], [55, 41], [76, 17], [35, 70], [77, 38], [14, 36], [43, 73], [47, 34], [73, 79], [47, 12], [64, 54], [27, 54], [78, 47], [6, 5], [70, 47], [56, 44]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[28, 82], [34, 65], [36, 1], [50, 7], [83, 2], [24, 47], [68, 24], [4, 38], [38, 51], [77, 75], [50, 37], [81, 56], [17, 72], [80, 57], [45, 64], [33, 70], [34, 37], [2, 61], [28, 58], [71, 79], [42, 22], [74, 50], [56, 61], [52, 78], [35, 3], [39, 1], [30, 83], [74, 85], [51, 78], [53, 57], [63, 54], [14, 34], [44, 63], [13, 31], [54, 21], [20, 66], [40, 16], [74, 84], [14, 58], [81, 64], [48, 27], [17, 4], [66, 63], [45, 46], [63, 51], [76, 84], [69, 83], [15, 2], [5, 60], [59, 2], [64, 18], [17, 39], [22, 67], [56, 41], [74, 30], [10, 24], [6, 1], [48, 26], [1, 72], [43, 43], [68, 67], [8, 60], [4, 77], [63, 41], [23, 23], [83, 73], [21, 38], [60, 78], [73, 50], [61, 6], [80, 84], [8, 58], [82, 67], [64, 71], [4, 8], [57, 80], [84, 48], [40, 57], [5, 21], [0, 66], [47, 4], [51, 44], [58, 17], [55, 15], [9, 4], [58, 39], [69, 74], [57, 6], [60, 5], [50, 17], [64, 57], [38, 59], [7, 84], [80, 48], [70, 27], [67, 12], [9, 75], [83, 58], [8, 2], [29, 19], [73, 30], [11, 44], [43, 40], [71, 32], [58, 53], [53, 69], [74, 72], [28, 76], [7, 25], [60, 70], [30, 79], [59, 15], [37, 59], [35, 64], [40, 84], [69, 18], [80, 74], [54, 66], [31, 22], [60, 2], [61, 5], [12, 41], [79, 35], [28, 83], [43, 72], [44, 19], [71, 65], [56, 45], [74, 37], [1, 69], [9, 42], [50, 75], [55, 3], [61, 69], [83, 11], [82, 51], [65, 5], [43, 66], [72, 52], [11, 76], [19, 26], [25, 57], [4, 21], [1, 41], [53, 33], [17, 5], [7, 20], [33, 11], [17, 49], [2, 45], [76, 25], [55, 41], [76, 17], [35, 70], [77, 38], [14, 36], [43, 73], [47, 34], [73, 79], [47, 12], [64, 54], [27, 54], [78, 47], [6, 5], [70, 47], [56, 44]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_3",
    "sat": "def sat(p: List[int], edges=[[26, 18], [17, 34], [17, 30], [37, 23], [26, 2], [23, 4], [18, 37], [3, 1], [3, 11], [36, 14], [31, 13], [27, 29], [24, 20], [24, 18], [28, 16], [29, 13], [35, 16], [36, 34], [14, 2], [20, 38], [16, 0], [7, 32], [13, 23], [20, 27], [32, 23], [8, 28], [25, 27], [2, 15], [37, 37], [30, 24], [4, 37], [8, 18], [25, 21], [2, 9], [37, 28], [17, 21], [2, 13], [1, 16], [35, 3], [9, 33], [7, 13], [22, 15], [6, 36], [27, 11], [18, 22], [24, 28], [4, 10], [3, 20], [38, 1], [38, 31], [5, 14], [7, 19], [2, 21], [25, 14], [3, 8], [37, 0], [28, 3], [10, 27], [26, 22], [24, 2], [20, 28], [11, 26], [6, 34], [37, 5], [0, 8], [17, 36], [6, 19], [23, 14], [34, 12], [33, 19]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[26, 18], [17, 34], [17, 30], [37, 23], [26, 2], [23, 4], [18, 37], [3, 1], [3, 11], [36, 14], [31, 13], [27, 29], [24, 20], [24, 18], [28, 16], [29, 13], [35, 16], [36, 34], [14, 2], [20, 38], [16, 0], [7, 32], [13, 23], [20, 27], [32, 23], [8, 28], [25, 27], [2, 15], [37, 37], [30, 24], [4, 37], [8, 18], [25, 21], [2, 9], [37, 28], [17, 21], [2, 13], [1, 16], [35, 3], [9, 33], [7, 13], [22, 15], [6, 36], [27, 11], [18, 22], [24, 28], [4, 10], [3, 20], [38, 1], [38, 31], [5, 14], [7, 19], [2, 21], [25, 14], [3, 8], [37, 0], [28, 3], [10, 27], [26, 22], [24, 2], [20, 28], [11, 26], [6, 34], [37, 5], [0, 8], [17, 36], [6, 19], [23, 14], [34, 12], [33, 19]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_4",
    "sat": "def sat(p: List[int], edges=[[85, 9], [39, 34], [2, 20], [60, 47], [60, 76], [50, 63], [23, 37], [47, 18], [3, 5], [84, 87], [88, 84], [31, 33], [49, 3], [8, 60], [52, 36], [88, 87], [81, 32], [53, 82], [80, 39], [33, 60], [88, 27], [47, 0], [28, 34], [58, 51], [42, 71], [27, 50], [20, 14], [28, 18], [8, 78], [33, 63], [41, 12], [22, 18], [15, 19], [45, 67], [12, 50], [47, 52], [24, 2], [17, 66], [10, 15], [29, 56], [23, 25], [57, 55], [62, 10], [55, 19], [17, 82], [27, 88], [11, 45], [26, 33], [81, 62], [74, 75], [30, 32], [69, 14], [48, 72], [48, 8], [72, 56], [1, 84], [31, 22], [12, 11], [86, 7], [45, 10], [56, 70], [27, 8], [2, 22], [14, 47], [29, 82], [30, 8], [21, 84], [73, 8], [38, 27], [28, 3], [9, 69], [69, 47], [54, 81], [57, 18], [49, 68], [0, 58], [39, 8], [84, 4], [42, 78], [38, 43], [16, 68], [71, 49], [35, 12], [84, 20], [17, 54], [84, 12], [16, 42], [51, 66], [18, 60], [34, 44], [83, 13], [82, 6], [39, 41], [77, 73], [34, 20], [34, 61], [30, 59], [7, 0], [50, 16], [42, 3], [29, 62], [74, 3], [22, 57], [66, 77], [69, 51], [82, 46], [62, 75], [43, 0], [32, 78], [18, 15], [26, 44], [10, 35], [39, 36], [8, 70], [59, 61], [32, 67], [8, 6], [57, 14], [18, 78], [51, 28], [74, 5], [42, 11], [69, 54], [33, 77], [10, 54], [86, 28], [29, 26], [85, 7], [48, 45], [38, 41], [64, 37], [50, 83], [52, 62], [30, 31], [48, 81], [80, 28], [88, 49], [77, 77], [48, 21], [55, 57], [48, 15], [67, 57], [5, 83], [43, 63], [50, 42], [38, 4], [47, 1], [23, 55], [88, 72], [13, 63], [58, 70], [50, 64], [0, 12], [5, 60], [84, 58], [74, 61], [63, 10], [53, 33], [50, 41], [33, 44], [41, 83], [27, 3], [72, 59], [9, 61], [49, 75], [70, 60], [11, 21], [31, 88], [13, 59], [65, 49], [33, 17], [70, 59], [67, 76], [86, 24], [48, 60]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[85, 9], [39, 34], [2, 20], [60, 47], [60, 76], [50, 63], [23, 37], [47, 18], [3, 5], [84, 87], [88, 84], [31, 33], [49, 3], [8, 60], [52, 36], [88, 87], [81, 32], [53, 82], [80, 39], [33, 60], [88, 27], [47, 0], [28, 34], [58, 51], [42, 71], [27, 50], [20, 14], [28, 18], [8, 78], [33, 63], [41, 12], [22, 18], [15, 19], [45, 67], [12, 50], [47, 52], [24, 2], [17, 66], [10, 15], [29, 56], [23, 25], [57, 55], [62, 10], [55, 19], [17, 82], [27, 88], [11, 45], [26, 33], [81, 62], [74, 75], [30, 32], [69, 14], [48, 72], [48, 8], [72, 56], [1, 84], [31, 22], [12, 11], [86, 7], [45, 10], [56, 70], [27, 8], [2, 22], [14, 47], [29, 82], [30, 8], [21, 84], [73, 8], [38, 27], [28, 3], [9, 69], [69, 47], [54, 81], [57, 18], [49, 68], [0, 58], [39, 8], [84, 4], [42, 78], [38, 43], [16, 68], [71, 49], [35, 12], [84, 20], [17, 54], [84, 12], [16, 42], [51, 66], [18, 60], [34, 44], [83, 13], [82, 6], [39, 41], [77, 73], [34, 20], [34, 61], [30, 59], [7, 0], [50, 16], [42, 3], [29, 62], [74, 3], [22, 57], [66, 77], [69, 51], [82, 46], [62, 75], [43, 0], [32, 78], [18, 15], [26, 44], [10, 35], [39, 36], [8, 70], [59, 61], [32, 67], [8, 6], [57, 14], [18, 78], [51, 28], [74, 5], [42, 11], [69, 54], [33, 77], [10, 54], [86, 28], [29, 26], [85, 7], [48, 45], [38, 41], [64, 37], [50, 83], [52, 62], [30, 31], [48, 81], [80, 28], [88, 49], [77, 77], [48, 21], [55, 57], [48, 15], [67, 57], [5, 83], [43, 63], [50, 42], [38, 4], [47, 1], [23, 55], [88, 72], [13, 63], [58, 70], [50, 64], [0, 12], [5, 60], [84, 58], [74, 61], [63, 10], [53, 33], [50, 41], [33, 44], [41, 83], [27, 3], [72, 59], [9, 61], [49, 75], [70, 60], [11, 21], [31, 88], [13, 59], [65, 49], [33, 17], [70, 59], [67, 76], [86, 24], [48, 60]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_5",
    "sat": "def sat(p: List[int], edges=[[0, 6], [7, 0], [7, 2], [0, 1], [2, 5], [2, 2], [2, 7], [0, 5], [4, 2], [4, 6], [5, 0], [7, 6], [4, 1], [5, 1], [7, 5]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[0, 6], [7, 0], [7, 2], [0, 1], [2, 5], [2, 2], [2, 7], [0, 5], [4, 2], [4, 6], [5, 0], [7, 6], [4, 1], [5, 1], [7, 5]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_6",
    "sat": "def sat(p: List[int], edges=[[28, 20], [9, 53], [12, 5], [29, 42], [0, 39], [12, 39], [19, 28], [8, 30], [14, 6], [18, 23], [50, 23], [29, 19], [20, 15], [23, 33], [18, 55], [12, 13], [44, 13], [33, 41], [35, 9], [3, 4], [37, 22], [9, 25], [38, 17], [6, 50], [49, 37], [33, 22], [15, 37], [49, 11], [14, 13], [9, 33], [55, 21], [21, 24], [39, 1], [49, 31], [50, 27], [17, 49], [40, 23], [37, 11], [16, 42], [1, 11], [23, 32], [49, 17], [5, 2], [54, 11], [12, 55], [37, 16], [1, 24], [1, 14], [7, 52], [35, 46], [21, 19], [28, 27], [5, 27], [17, 8], [3, 49], [42, 40], [31, 8], [34, 48], [28, 32], [44, 36], [41, 2], [21, 52], [3, 15], [1, 4], [24, 22], [51, 49], [3, 9], [3, 31], [14, 1], [9, 14], [32, 11], [51, 4], [2, 13], [55, 33], [39, 6], [1, 52], [1, 1], [40, 47], [43, 54], [48, 14], [52, 49], [34, 33], [41, 7], [17, 37], [49, 7], [46, 2], [55, 12], [44, 0], [5, 53], [35, 5], [16, 20], [53, 43], [22, 10], [44, 34], [44, 2], [45, 35], [31, 50], [11, 51], [42, 41], [40, 43], [51, 24], [39, 20], [36, 21], [44, 48], [55, 44], [48, 48], [29, 46], [28, 17], [33, 31]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[28, 20], [9, 53], [12, 5], [29, 42], [0, 39], [12, 39], [19, 28], [8, 30], [14, 6], [18, 23], [50, 23], [29, 19], [20, 15], [23, 33], [18, 55], [12, 13], [44, 13], [33, 41], [35, 9], [3, 4], [37, 22], [9, 25], [38, 17], [6, 50], [49, 37], [33, 22], [15, 37], [49, 11], [14, 13], [9, 33], [55, 21], [21, 24], [39, 1], [49, 31], [50, 27], [17, 49], [40, 23], [37, 11], [16, 42], [1, 11], [23, 32], [49, 17], [5, 2], [54, 11], [12, 55], [37, 16], [1, 24], [1, 14], [7, 52], [35, 46], [21, 19], [28, 27], [5, 27], [17, 8], [3, 49], [42, 40], [31, 8], [34, 48], [28, 32], [44, 36], [41, 2], [21, 52], [3, 15], [1, 4], [24, 22], [51, 49], [3, 9], [3, 31], [14, 1], [9, 14], [32, 11], [51, 4], [2, 13], [55, 33], [39, 6], [1, 52], [1, 1], [40, 47], [43, 54], [48, 14], [52, 49], [34, 33], [41, 7], [17, 37], [49, 7], [46, 2], [55, 12], [44, 0], [5, 53], [35, 5], [16, 20], [53, 43], [22, 10], [44, 34], [44, 2], [45, 35], [31, 50], [11, 51], [42, 41], [40, 43], [51, 24], [39, 20], [36, 21], [44, 48], [55, 44], [48, 48], [29, 46], [28, 17], [33, 31]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_7",
    "sat": "def sat(p: List[int], edges=[[12, 7], [3, 52], [48, 11], [10, 18], [0, 2], [35, 10], [47, 38], [19, 43], [31, 38], [6, 24], [57, 20], [59, 52], [46, 46], [57, 10], [29, 41], [32, 55], [11, 55], [26, 45], [49, 53], [37, 23], [40, 25], [12, 15], [48, 44], [43, 34], [44, 1], [54, 54], [27, 10], [47, 6], [21, 29], [50, 1], [39, 44], [44, 48], [0, 21], [2, 7], [12, 28], [17, 36], [5, 4], [28, 57], [16, 4], [21, 50], [9, 32], [11, 59], [14, 41], [47, 49], [41, 24], [22, 28], [52, 55], [57, 11], [35, 58], [21, 20], [33, 40], [14, 58], [59, 2], [31, 51], [12, 5], [7, 4], [59, 57], [37, 54], [45, 52], [11, 10], [56, 6], [41, 29], [1, 22], [25, 58], [10, 10], [7, 57], [2, 10], [20, 17], [49, 52], [40, 4], [13, 55], [36, 43], [49, 8], [6, 38], [8, 19], [48, 14], [37, 2], [5, 17], [35, 4], [43, 9], [18, 39], [41, 54], [8, 56], [58, 49], [31, 11], [35, 42], [37, 32], [48, 29], [10, 44], [40, 22], [36, 50], [46, 14], [12, 0], [14, 42], [34, 40], [9, 36], [22, 8], [57, 18], [56, 35], [16, 59], [0, 29], [37, 46], [20, 45], [44, 30], [23, 34], [2, 45], [12, 26], [58, 10], [25, 11], [43, 8], [50, 7], [26, 0], [44, 4], [41, 16], [5, 54], [4, 35]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[12, 7], [3, 52], [48, 11], [10, 18], [0, 2], [35, 10], [47, 38], [19, 43], [31, 38], [6, 24], [57, 20], [59, 52], [46, 46], [57, 10], [29, 41], [32, 55], [11, 55], [26, 45], [49, 53], [37, 23], [40, 25], [12, 15], [48, 44], [43, 34], [44, 1], [54, 54], [27, 10], [47, 6], [21, 29], [50, 1], [39, 44], [44, 48], [0, 21], [2, 7], [12, 28], [17, 36], [5, 4], [28, 57], [16, 4], [21, 50], [9, 32], [11, 59], [14, 41], [47, 49], [41, 24], [22, 28], [52, 55], [57, 11], [35, 58], [21, 20], [33, 40], [14, 58], [59, 2], [31, 51], [12, 5], [7, 4], [59, 57], [37, 54], [45, 52], [11, 10], [56, 6], [41, 29], [1, 22], [25, 58], [10, 10], [7, 57], [2, 10], [20, 17], [49, 52], [40, 4], [13, 55], [36, 43], [49, 8], [6, 38], [8, 19], [48, 14], [37, 2], [5, 17], [35, 4], [43, 9], [18, 39], [41, 54], [8, 56], [58, 49], [31, 11], [35, 42], [37, 32], [48, 29], [10, 44], [40, 22], [36, 50], [46, 14], [12, 0], [14, 42], [34, 40], [9, 36], [22, 8], [57, 18], [56, 35], [16, 59], [0, 29], [37, 46], [20, 45], [44, 30], [23, 34], [2, 45], [12, 26], [58, 10], [25, 11], [43, 8], [50, 7], [26, 0], [44, 4], [41, 16], [5, 54], [4, 35]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_8",
    "sat": "def sat(p: List[int], edges=[[1, 2], [19, 6], [11, 19], [16, 8], [8, 7], [13, 2], [9, 3], [3, 13], [12, 9], [2, 7], [2, 15], [17, 8], [18, 0], [13, 9], [3, 1], [21, 11], [15, 11], [13, 3], [14, 17], [7, 16], [0, 20], [14, 8], [19, 15], [12, 4], [10, 13], [0, 10], [0, 4], [18, 9], [18, 3], [20, 12], [20, 14], [5, 14], [3, 2], [16, 4], [9, 6], [1, 9], [8, 9], [12, 19], [1, 20]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[1, 2], [19, 6], [11, 19], [16, 8], [8, 7], [13, 2], [9, 3], [3, 13], [12, 9], [2, 7], [2, 15], [17, 8], [18, 0], [13, 9], [3, 1], [21, 11], [15, 11], [13, 3], [14, 17], [7, 16], [0, 20], [14, 8], [19, 15], [12, 4], [10, 13], [0, 10], [0, 4], [18, 9], [18, 3], [20, 12], [20, 14], [5, 14], [3, 2], [16, 4], [9, 6], [1, 9], [8, 9], [12, 19], [1, 20]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "OddPath_9",
    "sat": "def sat(p: List[int], edges=[[5, 4], [1, 5], [2, 1], [5, 1], [1, 1], [3, 0], [1, 2], [0, 1], [3, 4], [4, 1]]):\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "sols": [
      "def sol(edges=[[5, 4], [1, 5], [2, 1], [5, 1], [1, 1], [3, 0], [1, 2], [0, 1], [3, 4], [4, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs"
  },
  {
    "name": "Zarankiewicz_0",
    "sat": "def sat(edges: List[List[int]]):\n    \"\"\"Find a bipartite graph with 4 vertices on each side, 13 edges, and no K_3,3 subgraph.\"\"\"\n    assert len(edges) == len({(a, b) for a, b in edges}) == 13  #  13 edges, no duplicates\n    assert all(i in range(4) for li in edges for i in li)  # 4 nodes on each side\n    for i in range(4):\n        v = [m for m in range(4) if m != i]\n        for j in range(4):\n            u = [m for m in range(4) if m != j]\n            if all([m, n] in edges for m in v for n in u):\n                return False\n    return True",
    "sols": [
      "def sol():\n    return [[i, j] for i in range(4) for j in range(4) if i != j or i == 0]"
    ],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_0",
    "sat": "def sat(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4]], g2=[[0, 4], [4, 1], [1, 2], [2, 3]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [
      "def sol(g1=[[0, 1], [1, 2], [2, 3], [3, 4]], g2=[[0, 4], [4, 1], [1, 2], [2, 3]]):  # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""
    ],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_1",
    "sat": "def sat(bi: List[int], g1=[[0, 0], [0, 4], [0, 6], [0, 8], [0, 10], [1, 1], [1, 3], [1, 4], [1, 10], [2, 0], [2, 3], [2, 5], [2, 7], [2, 9], [2, 10], [3, 1], [3, 2], [3, 6], [3, 10], [4, 1], [4, 2], [4, 5], [4, 7], [5, 0], [5, 2], [5, 3], [5, 5], [5, 6], [6, 1], [6, 3], [6, 7], [6, 8], [6, 10], [7, 3], [8, 0], [8, 1], [8, 2], [8, 9], [8, 10], [9, 0], [9, 5], [9, 6], [10, 0], [10, 2], [10, 3], [10, 5], [10, 6], [10, 7], [10, 9], [10, 10]], g2=[[3, 2], [5, 9], [1, 2], [7, 6], [1, 4], [8, 6], [3, 1], [6, 1], [5, 6], [0, 3], [0, 6], [6, 3], [4, 9], [6, 10], [2, 2], [8, 4], [0, 8], [7, 9], [9, 5], [10, 7], [9, 7], [2, 0], [5, 10], [4, 8], [5, 1], [4, 0], [8, 10], [1, 7], [8, 2], [9, 8], [6, 8], [3, 4], [7, 4], [2, 5], [6, 7], [7, 8], [1, 1], [8, 3], [8, 8], [8, 7], [4, 7], [0, 2], [0, 9], [2, 4], [1, 6], [2, 8], [6, 2], [9, 9], [4, 10], [8, 1]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_2",
    "sat": "def sat(bi: List[int], g1=[[0, 3], [0, 6], [0, 9], [0, 15], [1, 0], [1, 3], [1, 5], [1, 7], [1, 13], [1, 14], [2, 1], [2, 2], [2, 4], [2, 8], [2, 9], [2, 11], [2, 13], [2, 15], [3, 0], [3, 4], [3, 9], [3, 13], [3, 15], [4, 0], [4, 2], [4, 3], [4, 4], [4, 10], [4, 14], [5, 4], [5, 5], [5, 8], [6, 0], [6, 2], [6, 3], [6, 5], [6, 6], [6, 10], [6, 13], [6, 15], [7, 2], [7, 3], [7, 6], [7, 7], [7, 8], [7, 13], [8, 0], [8, 2], [8, 4], [8, 7], [8, 9], [8, 11], [8, 15], [9, 0], [9, 2], [9, 3], [9, 11], [9, 13], [9, 15], [10, 0], [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 10], [10, 15], [11, 3], [11, 7], [11, 8], [11, 9], [11, 10], [11, 11], [11, 13], [11, 14], [11, 15], [12, 0], [12, 11], [12, 12], [12, 14], [13, 2], [13, 3], [13, 6], [13, 8], [13, 12], [13, 14], [14, 0], [14, 1], [14, 4], [14, 6], [14, 7], [14, 9], [15, 3], [15, 4], [15, 8], [15, 9], [15, 14], [15, 15]], g2=[[2, 2], [4, 4], [13, 6], [6, 11], [0, 5], [8, 4], [5, 11], [8, 2], [11, 13], [14, 3], [1, 8], [6, 6], [3, 2], [13, 11], [13, 2], [6, 15], [0, 2], [6, 7], [0, 11], [14, 14], [10, 2], [5, 5], [1, 1], [10, 9], [13, 15], [9, 12], [3, 14], [5, 0], [9, 14], [8, 13], [6, 0], [15, 3], [3, 6], [13, 8], [13, 10], [15, 7], [0, 10], [7, 8], [4, 8], [7, 9], [7, 14], [6, 2], [10, 10], [8, 11], [3, 10], [14, 4], [12, 3], [14, 11], [15, 4], [0, 9], [12, 5], [0, 0], [3, 8], [11, 5], [10, 15], [11, 2], [5, 10], [3, 5], [10, 3], [3, 13], [1, 6], [5, 7], [10, 6], [9, 11], [5, 8], [0, 12], [10, 13], [1, 7], [11, 15], [4, 12], [2, 11], [2, 5], [6, 13], [14, 15], [4, 0], [4, 15], [2, 3], [6, 14], [4, 2], [7, 4], [0, 8], [9, 8], [11, 8], [2, 7], [15, 10], [9, 15], [2, 13], [6, 3], [4, 10], [14, 10], [9, 7], [15, 11], [12, 12], [7, 5], [4, 11], [7, 13], [15, 1], [10, 5]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_3",
    "sat": "def sat(bi: List[int], g1=[[0, 1], [1, 0]], g2=[[0, 1], [1, 0]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [
      "def sol(g1=[[0, 1], [1, 0]], g2=[[0, 1], [1, 0]]):  # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""
    ],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_4",
    "sat": "def sat(bi: List[int], g1=[[0, 2], [0, 5], [0, 6], [1, 1], [1, 2], [1, 5], [2, 1], [2, 3], [2, 6], [2, 7], [3, 1], [3, 4], [3, 7], [4, 2], [4, 6], [4, 7], [5, 0], [5, 4], [5, 7], [6, 1], [6, 4], [6, 6], [7, 0], [7, 1], [7, 2], [7, 5], [7, 6]], g2=[[2, 5], [3, 1], [2, 0], [0, 6], [5, 0], [3, 7], [5, 3], [5, 6], [0, 4], [1, 2], [4, 2], [4, 5], [3, 0], [7, 5], [0, 1], [5, 7], [2, 1], [6, 0], [1, 6], [7, 3], [5, 1], [4, 6], [6, 7], [7, 2], [6, 6], [0, 5], [1, 1]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [
      "def sol(g1=[[0, 2], [0, 5], [0, 6], [1, 1], [1, 2], [1, 5], [2, 1], [2, 3], [2, 6], [2, 7], [3, 1], [3, 4], [3, 7], [4, 2], [4, 6], [4, 7], [5, 0], [5, 4], [5, 7], [6, 1], [6, 4], [6, 6], [7, 0], [7, 1], [7, 2], [7, 5], [7, 6]], g2=[[2, 5], [3, 1], [2, 0], [0, 6], [5, 0], [3, 7], [5, 3], [5, 6], [0, 4], [1, 2], [4, 2], [4, 5], [3, 0], [7, 5], [0, 1], [5, 7], [2, 1], [6, 0], [1, 6], [7, 3], [5, 1], [4, 6], [6, 7], [7, 2], [6, 6], [0, 5], [1, 1]]):  # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""
    ],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_5",
    "sat": "def sat(bi: List[int], g1=[[0, 4], [1, 1], [1, 2], [1, 7], [2, 0], [2, 4], [2, 6], [3, 0], [3, 3], [3, 4], [3, 6], [3, 7], [4, 0], [4, 3], [4, 4], [4, 7], [5, 1], [5, 2], [6, 2], [6, 3], [6, 6], [7, 1], [7, 2], [7, 3], [7, 5]], g2=[[0, 5], [4, 6], [6, 2], [0, 3], [7, 7], [2, 6], [3, 2], [0, 1], [3, 6], [5, 4], [3, 3], [7, 4], [0, 4], [2, 2], [2, 3], [4, 2], [5, 5], [1, 4], [3, 7], [2, 0], [5, 0], [4, 7], [1, 5], [7, 3], [3, 0]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [
      "def sol(g1=[[0, 4], [1, 1], [1, 2], [1, 7], [2, 0], [2, 4], [2, 6], [3, 0], [3, 3], [3, 4], [3, 6], [3, 7], [4, 0], [4, 3], [4, 4], [4, 7], [5, 1], [5, 2], [6, 2], [6, 3], [6, 6], [7, 1], [7, 2], [7, 3], [7, 5]], g2=[[0, 5], [4, 6], [6, 2], [0, 3], [7, 7], [2, 6], [3, 2], [0, 1], [3, 6], [5, 4], [3, 3], [7, 4], [0, 4], [2, 2], [2, 3], [4, 2], [5, 5], [1, 4], [3, 7], [2, 0], [5, 0], [4, 7], [1, 5], [7, 3], [3, 0]]):  # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""
    ],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_6",
    "sat": "def sat(bi: List[int], g1=[[0, 1], [0, 4], [0, 5], [0, 7], [0, 8], [0, 10], [0, 11], [0, 12], [0, 13], [1, 0], [1, 1], [1, 2], [1, 6], [1, 7], [1, 10], [2, 2], [2, 3], [2, 9], [2, 12], [3, 0], [3, 1], [3, 3], [3, 4], [3, 5], [3, 6], [3, 12], [4, 2], [4, 3], [4, 9], [4, 11], [5, 0], [5, 3], [5, 4], [5, 6], [5, 7], [5, 8], [5, 10], [5, 12], [5, 13], [6, 1], [6, 3], [6, 5], [6, 8], [6, 11], [6, 12], [7, 0], [7, 1], [7, 3], [7, 6], [7, 9], [7, 12], [8, 7], [8, 10], [8, 11], [8, 13], [9, 3], [9, 5], [9, 10], [9, 11], [9, 12], [10, 2], [10, 3], [10, 4], [10, 7], [10, 9], [10, 10], [10, 11], [10, 13], [11, 4], [12, 0], [12, 7], [13, 1], [13, 2], [13, 8], [13, 10], [13, 13]], g2=[[13, 11], [5, 12], [3, 7], [13, 3], [0, 10], [0, 3], [0, 2], [8, 5], [1, 7], [1, 6], [4, 4], [7, 0], [7, 1], [7, 8], [12, 7], [4, 10], [0, 1], [6, 13], [7, 4], [2, 9], [0, 11], [12, 2], [2, 2], [12, 11], [6, 3], [5, 9], [5, 7], [10, 4], [5, 4], [8, 1], [1, 8], [3, 0], [9, 6], [0, 12], [5, 3], [4, 1], [13, 5], [2, 1], [9, 2], [1, 1], [9, 7], [1, 9], [4, 0], [9, 4], [4, 3], [11, 10], [1, 0], [5, 10], [6, 6], [5, 0], [5, 8], [9, 13], [8, 12], [4, 5], [9, 11], [6, 4], [8, 3], [8, 11], [2, 6], [4, 8], [7, 3], [10, 6], [10, 13], [12, 9], [0, 5], [0, 7], [5, 2], [2, 12], [13, 9], [7, 13], [9, 10], [9, 9], [13, 4], [8, 4], [10, 11], [0, 9]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_7",
    "sat": "def sat(bi: List[int], g1=[[1, 1], [1, 3], [2, 0], [2, 1], [2, 2], [3, 1]], g2=[[3, 1], [1, 1], [0, 0], [1, 3], [0, 1], [0, 2]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [
      "def sol(g1=[[1, 1], [1, 3], [2, 0], [2, 1], [2, 2], [3, 1]], g2=[[3, 1], [1, 1], [0, 0], [1, 3], [0, 1], [0, 2]]):  # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""
    ],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_8",
    "sat": "def sat(bi: List[int], g1=[[0, 0], [0, 1], [0, 2], [0, 4], [0, 10], [0, 11], [1, 0], [1, 2], [1, 5], [1, 6], [1, 9], [2, 1], [2, 3], [2, 5], [2, 6], [3, 2], [3, 3], [3, 4], [3, 6], [3, 11], [3, 12], [4, 2], [4, 4], [4, 5], [4, 8], [4, 11], [4, 12], [5, 0], [5, 1], [5, 2], [5, 5], [5, 7], [6, 2], [6, 5], [6, 6], [6, 9], [6, 12], [7, 0], [7, 1], [7, 3], [7, 10], [7, 12], [8, 6], [8, 7], [8, 8], [8, 9], [8, 10], [8, 11], [8, 12], [9, 2], [9, 3], [9, 5], [9, 8], [9, 9], [10, 0], [10, 2], [10, 3], [10, 6], [10, 10], [10, 11], [11, 1], [11, 3], [11, 5], [11, 7], [11, 10], [12, 3], [12, 11]], g2=[[10, 6], [1, 0], [12, 10], [12, 0], [0, 0], [4, 10], [8, 10], [1, 1], [12, 8], [8, 8], [3, 0], [8, 5], [5, 5], [5, 7], [11, 11], [3, 5], [11, 3], [5, 4], [6, 2], [9, 7], [0, 10], [4, 9], [7, 0], [1, 11], [2, 3], [2, 12], [2, 2], [1, 10], [4, 2], [6, 5], [11, 1], [5, 3], [9, 6], [7, 5], [6, 7], [0, 5], [11, 5], [3, 12], [0, 3], [1, 4], [0, 11], [1, 6], [2, 9], [2, 0], [8, 6], [7, 11], [7, 9], [6, 12], [12, 3], [9, 8], [10, 12], [4, 7], [8, 1], [9, 9], [9, 3], [5, 9], [12, 12], [8, 3], [2, 6], [9, 2], [7, 3], [3, 7], [12, 6], [1, 2], [6, 4], [4, 12], [11, 12]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "GraphIsomorphism_9",
    "sat": "def sat(bi: List[int], g1=[[0, 2], [0, 7], [0, 9], [0, 10], [0, 12], [0, 13], [0, 14], [1, 1], [1, 3], [1, 6], [1, 8], [1, 12], [1, 13], [1, 16], [2, 3], [2, 8], [2, 11], [2, 16], [2, 17], [3, 2], [3, 3], [3, 10], [3, 11], [3, 12], [3, 13], [3, 14], [4, 13], [4, 15], [4, 16], [5, 0], [5, 1], [5, 8], [5, 10], [5, 13], [5, 17], [6, 1], [6, 3], [6, 4], [6, 5], [6, 10], [6, 11], [6, 16], [6, 17], [7, 0], [7, 8], [7, 9], [7, 17], [8, 1], [8, 2], [8, 3], [8, 5], [8, 6], [8, 11], [9, 2], [9, 3], [9, 5], [9, 7], [9, 10], [9, 13], [9, 16], [10, 1], [10, 4], [10, 8], [10, 10], [10, 11], [10, 13], [10, 14], [10, 15], [11, 1], [11, 2], [11, 5], [11, 7], [11, 11], [11, 12], [11, 13], [11, 15], [11, 17], [12, 0], [12, 1], [12, 2], [12, 3], [12, 4], [12, 5], [12, 6], [12, 7], [12, 8], [12, 10], [12, 11], [12, 13], [12, 14], [12, 15], [12, 16], [13, 4], [13, 5], [13, 9], [13, 10], [13, 11], [13, 13], [13, 14], [13, 15], [13, 17], [14, 0], [14, 11], [14, 15], [14, 16], [14, 17], [15, 0], [15, 1], [15, 2], [15, 8], [15, 11], [15, 12], [15, 17], [16, 2], [16, 3], [16, 4], [16, 9], [16, 10], [16, 12], [16, 14], [16, 16], [16, 17], [17, 2], [17, 3], [17, 8], [17, 9], [17, 11], [17, 15], [17, 17]], g2=[[5, 12], [4, 4], [17, 14], [6, 4], [7, 2], [11, 13], [9, 7], [10, 12], [9, 3], [1, 13], [8, 4], [7, 17], [2, 13], [15, 15], [8, 3], [15, 12], [7, 1], [0, 1], [4, 5], [7, 7], [16, 14], [4, 10], [14, 17], [4, 8], [1, 12], [16, 5], [14, 10], [7, 14], [8, 1], [10, 7], [15, 5], [2, 4], [15, 10], [9, 8], [0, 9], [9, 2], [9, 1], [10, 3], [3, 3], [0, 17], [13, 7], [14, 6], [15, 0], [15, 1], [7, 3], [6, 0], [6, 17], [2, 0], [14, 11], [1, 9], [16, 15], [15, 14], [7, 0], [3, 1], [13, 5], [11, 3], [6, 11], [0, 0], [10, 9], [6, 10], [1, 0], [12, 4], [9, 16], [10, 0], [3, 11], [9, 0], [3, 8], [3, 15], [3, 5], [16, 13], [5, 7], [1, 17], [3, 7], [9, 6], [6, 7], [5, 11], [9, 11], [2, 15], [17, 3], [11, 17], [12, 0], [6, 8], [0, 15], [12, 10], [4, 9], [4, 15], [9, 13], [2, 1], [5, 4], [17, 10], [13, 3], [5, 10], [17, 6], [3, 2], [9, 17], [1, 15], [6, 15], [9, 14], [5, 3], [4, 2], [0, 16], [5, 16], [4, 7], [12, 15], [17, 4], [0, 12], [9, 12], [17, 9], [13, 16], [11, 14], [13, 12], [10, 10], [13, 9], [3, 0], [0, 3], [14, 12], [4, 12], [9, 10], [10, 2], [9, 4], [1, 14], [0, 11], [14, 0], [7, 8], [11, 15], [12, 14], [17, 17], [13, 2], [11, 7]]):\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "sols": [],
    "module": "graphs"
  },
  {
    "name": "ShortIntegerPath_0",
    "sat": "def sat(li: List[int]):\n    \"\"\"\n    Find a list of nine integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\n    \"\"\"\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128])) and len(li) == 9",
    "sols": [
      "def sol():\n    return [1, 3, 4, 12, 13, 14, 42, 126, 127]"
    ],
    "module": "graphs"
  },
  {
    "name": "BiPermutations_0",
    "sat": "def sat(perms: List[List[int]], prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_1",
    "sat": "def sat(perms: List[List[int]], prices0=[3, 0, 1, 3, 2, 3, 2, 0, 0, 1, 3, 2, 1, 2, 2, 1, 1, 0, 1, 2, 3, 2, 1, 2, 3, 1, 2, 0, 3, 1, 1, 1, 3, 2], prices1=[1, 2, 2, 0, 2, 3, 1, 3, 2, 3, 0, 0, 0, 2, 3, 1, 2, 1, 1, 1, 0, 3, 2, 2, 0, 2, 0, 0, 0, 3, 0, 3, 1, 2], heights0=[6, 11, 6, 2, 8, 5, 2, 5, 7, 4, 7, 7, 9, 7, 8, 11, 7, 11, 6, 9, 7, 8, 4, 10, 11, 12, 3, 13, 12, 4, 9, 10, 11, 4], heights1=[4, 3, 6, 3, 2, 1, 6, 9, 6, 3, 7, 4, 10, 7, 3, 6, 8, 3, 9, 1, 2, 9, 4, 4, 3, 3, 10, 9, 3, 4, 3, 6, 1, 6]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[3, 0, 1, 3, 2, 3, 2, 0, 0, 1, 3, 2, 1, 2, 2, 1, 1, 0, 1, 2, 3, 2, 1, 2, 3, 1, 2, 0, 3, 1, 1, 1, 3, 2], prices1=[1, 2, 2, 0, 2, 3, 1, 3, 2, 3, 0, 0, 0, 2, 3, 1, 2, 1, 1, 1, 0, 3, 2, 2, 0, 2, 0, 0, 0, 3, 0, 3, 1, 2], heights0=[6, 11, 6, 2, 8, 5, 2, 5, 7, 4, 7, 7, 9, 7, 8, 11, 7, 11, 6, 9, 7, 8, 4, 10, 11, 12, 3, 13, 12, 4, 9, 10, 11, 4], heights1=[4, 3, 6, 3, 2, 1, 6, 9, 6, 3, 7, 4, 10, 7, 3, 6, 8, 3, 9, 1, 2, 9, 4, 4, 3, 3, 10, 9, 3, 4, 3, 6, 1, 6]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_2",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 1, 1, 1, 0, 0, 1, 1], prices1=[0, 0, 0, 1, 1, 0, 0, 1, 0, 1], heights0=[7, 12, 6, 11, 10, 7, 6, 6, 11, 8], heights1=[5, 9, 3, 6, 2, 6, 1, 9, 5, 5]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 0, 0, 1, 1, 1, 0, 0, 1, 1], prices1=[0, 0, 0, 1, 1, 0, 0, 1, 0, 1], heights0=[7, 12, 6, 11, 10, 7, 6, 6, 11, 8], heights1=[5, 9, 3, 6, 2, 6, 1, 9, 5, 5]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_3",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1], prices1=[0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0], heights0=[9, 11, 7, 6, 7, 6, 8, 15, 5, 7, 8, 6, 7, 5, 14, 11, 10], heights1=[9, 8, 4, 3, 3, 3, 6, 2, 7, 10, 5, 2, 8, 4, 1, 4, 10]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1], prices1=[0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0], heights0=[9, 11, 7, 6, 7, 6, 8, 15, 5, 7, 8, 6, 7, 5, 14, 11, 10], heights1=[9, 8, 4, 3, 3, 3, 6, 2, 7, 10, 5, 2, 8, 4, 1, 4, 10]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_4",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0, 0, 0, 0], heights0=[6, 5, 5, 9, 10, 8, 10, 13], heights1=[5, 1, 4, 3, 6, 9, 8, 9]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 0, 0, 0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0, 0, 0, 0], heights0=[6, 5, 5, 9, 10, 8, 10, 13], heights1=[5, 1, 4, 3, 6, 9, 8, 9]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_5",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0, 0, 0], heights0=[10, 12, 11, 11, 3, 7, 7], heights1=[10, 7, 9, 3, 8, 3, 2]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 0, 0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0, 0, 0], heights0=[10, 12, 11, 11, 3, 7, 7], heights1=[10, 7, 9, 3, 8, 3, 2]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_6",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0], prices1=[0, 0, 0], heights0=[14, 8, 9], heights1=[6, 9, 4]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 0, 0], prices1=[0, 0, 0], heights0=[14, 8, 9], heights1=[6, 9, 4]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_7",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[12, 7, 13, 8, 6], heights1=[9, 1, 8, 4, 5]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[12, 7, 13, 8, 6], heights1=[9, 1, 8, 4, 5]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_8",
    "sat": "def sat(perms: List[List[int]], prices0=[2, 5, 8, 7, 0, 2, 1, 2, 0, 3, 8, 7, 5, 0, 5, 5, 5, 2, 5, 3, 3, 1, 5, 8, 5, 4, 1, 8, 0, 3, 5, 1, 6, 0, 0, 5, 3, 6, 2, 1, 4, 4, 8, 0, 0, 2, 3, 6, 0, 5, 4, 0, 6, 0, 7, 3, 5, 2, 3, 2, 3, 3, 4, 2, 6, 8, 7, 0, 5, 5, 0, 4, 6, 4, 6, 8, 8, 7, 2, 2, 8, 0, 0, 5, 1, 5, 4, 8, 2], prices1=[0, 6, 1, 7, 7, 6, 7, 6, 5, 3, 8, 2, 3, 5, 1, 3, 8, 4, 5, 2, 0, 1, 4, 6, 8, 6, 2, 7, 0, 6, 5, 2, 2, 6, 8, 8, 2, 4, 8, 2, 2, 7, 2, 5, 3, 2, 3, 4, 3, 0, 8, 5, 5, 0, 8, 5, 7, 8, 7, 6, 4, 7, 3, 7, 5, 5, 7, 2, 6, 0, 3, 2, 1, 5, 4, 8, 8, 5, 7, 7, 8, 6, 8, 8, 4, 0, 1, 0, 4], heights0=[12, 5, 8, 10, 12, 4, 3, 9, 8, 14, 13, 13, 8, 12, 11, 5, 3, 11, 9, 11, 9, 5, 10, 10, 5, 8, 7, 4, 4, 15, 4, 12, 7, 3, 6, 9, 4, 13, 11, 15, 6, 7, 11, 5, 12, 7, 11, 7, 12, 8, 13, 11, 5, 8, 11, 11, 5, 13, 6, 4, 4, 8, 10, 7, 7, 4, 8, 4, 7, 15, 10, 7, 2, 5, 11, 8, 9, 6, 6, 13, 10, 10, 10, 12, 3, 5, 8, 10, 9], heights1=[2, 3, 10, 1, 7, 5, 10, 2, 2, 8, 1, 4, 5, 2, 9, 1, 8, 7, 1, 1, 9, 6, 2, 5, 10, 2, 9, 6, 1, 4, 4, 10, 9, 10, 6, 8, 6, 6, 7, 2, 4, 9, 8, 3, 10, 10, 5, 7, 10, 9, 7, 3, 10, 2, 1, 8, 4, 5, 5, 5, 10, 2, 3, 6, 3, 8, 6, 3, 8, 8, 2, 1, 9, 3, 4, 9, 6, 3, 2, 3, 7, 7, 8, 8, 10, 6, 7, 4, 6]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[2, 5, 8, 7, 0, 2, 1, 2, 0, 3, 8, 7, 5, 0, 5, 5, 5, 2, 5, 3, 3, 1, 5, 8, 5, 4, 1, 8, 0, 3, 5, 1, 6, 0, 0, 5, 3, 6, 2, 1, 4, 4, 8, 0, 0, 2, 3, 6, 0, 5, 4, 0, 6, 0, 7, 3, 5, 2, 3, 2, 3, 3, 4, 2, 6, 8, 7, 0, 5, 5, 0, 4, 6, 4, 6, 8, 8, 7, 2, 2, 8, 0, 0, 5, 1, 5, 4, 8, 2], prices1=[0, 6, 1, 7, 7, 6, 7, 6, 5, 3, 8, 2, 3, 5, 1, 3, 8, 4, 5, 2, 0, 1, 4, 6, 8, 6, 2, 7, 0, 6, 5, 2, 2, 6, 8, 8, 2, 4, 8, 2, 2, 7, 2, 5, 3, 2, 3, 4, 3, 0, 8, 5, 5, 0, 8, 5, 7, 8, 7, 6, 4, 7, 3, 7, 5, 5, 7, 2, 6, 0, 3, 2, 1, 5, 4, 8, 8, 5, 7, 7, 8, 6, 8, 8, 4, 0, 1, 0, 4], heights0=[12, 5, 8, 10, 12, 4, 3, 9, 8, 14, 13, 13, 8, 12, 11, 5, 3, 11, 9, 11, 9, 5, 10, 10, 5, 8, 7, 4, 4, 15, 4, 12, 7, 3, 6, 9, 4, 13, 11, 15, 6, 7, 11, 5, 12, 7, 11, 7, 12, 8, 13, 11, 5, 8, 11, 11, 5, 13, 6, 4, 4, 8, 10, 7, 7, 4, 8, 4, 7, 15, 10, 7, 2, 5, 11, 8, 9, 6, 6, 13, 10, 10, 10, 12, 3, 5, 8, 10, 9], heights1=[2, 3, 10, 1, 7, 5, 10, 2, 2, 8, 1, 4, 5, 2, 9, 1, 8, 7, 1, 1, 9, 6, 2, 5, 10, 2, 9, 6, 1, 4, 4, 10, 9, 10, 6, 8, 6, 6, 7, 2, 4, 9, 8, 3, 10, 10, 5, 7, 10, 9, 7, 3, 10, 2, 1, 8, 4, 5, 5, 5, 10, 2, 3, 6, 3, 8, 6, 3, 8, 8, 2, 1, 9, 3, 4, 9, 6, 3, 2, 3, 7, 7, 8, 8, 10, 6, 7, 4, 6]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "BiPermutations_9",
    "sat": "def sat(perms: List[List[int]], prices0=[0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], prices1=[0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], heights0=[13, 4, 8, 9, 4, 11, 9, 7, 13, 10, 6, 7, 12, 10, 8, 13, 6, 11, 11], heights1=[6, 3, 6, 5, 4, 8, 6, 9, 8, 3, 4, 7, 8, 8, 9, 8, 7, 3, 5]):\n    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "sols": [
      "def sol(prices0=[0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], prices1=[0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], heights0=[13, 4, 8, 9, 4, 11, 9, 7, 13, 10, 6, 7, 12, 10, 8, 13, 6, 11, 11], heights1=[6, 3, 6, 5, 4, 8, 6, 9, 8, 3, 4, 7, 8, 8, 9, 8, 7, 3, 5]):\n    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_0",
    "sat": "def sat(indices: List[int], H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_1",
    "sat": "def sat(indices: List[int], H=100000, alpha=41, beta=32, xs=[0, 3342, 100000], ys=[6953, 8761, 6143], thresh=299337417559):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=41, beta=32, xs=[0, 3342, 100000], ys=[6953, 8761, 6143], thresh=299337417559):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_2",
    "sat": "def sat(indices: List[int], H=100000, alpha=8, beta=1, xs=[0, 75570, 99107, 99601, 99995, 99999, 99999, 99999, 100000], ys=[35985, 20890, 24231, 1092, 88191, 86004, 44487, 8257, 46728], thresh=6267790046):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=8, beta=1, xs=[0, 75570, 99107, 99601, 99995, 99999, 99999, 99999, 100000], ys=[35985, 20890, 24231, 1092, 88191, 86004, 44487, 8257, 46728], thresh=6267790046):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_3",
    "sat": "def sat(indices: List[int], H=100000, alpha=4, beta=9, xs=[0, 77374, 86039, 99228, 100000], ys=[56968, 55689, 43779, 13236, 38336], thresh=56128442222):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=4, beta=9, xs=[0, 77374, 86039, 99228, 100000], ys=[56968, 55689, 43779, 13236, 38336], thresh=56128442222):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_4",
    "sat": "def sat(indices: List[int], H=100000, alpha=30, beta=29, xs=[0, 84, 4454, 4821, 12405, 13409, 17034, 20796, 20845, 20845, 20853, 20855, 20860, 20862, 25699, 30100, 39463, 40677, 50383, 57860, 59696, 67360, 68208, 69893, 74620, 74626, 77710, 84321, 85133, 85458, 86819, 87240, 87362, 87362, 87365, 87365, 87367, 96685, 98984, 100000], ys=[4279, 65561, 5059, 906, 68579, 81360, 74590, 53853, 52769, 66476, 22254, 74532, 48922, 4148, 43352, 61781, 26910, 91308, 79736, 67219, 19189, 42049, 57300, 53195, 42749, 31021, 39818, 34726, 86214, 86647, 96791, 66029, 19748, 44239, 52961, 34928, 49106, 39716, 62035, 61669], thresh=18146811094):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=30, beta=29, xs=[0, 84, 4454, 4821, 12405, 13409, 17034, 20796, 20845, 20845, 20853, 20855, 20860, 20862, 25699, 30100, 39463, 40677, 50383, 57860, 59696, 67360, 68208, 69893, 74620, 74626, 77710, 84321, 85133, 85458, 86819, 87240, 87362, 87362, 87365, 87365, 87367, 96685, 98984, 100000], ys=[4279, 65561, 5059, 906, 68579, 81360, 74590, 53853, 52769, 66476, 22254, 74532, 48922, 4148, 43352, 61781, 26910, 91308, 79736, 67219, 19189, 42049, 57300, 53195, 42749, 31021, 39818, 34726, 86214, 86647, 96791, 66029, 19748, 44239, 52961, 34928, 49106, 39716, 62035, 61669], thresh=18146811094):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_5",
    "sat": "def sat(indices: List[int], H=100000, alpha=13, beta=3, xs=[0, 20439, 37912, 46144, 71958, 89008, 89726, 97107, 99345, 99741, 99972, 100000], ys=[19663, 33472, 29506, 41439, 16578, 48031, 51835, 39584, 70847, 31294, 72587, 12323], thresh=5433242558):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=13, beta=3, xs=[0, 20439, 37912, 46144, 71958, 89008, 89726, 97107, 99345, 99741, 99972, 100000], ys=[19663, 33472, 29506, 41439, 16578, 48031, 51835, 39584, 70847, 31294, 72587, 12323], thresh=5433242558):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_6",
    "sat": "def sat(indices: List[int], H=100000, alpha=1, beta=2, xs=[0, 11989, 19323, 36943, 58122, 70518, 70881, 74237, 100000], ys=[71388, 728, 57947, 35905, 62039, 58222, 39302, 7562, 23725], thresh=3571194398):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=1, beta=2, xs=[0, 11989, 19323, 36943, 58122, 70518, 70881, 74237, 100000], ys=[71388, 728, 57947, 35905, 62039, 58222, 39302, 7562, 23725], thresh=3571194398):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_7",
    "sat": "def sat(indices: List[int], H=100000, alpha=47, beta=0, xs=[0, 4139, 4321, 5085, 5627, 6730, 8086, 17340, 32712, 33328, 41775, 42067, 44242, 45654, 48399, 49889, 50163, 50294, 50710, 50855, 50968, 51062, 51088, 51092, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51094, 54080, 56728, 58184, 67684, 69326, 87148, 89561, 92956, 97628, 100000], ys=[39899, 38443, 25728, 35967, 5383, 80078, 7419, 29968, 35367, 58423, 15184, 85280, 81853, 19485, 24228, 90242, 79609, 28954, 19974, 53334, 30198, 37246, 59197, 42906, 97653, 97786, 83638, 61651, 27147, 57627, 47838, 74861, 62230, 29759, 12614, 59765, 68782, 83726, 32981, 76216, 22026, 59876, 34311, 1931, 96406, 34912, 89714, 66825, 24200, 93065, 96599, 45182, 89291, 63953, 37126, 84616, 35397, 33889, 91785, 35484, 1774, 63022, 18316, 98875, 69252, 13402, 40076, 10060, 69147, 13972, 57161, 59646, 41640, 54805, 60425, 37157, 87472, 96922, 14220, 69288, 87392, 16695, 90989, 75770, 79778, 65138, 35057, 56966, 32280, 79058, 17493, 92089, 82915, 56715, 81441, 28060, 41003, 97347, 35684], thresh=10083051):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=47, beta=0, xs=[0, 4139, 4321, 5085, 5627, 6730, 8086, 17340, 32712, 33328, 41775, 42067, 44242, 45654, 48399, 49889, 50163, 50294, 50710, 50855, 50968, 51062, 51088, 51092, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51093, 51094, 54080, 56728, 58184, 67684, 69326, 87148, 89561, 92956, 97628, 100000], ys=[39899, 38443, 25728, 35967, 5383, 80078, 7419, 29968, 35367, 58423, 15184, 85280, 81853, 19485, 24228, 90242, 79609, 28954, 19974, 53334, 30198, 37246, 59197, 42906, 97653, 97786, 83638, 61651, 27147, 57627, 47838, 74861, 62230, 29759, 12614, 59765, 68782, 83726, 32981, 76216, 22026, 59876, 34311, 1931, 96406, 34912, 89714, 66825, 24200, 93065, 96599, 45182, 89291, 63953, 37126, 84616, 35397, 33889, 91785, 35484, 1774, 63022, 18316, 98875, 69252, 13402, 40076, 10060, 69147, 13972, 57161, 59646, 41640, 54805, 60425, 37157, 87472, 96922, 14220, 69288, 87392, 16695, 90989, 75770, 79778, 65138, 35057, 56966, 32280, 79058, 17493, 92089, 82915, 56715, 81441, 28060, 41003, 97347, 35684], thresh=10083051):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_8",
    "sat": "def sat(indices: List[int], H=100000, alpha=43, beta=44, xs=[0, 7579, 29310, 33151, 33241, 33778, 37766, 41925, 42918, 44220, 45872, 46977, 47299, 47540, 47640, 47646, 48086, 48615, 53279, 55719, 56651, 56781, 57049, 57176, 57195, 57238, 58524, 59325, 65164, 65864, 67820, 68363, 68931, 75945, 76005, 77133, 83429, 85784, 87873, 88091, 88379, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88381, 92677, 100000], ys=[28845, 34810, 46117, 3415, 39857, 70696, 38237, 70381, 19081, 48662, 3604, 40819, 13875, 6357, 25069, 67460, 85579, 77731, 97711, 19023, 88950, 70364, 93313, 77394, 5714, 31074, 16051, 10684, 82403, 61047, 9709, 77833, 66230, 37438, 11099, 84876, 76147, 28417, 22265, 48441, 10659, 65151, 5187, 51330, 28948, 74278, 61495, 87143, 70019, 43800, 63685, 71134, 81214, 31828, 77691, 62865, 5591, 29480, 32537, 62961, 39151, 14908, 51719, 83409, 16725, 25093, 22747, 93835, 81836, 23621, 9369, 32193, 90777, 82391, 88540, 52790, 14552, 80102, 45872, 55796, 27653, 42565, 967, 35979, 44554, 81656, 52547, 51269, 91835, 55711, 55455, 70944, 11745, 43481, 5148, 86684, 6594, 45567, 64730], thresh=37497247125):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=43, beta=44, xs=[0, 7579, 29310, 33151, 33241, 33778, 37766, 41925, 42918, 44220, 45872, 46977, 47299, 47540, 47640, 47646, 48086, 48615, 53279, 55719, 56651, 56781, 57049, 57176, 57195, 57238, 58524, 59325, 65164, 65864, 67820, 68363, 68931, 75945, 76005, 77133, 83429, 85784, 87873, 88091, 88379, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88380, 88381, 92677, 100000], ys=[28845, 34810, 46117, 3415, 39857, 70696, 38237, 70381, 19081, 48662, 3604, 40819, 13875, 6357, 25069, 67460, 85579, 77731, 97711, 19023, 88950, 70364, 93313, 77394, 5714, 31074, 16051, 10684, 82403, 61047, 9709, 77833, 66230, 37438, 11099, 84876, 76147, 28417, 22265, 48441, 10659, 65151, 5187, 51330, 28948, 74278, 61495, 87143, 70019, 43800, 63685, 71134, 81214, 31828, 77691, 62865, 5591, 29480, 32537, 62961, 39151, 14908, 51719, 83409, 16725, 25093, 22747, 93835, 81836, 23621, 9369, 32193, 90777, 82391, 88540, 52790, 14552, 80102, 45872, 55796, 27653, 42565, 967, 35979, 44554, 81656, 52547, 51269, 91835, 55711, 55455, 70944, 11745, 43481, 5148, 86684, 6594, 45567, 64730], thresh=37497247125):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "OptimalBridges_9",
    "sat": "def sat(indices: List[int], H=100000, alpha=3, beta=49, xs=[0, 245, 352, 927, 3295, 7103, 12961, 15927, 16016, 16043, 16086, 16090, 16090, 16090, 16090, 16090, 16090, 16090, 16090, 16090, 16091, 20745, 29240, 31474, 32761, 32954, 33097, 33100, 33105, 33116, 33119, 33121, 33122, 33122, 33123, 33123, 33123, 33123, 33123, 33123, 33123, 33124, 36682, 41289, 52381, 60946, 79106, 79668, 100000], ys=[21918, 8780, 24681, 18274, 8331, 56911, 54866, 67826, 77861, 4381, 56600, 96552, 80452, 77316, 97045, 73480, 45943, 64619, 34603, 28479, 9608, 24719, 71774, 47955, 78635, 718, 24984, 27520, 3289, 91813, 47119, 26151, 44726, 65950, 96921, 83212, 45338, 40043, 1928, 14033, 47071, 53309, 30321, 62226, 41733, 35671, 65036, 47684, 50144], thresh=55763049189):\n    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "sols": [
      "def sol(H=100000, alpha=3, beta=49, xs=[0, 245, 352, 927, 3295, 7103, 12961, 15927, 16016, 16043, 16086, 16090, 16090, 16090, 16090, 16090, 16090, 16090, 16090, 16090, 16091, 20745, 29240, 31474, 32761, 32954, 33097, 33100, 33105, 33116, 33119, 33121, 33122, 33122, 33123, 33123, 33123, 33123, 33123, 33123, 33123, 33124, 36682, 41289, 52381, 60946, 79106, 79668, 100000], ys=[21918, 8780, 24681, 18274, 8331, 56911, 54866, 67826, 77861, 4381, 56600, 96552, 80452, 77316, 97045, 73480, 45943, 64619, 34603, 28479, 9608, 24719, 71774, 47955, 78635, 718, 24984, 27520, 3289, 91813, 47119, 26151, 44726, 65950, 96921, 83212, 45338, 40043, 1928, 14033, 47071, 53309, 30321, 62226, 41733, 35671, 65036, 47684, 50144], thresh=55763049189):  # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_0",
    "sat": "def sat(position: List[List[int]], transcript=[[[3, 3], [5, 5], [3, 7]], [[5, 3], [6, 4]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[3, 3], [5, 5], [3, 7]], [[5, 3], [6, 4]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_1",
    "sat": "def sat(position: List[List[int]], transcript: List[List[List[int]]]=[]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_2",
    "sat": "def sat(position: List[List[int]], transcript=[[[1, 1], [2, 2]], [[7, 5], [6, 4]], [[6, 0], [5, 1]], [[5, 5], [4, 4]], [[7, 3], [5, 5]], [[1, 7], [2, 6]], [[5, 1], [4, 2]], [[4, 4], [5, 3]], [[4, 2], [6, 4]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[1, 1], [2, 2]], [[7, 5], [6, 4]], [[6, 0], [5, 1]], [[5, 5], [4, 4]], [[7, 3], [5, 5]], [[1, 7], [2, 6]], [[5, 1], [4, 2]], [[4, 4], [5, 3]], [[4, 2], [6, 4]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_3",
    "sat": "def sat(position: List[List[int]], transcript=[[[6, 0], [4, 2]], [[3, 7], [2, 6]], [[2, 0], [1, 1]], [[2, 6], [3, 5]], [[3, 3], [2, 4]], [[3, 5], [1, 3]], [[0, 2], [2, 4]], [[5, 7], [6, 6]], [[4, 2], [3, 3]], [[0, 6], [1, 5]], [[2, 4], [0, 6]], [[5, 5], [6, 4]], [[3, 3], [2, 4]], [[6, 4], [5, 3]], [[2, 2], [3, 3]], [[5, 3], [6, 2]], [[4, 0], [5, 1]], [[6, 2], [4, 0]], [[3, 1], [2, 2]], [[0, 4], [1, 3]], [[2, 2], [0, 4]], [[4, 6], [5, 5]], [[2, 4], [1, 5]], [[6, 6], [7, 5]], [[1, 1], [0, 2]], [[5, 5], [4, 4]], [[3, 3], [5, 5]], [[7, 5], [6, 4]], [[5, 5], [4, 6]], [[4, 0], [5, 1]], [[1, 5], [2, 6]], [[1, 7], [3, 5]], [[4, 6], [3, 7]], [[5, 1], [4, 0]], [[0, 6], [1, 7]], [[6, 4], [7, 3]], [[0, 2], [1, 3]], [[3, 5], [4, 4]], [[1, 3], [2, 4]], [[7, 3], [6, 2]], [[0, 4], [1, 5]], [[4, 4], [3, 3]], [[3, 7], [4, 6]], [[3, 3], [4, 2]], [[1, 7], [0, 6]], [[6, 2], [5, 1]], [[1, 5], [2, 6]], [[4, 2], [3, 1]], [[2, 4], [3, 5]], [[3, 1], [2, 0]], [[4, 6], [3, 7]], [[4, 0], [3, 1]], [[3, 7], [4, 6]], [[3, 1], [4, 2]], [[0, 6], [1, 5]], [[5, 1], [4, 0]], [[4, 6], [3, 7]], [[4, 0], [5, 1]], [[3, 7], [4, 6]], [[4, 2], [3, 1]], [[4, 6], [5, 5]], [[5, 1], [4, 0]], [[5, 5], [4, 6]], [[3, 1], [2, 2]], [[1, 5], [2, 4]], [[4, 0], [3, 1]], [[4, 6], [5, 7]], [[3, 1], [4, 0]], [[2, 6], [1, 7]], [[2, 2], [3, 3]], [[2, 4], [4, 2]], [[2, 0], [1, 1]], [[4, 2], [3, 1]], [[4, 0], [2, 2]], [[3, 5], [4, 6]], [[2, 2], [3, 3]], [[4, 6], [3, 7]], [[3, 3], [2, 4]], [[5, 7], [4, 6]], [[1, 1], [2, 0]], [[4, 6], [5, 7]], [[2, 0], [3, 1]], [[3, 7], [4, 6]], [[2, 4], [1, 5]], [[4, 6], [5, 5]], [[1, 5], [0, 4]], [[5, 5], [4, 6]], [[7, 7], [6, 6]], [[5, 7], [7, 5]], [[3, 1], [2, 2]], [[4, 6], [3, 7]], [[2, 2], [1, 3]], [[1, 7], [2, 6]], [[1, 3], [2, 2]], [[2, 6], [1, 7]], [[2, 2], [1, 1]], [[7, 5], [6, 4]], [[0, 4], [1, 3]], [[6, 4], [5, 3]], [[1, 3], [2, 2]], [[1, 7], [0, 6]], [[2, 2], [3, 1]], [[5, 3], [6, 4]], [[3, 1], [2, 2]], [[3, 7], [2, 6]], [[2, 2], [1, 3]], [[6, 4], [5, 5]], [[1, 3], [0, 2]], [[0, 6], [1, 5]], [[1, 1], [0, 0]], [[5, 5], [6, 6]], [[0, 0], [1, 1]], [[1, 5], [0, 6]], [[1, 1], [2, 0]], [[2, 6], [3, 5]], [[2, 0], [3, 1]], [[3, 5], [2, 6]], [[0, 2], [1, 1]], [[2, 6], [3, 7]], [[1, 1], [2, 2]], [[6, 6], [5, 7]], [[3, 1], [4, 0]], [[5, 7], [6, 6]], [[2, 2], [1, 1]], [[6, 6], [5, 5]], [[1, 1], [0, 0]], [[3, 7], [4, 6]], [[4, 0], [3, 1]], [[5, 5], [6, 6]], [[3, 1], [4, 0]], [[6, 6], [5, 5]], [[4, 0], [5, 1]], [[5, 5], [6, 6]], [[5, 1], [6, 0]], [[6, 6], [5, 5]], [[6, 0], [7, 1]], [[4, 6], [3, 7]], [[7, 1], [6, 0]], [[0, 6], [1, 7]], [[6, 0], [5, 1]], [[5, 5], [6, 4]], [[5, 1], [4, 2]], [[1, 7], [0, 6]], [[4, 2], [5, 1]], [[6, 4], [5, 3]], [[5, 1], [4, 0]], [[0, 6], [1, 5]], [[4, 0], [5, 1]], [[3, 7], [4, 6]], [[0, 0], [1, 1]], [[5, 3], [6, 4]], [[1, 1], [2, 2]], [[6, 4], [7, 5]], [[5, 1], [4, 0]], [[7, 5], [6, 4]], [[2, 2], [1, 1]], [[1, 5], [2, 4]], [[4, 0], [5, 1]], [[6, 4], [5, 5]], [[5, 1], [4, 0]], [[2, 4], [1, 5]], [[1, 1], [0, 0]], [[1, 5], [2, 6]], [[4, 0], [3, 1]], [[4, 6], [5, 7]], [[3, 1], [4, 0]], [[2, 6], [1, 7]], [[4, 0], [5, 1]], [[5, 5], [6, 6]], [[5, 1], [4, 0]], [[6, 6], [7, 7]], [[4, 0], [5, 1]], [[7, 7], [6, 6]], [[5, 1], [4, 2]], [[6, 6], [5, 5]], [[4, 2], [3, 1]], [[5, 7], [6, 6]], [[3, 1], [4, 0]], [[5, 5], [4, 6]], [[4, 0], [3, 1]], [[6, 6], [7, 7]], [[3, 1], [2, 2]], [[4, 6], [3, 7]], [[2, 2], [3, 1]], [[7, 7], [6, 6]], [[3, 1], [4, 0]], [[6, 6], [5, 5]], [[4, 0], [3, 1]], [[3, 7], [4, 6]], [[3, 1], [2, 2]], [[4, 6], [3, 7]], [[2, 2], [3, 3]], [[5, 5], [6, 6]], [[3, 3], [4, 2]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[6, 0], [4, 2]], [[3, 7], [2, 6]], [[2, 0], [1, 1]], [[2, 6], [3, 5]], [[3, 3], [2, 4]], [[3, 5], [1, 3]], [[0, 2], [2, 4]], [[5, 7], [6, 6]], [[4, 2], [3, 3]], [[0, 6], [1, 5]], [[2, 4], [0, 6]], [[5, 5], [6, 4]], [[3, 3], [2, 4]], [[6, 4], [5, 3]], [[2, 2], [3, 3]], [[5, 3], [6, 2]], [[4, 0], [5, 1]], [[6, 2], [4, 0]], [[3, 1], [2, 2]], [[0, 4], [1, 3]], [[2, 2], [0, 4]], [[4, 6], [5, 5]], [[2, 4], [1, 5]], [[6, 6], [7, 5]], [[1, 1], [0, 2]], [[5, 5], [4, 4]], [[3, 3], [5, 5]], [[7, 5], [6, 4]], [[5, 5], [4, 6]], [[4, 0], [5, 1]], [[1, 5], [2, 6]], [[1, 7], [3, 5]], [[4, 6], [3, 7]], [[5, 1], [4, 0]], [[0, 6], [1, 7]], [[6, 4], [7, 3]], [[0, 2], [1, 3]], [[3, 5], [4, 4]], [[1, 3], [2, 4]], [[7, 3], [6, 2]], [[0, 4], [1, 5]], [[4, 4], [3, 3]], [[3, 7], [4, 6]], [[3, 3], [4, 2]], [[1, 7], [0, 6]], [[6, 2], [5, 1]], [[1, 5], [2, 6]], [[4, 2], [3, 1]], [[2, 4], [3, 5]], [[3, 1], [2, 0]], [[4, 6], [3, 7]], [[4, 0], [3, 1]], [[3, 7], [4, 6]], [[3, 1], [4, 2]], [[0, 6], [1, 5]], [[5, 1], [4, 0]], [[4, 6], [3, 7]], [[4, 0], [5, 1]], [[3, 7], [4, 6]], [[4, 2], [3, 1]], [[4, 6], [5, 5]], [[5, 1], [4, 0]], [[5, 5], [4, 6]], [[3, 1], [2, 2]], [[1, 5], [2, 4]], [[4, 0], [3, 1]], [[4, 6], [5, 7]], [[3, 1], [4, 0]], [[2, 6], [1, 7]], [[2, 2], [3, 3]], [[2, 4], [4, 2]], [[2, 0], [1, 1]], [[4, 2], [3, 1]], [[4, 0], [2, 2]], [[3, 5], [4, 6]], [[2, 2], [3, 3]], [[4, 6], [3, 7]], [[3, 3], [2, 4]], [[5, 7], [4, 6]], [[1, 1], [2, 0]], [[4, 6], [5, 7]], [[2, 0], [3, 1]], [[3, 7], [4, 6]], [[2, 4], [1, 5]], [[4, 6], [5, 5]], [[1, 5], [0, 4]], [[5, 5], [4, 6]], [[7, 7], [6, 6]], [[5, 7], [7, 5]], [[3, 1], [2, 2]], [[4, 6], [3, 7]], [[2, 2], [1, 3]], [[1, 7], [2, 6]], [[1, 3], [2, 2]], [[2, 6], [1, 7]], [[2, 2], [1, 1]], [[7, 5], [6, 4]], [[0, 4], [1, 3]], [[6, 4], [5, 3]], [[1, 3], [2, 2]], [[1, 7], [0, 6]], [[2, 2], [3, 1]], [[5, 3], [6, 4]], [[3, 1], [2, 2]], [[3, 7], [2, 6]], [[2, 2], [1, 3]], [[6, 4], [5, 5]], [[1, 3], [0, 2]], [[0, 6], [1, 5]], [[1, 1], [0, 0]], [[5, 5], [6, 6]], [[0, 0], [1, 1]], [[1, 5], [0, 6]], [[1, 1], [2, 0]], [[2, 6], [3, 5]], [[2, 0], [3, 1]], [[3, 5], [2, 6]], [[0, 2], [1, 1]], [[2, 6], [3, 7]], [[1, 1], [2, 2]], [[6, 6], [5, 7]], [[3, 1], [4, 0]], [[5, 7], [6, 6]], [[2, 2], [1, 1]], [[6, 6], [5, 5]], [[1, 1], [0, 0]], [[3, 7], [4, 6]], [[4, 0], [3, 1]], [[5, 5], [6, 6]], [[3, 1], [4, 0]], [[6, 6], [5, 5]], [[4, 0], [5, 1]], [[5, 5], [6, 6]], [[5, 1], [6, 0]], [[6, 6], [5, 5]], [[6, 0], [7, 1]], [[4, 6], [3, 7]], [[7, 1], [6, 0]], [[0, 6], [1, 7]], [[6, 0], [5, 1]], [[5, 5], [6, 4]], [[5, 1], [4, 2]], [[1, 7], [0, 6]], [[4, 2], [5, 1]], [[6, 4], [5, 3]], [[5, 1], [4, 0]], [[0, 6], [1, 5]], [[4, 0], [5, 1]], [[3, 7], [4, 6]], [[0, 0], [1, 1]], [[5, 3], [6, 4]], [[1, 1], [2, 2]], [[6, 4], [7, 5]], [[5, 1], [4, 0]], [[7, 5], [6, 4]], [[2, 2], [1, 1]], [[1, 5], [2, 4]], [[4, 0], [5, 1]], [[6, 4], [5, 5]], [[5, 1], [4, 0]], [[2, 4], [1, 5]], [[1, 1], [0, 0]], [[1, 5], [2, 6]], [[4, 0], [3, 1]], [[4, 6], [5, 7]], [[3, 1], [4, 0]], [[2, 6], [1, 7]], [[4, 0], [5, 1]], [[5, 5], [6, 6]], [[5, 1], [4, 0]], [[6, 6], [7, 7]], [[4, 0], [5, 1]], [[7, 7], [6, 6]], [[5, 1], [4, 2]], [[6, 6], [5, 5]], [[4, 2], [3, 1]], [[5, 7], [6, 6]], [[3, 1], [4, 0]], [[5, 5], [4, 6]], [[4, 0], [3, 1]], [[6, 6], [7, 7]], [[3, 1], [2, 2]], [[4, 6], [3, 7]], [[2, 2], [3, 1]], [[7, 7], [6, 6]], [[3, 1], [4, 0]], [[6, 6], [5, 5]], [[4, 0], [3, 1]], [[3, 7], [4, 6]], [[3, 1], [2, 2]], [[4, 6], [3, 7]], [[2, 2], [3, 3]], [[5, 5], [6, 6]], [[3, 3], [4, 2]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_4",
    "sat": "def sat(position: List[List[int]], transcript=[[[6, 2], [5, 3]], [[7, 7], [6, 6]], [[7, 1], [6, 2]], [[3, 5], [4, 4]], [[5, 3], [3, 5]], [[6, 6], [5, 5]], [[0, 4], [1, 5]], [[0, 6], [2, 4]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[6, 2], [5, 3]], [[7, 7], [6, 6]], [[7, 1], [6, 2]], [[3, 5], [4, 4]], [[5, 3], [3, 5]], [[6, 6], [5, 5]], [[0, 4], [1, 5]], [[0, 6], [2, 4]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_5",
    "sat": "def sat(position: List[List[int]], transcript=[[[0, 4], [2, 6]], [[1, 7], [3, 5]], [[4, 2], [2, 4], [4, 6]], [[3, 7], [5, 5]], [[6, 2], [7, 3]], [[5, 7], [4, 6]], [[1, 1], [2, 2]], [[6, 4], [5, 3]], [[0, 2], [1, 3]], [[5, 3], [6, 2]], [[7, 1], [5, 3], [3, 5], [5, 7]], [[5, 5], [4, 4]], [[5, 1], [4, 2]], [[6, 6], [5, 5]], [[0, 0], [1, 1]], [[4, 4], [3, 3]], [[4, 2], [2, 4]], [[5, 5], [6, 4]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[0, 4], [2, 6]], [[1, 7], [3, 5]], [[4, 2], [2, 4], [4, 6]], [[3, 7], [5, 5]], [[6, 2], [7, 3]], [[5, 7], [4, 6]], [[1, 1], [2, 2]], [[6, 4], [5, 3]], [[0, 2], [1, 3]], [[5, 3], [6, 2]], [[7, 1], [5, 3], [3, 5], [5, 7]], [[5, 5], [4, 4]], [[5, 1], [4, 2]], [[6, 6], [5, 5]], [[0, 0], [1, 1]], [[4, 4], [3, 3]], [[4, 2], [2, 4]], [[5, 5], [6, 4]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_6",
    "sat": "def sat(position: List[List[int]], transcript=[[[1, 3], [0, 4]], [[1, 5], [2, 4]], [[3, 3], [1, 5], [3, 7]], [[1, 7], [0, 6]], [[3, 7], [5, 5]], [[6, 6], [4, 4]], [[4, 0], [3, 1]], [[4, 4], [3, 3]], [[2, 2], [4, 4]], [[5, 7], [4, 6]], [[6, 0], [5, 1]], [[4, 6], [5, 5]], [[4, 4], [6, 6]], [[7, 7], [5, 5]], [[3, 1], [4, 2]], [[5, 5], [4, 4]], [[4, 2], [3, 3]], [[4, 4], [2, 2], [0, 0]], [[0, 4], [1, 5]], [[0, 6], [2, 4]], [[5, 1], [4, 2]], [[7, 1], [6, 0]], [[0, 2], [1, 3]], [[2, 4], [0, 2]], [[4, 2], [3, 3]], [[6, 0], [7, 1]], [[3, 3], [2, 4]], [[0, 2], [1, 1]], [[2, 4], [3, 5]], [[1, 1], [2, 0]], [[3, 5], [2, 6]], [[7, 1], [6, 2]], [[2, 6], [1, 7]], [[6, 2], [5, 3]], [[1, 7], [2, 6]], [[5, 3], [4, 2]], [[2, 6], [1, 5]], [[4, 2], [5, 3]], [[1, 5], [0, 4]], [[0, 0], [1, 1]], [[0, 4], [1, 5]], [[2, 0], [3, 1]], [[1, 5], [2, 6]], [[5, 3], [6, 4]], [[2, 6], [1, 5]], [[1, 1], [0, 2]], [[1, 5], [2, 4]], [[0, 2], [1, 1]], [[2, 4], [3, 3]], [[1, 1], [2, 2]], [[3, 3], [1, 1]], [[3, 1], [4, 2]], [[1, 1], [0, 2]], [[6, 4], [7, 3]], [[0, 2], [1, 3]], [[4, 2], [3, 3]], [[1, 3], [2, 2]], [[3, 3], [1, 1]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[1, 3], [0, 4]], [[1, 5], [2, 4]], [[3, 3], [1, 5], [3, 7]], [[1, 7], [0, 6]], [[3, 7], [5, 5]], [[6, 6], [4, 4]], [[4, 0], [3, 1]], [[4, 4], [3, 3]], [[2, 2], [4, 4]], [[5, 7], [4, 6]], [[6, 0], [5, 1]], [[4, 6], [5, 5]], [[4, 4], [6, 6]], [[7, 7], [5, 5]], [[3, 1], [4, 2]], [[5, 5], [4, 4]], [[4, 2], [3, 3]], [[4, 4], [2, 2], [0, 0]], [[0, 4], [1, 5]], [[0, 6], [2, 4]], [[5, 1], [4, 2]], [[7, 1], [6, 0]], [[0, 2], [1, 3]], [[2, 4], [0, 2]], [[4, 2], [3, 3]], [[6, 0], [7, 1]], [[3, 3], [2, 4]], [[0, 2], [1, 1]], [[2, 4], [3, 5]], [[1, 1], [2, 0]], [[3, 5], [2, 6]], [[7, 1], [6, 2]], [[2, 6], [1, 7]], [[6, 2], [5, 3]], [[1, 7], [2, 6]], [[5, 3], [4, 2]], [[2, 6], [1, 5]], [[4, 2], [5, 3]], [[1, 5], [0, 4]], [[0, 0], [1, 1]], [[0, 4], [1, 5]], [[2, 0], [3, 1]], [[1, 5], [2, 6]], [[5, 3], [6, 4]], [[2, 6], [1, 5]], [[1, 1], [0, 2]], [[1, 5], [2, 4]], [[0, 2], [1, 1]], [[2, 4], [3, 3]], [[1, 1], [2, 2]], [[3, 3], [1, 1]], [[3, 1], [4, 2]], [[1, 1], [0, 2]], [[6, 4], [7, 3]], [[0, 2], [1, 3]], [[4, 2], [3, 3]], [[1, 3], [2, 2]], [[3, 3], [1, 1]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_7",
    "sat": "def sat(position: List[List[int]], transcript=[[[2, 2], [3, 3]], [[4, 6], [3, 5]], [[3, 3], [4, 4]], [[3, 5], [5, 3]], [[4, 2], [6, 4]], [[7, 5], [5, 3]], [[6, 2], [4, 4]], [[2, 6], [3, 5]], [[4, 4], [2, 6]], [[1, 7], [3, 5]], [[0, 4], [2, 6]], [[3, 7], [1, 5]], [[0, 2], [1, 3]], [[2, 4], [0, 2]], [[5, 1], [4, 2]], [[0, 2], [1, 1]], [[0, 0], [2, 2]], [[6, 6], [7, 5]], [[4, 0], [5, 1]], [[3, 5], [4, 4]], [[4, 2], [5, 3]], [[4, 4], [6, 2], [4, 0]], [[2, 0], [1, 1]], [[1, 5], [0, 4]], [[3, 1], [4, 2]], [[7, 7], [6, 6]], [[4, 2], [3, 3]], [[6, 6], [5, 5]], [[2, 2], [1, 3]], [[0, 4], [2, 2], [0, 0]], [[7, 1], [6, 2]], [[7, 3], [5, 1]], [[6, 0], [4, 2]], [[0, 6], [1, 5]], [[4, 2], [5, 3]], [[5, 5], [4, 4]], [[3, 3], [5, 5]], [[4, 0], [3, 1]], [[5, 3], [4, 4]], [[5, 7], [6, 6]], [[5, 5], [7, 7]], [[1, 5], [0, 4]], [[7, 7], [6, 6]], [[0, 0], [1, 1]], [[4, 4], [3, 5]], [[1, 1], [2, 2]], [[6, 6], [7, 7]], [[3, 1], [4, 0]], [[3, 5], [4, 6]], [[2, 2], [3, 3]], [[7, 7], [6, 6]], [[3, 3], [2, 2]], [[4, 6], [5, 7]], [[4, 0], [5, 1]], [[6, 6], [5, 5]], [[2, 2], [1, 1]], [[5, 5], [6, 4]], [[7, 5], [5, 3]], [[5, 7], [4, 6]], [[5, 1], [4, 0]], [[4, 6], [5, 7]], [[1, 1], [0, 2]], [[5, 7], [6, 6]], [[5, 3], [4, 2]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[2, 2], [3, 3]], [[4, 6], [3, 5]], [[3, 3], [4, 4]], [[3, 5], [5, 3]], [[4, 2], [6, 4]], [[7, 5], [5, 3]], [[6, 2], [4, 4]], [[2, 6], [3, 5]], [[4, 4], [2, 6]], [[1, 7], [3, 5]], [[0, 4], [2, 6]], [[3, 7], [1, 5]], [[0, 2], [1, 3]], [[2, 4], [0, 2]], [[5, 1], [4, 2]], [[0, 2], [1, 1]], [[0, 0], [2, 2]], [[6, 6], [7, 5]], [[4, 0], [5, 1]], [[3, 5], [4, 4]], [[4, 2], [5, 3]], [[4, 4], [6, 2], [4, 0]], [[2, 0], [1, 1]], [[1, 5], [0, 4]], [[3, 1], [4, 2]], [[7, 7], [6, 6]], [[4, 2], [3, 3]], [[6, 6], [5, 5]], [[2, 2], [1, 3]], [[0, 4], [2, 2], [0, 0]], [[7, 1], [6, 2]], [[7, 3], [5, 1]], [[6, 0], [4, 2]], [[0, 6], [1, 5]], [[4, 2], [5, 3]], [[5, 5], [4, 4]], [[3, 3], [5, 5]], [[4, 0], [3, 1]], [[5, 3], [4, 4]], [[5, 7], [6, 6]], [[5, 5], [7, 7]], [[1, 5], [0, 4]], [[7, 7], [6, 6]], [[0, 0], [1, 1]], [[4, 4], [3, 5]], [[1, 1], [2, 2]], [[6, 6], [7, 7]], [[3, 1], [4, 0]], [[3, 5], [4, 6]], [[2, 2], [3, 3]], [[7, 7], [6, 6]], [[3, 3], [2, 2]], [[4, 6], [5, 7]], [[4, 0], [5, 1]], [[6, 6], [5, 5]], [[2, 2], [1, 1]], [[5, 5], [6, 4]], [[7, 5], [5, 3]], [[5, 7], [4, 6]], [[5, 1], [4, 0]], [[4, 6], [5, 7]], [[1, 1], [0, 2]], [[5, 7], [6, 6]], [[5, 3], [4, 2]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_8",
    "sat": "def sat(position: List[List[int]], transcript=[[[0, 2], [1, 3]], [[1, 5], [0, 4]], [[1, 3], [2, 4]], [[3, 5], [1, 3]], [[6, 2], [5, 3]], [[4, 6], [3, 5]], [[1, 1], [0, 2]], [[7, 5], [6, 4]], [[5, 3], [7, 5]], [[5, 5], [6, 4]], [[0, 2], [2, 4], [4, 6]], [[5, 7], [3, 5]], [[7, 5], [5, 7]], [[6, 4], [7, 3]], [[2, 2], [1, 3]], [[0, 4], [2, 2]], [[3, 1], [1, 3]], [[2, 6], [1, 5]], [[0, 0], [1, 1]], [[1, 5], [2, 4]], [[5, 7], [4, 6]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[0, 2], [1, 3]], [[1, 5], [0, 4]], [[1, 3], [2, 4]], [[3, 5], [1, 3]], [[6, 2], [5, 3]], [[4, 6], [3, 5]], [[1, 1], [0, 2]], [[7, 5], [6, 4]], [[5, 3], [7, 5]], [[5, 5], [6, 4]], [[0, 2], [2, 4], [4, 6]], [[5, 7], [3, 5]], [[7, 5], [5, 7]], [[6, 4], [7, 3]], [[2, 2], [1, 3]], [[0, 4], [2, 2]], [[3, 1], [1, 3]], [[2, 6], [1, 5]], [[0, 0], [1, 1]], [[1, 5], [2, 4]], [[5, 7], [4, 6]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "CheckersPosition_9",
    "sat": "def sat(position: List[List[int]], transcript=[[[6, 0], [7, 1]], [[0, 6], [1, 5]], [[3, 7], [4, 6]], [[0, 0], [1, 1]], [[4, 6], [3, 7]], [[1, 5], [0, 6]], [[7, 1], [6, 0]], [[0, 6], [1, 5]], [[6, 0], [5, 1]], [[1, 5], [2, 6]], [[3, 7], [1, 5]], [[1, 1], [2, 0]], [[5, 1], [6, 2]], [[2, 0], [1, 1]], [[1, 5], [0, 4]], [[1, 1], [0, 0]], [[0, 4], [1, 3]], [[0, 0], [1, 1]], [[6, 2], [5, 1]], [[1, 1], [2, 0]], [[5, 1], [6, 2]], [[2, 0], [1, 1]], [[6, 2], [7, 3]], [[1, 1], [0, 2]], [[7, 3], [6, 4]], [[0, 2], [2, 4]], [[6, 4], [7, 5]], [[2, 4], [3, 5]], [[7, 5], [6, 6]], [[3, 5], [2, 6]], [[6, 6], [7, 7]], [[2, 6], [1, 5]], [[7, 7], [6, 6]], [[1, 5], [0, 4]], [[6, 6], [7, 7]], [[0, 4], [1, 3]], [[7, 7], [6, 6]], [[1, 3], [0, 4]], [[6, 6], [5, 7]], [[0, 4], [1, 3]], [[5, 7], [4, 6]], [[1, 3], [0, 4]], [[4, 6], [3, 7]], [[0, 4], [1, 3]], [[3, 7], [2, 6]], [[1, 3], [0, 2]], [[2, 6], [3, 7]], [[0, 2], [1, 1]], [[3, 7], [2, 6]], [[1, 1], [0, 2]], [[2, 6], [3, 7]], [[0, 2], [1, 1]], [[3, 7], [2, 6]], [[1, 1], [0, 2]], [[2, 6], [3, 5]], [[0, 2], [1, 3]], [[3, 5], [2, 6]], [[1, 3], [2, 4]], [[2, 6], [1, 5]], [[2, 4], [0, 6]]]):\n    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "sols": [
      "def sol(transcript=[[[6, 0], [7, 1]], [[0, 6], [1, 5]], [[3, 7], [4, 6]], [[0, 0], [1, 1]], [[4, 6], [3, 7]], [[1, 5], [0, 6]], [[7, 1], [6, 0]], [[0, 6], [1, 5]], [[6, 0], [5, 1]], [[1, 5], [2, 6]], [[3, 7], [1, 5]], [[1, 1], [2, 0]], [[5, 1], [6, 2]], [[2, 0], [1, 1]], [[1, 5], [0, 4]], [[1, 1], [0, 0]], [[0, 4], [1, 3]], [[0, 0], [1, 1]], [[6, 2], [5, 1]], [[1, 1], [2, 0]], [[5, 1], [6, 2]], [[2, 0], [1, 1]], [[6, 2], [7, 3]], [[1, 1], [0, 2]], [[7, 3], [6, 4]], [[0, 2], [2, 4]], [[6, 4], [7, 5]], [[2, 4], [3, 5]], [[7, 5], [6, 6]], [[3, 5], [2, 6]], [[6, 6], [7, 7]], [[2, 6], [1, 5]], [[7, 7], [6, 6]], [[1, 5], [0, 4]], [[6, 6], [7, 7]], [[0, 4], [1, 3]], [[7, 7], [6, 6]], [[1, 3], [0, 4]], [[6, 6], [5, 7]], [[0, 4], [1, 3]], [[5, 7], [4, 6]], [[1, 3], [0, 4]], [[4, 6], [3, 7]], [[0, 4], [1, 3]], [[3, 7], [2, 6]], [[1, 3], [0, 2]], [[2, 6], [3, 7]], [[0, 2], [1, 1]], [[3, 7], [2, 6]], [[1, 1], [0, 2]], [[2, 6], [3, 7]], [[0, 2], [1, 1]], [[3, 7], [2, 6]], [[1, 1], [0, 2]], [[2, 6], [3, 5]], [[0, 2], [1, 3]], [[3, 5], [2, 6]], [[1, 3], [2, 4]], [[2, 6], [1, 5]], [[2, 4], [0, 6]]]):\n    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_0",
    "sat": "def sat(cut_position: int, ring=\"yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM\", lower=5):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM\", lower=5):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_1",
    "sat": "def sat(cut_position: int, ring=\"BoKKRcRSKtCMCxIKSxkXtsRKcxoObmRiXcSIIRbmBbO\", lower=1):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"BoKKRcRSKtCMCxIKSxkXtsRKcxoObmRiXcSIIRbmBbO\", lower=1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_2",
    "sat": "def sat(cut_position: int, ring=\"iXmCWWwmitT\", lower=1):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"iXmCWWwmitT\", lower=1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_3",
    "sat": "def sat(cut_position: int, ring=\"tzTRy\", lower=1):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"tzTRy\", lower=1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_4",
    "sat": "def sat(cut_position: int, ring=\"M\", lower=0):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"M\", lower=0):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_5",
    "sat": "def sat(cut_position: int, ring=\"rtOwPrBXBtsLYjqsxcylTCRJWmyljXYccRqtmotbTTjJwvs\", lower=1):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"rtOwPrBXBtsLYjqsxcylTCRJWmyljXYccRqtmotbTTjJwvs\", lower=1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_6",
    "sat": "def sat(cut_position: int, ring=\"kngwNWKKkKwGsgFdsKg\", lower=1):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"kngwNWKKkKwGsgFdsKg\", lower=1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_7",
    "sat": "def sat(cut_position: int, ring=\"Ifdj\", lower=0):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"Ifdj\", lower=0):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_8",
    "sat": "def sat(cut_position: int, ring=\"StZNnSwtTnSZW\", lower=1):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"StZNnSwtTnSZW\", lower=1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "MatchingMarkers_9",
    "sat": "def sat(cut_position: int, ring=\"bh\", lower=0):\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "sols": [
      "def sol(ring=\"bh\", lower=0):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC"
  },
  {
    "name": "ExponentialCoinMoves_0",
    "sat": "def sat(states: List[List[int]], n=16385):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=16385):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_1",
    "sat": "def sat(states: List[List[int]], n=1):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=1):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_2",
    "sat": "def sat(states: List[List[int]], n=2):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=2):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_3",
    "sat": "def sat(states: List[List[int]], n=4):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=4):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_4",
    "sat": "def sat(states: List[List[int]], n=8):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=8):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_5",
    "sat": "def sat(states: List[List[int]], n=16):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=16):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_6",
    "sat": "def sat(states: List[List[int]], n=32):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=32):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_7",
    "sat": "def sat(states: List[List[int]], n=64):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=64):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_8",
    "sat": "def sat(states: List[List[int]], n=128):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=128):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "ExponentialCoinMoves_9",
    "sat": "def sat(states: List[List[int]], n=256):\n    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "sols": [
      "def sol(n=256):\n    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_0",
    "sat": "def sat(nums: List[int], b=6, m=2):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [
      "def sol(b=6, m=2):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_1",
    "sat": "def sat(nums: List[int], b=14, m=99):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_2",
    "sat": "def sat(nums: List[int], b=11, m=59):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_3",
    "sat": "def sat(nums: List[int], b=11, m=75):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_4",
    "sat": "def sat(nums: List[int], b=12, m=75):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_5",
    "sat": "def sat(nums: List[int], b=18, m=55):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_6",
    "sat": "def sat(nums: List[int], b=6, m=66):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [
      "def sol(b=6, m=66):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_7",
    "sat": "def sat(nums: List[int], b=9, m=44):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [
      "def sol(b=9, m=44):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_8",
    "sat": "def sat(nums: List[int], b=15, m=2):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "NoRelativePrimes_9",
    "sat": "def sat(nums: List[int], b=11, m=57):\n    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "sols": [],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_0",
    "sat": "def sat(indices: List[int], a0=123):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=123):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_1",
    "sat": "def sat(indices: List[int], a0=1330788):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=1330788):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_2",
    "sat": "def sat(indices: List[int], a0=514098):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=514098):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_3",
    "sat": "def sat(indices: List[int], a0=2259306):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=2259306):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_4",
    "sat": "def sat(indices: List[int], a0=904371):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=904371):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_5",
    "sat": "def sat(indices: List[int], a0=800352):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=800352):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_6",
    "sat": "def sat(indices: List[int], a0=2260581):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=2260581):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_7",
    "sat": "def sat(indices: List[int], a0=1310709):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=1310709):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_8",
    "sat": "def sat(indices: List[int], a0=1774233):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=1774233):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindRepeats_9",
    "sat": "def sat(indices: List[int], a0=1866333):\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "sols": [
      "def sol(a0=1866333):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_0",
    "sat": "def sat(keep: List[bool], heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_1",
    "sat": "def sat(keep: List[bool], heights=[19, 6, 1, 5, 10, 9, 0, 11, 16, 3, 8, 15, 17, 13, 14, 12, 2, 7, 4, 18]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[19, 6, 1, 5, 10, 9, 0, 11, 16, 3, 8, 15, 17, 13, 14, 12, 2, 7, 4, 18]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_2",
    "sat": "def sat(keep: List[bool], heights=[0, 3, 11, 4, 7, 9, 2, 8, 1, 6, 10, 5]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[0, 3, 11, 4, 7, 9, 2, 8, 1, 6, 10, 5]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_3",
    "sat": "def sat(keep: List[bool], heights=[33, 4, 19, 45, 15, 48, 41, 5, 32, 18, 51, 28, 52, 14, 20, 1, 26, 40, 47, 16, 27, 21, 36, 29, 12, 46, 10, 17, 55, 3, 35, 6, 30, 37, 54, 49, 44, 53, 38, 13, 0, 22, 24, 8, 11, 31, 25, 23, 50, 39, 7, 2, 43, 9, 34, 42]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[33, 4, 19, 45, 15, 48, 41, 5, 32, 18, 51, 28, 52, 14, 20, 1, 26, 40, 47, 16, 27, 21, 36, 29, 12, 46, 10, 17, 55, 3, 35, 6, 30, 37, 54, 49, 44, 53, 38, 13, 0, 22, 24, 8, 11, 31, 25, 23, 50, 39, 7, 2, 43, 9, 34, 42]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_4",
    "sat": "def sat(keep: List[bool], heights=[20, 33, 10, 39, 38, 15, 24, 4, 17, 6, 37, 2, 31, 35, 8, 14, 41, 34, 29, 12, 27, 3, 28, 21, 13, 7, 9, 0, 32, 18, 16, 5, 1, 19, 23, 25, 26, 11, 40, 36, 30, 22]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[20, 33, 10, 39, 38, 15, 24, 4, 17, 6, 37, 2, 31, 35, 8, 14, 41, 34, 29, 12, 27, 3, 28, 21, 13, 7, 9, 0, 32, 18, 16, 5, 1, 19, 23, 25, 26, 11, 40, 36, 30, 22]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_5",
    "sat": "def sat(keep: List[bool], heights=[0, 1]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[0, 1]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_6",
    "sat": "def sat(keep: List[bool], heights=[33, 9, 11, 16, 12, 19, 22, 17, 34, 41, 40, 10, 32, 14, 30, 29, 37, 35, 18, 3, 7, 5, 13, 24, 38, 0, 36, 1, 25, 20, 6, 2, 27, 23, 31, 4, 26, 21, 39, 15, 28, 8]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[33, 9, 11, 16, 12, 19, 22, 17, 34, 41, 40, 10, 32, 14, 30, 29, 37, 35, 18, 3, 7, 5, 13, 24, 38, 0, 36, 1, 25, 20, 6, 2, 27, 23, 31, 4, 26, 21, 39, 15, 28, 8]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_7",
    "sat": "def sat(keep: List[bool], heights=[13, 48, 11, 34, 15, 12, 14, 52, 1, 16, 21, 31, 41, 2, 50, 47, 5, 46, 18, 45, 38, 54, 55, 51, 26, 8, 19, 39, 0, 24, 42, 40, 10, 44, 43, 3, 7, 25, 33, 9, 22, 23, 53, 4, 36, 32, 29, 35, 20, 37, 27, 6, 30, 49, 17, 28]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[13, 48, 11, 34, 15, 12, 14, 52, 1, 16, 21, 31, 41, 2, 50, 47, 5, 46, 18, 45, 38, 54, 55, 51, 26, 8, 19, 39, 0, 24, 42, 40, 10, 44, 43, 3, 7, 25, 33, 9, 22, 23, 53, 4, 36, 32, 29, 35, 20, 37, 27, 6, 30, 49, 17, 28]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_8",
    "sat": "def sat(keep: List[bool], heights=[31, 60, 17, 37, 55, 68, 45, 61, 42, 38, 25, 65, 3, 58, 9, 70, 29, 53, 30, 8, 0, 36, 41, 20, 18, 39, 21, 59, 71, 7, 64, 22, 48, 67, 35, 5, 2, 56, 54, 6, 43, 28, 69, 19, 49, 13, 50, 27, 62, 4, 14, 26, 1, 11, 34, 32, 51, 63, 52, 47, 24, 33, 23, 46, 16, 66, 57, 10, 40, 44, 15, 12]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[31, 60, 17, 37, 55, 68, 45, 61, 42, 38, 25, 65, 3, 58, 9, 70, 29, 53, 30, 8, 0, 36, 41, 20, 18, 39, 21, 59, 71, 7, 64, 22, 48, 67, 35, 5, 2, 56, 54, 6, 43, 28, 69, 19, 49, 13, 50, 27, 62, 4, 14, 26, 1, 11, 34, 32, 51, 63, 52, 47, 24, 33, 23, 46, 16, 66, 57, 10, 40, 44, 15, 12]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "PickNearNeighbors_9",
    "sat": "def sat(keep: List[bool], heights=[10, 2, 12, 19, 15, 9, 1, 8, 4, 14, 11, 5, 0, 7, 13, 18, 6, 3, 16, 17]):\n    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "sols": [
      "def sol(heights=[10, 2, 12, 19, 15, 9, 1, 8, 4, 14, 11, 5, 0, 7, 13, 18, 6, 3, 16, 17]): # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_0",
    "sat": "def sat(li: List[int], n=18):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=18):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_1",
    "sat": "def sat(li: List[int], n=3):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=3):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_2",
    "sat": "def sat(li: List[int], n=6):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=6):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_3",
    "sat": "def sat(li: List[int], n=9):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=9):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_4",
    "sat": "def sat(li: List[int], n=12):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=12):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_5",
    "sat": "def sat(li: List[int], n=15):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=15):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_6",
    "sat": "def sat(li: List[int], n=21):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=21):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_7",
    "sat": "def sat(li: List[int], n=24):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=24):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_8",
    "sat": "def sat(li: List[int], n=27):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=27):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "FindProductiveList_9",
    "sat": "def sat(li: List[int], n=30):\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "sols": [
      "def sol(n=30):\n    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_0",
    "sat": "def sat(li: List[int], n=3, tags=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=3, tags=[0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_1",
    "sat": "def sat(li: List[int], n=1, tags=[0, 0, 0, 0]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=1, tags=[0, 0, 0, 0]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_2",
    "sat": "def sat(li: List[int], n=2, tags=[1, 0, 0, 1, 0, 0, 1, 1]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=2, tags=[1, 0, 0, 1, 0, 0, 1, 1]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_3",
    "sat": "def sat(li: List[int], n=9, tags=[6, 2, 7, 5, 0, 4, 1, 8, 0, 0, 4, 2, 4, 7, 8, 8, 1, 3, 1, 6, 6, 2, 1, 3, 8, 3, 2, 4, 0, 7, 5, 5, 7, 6, 5, 3]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=9, tags=[6, 2, 7, 5, 0, 4, 1, 8, 0, 0, 4, 2, 4, 7, 8, 8, 1, 3, 1, 6, 6, 2, 1, 3, 8, 3, 2, 4, 0, 7, 5, 5, 7, 6, 5, 3]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_4",
    "sat": "def sat(li: List[int], n=6, tags=[3, 4, 5, 2, 0, 3, 0, 5, 3, 0, 4, 2, 0, 4, 1, 5, 3, 4, 1, 1, 5, 1, 2, 2]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=6, tags=[3, 4, 5, 2, 0, 3, 0, 5, 3, 0, 4, 2, 0, 4, 1, 5, 3, 4, 1, 1, 5, 1, 2, 2]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_5",
    "sat": "def sat(li: List[int], n=6, tags=[0, 3, 4, 0, 5, 5, 5, 3, 2, 4, 3, 1, 5, 2, 2, 4, 0, 2, 1, 0, 1, 1, 4, 3]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=6, tags=[0, 3, 4, 0, 5, 5, 5, 3, 2, 4, 3, 1, 5, 2, 2, 4, 0, 2, 1, 0, 1, 1, 4, 3]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_6",
    "sat": "def sat(li: List[int], n=5, tags=[2, 2, 0, 4, 3, 3, 4, 4, 1, 2, 3, 4, 3, 1, 0, 0, 0, 2, 1, 1]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=5, tags=[2, 2, 0, 4, 3, 3, 4, 4, 1, 2, 3, 4, 3, 1, 0, 0, 0, 2, 1, 1]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_7",
    "sat": "def sat(li: List[int], n=8, tags=[0, 7, 7, 4, 1, 4, 3, 5, 2, 1, 7, 1, 6, 4, 6, 7, 1, 5, 4, 0, 6, 3, 0, 2, 5, 2, 0, 5, 6, 3, 3, 2]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=8, tags=[0, 7, 7, 4, 1, 4, 3, 5, 2, 1, 7, 1, 6, 4, 6, 7, 1, 5, 4, 0, 6, 3, 0, 2, 5, 2, 0, 5, 6, 3, 3, 2]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_8",
    "sat": "def sat(li: List[int], n=8, tags=[5, 4, 6, 1, 1, 4, 3, 3, 7, 1, 7, 5, 4, 5, 6, 6, 7, 3, 3, 2, 0, 5, 0, 2, 4, 6, 0, 0, 1, 2, 7, 2]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=8, tags=[5, 4, 6, 1, 1, 4, 3, 3, 7, 1, 7, 5, 4, 5, 6, 6, 7, 3, 3, 2, 0, 5, 0, 2, 4, 6, 0, 0, 1, 2, 7, 2]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "HalfTag_9",
    "sat": "def sat(li: List[int], n=6, tags=[2, 0, 0, 1, 4, 4, 5, 2, 2, 2, 3, 3, 3, 0, 5, 5, 4, 5, 3, 4, 0, 1, 1, 1]):\n    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "sols": [
      "def sol(n=6, tags=[2, 0, 0, 1, 4, 4, 5, 2, 2, 2, 3, 3, 3, 0, 5, 5, 4, 5, 3, 4, 0, 1, 1, 1]):\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO"
  },
  {
    "name": "LearnParity_0",
    "sat": "def sat(inds: List[int], vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_1",
    "sat": "def sat(inds: List[int], vecs=[2, 4, 7, 4, 7, 2, 1, 4]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[2, 4, 7, 4, 7, 2, 1, 4]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_2",
    "sat": "def sat(inds: List[int], vecs=[3, 3, 1, 3, 1]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[3, 3, 1, 3, 1]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_3",
    "sat": "def sat(inds: List[int], vecs=[395, 133, 456, 415, 419, 15, 104, 9, 326, 94, 208, 482, 460, 21, 488, 358, 443, 374, 187, 183, 82, 187, 232, 322, 281, 405, 238, 141, 425, 305, 37, 189, 413, 366, 33, 68, 145, 330, 149, 391, 254]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[395, 133, 456, 415, 419, 15, 104, 9, 326, 94, 208, 482, 460, 21, 488, 358, 443, 374, 187, 183, 82, 187, 232, 322, 281, 405, 238, 141, 425, 305, 37, 189, 413, 366, 33, 68, 145, 330, 149, 391, 254]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_4",
    "sat": "def sat(inds: List[int], vecs=[3, 2, 3]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[3, 2, 3]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_5",
    "sat": "def sat(inds: List[int], vecs=[8, 3, 23, 1, 13, 30, 27]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[8, 3, 23, 1, 13, 30, 27]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_6",
    "sat": "def sat(inds: List[int], vecs=[8, 51, 40, 10, 5, 50, 39, 7]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[8, 51, 40, 10, 5, 50, 39, 7]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_7",
    "sat": "def sat(inds: List[int], vecs=[44405891551213740936351, 16963445045128188673478, 192362914882855486523808, 248257659418289707995283, 140827403611110097438621, 51426254616580808756911, 108918420691370245025039, 160974162046370590442057, 2099781081069086844131, 273772731653468291433627, 86461722651525024906933, 298652019072988786753467, 180061710512175392939095, 30168642400468060080700, 193739233920133243612777, 46000897317295766736486, 232208703050797213846436, 142517704532123130818883, 278207191869355441137554, 18338854552382045899672, 117528844163100720415411, 96329378367958762949681, 226234067592007970890244, 154746862623486184395913, 50373421161594724981903, 299058807878264857923668, 205400807731601740103843, 239143125680490553846338, 92773159366213986584534, 139755776146517978224231, 87048213295035813839335, 138460255579189000691300, 208911402021963132605933, 202436659981238642045534, 259531174112081738463555, 26738662197858246203976, 161812467578933460068773, 174164736209601038504310, 62594440579181771726769, 174323946280126567339651, 206720085106973956637855, 259572186008510841547920, 141747959628307700529371, 192076483872643841791839, 61301823684491348034896, 132061411394032723457471, 276681550238351290988435, 116330848673182482395833, 234446125118258157632322, 83790963328724334628185, 95038439124860860209260, 176359994410162652429897, 278987873096558826506456, 170263295013584426936090, 175685143482185840248812, 25429386478469132238060, 149630502294781778022956, 75321711516617941278773, 5430746315842367421454, 223546286945002114096350, 191138743922283402111023, 88247876516898268123812, 56518698839741940162981, 172798289837060009397298, 130612710294568347811262, 2708004515258309966365, 222837602961364600906335, 153566656637165740869248, 290143749030031918995405, 231137309829036868729396, 207949573739101097551917, 41649463709490006455738, 167289023243730591035787, 56344830938281953176867, 17946803959493224986477, 292594412092989524931865, 93317128440631058843707, 10046538177069620241100, 37346063184387084032570, 140683485876790681543130, 118658938638248306125961, 145421179991479804812281, 201045720335062631230751, 64457740217465135337062, 118776142305086682165001, 114055384563084265908940, 79891066341071849682484, 281735801606739233532227, 238073138144173994277584, 90802161516918073069844, 126920059427757318839035, 18835084845282212760992, 133640576993262787918195, 141542402757759387322836, 73225398454728967041967, 168168689474966083481119, 136189367394413200095736, 169089568726192471365558, 66310968488092109442250, 220285118804459421466731, 216107206594491872287046, 24441626258489627188314, 45055594803173059406171, 33439119569155567932893, 207663738968141546362157, 90637194128807289805987, 301058480015096494587503, 8157717991884959030043, 169942245670642516161350, 192272736938122480975427, 17222373990828809108283, 166945499031511276551739, 96558211148985426585059, 22756610348132008786798, 37375934049596689130053, 168277933305762277469373, 190869489246753202812330, 48613308401858186944452, 19348942181330353183885, 61763718291573826011467, 290018495534341436180893, 21540644357434894730188, 109585801859688978853863, 223643997344461214481255, 53849386717144716022107, 264880124331226829956649, 260209307993160588459961, 59049933037899173712449, 170065565351049590396438, 10441219933478359654825, 242946177390181997331704, 6938078380545730849378, 52433825907023921956229, 76302876688091339281618, 105454382772139033659188, 90662460554459666869473, 49989161238073089746095, 226491341044237616904880, 26195259642219416111811, 22540669421992351336320, 41957429579653497006847, 84394859615567009775487, 248903862945392407986989, 50353424985865597019531, 92897826203197840513964, 89371522991999491032654, 104843117061236290111788, 175706760852459004699646, 235814582046715815056029, 92856997384076633583113, 162062604337284116608063, 264952362651485621033996, 117865638205793158811159, 222374566925353491056400, 267469972485586471434802, 242681266444601915645300, 107262203293816857978861, 219198940159234982907980, 47419994366491962737666, 167110326877008707421820, 103518303208919733592350, 267561234684358876244881, 160376908255332763233740, 214687340988717108659704, 12699404532156797519190, 129775158786106479343681, 167603541646373274326334, 177660830380872110190496, 209154036499925215280042, 108952827448488775485038, 167587429812386756864091, 185755729091971758507373, 179497043220973698647668, 217468054653200691254623, 2728573865051971899489, 67352427276612471120226, 82555205790658051048635, 279178952637042372847014, 277319555916812065945313, 253679418055361931483102, 19882340709312459253612, 193794893974520915134469, 199967430623349698391660, 80657859927108336457699, 300674727536070863440264, 255731433737682449686270, 261133293576523649547490, 69203251028330418605989, 101655519278167377930923, 39046276325651175444234, 114443974963906086814181, 212861820124001074424894, 163724719207087381310853, 154560481020606767158616, 244084453707547672649519, 108741640378187473214906, 188316082549953214419257, 224188384746337099324937, 125404685589890443492222, 208550195623414286723210, 42402768153369047581639, 142393263080524986548491, 24369397432606454708939, 242538246047383502079042, 295701606838662741620590, 142246250545987495105231, 4736946692841997661617, 167656915545394409746984, 142477734393846647718845, 165034498099213488805582, 264763328284878654898063, 210184233652720836452932, 98627969933495729123290, 35180482958689263075822, 154068801595186424294120, 72571996286971405351878, 231796734476498118647133, 13378836369290465851683, 159416096417370045418973, 295751706159196945769430, 179003634355046875553898, 156682437421818932337162, 147395961518812125838543, 135629640964203452277722, 6384146199689595407699, 170098243560349937283776, 150587290064285609684050, 280800265850794908781903, 219540611347898739654979, 228882180416086968169954, 208450888549878539680122, 113865372822805898352603, 184376215709920197233499, 58081249545875560630000, 295440075609600091485208, 134226636002745175790097, 258130793319447609266116, 85978480672254678423872, 253038959776780625426416, 191374805330190734421107, 172131331131889090586201, 186665469269600345332476, 177794517181006800580878, 13458711837406735329094, 67709337510067207169710, 239719028618579094384978, 289238506074911831966003, 42427470959683343276951, 98210902106204093924805, 75689533466532518409913, 267417483407189310950221, 49373691842728259742896, 25792835758214557810436, 261347217321820908768238, 128350935847018441682454, 113373884651790171897951, 58739067281224458298514, 156295754026109027446582, 160008538041675556591327, 557300170106054820985, 157835068344945837764675, 300379331713321094810272, 12738417104166982353000, 177495730035477145228407, 80445882200825387968299, 78587474684985380826648, 141913072587870318428611, 6436754385977634584236, 20579591364035261148478, 77661110724162796991528, 56598040030238847912039, 151457166621671072041309, 212574536763876203750989, 157759644100759211047089, 246825013481858456932626, 102089464534047406390961, 159844518079686345184780, 4368494957687505148308, 240607180846591765240436, 70630753516391797429750, 153327582171447390224225, 221671003562120783187085, 259068588333981719954952, 230731004615333530642386, 299721827291460771815586, 212783133287268515474457, 161005432223028106116736, 270247827930460716806123, 87999162667462374807133, 186008342479131234583183, 169748795464302212641759, 234781920243219145319197, 210312426261354038910142, 100492582835558237136969, 227829130085217778975868, 127568921405217789240777, 238869106416916808515193, 195044486154197399960090, 41172112530820026689567, 130181905413743288307531, 11840819465342680778893, 25794662305805810816060, 257857782794662028619163, 254615802905906775660761, 288984991563174677279281, 267364139712677678892335, 285427822644103712052208, 111833099677224982062676, 278212994959987832534346, 14189908757583030570760, 235625878900059640997214, 63849389906426671122176, 53246001348680435224369, 77127011593900898896789, 237631993745402286396542, 76900196605341606653972, 240848249149619770008733, 285689454914881978324767, 23312938278535881353994, 129722333050288962095018, 271583182253892703884978, 265259834403476515584679, 88214852344022870871405, 288205605328933343716400, 166269253821844600542458, 81817913229849044893922, 283236732222015571139390, 46629969527614587808537, 68761040517357522598603, 137011720262822356436522, 281138383820482838088200, 203401616736121266318748, 274606936212129778120738, 274224538452694079167837, 296224780410365528225934, 233861012103492556541960, 220052802678145783923389, 144559807256026600024729, 241981848907382825459155, 163275154710810353778173, 15988351293336666669140, 95536275487448736061989, 252689265286905435362056, 80742120077020466786134, 45698971751309045805772, 57263460479539954944251, 157343565344683380766092, 285219973352453690379024, 27603937048254604864612, 138860055154411820496796, 22330851209861081509027, 1553117071035772388190, 166023921248999495678734, 201111322362908727879344, 172338302541970241428585, 263372879548665574263765, 100647746887813967102966, 195739795187932074763506, 192673010628542257489668, 247935731561490543352168, 136248096130443200590107, 179383500163418439523200, 42828921946404737129622, 80177229463345635189652, 281378693889441217136720, 65675805909803358327559, 212266407134553894490040, 118779979851327572635295, 210367217854161267931522, 184223552735968682388833, 208212234016120467104450, 23214275345257556195487, 23174477807179858587515, 267348290192447363867539, 8562653687897433429467, 14580080794261283664039, 82043653536435374357118, 85717810528014527313008, 63951651385338181020604, 137351319571160337184633, 157222339221859732297606, 294885345098784342435410, 92339686096865844980021, 280435212261725617925592, 4700771777767625989321, 224626900200173330648823, 257869886435760330654380]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[44405891551213740936351, 16963445045128188673478, 192362914882855486523808, 248257659418289707995283, 140827403611110097438621, 51426254616580808756911, 108918420691370245025039, 160974162046370590442057, 2099781081069086844131, 273772731653468291433627, 86461722651525024906933, 298652019072988786753467, 180061710512175392939095, 30168642400468060080700, 193739233920133243612777, 46000897317295766736486, 232208703050797213846436, 142517704532123130818883, 278207191869355441137554, 18338854552382045899672, 117528844163100720415411, 96329378367958762949681, 226234067592007970890244, 154746862623486184395913, 50373421161594724981903, 299058807878264857923668, 205400807731601740103843, 239143125680490553846338, 92773159366213986584534, 139755776146517978224231, 87048213295035813839335, 138460255579189000691300, 208911402021963132605933, 202436659981238642045534, 259531174112081738463555, 26738662197858246203976, 161812467578933460068773, 174164736209601038504310, 62594440579181771726769, 174323946280126567339651, 206720085106973956637855, 259572186008510841547920, 141747959628307700529371, 192076483872643841791839, 61301823684491348034896, 132061411394032723457471, 276681550238351290988435, 116330848673182482395833, 234446125118258157632322, 83790963328724334628185, 95038439124860860209260, 176359994410162652429897, 278987873096558826506456, 170263295013584426936090, 175685143482185840248812, 25429386478469132238060, 149630502294781778022956, 75321711516617941278773, 5430746315842367421454, 223546286945002114096350, 191138743922283402111023, 88247876516898268123812, 56518698839741940162981, 172798289837060009397298, 130612710294568347811262, 2708004515258309966365, 222837602961364600906335, 153566656637165740869248, 290143749030031918995405, 231137309829036868729396, 207949573739101097551917, 41649463709490006455738, 167289023243730591035787, 56344830938281953176867, 17946803959493224986477, 292594412092989524931865, 93317128440631058843707, 10046538177069620241100, 37346063184387084032570, 140683485876790681543130, 118658938638248306125961, 145421179991479804812281, 201045720335062631230751, 64457740217465135337062, 118776142305086682165001, 114055384563084265908940, 79891066341071849682484, 281735801606739233532227, 238073138144173994277584, 90802161516918073069844, 126920059427757318839035, 18835084845282212760992, 133640576993262787918195, 141542402757759387322836, 73225398454728967041967, 168168689474966083481119, 136189367394413200095736, 169089568726192471365558, 66310968488092109442250, 220285118804459421466731, 216107206594491872287046, 24441626258489627188314, 45055594803173059406171, 33439119569155567932893, 207663738968141546362157, 90637194128807289805987, 301058480015096494587503, 8157717991884959030043, 169942245670642516161350, 192272736938122480975427, 17222373990828809108283, 166945499031511276551739, 96558211148985426585059, 22756610348132008786798, 37375934049596689130053, 168277933305762277469373, 190869489246753202812330, 48613308401858186944452, 19348942181330353183885, 61763718291573826011467, 290018495534341436180893, 21540644357434894730188, 109585801859688978853863, 223643997344461214481255, 53849386717144716022107, 264880124331226829956649, 260209307993160588459961, 59049933037899173712449, 170065565351049590396438, 10441219933478359654825, 242946177390181997331704, 6938078380545730849378, 52433825907023921956229, 76302876688091339281618, 105454382772139033659188, 90662460554459666869473, 49989161238073089746095, 226491341044237616904880, 26195259642219416111811, 22540669421992351336320, 41957429579653497006847, 84394859615567009775487, 248903862945392407986989, 50353424985865597019531, 92897826203197840513964, 89371522991999491032654, 104843117061236290111788, 175706760852459004699646, 235814582046715815056029, 92856997384076633583113, 162062604337284116608063, 264952362651485621033996, 117865638205793158811159, 222374566925353491056400, 267469972485586471434802, 242681266444601915645300, 107262203293816857978861, 219198940159234982907980, 47419994366491962737666, 167110326877008707421820, 103518303208919733592350, 267561234684358876244881, 160376908255332763233740, 214687340988717108659704, 12699404532156797519190, 129775158786106479343681, 167603541646373274326334, 177660830380872110190496, 209154036499925215280042, 108952827448488775485038, 167587429812386756864091, 185755729091971758507373, 179497043220973698647668, 217468054653200691254623, 2728573865051971899489, 67352427276612471120226, 82555205790658051048635, 279178952637042372847014, 277319555916812065945313, 253679418055361931483102, 19882340709312459253612, 193794893974520915134469, 199967430623349698391660, 80657859927108336457699, 300674727536070863440264, 255731433737682449686270, 261133293576523649547490, 69203251028330418605989, 101655519278167377930923, 39046276325651175444234, 114443974963906086814181, 212861820124001074424894, 163724719207087381310853, 154560481020606767158616, 244084453707547672649519, 108741640378187473214906, 188316082549953214419257, 224188384746337099324937, 125404685589890443492222, 208550195623414286723210, 42402768153369047581639, 142393263080524986548491, 24369397432606454708939, 242538246047383502079042, 295701606838662741620590, 142246250545987495105231, 4736946692841997661617, 167656915545394409746984, 142477734393846647718845, 165034498099213488805582, 264763328284878654898063, 210184233652720836452932, 98627969933495729123290, 35180482958689263075822, 154068801595186424294120, 72571996286971405351878, 231796734476498118647133, 13378836369290465851683, 159416096417370045418973, 295751706159196945769430, 179003634355046875553898, 156682437421818932337162, 147395961518812125838543, 135629640964203452277722, 6384146199689595407699, 170098243560349937283776, 150587290064285609684050, 280800265850794908781903, 219540611347898739654979, 228882180416086968169954, 208450888549878539680122, 113865372822805898352603, 184376215709920197233499, 58081249545875560630000, 295440075609600091485208, 134226636002745175790097, 258130793319447609266116, 85978480672254678423872, 253038959776780625426416, 191374805330190734421107, 172131331131889090586201, 186665469269600345332476, 177794517181006800580878, 13458711837406735329094, 67709337510067207169710, 239719028618579094384978, 289238506074911831966003, 42427470959683343276951, 98210902106204093924805, 75689533466532518409913, 267417483407189310950221, 49373691842728259742896, 25792835758214557810436, 261347217321820908768238, 128350935847018441682454, 113373884651790171897951, 58739067281224458298514, 156295754026109027446582, 160008538041675556591327, 557300170106054820985, 157835068344945837764675, 300379331713321094810272, 12738417104166982353000, 177495730035477145228407, 80445882200825387968299, 78587474684985380826648, 141913072587870318428611, 6436754385977634584236, 20579591364035261148478, 77661110724162796991528, 56598040030238847912039, 151457166621671072041309, 212574536763876203750989, 157759644100759211047089, 246825013481858456932626, 102089464534047406390961, 159844518079686345184780, 4368494957687505148308, 240607180846591765240436, 70630753516391797429750, 153327582171447390224225, 221671003562120783187085, 259068588333981719954952, 230731004615333530642386, 299721827291460771815586, 212783133287268515474457, 161005432223028106116736, 270247827930460716806123, 87999162667462374807133, 186008342479131234583183, 169748795464302212641759, 234781920243219145319197, 210312426261354038910142, 100492582835558237136969, 227829130085217778975868, 127568921405217789240777, 238869106416916808515193, 195044486154197399960090, 41172112530820026689567, 130181905413743288307531, 11840819465342680778893, 25794662305805810816060, 257857782794662028619163, 254615802905906775660761, 288984991563174677279281, 267364139712677678892335, 285427822644103712052208, 111833099677224982062676, 278212994959987832534346, 14189908757583030570760, 235625878900059640997214, 63849389906426671122176, 53246001348680435224369, 77127011593900898896789, 237631993745402286396542, 76900196605341606653972, 240848249149619770008733, 285689454914881978324767, 23312938278535881353994, 129722333050288962095018, 271583182253892703884978, 265259834403476515584679, 88214852344022870871405, 288205605328933343716400, 166269253821844600542458, 81817913229849044893922, 283236732222015571139390, 46629969527614587808537, 68761040517357522598603, 137011720262822356436522, 281138383820482838088200, 203401616736121266318748, 274606936212129778120738, 274224538452694079167837, 296224780410365528225934, 233861012103492556541960, 220052802678145783923389, 144559807256026600024729, 241981848907382825459155, 163275154710810353778173, 15988351293336666669140, 95536275487448736061989, 252689265286905435362056, 80742120077020466786134, 45698971751309045805772, 57263460479539954944251, 157343565344683380766092, 285219973352453690379024, 27603937048254604864612, 138860055154411820496796, 22330851209861081509027, 1553117071035772388190, 166023921248999495678734, 201111322362908727879344, 172338302541970241428585, 263372879548665574263765, 100647746887813967102966, 195739795187932074763506, 192673010628542257489668, 247935731561490543352168, 136248096130443200590107, 179383500163418439523200, 42828921946404737129622, 80177229463345635189652, 281378693889441217136720, 65675805909803358327559, 212266407134553894490040, 118779979851327572635295, 210367217854161267931522, 184223552735968682388833, 208212234016120467104450, 23214275345257556195487, 23174477807179858587515, 267348290192447363867539, 8562653687897433429467, 14580080794261283664039, 82043653536435374357118, 85717810528014527313008, 63951651385338181020604, 137351319571160337184633, 157222339221859732297606, 294885345098784342435410, 92339686096865844980021, 280435212261725617925592, 4700771777767625989321, 224626900200173330648823, 257869886435760330654380]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_8",
    "sat": "def sat(inds: List[int], vecs=[2, 1]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[2, 1]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParity_9",
    "sat": "def sat(inds: List[int], vecs=[15, 5, 11, 11, 11, 11, 1, 2, 8, 8, 2, 8, 6, 1, 8, 6, 1]):\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set $S$ of indices such that:\n    $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "sols": [
      "def sol(vecs=[15, 5, 11, 11, 11, 11, 1, 2, 8, 8, 2, 8, 6, 1, 8, 6, 1]):  # Gaussian elimination\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_0",
    "sat": "def sat(inds: List[int], vecs=[26, 5, 16, 3, 15, 18, 31, 13, 24, 25, 6, 5, 15, 24, 16, 13, 0, 27, 13]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [
      "def sol(vecs=[26, 5, 16, 3, 15, 18, 31, 13, 24, 25, 6, 5, 15, 24, 16, 13, 0, 27, 13]):  # brute force\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    while True:\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_1",
    "sat": "def sat(inds: List[int], vecs=[8, 5, 5, 8, 11, 6, 15, 11, 8, 11, 1, 12, 11, 1, 12, 15, 5, 11, 12, 11, 5]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [
      "def sol(vecs=[8, 5, 5, 8, 11, 6, 15, 11, 8, 11, 1, 12, 11, 1, 12, 15, 5, 11, 12, 11, 5]):  # brute force\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    while True:\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_2",
    "sat": "def sat(inds: List[int], vecs=[48883310367120098642, 151621873678343265618, 42308385516080474106, 174491590372776332820, 292538552135162364946, 61422928210710205827, 248876300929081508166, 82351218277587105453, 88528345811298840657, 223960937422236180584, 108642103136190079698, 169023923231936193463, 56501187422877749529, 230308141669053883819, 122529707180854892123, 158889604029824572235, 18250923255771665529, 136623127766924186116, 273550097092583203252, 192528198075084629072, 99171681018289203349, 46117830106929458816, 1718937309111118969, 45645233868436093944, 241677476997908624478, 254400644053664900153, 17240537040316511011, 244611949836475673857, 105708513004278633388, 273712257347025699327, 273379969902930285997, 57728385680277340774, 55394410535352397868, 155065536373612358171, 185580405039804416929, 26413751887953302651, 111186607673582976872, 119333049401758860983, 135606685889635643175, 130903520108694694620, 30719860240518512609, 264814747596592984968, 61636564520930974888, 195185303456569046912, 59375573860082387930, 19999931556354215763, 220764148213366222759, 31954260705774203560, 179323517021812248454, 112137357337102970134, 175160780362423616435, 115793240061200508926, 215569514216205598176, 62324365463896809079, 245156609326949413106, 131847705432889652370, 118991748344338034088, 170024160602311492811, 229336366552161568106, 48347749734203770361, 29011302500253617135, 104229895385815847481, 165611747154565518040, 40688408891493242847, 60785539870694961913, 187000270415677827447, 249440519758982077370, 2569546960828506788, 111822104782761941909, 26124315088975997431, 18229880861818601258, 280173876370967042686, 182189762136398660028, 289914041471511907119, 196996216202486446361, 111883679730249825531, 87408950462826446303, 271133071301318829986, 209140140719042654257, 69109334360268530002, 12626844169713903521, 241225696793294761035, 126239095693003849754, 8324820653899999724, 94647180029172889926, 154891729657422540948, 110345785416942163180, 2732868638504436888, 282778059598652665688, 152890582433922096833, 274845155552135609166, 106892472854108223926, 129411433552588404651, 71474049526414065949, 263034761013001415055, 235503556388327366263, 15004283814333100721, 199178557050007170957, 9793668190766914729, 43114959452970266121, 111388095042859035801, 84175995126850467443, 132321859075709044474, 226732200363583617835, 51732965233730370197, 162540931820189101019, 261409123793139875330, 145230740931530321512, 61921298170010371485, 182264771634428981563, 61718141718846047223, 238869349392628081624, 202102791378019241494, 17641778006039127942, 227787747081282627898, 219728838295947593584, 136459318238560677600, 203312942781757158034, 246922583185640857407, 212365698394713355249, 185110414291260378280, 240988287239122015205, 146788070145402418245, 90074901121521626964, 230822391125970207651, 267982725886549783456, 45655675662772211846, 147066138508582629759, 149956184245892086012, 91656839598002222555, 128674392040389675226, 97027686219704514790, 162861869521049503062, 128213232474040297595, 230010820024266969297, 169738832778048616392, 61781791524987266881, 34572281345810013099, 104367475583199197417, 9197863017976211289, 128815668955153949178, 7061822540449095032, 110132275989551264723, 173513152485879496747, 268002233282534959716, 81320456647556992012, 42333482800385420323, 39610077749673747512, 245592199078644998061, 74217448855113741394, 254585689306021977313, 269022731526725129447, 51618657842502714025, 136217922939637072784, 44585359410201808484, 19865729496619436684, 141673815463463046201, 17515158960294944097, 231528391035641878794, 193337459662039994762, 229745434395347817638, 22604743234559386281, 8369665855478672999, 269627224281158566031, 237295203237979848827, 286372537235322822128, 36748010037208506897, 162237954973995683734, 57878419886010691481, 187923981169711441427, 149225175653951088321, 77131862908897149294, 255374803725605125843, 144203373258026666169, 71774599061532953849, 73338886649451712243, 165168884736278043015, 294550744282906042516, 186055392073594680607, 270032336038761796016, 118898452727883005353, 165788629536269816592, 203177688798915791859, 36488469023634284837, 252866770787836615528, 27136804434744547028, 251938268135757783523, 286247638713209604012, 227642808637611447633, 107972376411355034956, 264064707401961514707, 22238481259626568036, 259681898294565781693, 116401600475434914571, 199469535943431638965, 69434574138551980616, 139957511875692314321, 76657072286057644400, 187577146337874557178, 255234265140046578330, 79931345077208122337, 237208495848913347125, 134980737089769295735, 63841222695301618876, 166121750770399344061, 128404439121206076428, 229688107716411727832, 147913993139764588756, 221308068443490169330, 107841642802792414063, 282139619579414664840, 283396784495788082782, 291232664135117509407, 212935506914358831887, 247038850096680364088, 84816924002949532741, 40376559443473150127, 129428067544853102675, 153352427247651448111, 286759488828065182665, 86887454160588197708, 64567595853502080542, 113831044496294614799, 156488309849615284486, 97650997837601135184, 109191790969744676276, 156500735873364034942, 187946645229624394878, 45539356813056649056, 168115572589632247094, 175394653824393035876, 72046813717943211806, 261364246612989727317, 139548365454544930160, 15139711202057478095, 88974277001098512507, 284661753304923049932, 55524845356670343692, 60465710886831892607, 5700334316457595929, 16008055426191438209, 103593266527217461368, 204443507608942098177, 162041695518890712456, 71580830346376289312, 285816658723003930422, 6494606881971460304, 51058294850986751956, 57187600795430545191, 47441725781632286714, 225656241382626073009, 285527063004551246875, 203630041707397106823, 21864723931089104071, 46976931324852484155, 153631130977378586117, 287714457645569306341, 205393140394019317238, 245516241297467510994, 278132491502524705400, 128181306086608440519, 254627887891188230398, 271825178564941233054, 64086864506405572454, 30492235676191568109, 50079403205159813475, 243710400800728729830, 90531158896965567248, 32350881834915579178, 53214661763468550927, 205586779808437833303, 290607728786529614929, 257741538744968812870, 117049245612495447702, 139767077866926908095, 130464607937348606252, 35443752154635565978, 27597487147274323466, 110588843215614093024, 255047312408775217342, 249314382809620362581, 6128429841285939102, 208482224553128266243, 69088974142499696234, 51626074837954414949, 145910108429146863199, 280521165780282839528, 46476717229748331774, 276912241206964500055, 203893796665034141354, 15591659902810332124, 126967544245081667344, 209715140362000196852, 285481931092051815864, 89993009084743042431, 21522286616939396772, 49597436895621879812, 186070360206559669148, 281021233453258848703, 193851170115137109700, 127347697339902499783, 174083594798710653396, 43989619515037261848, 19036989138749683669, 100409630814683870566, 216292753219480123800, 237800751111038692372, 7314676125586392546, 111255163317924123074, 68965924653413074608, 283543846131864661147, 272077356215115741362, 64577110912313046250, 79383860018070544738, 156567812816085480303, 37934106982891768503, 136581851691202503298, 208891929419226302216, 80503693211783609044, 147591841136409145089, 151667002102865502436, 188093445577737297503, 52782140936967102688, 209071031014612527527, 29576493695725832131, 147425858884268506855, 3256998631999970898, 122110742725964185324, 232693660186494472265, 289397570471003648780, 101462536203008251289, 97760763906192887216, 111597982531422658551, 37621422222498680632, 249515965983463401305, 143978227260342192223, 21097566502049338613, 226632408772887423414, 259329499238503205632, 18790237249858227470, 46777521098621146711, 232080109218409041197, 10076051026988365813, 75864728293385272076, 36223074010543487256, 218279675067370061062, 50638379416940936117, 20690795805427777410, 64922679001517940722, 140262495439455001576, 7045285684422841805, 224568379001702866991, 31796823543086472946, 190020333924360007449, 250019145209655760139, 248673279963355094632, 138912456995204433390, 99938368120906874188, 23556959494843589494, 265828658516816701071, 183878272169394112649, 100624431375429001659, 235661089688489942558, 221381729279748350451, 159030602758630921023, 80668293200268944724, 161723379713918670907, 19095219459145990352, 25778687642708542663, 276117532019472466773, 131175786907301373611, 213259586235577592406, 210742247807779351304, 131083298261565846704, 73990787839574803976, 234200414689716939380, 18178466048675483452, 10534597703270340020, 99906660296059041064, 22550318240510916039, 143339695208613195152, 175074181597776230281, 228165260204662034422, 503176525911023980, 280314810580237713881, 265090987459223437665, 51951751273044669947, 187014454032309447671, 160996218913095531255, 43822310611916608828, 283945447353214915935, 190657925195282121201, 214934501373640855231, 16906558725995801868, 109426368767011779969, 135232521142825611372, 57054366832134054044, 112928365537203227277, 51750790200329407997, 253165302777819389657, 10699640959459700457, 34374405205700554652, 14653669169550361250, 86178331755188231962, 284518083250897813154, 248886910848724618251, 34591703785999051833, 23311282188640816541, 102486169452114641257, 5560201960362810598, 34090964512392912795, 15125897533154817361, 269417025072666938816, 285079519012501215859, 95800596197079184660, 152798255534204473913, 285908215402380905079, 236684912662928802316, 169531543949523822703, 166490838803597801882, 170399181771008778351, 104194744063825932901, 149170909290233700487, 251051166995962335517, 133320530382705839286, 53919205880535240057, 249692335995691690627, 4885519689690975595, 88643009022052528777, 269509904294023759060, 255263465446140912953, 202189671083359155902, 154697693747668850941, 4356283927813754622, 172281463241632821400, 231314844279892027451, 38533224209920601357, 8417349319923552422, 213278795653799796119, 265868834803746203201, 102263861709470277305, 277137505796898630981, 210622688775676863129, 161881909155503885818, 121832828117081874214, 294309519673350827862, 256240729854223027619, 124072090367479006144, 125495416177439636642, 85984642722080884418, 92017604820798749680, 185637921438495663997, 19330706201535453430, 72202490987952244444, 191576035416032882073, 17173436979516807863, 90013834338368208547, 290473383158338989736, 104831699314139588096, 43784205045839242801, 217717325042968368598, 98349686199489381790, 9773713123106323260, 213609662587960640476, 266008320545907795487, 94788121646610497842, 178748017489769871558, 213033980229030716744, 5660150249146966112, 117119054102463333780, 233950665775262632996, 196506025581864035112, 138152173241996466490, 121451806035326899443, 233044894484869490880, 255990100918816672724, 245421252961843201674, 257955804019764749015, 166918144489878834635, 108184288730157016097, 116916198943165134375, 271856906595295101107, 222037992580921777918, 89525287013344472780, 2917433650229180402, 148808704614107213239, 124836613913072763325, 19664709212022805444, 164770526889244274986, 202382557300307608737, 226171899425984048319, 190180927734310600429, 11806821145039619328, 160426771560362779617, 283095400296533323129, 13732780064234936605, 246107021346292330025, 77147913848099213150, 21457197471736022487, 136513693460238227716, 95452761024744147468, 280857863493580906243, 109294144795588906803, 107544958908111372508, 113525020885122711821, 252006984447487510944, 194363886661861508315, 202640877940729862863, 239592368433796617996, 42866211267628614139, 46427313989391046323, 143142691427013846121, 13816334658147211224, 126045196100672590042, 79610592272942392231, 70144283775270289423, 283607002539636320163, 270922624285598137046, 20204652193496879065, 170301302439556222962, 109984377067681645725, 234576147561354106182, 16274318752366801629, 272399155093171614778, 285749096166966942863, 196802421613926178371, 65318466013678071137, 292103294608093135889, 281459435506016049922, 125258203358035398244, 32688125687373375141, 237157004366650518250, 32589280956618706914, 61604698254950011744, 109969137892371336340, 207477258481091914045, 154496952433068384519, 177865720470502019209, 253277291944360563869, 32438486540121872365, 128608601733977224301, 156247128611455822272, 252312520078105814662, 193580585577615913965, 189711672861019850983, 209776687708252219294, 290453778297849437179, 290703104290468449296, 202566230899081950851, 23423114159713166431, 134608179334286011368, 198119070236812221392, 98491056663265061670, 6514656992215254187, 86214581718070839234, 213870277590905353179, 155518881858787298495, 40191835083355663475, 40174874352277455487, 9943622949097966545]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_3",
    "sat": "def sat(inds: List[int], vecs=[2, 1, 1, 3, 1, 2, 2, 2, 0, 1, 2, 2, 1, 1]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [
      "def sol(vecs=[2, 1, 1, 3, 1, 2, 2, 2, 0, 1, 2, 2, 1, 1]):  # brute force\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    while True:\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_4",
    "sat": "def sat(inds: List[int], vecs=[112557378773695, 270866153890845, 259772777933997, 29664983916837, 133723573944846, 189405200109270, 119311752175167, 253148442899675, 182468976640897, 228289607853943, 62821766415122, 117551007338556, 111141728255234, 150403732655051, 117940260870027, 42016143615604, 226377969216086, 81934964486482, 63971670864788, 52322962081286, 155670375998103, 218739623802242, 117565936908576, 97362787514403, 80881199143059, 42853181440138, 153969448246372, 200025364713657, 280789587542115, 88942698334098, 10543893414582, 207990488538016, 129578274858411, 111254770973475, 70441125776358, 60328753683106, 260844230576925, 184238453453853, 30171707771778, 111357680999729, 273117153530448, 48728325308786, 152211639351933, 115594637747288, 196592622370612, 244747458485472, 77346714252305, 31233287609427, 71430731035577, 83394537854270, 235578236537087, 205977734052345, 269607862242148, 11317276683686, 124500934316705, 64934100346097, 62294569841381, 56597880931038, 107444872276613, 204377771561372, 217236938439109, 115045359370160, 106778271648439, 171104945490330, 71109231189743, 110192839337519, 45012290007111, 31010151487450, 9572964659861, 218114552428120, 206408425876023, 117252230853334, 223915476786639, 225378637948011, 91453698488312, 127144965770263, 62504082783310, 280566085961498, 241054713383888, 207768550695166, 11584161301542, 131894660721467, 54258317374630, 102170417140929, 191897972098570, 157940372059596, 179979860326165, 190112353872555, 146400204431372, 43415992492817, 201840766757575, 211359742114400, 274311253123659, 233960873326987, 186772284973638, 15437624246658, 240103490403823, 194144481932751, 33907702726316, 125036615439731, 87781308604273, 71814201183782, 211555304420518, 247307224143067, 55926221844692, 155310210923803, 184501883529802, 154212526226856, 106796845964396, 79299411234061, 53226118293042, 131239072004543, 170260950109404, 223107870878245, 110180061361201, 78700811094814, 163467765623168]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_5",
    "sat": "def sat(inds: List[int], vecs=[33, 27, 51, 34, 14, 10, 6, 60, 39, 24, 33, 33, 37, 5, 36, 12, 26, 63, 26, 50, 34, 31, 48, 37, 35, 48, 36, 57, 11, 52, 37, 14, 13, 9, 8, 27, 35]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [
      "def sol(vecs=[33, 27, 51, 34, 14, 10, 6, 60, 39, 24, 33, 33, 37, 5, 36, 12, 26, 63, 26, 50, 34, 31, 48, 37, 35, 48, 36, 57, 11, 52, 37, 14, 13, 9, 8, 27, 35]):  # brute force\n    d = 0 # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    while True:\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans"
    ],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_6",
    "sat": "def sat(inds: List[int], vecs=[139211427784908225293, 301508162070103547017, 1039263672050865493078, 782519721421015520965, 1151725596234347948461, 309426661683451493048, 943531969317179520380, 39650635037470010087, 481013829486194546287, 860201571853986274519, 1145101744276037688712, 978362517444788245165, 1159767002400870767232, 1045070561192774517845, 797710087119334294324, 271366268899490888049, 596685740788081942652, 145165859592696535721, 201183755876377484453, 945551634141543173322, 193651588397230120262, 1027230671584504425770, 606175633512033445725, 499493308618459489491, 1050462515964618539791, 1046798233400258254009, 842230269516390321706, 569049062409445764334, 678451735531047264535, 649376071239267044045, 1093698445263602113483, 672319423225890615964, 599259240436742575937, 198165474175942018898, 524281904125854374815, 693548431615635446535, 403415921673531358348, 1026759289724835537225, 557191565298581474258, 1159453532766075136353, 1066247199602251557102, 554817163454399739277, 833849217440753185245, 711043879850291789734, 916920612722870382738, 172425105783355840436, 15732735009270638273, 258275688719440718478, 382243032483130705946, 875834923489852443996, 660862574869037871212, 494438454674657701632, 580270668185063341233, 483381737235336685846, 1015230147098156295088, 813873287462118674274, 394787381647207190592, 564164614522497637730, 593407991593538639727, 123350664129678081589, 1114964288037723928167, 222049915651296731508, 379841661951729703592, 197737634386819051535, 384046244843442323207, 382767278460273782169, 496511471884642950386, 657383614785187715075, 795117451865674336568, 656399597888630775464, 7891180057511264787, 434393178326058919422, 1082645654198976215241, 748006068516902098494, 970142863159938642379, 1089552044152922408856, 705145932255423382645, 186149126306921096653, 599192735071252681917, 548876459029362207670, 1009719905352860906086, 782369104725763228709, 297967273206335151856, 151944761078495560362, 835830239157483367821, 210680993780367181562, 168027718191562205170, 595857688618099320332, 567735785036646842630, 953313006604151003077, 819335930143515255974, 188825134320344730573, 440939349998947868909, 226919153128229801096, 546213648836367025047, 739946216119225307720, 153928499394377759868, 976509099260279483185, 1084747744168096424865, 716581469041778508707, 576010086518608744133, 563513598413621132775, 203729115039564877559, 133538093726124210778, 989227244882565515413, 876973103916113552359, 557264809939637852605, 246692473480782101437, 984653716616668529610, 376167315795478774580, 184660322869385081813, 158514118846865075343, 438937203603941518138, 282308052765568766239, 1147590761216634031371, 874252216778193864963, 1057409200021815277831, 197698018241771936966, 242281838526288016232, 349857812646129351748, 270977706091792787045, 1172319502403005826161, 925778976546865808566, 645344740062560153568, 719602734081604085119, 632913028527410474429, 31360046526439679111, 495564787959298486931, 306864497082609681935, 138114603741309004168, 1153010356498136433751, 441750724360871431138, 181499885289597297066, 831477044668181087859, 211885640444386950118, 1170392579746497430149, 359314787666397840695, 390787567935926748823, 544629954592674977098, 155514318891372825387, 448390784915864598543, 363755570179602826075, 949316956150590261467, 915270312860481571997, 505776611435316961090, 309337757903592089754, 18599728401196074, 75685151425946709221, 283403041421022684284, 573640740533574431176, 460585616534601066227, 352337496371512657692, 978945535717645988226, 402701097187980396627, 549022889370228904340, 1040008203204565406893, 696070306185587180301, 76386058886821019857, 215616634961359449481, 81107393353569451902, 110894509447202043547, 517359077453305617615, 608030560129188665868, 404410288639477211237, 967364246391892927322, 293091377922609473239, 475566809157864512955, 230251439416683246109, 901729048759244122268, 497946749572954098707, 1124621114702837038122, 187146159808178180496, 470488802129860901908, 180420162130449526332, 711978601424861151515, 522837705906783346803, 1056289638784206478617, 106131931969394454903, 110248584376535588647, 541771209986894295228, 267609245281559041297, 411497494513354015961, 377979962031675489788, 197748619348150612847, 676759615317019587053, 212749247220097738344, 204432193390037354681, 475185743443474773041, 860725352857805383079, 549691050729467965761, 142158618236307626969, 658745983458861944205, 784524429883361711979, 782795784458406831070, 199490256355033818356, 27994370305853201822, 1115786430378109098460, 531447421989197432986, 1107958287243042808601, 454956667556037711758, 1076810406758701902590, 868808609743824782105, 794865875421630236565, 472650308618532473155, 227784466573926824521, 1032476964003263849004, 657494955170969818365, 651392495177352999715, 265535262815504721356, 812941862025362823377, 78205023650249380736, 672636089200470063325, 975112118923207347318, 405669580095878427954, 950807843989295034549, 395641180647502519047, 1027085066285618150452, 862322084005197523270, 485775340277625204489, 492203913195129120709, 497241219094838071474, 44855479955509456223, 256741273863273497030, 430876155593472598838, 689277110426864130643, 154664127238994219447, 650944214955214353338, 270052053245262423720, 6023443461613686884, 697375559266788648582, 601830618735147147504, 1027501108442430721240, 237983973262441226889, 320137646470636518910, 580514930760884732539, 855950282181826196866, 540300101727450231692, 911221017679419837681, 675576366205607538832, 438799448394321315233, 484367835342057503133, 986538841803435576893, 400033202601266829333, 495034496099596777597, 981412239244651215507, 481455570777420901163, 825654859240054702117, 118654476711019731146, 413665157185471854695, 1021165071392379901210, 702669165420349540753, 257074619145259709900, 383219911737942212532, 1067083672412616185863, 697971254926240746442, 1155005907509516176871, 1020946659880091654867, 558706837302888736049, 352332141083726599030, 1111133703754852853509, 723684808636426166663, 1058962870308866337296, 884941680925064249381, 399361959594467145489, 1138494150436099216873, 29006361147994629588, 1010424713069803186343, 778915193922861696579, 666446991698045230944, 523767190515848239420, 107198033009307235343, 299260144378946683178, 438457838288974238236, 541508687357752876536, 701378074036738469214, 953439422941429540079, 123882965228394885080, 84049123191808492128, 578957777372508493712, 125479240186031369046, 1100271944300177122981, 905617941155467454865, 450074018145436220753, 899859312222827761991, 563161382084814089147, 1039542444803977817817, 42311917457780102160, 713353200034190496231, 1052818722583282413941, 141743440967127834042, 49609083583058121005, 605271998398918903958, 852288163298337733952, 1148642406534698098633, 895419170830617810316, 1069347370032718376737, 734957082673453207033, 273472148535589333527, 44121480813553743477, 707113076039486274360, 827888800648411029234, 1003889024105597623114, 1159936242801456721429, 1100645608895722749850, 540825354915577780402, 562366852659192513719, 468706732093827959014, 580364042922822015572, 812670425482740201669, 735641239163538558364, 559477025988714136256, 361704003646534050359, 1150280156015079698854, 1086392633370067215523, 1103881270106827660767, 762023848727343835111, 937718308557488488598, 664802374033906677670, 829451138157734112719, 1107383997247123519194, 333415741593308218011, 826595880935658160148, 335591341884592235168, 316476165950371771796, 1113765988404449860530, 653001708696577925365, 930594317861352404600, 459216794308998313665, 159857396674208999307, 186464621889759924928, 42988761971917338843, 237827732113547284717, 1028948887580601741083, 693702051583922399086, 1107600655900644308431, 649771179335532407121, 725542358930767701259, 1048182555391239096554, 978356535751044404322, 761066527737031062621, 197283124463523185457, 817868186135860902702, 305733027481569220999, 176753607770550282181, 771135743384144298312, 1096919427523830076923, 665669610870879182393, 257928467689907351771, 1010046900025744265321, 1030636990795117352925, 247114038451864631364, 780316225672494280191, 928942421935219991372, 235411479252651956051, 879606231009086835376, 409676987377031488161, 1127933794999672912962, 231821467982037005852, 931045254887371251929, 1122770674604822137749, 892800443486460348669, 64667755327458732663, 642784933883163711283, 751651556770489159248, 808069135764996672548, 968474692684150323251, 508500800882523096007, 304818694844249279307, 603635242064980590412, 184510437814543135204, 137915784919635940194, 1107855418597324593887, 584245359884878461982, 916232548771951489321, 71825223409885326385, 320687560344875902954, 425351145816605085364, 566651970253646637070, 1036536645863808579123, 130739722801761551400, 696206225240353686002, 666847078067089384699, 869658562005120489930, 1082452614955474480117, 1109945167852810133882, 1000523938362153289417, 504256391102992009313, 1045701915454774991022, 28729095831724863293, 776492799208468543920, 491717657418640858943, 918166447218657292009, 437560831625269244074, 1043456756202666936197, 1130247960422354729313]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_7",
    "sat": "def sat(inds: List[int], vecs=[224484412876901052479391954840, 179085820409898667319444071014, 219517040227285841312443641754, 122138940917878985760307358002, 1240361234283063843659647925, 37365587030445949018803120865, 248828597635181421075760838482, 202012393908319708623393531746, 226721996418537675208341194544, 295091164042774548466713453025, 257870528376931853050557511259, 50508644330627532212302689696, 46304169740232556704581170108, 49844696663262771317521539964, 270810754208447092057383574542, 11223646801567311771035912808, 226244103906364785824508954981, 96678612234454000631346749292, 238241007824596846668745281552, 24106988571947139818132149447, 99598823538954646571723891315, 98150537516032189698133420190, 258676344119595823517967137973, 260704651544185929845220007949, 171719846816784681439434394018, 290239831738794597691378110624, 32670705953539007618585016334, 215664189020747022470318359929, 254394184355179403885787671748, 198149666937274016602459237494, 310808467590594926726067622112, 130234895225778728303451033561, 198635840178016472568868644469, 31316306349076464251517370418, 244291447467399897193590955672, 117484692320658591881948662303, 148043351210331670622180521456, 166479603070142185942075517028, 64561831263458834367986112295, 166218673438802092603289948331, 119593442499247573638440802647, 167164562427321795602443696188, 244451230594935684674573886654, 202265964051113993196100369605, 264838685893441258468414690487, 200859923144887532039867963349, 148136904899019472499348263259, 261796623787577486540604586527, 151865906915003648197872650984, 130615133743644692189803733321, 193739799611941487103987885966, 240012452174125261104375231863, 75956872600628326486924913841, 150909172477866518168028092813, 166043394314179349565658307174, 292241885134470140678692113803, 289230525633119411623511538925, 192357699448068276476810489730, 73478345531086880720059735027, 209645100058027798351827533777, 22043759637157644436884923206, 129894516614690270042895034052, 273252466057047791503917913179, 269383139956764888882907194795, 238128417525922682034039621856, 226780557569361280476222304650, 40103448563059458845872407717, 203674637683054019656749598189, 74420662933637746265695733524, 265008991033039547130765400443, 71308679200893250735826397484, 249315929167081191322920450813, 77291834092767653298351953134, 232307611368718689282272288172, 256986786785800331357943832030, 108776005417110367840337637919, 19083042795724839029031121002, 301077737975789032046752984197, 240178049336378390318596423263, 12012657045680551392068999295, 227044125054546392636533004010, 210519272676332773028621113904, 112081486845655230594251947304, 175149124976078152592103404038, 238182614861032429971749948863, 69656726568915399253053931747, 116121235207936431736670600352, 300141558258446468260314160673, 52867412028951600428281436227, 3795338173322222643863933668, 183345195735125167176140861460, 2668534424425271222394394309, 162930502828139376623808863311, 240539700108393610870487086377, 155846975950973196977615859985, 67043553472447671365267421021, 149641820640687938666470794951, 100431541107323880259042051948, 293614361448068220422068911713, 110309828162326917320583549612, 8273848307330575684806060332, 56745985260563755781258060693, 250662629703732089408331839207, 3575915678331819232988773518, 241389775739659698804563790993, 284392048496994001157304092810, 185459931976680844864538836406, 240324610728877385519526499731, 52947557425097682382732333631, 224115819963519576258150696273, 101179861702465712757726798658, 275083117531920743532008680923, 209298985587103302552308697958, 42218557730231534821402461375, 127956193181509121738674251122, 173740857184153978354221991252, 92642492485848703382936263234, 292907098139423616149572750234, 74750440670742508404106672696, 99937233563944412295983139254, 18903232079921303569548924635, 111959929956994646922094787448, 20759182924231574409693099443, 231124573504916988240452879148, 203873996967751876570258541864, 117187473711421263611574474882, 287958122239060359117805873084, 217481629394191837240219070621, 293581399869737769729028404852, 167200004062964342092168427237, 6940453661054289443342316980, 245084584806991833532653484508, 156042320953926184383715804606, 222599597803866327732231469618, 295262462610511987040987358959, 307593817236697430801281865352, 1993331437692677840865627569, 45773411529355757378508590105, 102577852044521045816287572420, 164846805160262596051875810632, 214407677873644631392351514509, 261534237608893629205628917616, 120125924522232578373904521468, 21336678648942617489255092636, 35909836639661426794956689138, 53349781434383367568125433604, 294278514646278107727448171272, 251180764302073728666442577533, 288727474297197895646043404680, 50485480560215007645020046050, 269452952583889649919904758045, 75180071939041299531537680863, 187416404035674772742002346277, 48767846495675110392761366121, 307962413573885747099135410405, 104468497555423024003964803425, 307202211328990099520725387163, 179991240144884779904830648479, 261651382530478962558238601031, 9891628558437894262272166344, 152776934262410526130984990011, 54557535988473476113593088636, 43653030365256279476230793791, 94032239798301829337191100627, 296771802014682299007892708175, 143749468980831326753589296396, 128175800271375430312576378663, 93331154052604339032123020992, 184658210133330437922804749541, 115866216348307466979734471754, 143644813577482077989752571231, 248117326989119177609249109454, 264783334090240309141945804023, 78369294004293639720942634777, 239983302278957948538217097714, 27752597175990302224639592450, 306903149469886970611097609161, 261947940652905804193016946181, 38432932548965465132398450067, 225210209814645826285708304094, 197340290066526836964761755544, 168386728751608341020581732507, 156769082697958612676875836302, 150929676071005118747608318799, 116207503809051943573452749392, 196557662822334722453867722929, 150172645195988529027732227606, 39051648521014635945977116916, 92653839850151119433065575742, 144044286596432923431611697563, 259904632682374455076373837019, 202914381225890505183159093154, 158210470073633709808622283582, 240985474604207267244832213326, 153857228261818546295807468676, 212105695898625803839437461359, 80134447728689642556670361623, 242265120379372306803240900788, 275848256706838135141264739391, 36447935866585287673470052698, 134399979604471073413150490060, 249226673946802564833437496165, 70944860622464092462178640480, 12203625063763904708414086968, 76794605129805946588021882603, 30045334322383803297472727158, 198716067902687506262113509025, 194779040699485187444123836070, 64670861965407305092097332764, 248550615451564299841638883605, 315430212906884174451420989367, 70464863710874158480115125431, 52456076134821491873753959662, 161497250940922641415168868314, 216360282986142166615866587874, 193855968679282577356079551873, 72078083378808454015426599623, 199292082320385133383295398129, 63019288678128596814922995587, 73651724284648370742419515703, 97527648175681711913230719078, 9999008806823556842419650589, 285122123857000870886212993663, 18347502544554028497740184225, 76051878185881395564965831445, 134258479262748306875454887735, 100438845918667689989922769112, 196272097547492798552229886979, 19499225120971659253308731185, 119519475267292659805956790186, 30794448788527466242177625940, 20566226076740103477582183240, 89976587968451641570423776710, 80353963716101723117772685424, 290519281465579314329982632018, 291111945325554732849661720344, 151114760597740613025210255281, 165828204405761889247166739939, 89571864997242416109998751946, 31074084427521860964229362486, 22729719717678133286946443946, 226189928088780970614769212151, 218898529937959204408447087791, 288195503732732216452203010589, 153497157273770095357179976574, 180222606313079143793545678786, 31435268843631317278028042939, 39986343619249955809552012678, 272307691218551739705933894942, 93623302137608119254700357139, 227711449755877300403996519534, 114347419131786759708186127779, 173685590314900028850548908187, 207463739390556928980545285258, 160547830668582844833663343508, 93751190244973915555338688818, 42711692423946627302330870040, 188904750652243120694103795763, 62778039277380989949664624625, 32505597338147553928687233642, 141586195947148575215934482803, 197759576446311546335350317559, 8770103650037258770149227447, 220672962297538808202248116712, 178597283865797138463272168742, 113721997656970391730600503823, 188623414336105185348347492017, 159998239933193281775033884724, 63125950174691472531196945304, 163374918093140722908871851215, 274413362451755382020116189106, 72179077742213122064657504031, 7216851748929193734257071414, 86522893191004002307128208342, 229290031734786039097879901443, 89789417324610520735540801249, 116873008486689271489563241248, 113944373666854769482272045966, 268640892178704555727089641836, 125333362125731383908083888161, 193761127696404434404767530516, 266954086178669545535988115379, 291356378672804867973543284124, 278152426315275206026801603157, 144487388031561847386623197915, 185294235320460967841256262519, 141278917460396379093296729223, 94781267297134060055777626629, 269922723523726216853067605166, 47634946709271247291637821392, 168220409347371414538065664824, 201165579045403778854614818585, 60305200202074575264576457297, 20120581191644439004759868677, 192822140456025648696382720613, 84734656253635942140886706344, 314078024393251953250518202561, 246044039952083857136764141900, 84689529883453152947421753145, 56459481127946429952031487383, 195233971723642944586178796274, 278951129323709819589037817296, 280123695794138396140017340510, 272951152841709517107869173623, 98027382961150929997365498635, 95938820845512520613445611890, 9960377547236192657867202218, 303846863119360005447681253837, 160722725372024794375423462326, 35508131992392098773394389520, 183520052819478536763023938689, 194894351480055249555884288869, 224417118314933251740091831563, 81787616856665493661326170859, 71224083103518866197910388220, 102556292059110491036734576105, 1288902543221861345309583985, 143753692163402904655816467666, 263329464021956827045622764443, 55602272045780281509300963741, 230806882465135116943069436280, 203219684085568112003025203462, 54120526534844280161294766200, 60472535280002184455292392044, 95464894358795113303975419555, 115539585195166792069658824032, 268216464371461739463256671240, 41165061912124706447851763460, 121790351561937906012037482964, 64372859742063248743617004664, 38481179363414287544353870538, 197256536058792988740736268995, 61269510189008702900955671301, 258923590121905306234636887843, 140164635184844270284341749599, 85190976375301571427053100952, 304471304465746469158543760382, 82750809946715602445201402502, 94408645267807196546632299472, 20486734504405377888569625383, 193199982572286217903539458613, 173818372443572071756538382261, 112689505183867805735104875585, 293538952685245069870535689142, 111122853267996015813867714511, 34360337786655503999113997750, 173100295813593313809027906321, 146242158105946126207157484058, 51714284972004951918286109332, 225062026658300072535772833045, 253601657593079387316277624326, 56972700628172275297865120825, 89024693080148265555980261523, 150751930260676651938850957907, 223049866591715660455772111261, 160355672259252501468207922303, 47299470787820697320607473153, 310373508761839291006736036087, 34932161782538786243384126237, 101648381895513849383484651698, 67024907783843683617307800732, 122739217844073857680017546396, 310939154943521331954552961786, 26555478883526176708966141890, 55315421155562815296828475334, 261882330085151209065472287525, 87557304954024858387649363718, 52746382465825957591232969130, 155730313455102088751316710427, 45838714662825060551282089514, 111391008855741174037070635271, 97962725452644551977376348040, 220826430724806356431219511578, 198162963545100843958582824223, 129583202714780001008436286605, 274449658584080803592036654484, 56647270613463685767171832771, 172376691714007442585280806064, 224514259013675915096597776373, 82018842169409197094796142478, 63900949906088501904639106939, 22055643997171321416866972503, 259981379168210805624469596970, 304649631455610181002922849655, 257790677700045772361317812097, 181215637713492729645266388470, 46262371938390353103995064295, 137865428164211480642532068615, 190905633891157115268147893321, 312435280814099776485846106386, 190096684439235827448590214566, 220303582781478664485535856686, 277384832636577945474315918848, 233377941477906329401068798246, 301837913847514539807046757114, 165649739604040809945437870376, 90285264201916547076968598503, 143743982174039641844103533267, 206376684109013746979979021446, 233725524788588470434298142188, 295119375585689713789825092488, 259272931387186541792460209522, 243980827724438580539427185739, 189657721757524077848490290663, 188809408580558060711523334473, 28641984120111057144543206883, 254890286389719220858608567792, 315134165086022640356181541173, 179566396874467718098552157209, 161415307191212820407085940567, 104423284660708498066714001689, 98677110929289595982578270770, 163391137763532254397745134688, 255863203826459362095499938184, 174956350900270861735621236344, 127582694478968412388802907326, 134170240772840935356778786113, 251773274521299804909042117263, 5640901410046196455536790634, 157033891260841919968614448412, 174606393074874430443942329426, 239376162824539010729966251108, 39900393582187074514480568855, 302822898300569443788198147655, 296420284538752192391326037961, 207230135237035198312067069356, 99620972127256933225574625613, 210338521582700764815879576024, 51782227096811747824485993951, 145691866226671633609987955845, 99487291147390621528546312787, 285861464281789260140252120369, 123405416862579231304552111714, 70683520934208910290433162422, 24152349736200896517559573846, 191343492327217228841221134002, 56984708849489254356702163371, 299073706662344262326753180555, 156318855101862179086282465917, 219902571585865397154184562135, 173671856185170511412273698214, 52350342247917025086199224500, 213699101920240024906266026576, 113777249781641970328863409925, 272292002563145704081541741266, 157575270479354743960280331858, 198490399413987647854176713159, 202756399921638545583677512828, 114944002055345393589911335901, 245134155115617185367393606024, 166581732492788784490189867263, 8751720907006510740247546539, 116534977425296540784564733746, 250898427447091485233588984534, 38681927295721057546989651888, 76980108610659692154033967311, 281735632989666489704281456968, 226265105326869771892763159913, 15085450045815896599508389650, 125972756126112606030439807127, 107803833375648676114926397148, 87309030408950686962779845979, 212644897116227079730561280136, 114923019995920857097914357434, 120896120680869037112114377322, 283071267176053034725088490216, 184676238516847364357791541464, 11692273219104443146432702499, 137688131586767550548491373085, 189829091327996758787736168260, 286003492183335162082277834374, 118313504359454225886645592270, 76664434447944532744497817611, 81672611605582079355098262509, 196330469428490787851927802190, 44488004955098053996668201679, 195356448365184328819520192575, 276081095005839092368742638747, 301008872651600243699756243225, 204434519695769904983458085378]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_8",
    "sat": "def sat(inds: List[int], vecs=[598566312247922499287713, 1090782178876385268504307, 1581507182233828931269092, 554780352441680630122104, 333074301466940403535534, 1626645880600826479576078, 2361277904440203511759688, 1757201304698784646134666, 1637416350891176501796801, 2154976222184922222465620, 123541723418687725335393, 1978981852232420293307415, 1425185058767802035159783, 2068521602085868679544717, 2238171904468320954787621, 2140146527156197310609927, 750189596881274234776804, 1065798663343102712638319, 768244409980910537976171, 1773334236466632618024781, 1986221702112653152622781, 1701394627117357588135919, 2179130635069910352238148, 1741827024284754832816371, 259587842768959646389749, 1183547012912285014291137, 2250848214525997126757424, 1517795457185501259489387, 1045954914426612945283778, 1192872334179810155764461, 367184999613965815310384, 1373102860768036565261266, 456554316417562529964614, 1296615250361556367508469, 2410817996053361085675332, 1873398973541349237214707, 1446451751826590555267475, 938862255411994730058022, 1614118408247747033301913, 2351161574383493302506533, 1380545004133821575124195, 1137173774008051001284330, 297928956092604325351378, 1982436280103274828694332, 241797568322644599540568, 732381811480814606729292, 923882629266809458318805, 552565512943433712250984, 1088880460016959850798611, 2274059428337417807241019, 489298647623369914407864, 2049577855520800321182632, 280199125760206106361298, 1002065419549390246850037, 1010954072377148025687910, 627196044464023882735804, 218273990676579048142892, 2209112500482320186086719, 280692489482298411632367, 1713880655231556122201267, 28120455718535903717356, 617799339241966940330705, 1131073324850011108521781, 1360892961866233727592395, 975729079706484954211450, 1058029396802804635401007, 793602166649170063945048, 837546722109318771162646, 1379471992793601729483189, 1575677444365790776103609, 1477828625751249851838007, 1580989997615967912138623, 2368126250228310172629239, 2202151742830541072880119, 849686368232257186758768, 2122253724810853581438107, 926900316166130100008933, 1776211902061425591611409, 328928979519409740657328, 247300180411738780635008, 628680602587824301958117, 1084280071830173232062387, 1809695326189866589243950, 2318699668497733232744265, 2342350100708102655089429, 960924442679754961738523, 7364507444160745861658, 1712582719067541471512215, 681290562464499451184980, 1272116165586563557294893, 1913819244198397186264466, 643915310809735095251319, 2160518936784940879369088, 1673206868891403176084015, 384057726114073098837748, 153577127977537052029191, 2389390133184670567226454, 1957808067535829109024776, 2208793915944522244135739, 219485001819443945838093, 1464931810740390946910755, 1580430575783660351845745, 931958726087788216468591, 1374299371937761890090826, 253130193454412585098813, 53380351089378620680849, 2191388100290386871726183, 2192713788948823569894935, 2266246068746255699858871, 177037734653194532537562, 172903115385406963342256, 2011743812230999783285376, 201215486442051143957388, 1687202900354567099254987, 2277646374948609159808724, 2379891920362403906638611, 1989426916553388952006726, 164139493513141549838100, 2274819163123946044563969, 1578682984183680714810035, 853022460388703741219823, 152669567822918011319174, 985069692465026911621169, 592765209305085949580503, 1858837321781964170384791, 2206222659134946616601770, 1519496995479180557318465, 878023815632260422323170, 456736568352453625343725, 38650313653800427353404, 307440856169372858743675, 641622966665946400959534, 794827876787662479236107, 887262277284590161501306, 218759120096017817538520, 423224752952668740440767, 2361141403569353597639696, 748677421611984554713124, 1680130852274741147513033, 86811037308027389304074, 1744386031921363068870614, 1372393515502389878944056, 583898007939305286112435, 963805969036044635762860, 1142134709682927478109898, 1152158890061498222277254, 596868803245454867214561, 1853147840031603829838562, 768524406009307578071712, 1512416257549132636136078, 79080680029971887932650, 1189260305888945064776414, 2253265091240829528093096, 1566365555765796334502063, 1853383048970891722240464, 2352866090966007864577330, 466542190231767708697683, 959480049306799839780392, 536621328229762305479589, 621649416655440646996618, 1900799112328643103342934, 191431867663628115286490, 1486157718357981245630893, 1191478675835169806337818, 558658085870226794864480, 2388488872047730160403404, 1480504010280813629179576, 2188978148737110419779404, 1129910880593733715668669, 741836605622123810337327, 1309428367109376706819776, 1777543592220839761813089, 559755414151615758603084, 16236949886849954310447, 1183577131233452066341002, 1936887040056540491314484, 1270261311905269647577756, 884209967232751192768280, 1555825842417169954887141, 983239494112020555445026, 980834071694316675678966, 218829033778170763339900, 86506421331462124336472, 511382953027262499043202, 1960772012983704210049677, 1264346635065640776944877, 1836433972297988098905818, 1294769713656481689202578, 1270026464483056618140657, 608296334525209961554467, 2391828913468796305773718, 2272089913224943030653620, 359474142722644621017255, 1219529971610064787847213, 2305237371009623342149760, 1908040129451310636364216, 631182707764002145505980, 553887526391068031320455, 317037974331696401322030, 906760543961530879672947, 1851893886140718336998772, 315251076411005051369717, 42285674379112122726065, 1332814025988462450426706, 827361214249189592666950, 1249541422604502655089986, 1110779314076696642424796, 2010886555836545430219251, 2350124099397106365439690, 212328237838001117721910, 1381099053879063960543218, 2349770200863544197554402, 894194540844922757949091, 2068129293668538340431121, 1153175982887959844612568, 1162477740919394297104536, 2057600497947095823242139, 1735373779817780215879059, 620739773862877231512994, 739993705568685843725759, 110748985215823679883890, 1867232429399525630041587, 1614393028406121928593001, 2358312553418047176017, 733194524946917821468007, 86827664457053787925185, 1247814044969323016636800, 275110810661307258714758, 14430933851490971330611, 1071959703651608529479067, 1903456667854719314584147, 1446049160857049418450198, 807055346393310619401536, 59031594978861569509736, 1722509116946609878966095, 1793443261757162311440828, 1326193326785853268872741, 1381643206007498681240889, 1674769974409029187002740, 2343823878240108182766601, 2266557702847321763980930, 1973477742509139790230850, 191898677558452576597685, 976198459236673673151379, 1301415910911960282077254, 466021552068914307538930, 1453866177533851720527685, 1859729093573708753273043, 233347429326077206039979, 774809326318345034541948, 798662925537975284012625, 1963831064724131623450608, 2147787085164216692529222, 2255985778029706212179152, 644875988465789160599389, 1966114337141327189765464, 163160019391941573881338, 498457428985140133572624, 1974769374776527831358749, 360036987284235885230686, 2118046936981020224020263, 605737870625814994076753, 698585518361755160194618, 1151550782841484301279565, 1564467982545201925783743, 1113181563808012330237201, 1010538210893316197961814, 557252864640545835241931, 2308391468729569581380993, 1898239065203683933600973, 1657876162308645890858021, 2183403329179916667138998, 2356745537308836696868373, 365747411319200172349174, 1950002744927518993947763, 2045322424198076891967049, 2368659015863862257063346, 2123638185496545849834695, 1519865411189181482477645, 1130570347891697282361520, 1055598519782759570623816, 869199023834296042637593, 1436858422120811410741981, 377278115448457713560866]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [],
    "module": "lattices"
  },
  {
    "name": "LearnParityWithNoise_9",
    "sat": "def sat(inds: List[int], vecs=[138526096052656348531088335317, 246161352115180815805683996007, 53363594490929354461853167125, 152403558349790560269982588896, 218461187930649932992610032016, 314339326918440331897616661626, 150956080511942366379385830109, 270323083152470942546693861139, 172283015582961411581393059525, 90128033656827599389576255218, 131076496208781504231160044779, 26987058721148056561698367013, 205765717164196964788040327680, 137115225152673232897157738602, 204112366300032053111487749688, 164092603797566313612391886499, 8905980982366340959911841576, 186010224267728469281160113853, 257989722491385790343433022245, 298617783741450582342711557224, 208208746133582328372590737969, 88825752720119216139330176199, 192611018751965717931241764426, 54041390560628884517875707754, 261362441155725526817461660321, 71762372424664706743157428280, 52606559186644534346231641601, 149849224624211603169149333699, 96654108158069590573559301137, 212535411979319752502618431389, 245793894138990360815068197, 16826900515646704753680118247, 186129519208189358114891233236, 33356662386290665174782246859, 262348478807902216649982313253, 173726281303516253044227617998, 316446098336183826406917656846, 132779970098594556445521978943, 63804502814156028135746467960, 105918285847190348650932178262, 217767408828679172715437119018, 10955844825587526702252975187, 309860049484723206794248798134, 67610802002163350426597064706, 153985918345943249453131617706, 302032176154738877465572238935, 311348801006678968704165236319, 219357869971367115759046692220, 152790095505431214533591957262, 177276708056560573973377305337, 148663141727944401355804629983, 215750102850298710917921894265, 125458515605310389352044255982, 150173738957711707005711106937, 186879294294243310883656038754, 61352965267157909179126338213, 10366464015531252188508233018, 118887348331449524682285458671, 230273555424934713930863232524, 118128677732046559560533982259, 105370866747716195456165791545, 209269505261133698482762742371, 238712701288670092272567494234, 192813157451946534320876996365, 40363821432772980341518345271, 164379096079040766801640423574, 205403572336327440388050165726, 25231599681910257364331783069, 1313447185493644155573150392, 238442374869881909327347109636, 278440134671455956868272563651, 25704934268841145671141291786, 193275607722490721612127567882, 206869192843968215012281330126, 55787211440617839917948060697, 133486336968986821787749185849, 125405958661815495112653231386, 208600252133335831862478488526, 72687640612176197521220035923, 172928313253382040459250288228, 183407777935492445322462533801, 114432541125785577338026286386, 258665891510816110779106120546, 234791215011837029757794710188, 190641306598146307143574924823, 229518471000748396756361149981, 156961638570865813014774927594, 47292905036301312609413082085, 178864039127673417127357047439, 55133574701396570932854868545, 155746164169589068963492147099, 162128272885811402151894779946, 17785995774412907204360975122, 92255288559921962082180930840, 234912818144872021774914660394, 80481868572697069274451144214, 167954007290897822539416363556, 89970373421100033064370438961, 13590930929721693528081844268, 172139570218500628449671705459, 141744264383769804946830536183, 286910760886198830968992245095, 152742362682283765319097783213, 216593084815746793007899255882, 156701626525151441937088234930, 296063624121531637126056756952, 4837197359821313992360209152, 31622307827699163474868203572, 222340685589152781088419199747, 286626033995617648091132515721, 253115642650515455032792267994, 28254991706843547007949199575, 120514304624743547339317141707, 73844356351460565721650284136, 129712962315085539552048683647, 311406671102839061476779627891, 42771748044995876541118297074, 290248444029388088939940875900, 225965692917145731753627137948, 273344698809482781626761204761, 301347907512161933523019013683, 56148451805582043256559305450, 231635822747764053189820684023, 63290402507237088027659346360, 229901294060711437409274266717, 195976993020874726301602892998, 30250479873817518820976366238, 163790191886177830389627176240, 64749680968461467896948268522, 252174102868844001393630024657, 236577678856984092329427627641, 58144107490268361274700327534, 187754019234606649540765667875, 72205302461345468264932244724, 162896382134769803596320099156, 234349676516608654133081519728, 112165456661033195319768287781, 243985756595349240203282214834, 146036178194818469429547218871, 227887202375095565174884396881, 123243351019587624129204191385, 193974158457360198903632205432, 211855492663075557418930445753, 262351739062882371113934312781, 250622965563469580970760553552, 210549876159644329039358903313, 113662759360494918792859304999, 178661158380466620093727664451, 81354278794362997655551152436, 258904451019181239797014102117, 21720368568708533804561655513, 413347756159771020145534002, 277467899431549850957974865505, 25688924851374367613902086241, 145649191602783998087340425970, 135629345860575335619275233622, 39063750896007110262830778236, 34938594752555690618215994355, 134981843015139757652014431936, 195391282210929715250755348113, 144985614406855504339798249902, 222405537520505770105438231011, 71652276009463351606253207848, 41846740975011500482381780014, 160452039499578373198542549755, 271183966707666215068678772430, 103421315179512174987883522088, 243493327081109842763411204613, 109313152341466257467147362661, 268390682970503137950061502012, 81490024879916447971783089068, 180392163339085659801256836190, 26632184979069091104180951849, 222453490792392461450026620101, 30925683170981422640160227448, 99188895639812157150748928232, 112020185286234253963076931137, 182679613882411238613012111166, 51817060337596975754668906912, 180590271555027787216941988336, 64992670449856201516929188835, 108660180565550319902343744101, 17414447148371815125403293311, 213169949629385198533465447348, 297325457064022783421535126203, 257544040891715438588699733790, 68628775513580275683788753866, 145358788249553017522112738967, 32947739905995339417294588080, 133420144462102556635231701310, 112663394729511447304341938269, 60171259682329010463733710746, 55845186605590782962992562782, 68684811525926844411993175801, 313285326475473303700054932376, 15532402050720729303535421244, 236180912863885680119438957600, 179503840774633441226048035199, 207877281078901370474028283714, 84080391663873966964930199978, 69104720928224548852740561487, 73560493262763870990308584221, 55761363088327178560205477934, 298365488724031886422748148457, 40242461106745038298828803151, 96008873452742769718935359740, 194222565914521269876270638933, 74006201605359280021012653053, 19958442024413967318828340977, 217948163376293144797809977403, 205683861033874309832810820566, 15182528095014748782467024604, 201567437079674302329298653779, 131485429058608263448712552865, 293249987520835187260842934372, 290649511148481822813330761694, 140291847086938600564395313926, 68089336455346268571523798511, 214168005226553372741981422599, 240470029767166600243408475768, 234809103829388089690860252168, 39453682684166321332601330444, 38625583995478807327920793988, 246079610514192177274998887908, 32701871210502027559007833703, 188966096705713214591870835730, 44381313613025727546395012000, 193520500546893454076922582002, 229420525486719266271908057834, 94585186392187809613887887255, 61575266857893389251892686617, 191076308177267817808486829492, 269775969921954900433637904819, 244622195757360968668348194212, 302933073258751477472113387027, 31826144117325632399079108144, 73260496713419713835555845844, 172149408006386313865700877471, 249691271699377943120667756891, 70350264538386445423713932405, 117211219724282526464973354370, 226166017482149933132249369101, 121321117292042208612976826581, 193048236843904999005250394781, 198841367069239506608969851175, 190307761203103259032324882609, 25118399049327342849925466655, 69093638502712777823867538209, 87845879808274498840194589709, 127944972398492610948171031745, 179645775910242859422524154787, 260415009395050155623793443181, 284824160085204608821142114770, 102320838222700719197864836481, 46437964546067587107303128526, 270178338114609004853308824799, 94774754203498885313819023140, 60488534222728987568717962087, 196776434632825540608212082237, 29996029319852533742920761976, 268717478549300927918534685454, 67016711806073039618142555031, 133441961228080642360433143432, 93359677114750944298520105979, 275635637240527538214065924737, 7331054399333553849211027053, 165858407398252745724856865372, 128784322423596297005604314157, 161989236095365328098237221560, 313768639392235519571073903784, 19070813977089021701561311180, 190104607713388369988718468539, 312482422647580352718131708621, 86247059032892482465949646300, 285272663401965954664874015753, 262927097563918087927653386519, 109244100380005055374458234391, 232407657060350478165796847336, 94480985959658832815003400659, 76060162510329908707079308886, 200610730323306834595270749866, 134234670254288355538874602942, 300333199017064232466921554925, 277956488778995726937900846526, 309140984185531186651639497188, 72213018724225274665139522092, 106094907353951854481491926980, 125032428688377829679924657120, 225877276041094232268925984182, 311996488334000688136056364311, 294109671768894319739635254739, 256257157798416835481952354003, 144433007082892971511612444268, 108561439402836815464274576227, 199384974571784501306517144189, 313317383113695905767774065234, 192885141644545076079547948507, 73098919979678407227545525286, 31515963200403877345165947236, 5701590302824046238987467661, 257291042572495605524995494095, 252411268649401120065566074766, 75083940401937257125636929320, 182747972790296524441932707860, 4842304701332691796145108720, 161004607721627461924931289191, 166242800108778007957408110945, 297400928472284324291649610686, 142469734569582616226432625367, 256650217570448166436002707113, 161241459741338402954285460321, 246274621522289874103964479238, 236150331004144082278449810210, 133030838390920261753414917833, 82439616159777647692530256845, 83457238027079561733471174003, 31515246472741606601046083423, 99964694287479965432930431584, 216899694989434036847756785773, 159475289663846674846501451142, 273669544190892421754160531267, 210947277085425194708520593285, 9304601942540091365467767614, 258740831778280076078750962457, 197275937084983354017627501957, 219707024065066544460670914432, 107057915620488969069696468343, 1140890443918312622757927867, 260977313642962546897906465026, 87046950245167477641277979818, 257735076285764498574260023293, 177878207001007692121088137871, 92772061248831743574899047446, 221236894696827106121321314185, 264127863487546916055941079239, 227295677135791302453661268033, 174813087859156028125329476410, 307108023970603409844027637277, 174497394439746391119459987788, 37450919415970424497788928544, 63970800455000148424570066695, 269617750683459987814311303906, 134151452385573061707472259569, 66976624964560241429353803750, 142767624823722391038026221563, 299002605656277520714458345955, 297409869598410821837082053374, 119498927412515856392476131168, 231454493580154971231806286125, 183923946339097731398612688821, 223550514708727330580020771998, 272371124888605390348351774671, 12509743455015395779489203031, 230241972119352775252412702828, 86476093129666662928946132879, 64556562083133870021648545761, 226524960878675681018804463556, 160943439482708640191757698281, 259836212220386375499234583438, 282872134067072185358597128106, 154471610547050642710433165120, 56195107774913946936297615035, 126444618204830681610791829868, 314458028004583163858499039803, 207829963234750731041793389926, 50876765371988998057836597284]):\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "sols": [],
    "module": "lattices"
  },
  {
    "name": "FermatsLastTheorem_0",
    "sat": "def sat(nums: List[int]):\n    a, b, c, n = nums\n    return (a ** n + b ** n == c ** n) and min(a, b, c) > 0 and n > 2",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "GCD_0",
    "sat": "def sat(n: int, a=15482, b=23223, lower_bound=5):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=15482, b=23223, lower_bound=5):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=15482, b=23223, lower_bound=5):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_1",
    "sat": "def sat(n: int, a=80582, b=12173504, lower_bound=83):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=80582, b=12173504, lower_bound=83):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=80582, b=12173504, lower_bound=83):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_2",
    "sat": "def sat(n: int, a=7904, b=5692856, lower_bound=1875):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=7904, b=5692856, lower_bound=1875):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=7904, b=5692856, lower_bound=1875):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_3",
    "sat": "def sat(n: int, a=34862131, b=577880864, lower_bound=24382):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=34862131, b=577880864, lower_bound=24382):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=34862131, b=577880864, lower_bound=24382):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_4",
    "sat": "def sat(n: int, a=588384, b=92, lower_bound=4):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=588384, b=92, lower_bound=4):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=588384, b=92, lower_bound=4):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_5",
    "sat": "def sat(n: int, a=5607819162, b=27335564358498, lower_bound=36723536):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=5607819162, b=27335564358498, lower_bound=36723536):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=5607819162, b=27335564358498, lower_bound=36723536):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_6",
    "sat": "def sat(n: int, a=276165, b=19897909182, lower_bound=2252):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=276165, b=19897909182, lower_bound=2252):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=276165, b=19897909182, lower_bound=2252):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_7",
    "sat": "def sat(n: int, a=1, b=362, lower_bound=0):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=1, b=362, lower_bound=0):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=1, b=362, lower_bound=0):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_8",
    "sat": "def sat(n: int, a=5707464, b=770664688, lower_bound=5):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=5707464, b=770664688, lower_bound=5):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=5707464, b=770664688, lower_bound=5):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_9",
    "sat": "def sat(n: int, a=706628775284, b=309130932086020, lower_bound=7127423):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "sols": [
      "def sol(a=706628775284, b=309130932086020, lower_bound=7127423):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "def sol(a=706628775284, b=309130932086020, lower_bound=7127423):\n    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_0",
    "sat": "def sat(n: int, nums=[77410, 23223, 54187], lower_bound=2):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[77410, 23223, 54187], lower_bound=2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_1",
    "sat": "def sat(n: int, nums=[70495401, 23269860753882480, 23498467, 23498467, 148219329923139, 23498467], lower_bound=19991401):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[70495401, 23269860753882480, 23498467, 23498467, 148219329923139, 23498467], lower_bound=19991401):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_2",
    "sat": "def sat(n: int, nums=[1225, 71295, 47326599040], lower_bound=181):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[1225, 71295, 47326599040], lower_bound=181):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_3",
    "sat": "def sat(n: int, nums=[6214120, 141230, 4448745, 70615, 4236900], lower_bound=68890):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[6214120, 141230, 4448745, 70615, 4236900], lower_bound=68890):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_4",
    "sat": "def sat(n: int, nums=[9557030, 8928548, 475706, 1, 24815284, 23603664, 10, 7807], lower_bound=1):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[9557030, 8928548, 475706, 1, 24815284, 23603664, 10, 7807], lower_bound=1):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_5",
    "sat": "def sat(n: int, nums=[1157765950, 1937953956180, 143957836924, 193409038152176, 17061814, 307616616549726, 2437402, 326611868, 105883180282, 11393204228846], lower_bound=2159154):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[1157765950, 1937953956180, 143957836924, 193409038152176, 17061814, 307616616549726, 2437402, 326611868, 105883180282, 11393204228846], lower_bound=2159154):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_6",
    "sat": "def sat(n: int, nums=[7000014, 391845543, 1473, 231, 274782], lower_bound=3):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[7000014, 391845543, 1473, 231, 274782], lower_bound=3):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_7",
    "sat": "def sat(n: int, nums=[61531310315922, 1637700402641796, 11571255523926, 2110999626734], lower_bound=241300149):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[61531310315922, 1637700402641796, 11571255523926, 2110999626734], lower_bound=241300149):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_8",
    "sat": "def sat(n: int, nums=[2084264416, 151216766, 20324019092], lower_bound=23):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[2084264416, 151216766, 20324019092], lower_bound=23):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "GCD_multi_9",
    "sat": "def sat(n: int, nums=[472631968779466264, 507448232, 147555108801157408, 406466033832, 2228712634944, 212740566990752], lower_bound=356670399):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "sols": [
      "def sol(nums=[472631968779466264, 507448232, 147555108801157408, 406466033832, 2228712634944, 212740566990752], lower_bound=356670399):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_0",
    "sat": "def sat(n: int, a=15, b=27, upper_bound=150):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=15, b=27, upper_bound=150):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_1",
    "sat": "def sat(n: int, a=40730910, b=617135, upper_bound=67814892):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=40730910, b=617135, upper_bound=67814892):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_2",
    "sat": "def sat(n: int, a=759520, b=46004540, upper_bound=55417409741):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=759520, b=46004540, upper_bound=55417409741):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_3",
    "sat": "def sat(n: int, a=681620170, b=583310, upper_bound=13039869606):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=681620170, b=583310, upper_bound=13039869606):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_4",
    "sat": "def sat(n: int, a=3720, b=47740, upper_bound=448957):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=3720, b=47740, upper_bound=448957):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_5",
    "sat": "def sat(n: int, a=4891901256, b=792, upper_bound=7687584134):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=4891901256, b=792, upper_bound=7687584134):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_6",
    "sat": "def sat(n: int, a=379456020, b=196052277, upper_bound=21681902847):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=379456020, b=196052277, upper_bound=21681902847):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_7",
    "sat": "def sat(n: int, a=420682887330, b=5848880, upper_bound=3699733059548):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=420682887330, b=5848880, upper_bound=3699733059548):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_8",
    "sat": "def sat(n: int, a=3244, b=284, upper_bound=334054):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=3244, b=284, upper_bound=334054):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_9",
    "sat": "def sat(n: int, a=416159262333570, b=43959058633350, upper_bound=104635376425254699008):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "sols": [
      "def sol(a=416159262333570, b=43959058633350, upper_bound=104635376425254699008):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_0",
    "sat": "def sat(n: int, nums=[15, 27, 102], upper_bound=5000):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[15, 27, 102], upper_bound=5000):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_1",
    "sat": "def sat(n: int, nums=[1581170390331, 935571217, 10323312942782, 154337221249218, 15869510317262784, 100216187421, 2796257266810], upper_bound=2881733032617239197781819941037614825472):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[1581170390331, 935571217, 10323312942782, 154337221249218, 15869510317262784, 100216187421, 2796257266810], upper_bound=2881733032617239197781819941037614825472):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_2",
    "sat": "def sat(n: int, nums=[32746155, 202987127583240, 27932470215, 11461154250, 209542645845, 838039598760, 50274484102245, 3260600538613860, 65492310], upper_bound=540445887743223187159941470399403917312):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[32746155, 202987127583240, 27932470215, 11461154250, 209542645845, 838039598760, 50274484102245, 3260600538613860, 65492310], upper_bound=540445887743223187159941470399403917312):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_3",
    "sat": "def sat(n: int, nums=[50373291392, 667, 1232498608, 667, 28014, 667], upper_bound=197110332911461056):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[50373291392, 667, 1232498608, 667, 28014, 667], upper_bound=197110332911461056):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_4",
    "sat": "def sat(n: int, nums=[36194984, 36194984, 6494176419248, 941069584, 274510323407656, 1990724120, 63904814095864, 32611680584], upper_bound=101429010112535110728755701612544):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[36194984, 36194984, 6494176419248, 941069584, 274510323407656, 1990724120, 63904814095864, 32611680584], upper_bound=101429010112535110728755701612544):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_5",
    "sat": "def sat(n: int, nums=[4571410, 20317080, 98862079810, 57692464520, 176988066980, 598547180], upper_bound=270210189895472806313241856584454242304):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[4571410, 20317080, 98862079810, 57692464520, 176988066980, 598547180], upper_bound=270210189895472806313241856584454242304):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_6",
    "sat": "def sat(n: int, nums=[4465095852, 8231892599598764, 10631180600, 2650459635386, 44156127880113268, 110561088885820, 580356148954], upper_bound=36102848231213970699855315069198363787264):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[4465095852, 8231892599598764, 10631180600, 2650459635386, 44156127880113268, 110561088885820, 580356148954], upper_bound=36102848231213970699855315069198363787264):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_7",
    "sat": "def sat(n: int, nums=[21126496, 488, 488, 437297923376, 488, 4390558936, 488], upper_bound=168940123904877776601088):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[21126496, 488, 488, 437297923376, 488, 4390558936, 488], upper_bound=168940123904877776601088):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_8",
    "sat": "def sat(n: int, nums=[41627404, 52622985428, 89201580, 129401758720, 17840316, 781164841917928], upper_bound=2799806977933082890338304):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[41627404, 52622985428, 89201580, 129401758720, 17840316, 781164841917928], upper_bound=2799806977933082890338304):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "LCM_multi_9",
    "sat": "def sat(n: int, nums=[348783442095, 8221554, 456753, 12959909622, 307553262291, 139309665, 29366300161836, 3197271, 400197073911195, 26790847215], upper_bound=99134013622070923956708454273026338995568640):\n    return all(n % i == 0 for i in nums) and n <= upper_bound",
    "sols": [
      "def sol(nums=[348783442095, 8221554, 456753, 12959909622, 307553262291, 139309665, 29366300161836, 3197271, 400197073911195, 26790847215], upper_bound=99134013622070923956708454273026338995568640):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_0",
    "sat": "def sat(n: int, b=2, target=5):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=2, target=5):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_1",
    "sat": "def sat(n: int, b=2, target=3):\n    return (b ** n) % n == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_2",
    "sat": "def sat(n: int, b=1, target=2):\n    return (b ** n) % n == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_3",
    "sat": "def sat(n: int, b=69, target=2):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=69, target=2):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_4",
    "sat": "def sat(n: int, b=14, target=3):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=14, target=3):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_5",
    "sat": "def sat(n: int, b=34, target=3):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=34, target=3):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_6",
    "sat": "def sat(n: int, b=56, target=3):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=56, target=3):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_7",
    "sat": "def sat(n: int, b=74, target=3):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=74, target=3):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_8",
    "sat": "def sat(n: int, b=17, target=4):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=17, target=4):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "SmallExponentBigSolution_9",
    "sat": "def sat(n: int, b=53, target=4):\n    return (b ** n) % n == target",
    "sols": [
      "def sol(b=53, target=4):\n    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_0",
    "sat": "def sat(nums: List[int], target=10):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [
      "def sol(target=10):\n    assert target % 9 not in {4, 5}\n    for i in range(20):\n        for j in range(i + 1):\n            for k in range(-20, j + 1):\n                n = i ** 3 + j ** 3 + k ** 3\n                if n == target:\n                    return [i, j, k]\n                if n == -target:\n                    return [-i, -j, -k]"
    ],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_1",
    "sat": "def sat(nums: List[int], target=114):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_2",
    "sat": "def sat(nums: List[int], target=390):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_3",
    "sat": "def sat(nums: List[int], target=579):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_4",
    "sat": "def sat(nums: List[int], target=627):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_5",
    "sat": "def sat(nums: List[int], target=633):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_6",
    "sat": "def sat(nums: List[int], target=732):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_7",
    "sat": "def sat(nums: List[int], target=921):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_8",
    "sat": "def sat(nums: List[int], target=975):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "ThreeCubes_9",
    "sat": "def sat(nums: List[int], target=0):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "sols": [
      "def sol(target=0):\n    assert target % 9 not in {4, 5}\n    for i in range(20):\n        for j in range(i + 1):\n            for k in range(-20, j + 1):\n                n = i ** 3 + j ** 3 + k ** 3\n                if n == target:\n                    return [i, j, k]\n                if n == -target:\n                    return [-i, -j, -k]"
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_0",
    "sat": "def sat(nums: List[int], n=12345):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [
      "def sol(n=12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_1",
    "sat": "def sat(nums: List[int], n=1):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [
      "def sol(n=1):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_2",
    "sat": "def sat(nums: List[int], n=0):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [
      "def sol(n=0):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_3",
    "sat": "def sat(nums: List[int], n=3):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [
      "def sol(n=3):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_4",
    "sat": "def sat(nums: List[int], n=8):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [
      "def sol(n=8):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_5",
    "sat": "def sat(nums: List[int], n=15):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [
      "def sol(n=15):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_6",
    "sat": "def sat(nums: List[int], n=899330372175195569519918999778):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_7",
    "sat": "def sat(nums: List[int], n=6878709965):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_8",
    "sat": "def sat(nums: List[int], n=6252029730540891155562265349):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "FourSquares_9",
    "sat": "def sat(nums: List[int], n=95069368052509365912138760244537767163246994457):\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_0",
    "sat": "def sat(i: int, n=62710561):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [
      "def sol(n=62710561):\n    if n % 2 == 0:\n        return 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n    assert False, \"problem defined for composite n only\""
    ],
    "module": "number_theory"
  },
  {
    "name": "Factoring_1",
    "sat": "def sat(i: int, n=16):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [
      "def sol(n=16):\n    if n % 2 == 0:\n        return 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n    assert False, \"problem defined for composite n only\""
    ],
    "module": "number_theory"
  },
  {
    "name": "Factoring_2",
    "sat": "def sat(i: int, n=1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_3",
    "sat": "def sat(i: int, n=35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_4",
    "sat": "def sat(i: int, n=227010481295437363334259960947493668895875336466084780038173258247009162675779735389791151574049166747880487470296548479):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_5",
    "sat": "def sat(i: int, n=114381625757888867669235779976146612010218296721242362562561842935706935245733897830597123563958705058989075147599290026879543541):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_6",
    "sat": "def sat(i: int, n=1807082088687404805951656164405905566278102516769401349170127021450056662540244048387341127590812303371781887966563182013214880557):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_7",
    "sat": "def sat(i: int, n=21290246318258757547497882016271517497806703963277216278233383215381949984056495911366573853021918316783107387995317230889569230873441936471):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_8",
    "sat": "def sat(i: int, n=155089812478348440509606754370011861770654545830995430655466945774312632703463465954363335027577729025391453996787414027003501631772186840890795964683):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Factoring_9",
    "sat": "def sat(i: int, n=10941738641570527421809707322040357612003732945449205990913842131476349984288934784717997257891267332497625752899781833797076537244027146743531593354333897):\n    \"\"\"Find a non-trivial factor of integer n\"\"\"\n    return 1 < i < n and n % i == 0",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_0",
    "sat": "def sat(n: int, g=3, p=17, t=13):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [
      "def sol(g=3, p=17, t=13):\n    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""
    ],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_1",
    "sat": "def sat(n: int, g=7, p=204706270385532838059744535166974274803608394340123459695798674591526591372685229510652847339705797622075505069831043486651682279, t=127402180119973946824269244334322849749382042586931621654557735290322914679095998681860978813046595166455458144280588076766033781):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_2",
    "sat": "def sat(n: int, g=417527329812220474, p=445926901339026639, t=56116700748521056):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_3",
    "sat": "def sat(n: int, g=447, p=501, t=336):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [
      "def sol(g=447, p=501, t=336):\n    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""
    ],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_4",
    "sat": "def sat(n: int, g=14885268, p=24263045, t=14253999):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_5",
    "sat": "def sat(n: int, g=337960848589361497017, p=828164075183613036729, t=283192599326395931298):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_6",
    "sat": "def sat(n: int, g=5898096975203, p=6689543714119, t=1202980151897):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_7",
    "sat": "def sat(n: int, g=2, p=3, t=1):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [
      "def sol(g=2, p=3, t=1):\n    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""
    ],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_8",
    "sat": "def sat(n: int, g=41480, p=55241, t=1914):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [
      "def sol(g=41480, p=55241, t=1914):\n    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""
    ],
    "module": "number_theory"
  },
  {
    "name": "DiscreteLog_9",
    "sat": "def sat(n: int, g=34216798, p=77875545, t=74002357):\n    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"\n    return pow(g, n, p) == t",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "GCD17_0",
    "sat": "def sat(n: int):\n    \"\"\"Find n for which gcd(n^17+9, (n+1)^17+9) != 1\"\"\"\n    i = n ** 17 + 9\n    j = (n + 1) ** 17 + 9\n\n    while i != 0:  # compute gcd using Euclid's algorithm\n        (i, j) = (j % i, i)\n\n    return n >= 0 and j != 1",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "Znam_0",
    "sat": "def sat(li: List[int], k=5):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=5):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_1",
    "sat": "def sat(li: List[int], k=6):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=6):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_2",
    "sat": "def sat(li: List[int], k=7):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=7):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_3",
    "sat": "def sat(li: List[int], k=8):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=8):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_4",
    "sat": "def sat(li: List[int], k=9):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=9):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_5",
    "sat": "def sat(li: List[int], k=10):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=10):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_6",
    "sat": "def sat(li: List[int], k=11):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=11):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_7",
    "sat": "def sat(li: List[int], k=12):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=12):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_8",
    "sat": "def sat(li: List[int], k=13):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=13):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "Znam_9",
    "sat": "def sat(li: List[int], k=14):\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "sols": [
      "def sol(k=14):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory"
  },
  {
    "name": "CollatzCycleUnsolved_0",
    "sat": "def sat(n: int):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find n > 4 which is part of a cycle of this process\n    \"\"\"\n    m = n\n    while n > 4:\n        n = 3 * n + 1 if n % 2 else n // 2\n        if n == m:\n            return True",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzGeneralizedUnsolved_0",
    "sat": "def sat(start: int):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find n which is part of a cycle of this process that has |n| > 1000\n    \"\"\"\n    n = start  # could be positive or negative ...\n    while abs(n) > 1000:\n        n = 3 * n + 1 if n % 2 else n // 2\n        if n == start:\n            return True",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_0",
    "sat": "def sat(n: int, t=100, upper=10):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [
      "def sol(t=100, upper=10):  # Faster solution for simultaneously solving multiple problems is of course possible\n    bound = t + 10\n    while True:\n        bound *= 2\n        prev = {1}\n        seen = set()\n        for delay in range(t):\n            seen.update(prev)\n            curr = {2 * n for n in prev}\n            curr.update({(n - 1) // 3 for n in prev if n % 6 == 4})\n            prev = {n for n in curr if n <= bound} - seen\n        if prev:\n            return min(prev)"
    ],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_1",
    "sat": "def sat(n: int, t=1000, upper=131):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_2",
    "sat": "def sat(n: int, t=2000, upper=164):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_3",
    "sat": "def sat(n: int, t=2283, upper=188):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_4",
    "sat": "def sat(n: int, t=2337, upper=192):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_5",
    "sat": "def sat(n: int, t=2350, upper=223):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_6",
    "sat": "def sat(n: int, t=2500, upper=232):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_7",
    "sat": "def sat(n: int, t=3000, upper=285):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_8",
    "sat": "def sat(n: int, t=4000, upper=341):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [],
    "module": "number_theory"
  },
  {
    "name": "CollatzDelay_9",
    "sat": "def sat(n: int, t=0, upper=98):\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "sols": [
      "def sol(t=0, upper=98):  # Faster solution for simultaneously solving multiple problems is of course possible\n    bound = t + 10\n    while True:\n        bound *= 2\n        prev = {1}\n        seen = set()\n        for delay in range(t):\n            seen.update(prev)\n            curr = {2 * n for n in prev}\n            curr.update({(n - 1) // 3 for n in prev if n % 6 == 4})\n            prev = {n for n in curr if n <= bound} - seen\n        if prev:\n            return min(prev)"
    ],
    "module": "number_theory"
  },
  {
    "name": "Lehmer_0",
    "sat": "def sat(n: int):\n    \"\"\"Find n  such that 2^n mod n = 3\"\"\"\n    return pow(2, n, n) == 3",
    "sols": [
      "def sol():\n    return 4700063497"
    ],
    "module": "number_theory"
  },
  {
    "name": "BirthdayParadox_0",
    "sat": "def sat(n: int, year_len=365):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_1",
    "sat": "def sat(n: int, year_len=60182):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_2",
    "sat": "def sat(n: int, year_len=2):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_3",
    "sat": "def sat(n: int, year_len=3):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_4",
    "sat": "def sat(n: int, year_len=4):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=4):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_5",
    "sat": "def sat(n: int, year_len=5):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=5):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_6",
    "sat": "def sat(n: int, year_len=6):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=6):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_7",
    "sat": "def sat(n: int, year_len=7):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=7):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_8",
    "sat": "def sat(n: int, year_len=8):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=8):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadox_9",
    "sat": "def sat(n: int, year_len=9):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=9):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_0",
    "sat": "def sat(n: int, year_len=365):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_1",
    "sat": "def sat(n: int, year_len=60182):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_2",
    "sat": "def sat(n: int, year_len=2):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_3",
    "sat": "def sat(n: int, year_len=3):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_4",
    "sat": "def sat(n: int, year_len=4):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=4):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_5",
    "sat": "def sat(n: int, year_len=5):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=5):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_6",
    "sat": "def sat(n: int, year_len=6):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=6):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_7",
    "sat": "def sat(n: int, year_len=7):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=7):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_8",
    "sat": "def sat(n: int, year_len=8):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=8):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BirthdayParadoxMonteCarlo_9",
    "sat": "def sat(n: int, year_len=9):\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=9):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_0",
    "sat": "def sat(counts: List[int], target_prob=0.5):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_1",
    "sat": "def sat(counts: List[int], target_prob=0.2):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_2",
    "sat": "def sat(counts: List[int], target_prob=0.0):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_3",
    "sat": "def sat(counts: List[int], target_prob=0.4731182795698925):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4731182795698925):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_4",
    "sat": "def sat(counts: List[int], target_prob=0.7370030581039755):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7370030581039755):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_5",
    "sat": "def sat(counts: List[int], target_prob=0.4):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_6",
    "sat": "def sat(counts: List[int], target_prob=0.7702702702702703):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7702702702702703):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_7",
    "sat": "def sat(counts: List[int], target_prob=0.13953488372093023):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13953488372093023):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_8",
    "sat": "def sat(counts: List[int], target_prob=0.30275229357798167):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30275229357798167):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BallotProblem_9",
    "sat": "def sat(counts: List[int], target_prob=0.5136612021857924):\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5136612021857924):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_0",
    "sat": "def sat(counts: List[int], p=0.5, target_prob=0.0625):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5, target_prob=0.0625):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_1",
    "sat": "def sat(counts: List[int], p=0.41409343481407657, target_prob=0.5859065651859234):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41409343481407657, target_prob=0.5859065651859234):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_2",
    "sat": "def sat(counts: List[int], p=0.44988724294487226, target_prob=0.4949774231606675):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44988724294487226, target_prob=0.4949774231606675):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_3",
    "sat": "def sat(counts: List[int], p=0.0891376737959737, target_prob=4.4712512394951255e-08):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0891376737959737, target_prob=4.4712512394951255e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_4",
    "sat": "def sat(counts: List[int], p=0.22245375340163231, target_prob=0.04948567240247424):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22245375340163231, target_prob=0.04948567240247424):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_5",
    "sat": "def sat(counts: List[int], p=0.16630127396334493, target_prob=1.82976534893595e-05):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16630127396334493, target_prob=1.82976534893595e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_6",
    "sat": "def sat(counts: List[int], p=0.31903948796620407, target_prob=0.03247381549709785):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31903948796620407, target_prob=0.03247381549709785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_7",
    "sat": "def sat(counts: List[int], p=0.061342203040559706, target_prob=1.4159159584729811e-05):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.061342203040559706, target_prob=1.4159159584729811e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_8",
    "sat": "def sat(counts: List[int], p=0.4251415150249188, target_prob=0.18074530779768327):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4251415150249188, target_prob=0.18074530779768327):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "BinomialProbabilities_9",
    "sat": "def sat(counts: List[int], p=0.5984613901460974, target_prob=0.04203336626485389):\n    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5984613901460974, target_prob=0.04203336626485389):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_0",
    "sat": "def sat(p_stop: float, steps=10, target_prob=0.5):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.5):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_1",
    "sat": "def sat(p_stop: float, steps=99, target_prob=0.29381508328848427):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.29381508328848427):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_2",
    "sat": "def sat(p_stop: float, steps=77, target_prob=0.7594821007442389):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.7594821007442389):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_3",
    "sat": "def sat(p_stop: float, steps=76, target_prob=0.08848373947217114):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.08848373947217114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_4",
    "sat": "def sat(p_stop: float, steps=1, target_prob=0.20502531669793944):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.20502531669793944):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_5",
    "sat": "def sat(p_stop: float, steps=76, target_prob=0.8980427563722572):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.8980427563722572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_6",
    "sat": "def sat(p_stop: float, steps=45, target_prob=0.6692404380399146):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.6692404380399146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_7",
    "sat": "def sat(p_stop: float, steps=16, target_prob=0.29461710854304):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.29461710854304):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_8",
    "sat": "def sat(p_stop: float, steps=86, target_prob=0.2977620128149647):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.2977620128149647):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "ExponentialProbability_9",
    "sat": "def sat(p_stop: float, steps=91, target_prob=0.054389734064553275):\n    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.054389734064553275):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability"
  },
  {
    "name": "HelloWorld_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a string that when concatenated onto 'world' gives 'Hello world'.\"\"\"\n    return s + 'world' == 'Hello world'",
    "sols": [],
    "module": "trivial_inverse"
  },
  {
    "name": "BackWorlds_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'world' gives 'Hello world'.\"\"\"\n    return s[::-1] + 'world' == 'Hello world'",
    "sols": [
      "def sol():\n    return ' olleH'",
      "def sol():  # solution methods must begin with 'sol'\n    return 'Hello '[::-1]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_0",
    "sat": "def sat(st: str, a=\"world\", b=\"Hello world\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"world\", b=\"Hello world\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_1",
    "sat": "def sat(st: str, a=\"chochevuvy\", b=\"chochevuvy\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"chochevuvy\", b=\"chochevuvy\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_2",
    "sat": "def sat(st: str, a=\"lubyvokucesiwak\", b=\"lubyvokucesiwak\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"lubyvokucesiwak\", b=\"lubyvokucesiwak\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_3",
    "sat": "def sat(st: str, a=\"wach\", b=\"wach\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"wach\", b=\"wach\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_4",
    "sat": "def sat(st: str, a=\"xu\", b=\"cuquadalybezumoxu\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"xu\", b=\"cuquadalybezumoxu\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_5",
    "sat": "def sat(st: str, a=\"eq\", b=\"deq\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"eq\", b=\"deq\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_6",
    "sat": "def sat(st: str, a=\"t\", b=\"fikajewathutext\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"t\", b=\"fikajewathutext\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_7",
    "sat": "def sat(st: str, a=\"ch\", b=\"lefofaruch\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"ch\", b=\"lefofaruch\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_8",
    "sat": "def sat(st: str, a=\"chuquefyte\", b=\"nexosegavechuquefyte\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"chuquefyte\", b=\"nexosegavechuquefyte\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAdd_9",
    "sat": "def sat(st: str, a=\"axudy\", b=\"haxudy\"):\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b",
    "sols": [
      "def sol(a=\"axudy\", b=\"haxudy\"):\n    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_0",
    "sat": "def sat(s: str, dups=2021):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=2021):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_1",
    "sat": "def sat(s: str, dups=0):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=0):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_2",
    "sat": "def sat(s: str, dups=1):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=1):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_3",
    "sat": "def sat(s: str, dups=2):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=2):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_4",
    "sat": "def sat(s: str, dups=3):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=3):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_5",
    "sat": "def sat(s: str, dups=4):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=4):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_6",
    "sat": "def sat(s: str, dups=5):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=5):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_7",
    "sat": "def sat(s: str, dups=6):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=6):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_8",
    "sat": "def sat(s: str, dups=7):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=7):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSetLen_9",
    "sat": "def sat(s: str, dups=8):\n    \"\"\"Find a string with dups duplicate chars\"\"\"\n    return len(set(s)) == len(s) - dups",
    "sols": [
      "def sol(dups=8):\n    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_0",
    "sat": "def sat(s: str, target=\"foofoofoofoo\", n=2):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"foofoofoofoo\", n=2):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_1",
    "sat": "def sat(s: str, target=\"muchuthutmuchuthutmuchuthutmuchuthutmuchuthutmuchuthutmuchuthutmuchuthut\", n=8):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"muchuthutmuchuthutmuchuthutmuchuthutmuchuthutmuchuthutmuchuthutmuchuthut\", n=8):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_2",
    "sat": "def sat(s: str, target=\"tttttttttttttttttt\", n=6):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"tttttttttttttttttt\", n=6):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_3",
    "sat": "def sat(s: str, target=\"xyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojy\", n=7):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"xyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojyxyfajytizemojy\", n=7):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_4",
    "sat": "def sat(s: str, target=\"majmajmajmajmajmaj\", n=2):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"majmajmajmajmajmaj\", n=2):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_5",
    "sat": "def sat(s: str, target=\"biruharikytugehupbiruharikytugehupbiruharikytugehup\", n=1):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"biruharikytugehupbiruharikytugehupbiruharikytugehup\", n=1):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_6",
    "sat": "def sat(s: str, target=\"wequocizipetukaciwequocizipetukaci\", n=2):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"wequocizipetukaciwequocizipetukaci\", n=2):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_7",
    "sat": "def sat(s: str, target=\"pizysepizysepizysepizysepizysepizysepizysepizysepizysepizyse\", n=5):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"pizysepizysepizysepizysepizysepizysepizysepizysepizysepizyse\", n=5):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_8",
    "sat": "def sat(s: str, target=\"\", n=0):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"\", n=0):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul_9",
    "sat": "def sat(s: str, target=\"buthubuthubuthubuthubuthubuthubuthubuthubuthu\", n=3):\n    \"\"\"Find a string which when repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"buthubuthubuthubuthubuthubuthubuthubuthubuthu\", n=3):\n    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_0",
    "sat": "def sat(n: int, target=\"foofoofoofoo\", s=\"foofoo\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"foofoofoofoo\", s=\"foofoo\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_1",
    "sat": "def sat(n: int, target=\"ququququququququququququququququququququququququ\", s=\"quququ\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"ququququququququququququququququququququququququ\", s=\"quququ\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_2",
    "sat": "def sat(n: int, target=\"quanetugyquanetugyquanetugyquanetugy\", s=\"quanetugyquanetugy\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"quanetugyquanetugyquanetugyquanetugy\", s=\"quanetugyquanetugy\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_3",
    "sat": "def sat(n: int, target=\"jimothatojawyrajimothatojawyra\", s=\"jimothatojawyra\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"jimothatojawyrajimothatojawyra\", s=\"jimothatojawyra\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_4",
    "sat": "def sat(n: int, target=\"pidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudu\", s=\"pidutevorudupidutevorudupidutevorudu\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"pidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudupidutevorudu\", s=\"pidutevorudupidutevorudupidutevorudu\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_5",
    "sat": "def sat(n: int, target=\"\", s=\"bbb\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"\", s=\"bbb\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_6",
    "sat": "def sat(n: int, target=\"hohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrot\", s=\"hohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrot\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"hohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrot\", s=\"hohycymuhacyjyrothohycymuhacyjyrothohycymuhacyjyrot\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_7",
    "sat": "def sat(n: int, target=\"duwoduwoduwoduwoduwoduwo\", s=\"duwoduwoduwo\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"duwoduwoduwoduwoduwoduwo\", s=\"duwoduwoduwo\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_8",
    "sat": "def sat(n: int, target=\"pacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawije\", s=\"pacabifusawijepacabifusawije\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"pacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawijepacabifusawije\", s=\"pacabifusawijepacabifusawije\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrMul2_9",
    "sat": "def sat(n: int, target=\"kipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquax\", s=\"kipatextyquiquax\"):\n    \"\"\"Find n such that s repeated n times gives target\"\"\"\n    return s * n == target",
    "sols": [
      "def sol(target=\"kipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquaxkipatextyquiquax\", s=\"kipatextyquiquax\"):\n    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_0",
    "sat": "def sat(s: str, n=1000):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=1000):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_1",
    "sat": "def sat(s: str, n=6105):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=6105):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_2",
    "sat": "def sat(s: str, n=623):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=623):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_3",
    "sat": "def sat(s: str, n=0):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=0):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_4",
    "sat": "def sat(s: str, n=5081):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=5081):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_5",
    "sat": "def sat(s: str, n=431):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=431):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_6",
    "sat": "def sat(s: str, n=398):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=398):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_7",
    "sat": "def sat(s: str, n=99):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=99):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_8",
    "sat": "def sat(s: str, n=5):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=5):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrLen_9",
    "sat": "def sat(s: str, n=49):\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n",
    "sols": [
      "def sol(n=49):\n    return 'a' * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_0",
    "sat": "def sat(i: int, s=\"cat\", target=\"a\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"cat\", target=\"a\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_1",
    "sat": "def sat(i: int, s=\"hyfijiketexthyfijiketext\", target=\"j\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"hyfijiketexthyfijiketext\", target=\"j\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_2",
    "sat": "def sat(i: int, s=\"sisipivusisipivusisipivu\", target=\"v\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"sisipivusisipivusisipivu\", target=\"v\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_3",
    "sat": "def sat(i: int, s=\"chchch\", target=\"c\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"chchch\", target=\"c\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_4",
    "sat": "def sat(i: int, s=\"kyxobuguskyxobugus\", target=\"u\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"kyxobuguskyxobugus\", target=\"u\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_5",
    "sat": "def sat(i: int, s=\"lythebipifilythebipifi\", target=\"t\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"lythebipifilythebipifi\", target=\"t\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_6",
    "sat": "def sat(i: int, s=\"kiluzuvothecigkiluzuvothecigkiluzuvothecig\", target=\"u\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"kiluzuvothecigkiluzuvothecigkiluzuvothecig\", target=\"u\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_7",
    "sat": "def sat(i: int, s=\"jyjipaxosutu\", target=\"s\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"jyjipaxosutu\", target=\"s\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_8",
    "sat": "def sat(i: int, s=\"nuneherekativytnuneherekativyt\", target=\"t\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"nuneherekativytnuneherekativyt\", target=\"t\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrAt_9",
    "sat": "def sat(i: int, s=\"cezeramuvironagythcezeramuvironagythcezeramuvironagyth\", target=\"e\"):\n    \"\"\"Find the index of target in string s\"\"\"\n    return s[i] == target",
    "sols": [
      "def sol(s=\"cezeramuvironagythcezeramuvironagythcezeramuvironagyth\", target=\"e\"):\n    return s.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_0",
    "sat": "def sat(i: int, s=\"cat\", target=\"a\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"cat\", target=\"a\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_1",
    "sat": "def sat(i: int, s=\"wuwyculojahyhywwuwyculojahyhyw\", target=\"w\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"wuwyculojahyhywwuwyculojahyhyw\", target=\"w\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_2",
    "sat": "def sat(i: int, s=\"jyrezuwosynojyrezuwosyno\", target=\"e\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"jyrezuwosynojyrezuwosyno\", target=\"e\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_3",
    "sat": "def sat(i: int, s=\"lequlequ\", target=\"e\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"lequlequ\", target=\"e\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_4",
    "sat": "def sat(i: int, s=\"xorxorxor\", target=\"o\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"xorxorxor\", target=\"o\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_5",
    "sat": "def sat(i: int, s=\"vatextyfevafivatextyfevafivatextyfevafi\", target=\"t\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"vatextyfevafivatextyfevafivatextyfevafi\", target=\"t\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_6",
    "sat": "def sat(i: int, s=\"laba\", target=\"a\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"laba\", target=\"a\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_7",
    "sat": "def sat(i: int, s=\"p\", target=\"p\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"p\", target=\"p\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_8",
    "sat": "def sat(i: int, s=\"vyhivyhivyhi\", target=\"v\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"vyhivyhivyhi\", target=\"v\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrNegAt_9",
    "sat": "def sat(i: int, s=\"ziluzilu\", target=\"l\"):\n    \"\"\"Find the index of target in s using a negative index.\"\"\"\n    return s[i] == target and i < 0",
    "sols": [
      "def sol(s=\"ziluzilu\", target=\"l\"):\n    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_0",
    "sat": "def sat(inds: List[int], s=\"hello world\", target=\"do\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"hello world\", target=\"do\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_1",
    "sat": "def sat(inds: List[int], s=\"byjebudibegybyjebudibegybyjebudibegy\", target=\"b\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"byjebudibegybyjebudibegybyjebudibegy\", target=\"b\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_2",
    "sat": "def sat(inds: List[int], s=\"gycyjotixyfi\", target=\"\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"gycyjotixyfi\", target=\"\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_3",
    "sat": "def sat(inds: List[int], s=\"jikjikjik\", target=\"\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"jikjikjik\", target=\"\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_4",
    "sat": "def sat(inds: List[int], s=\"katykukatykukatyku\", target=\"\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"katykukatykukatyku\", target=\"\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_5",
    "sat": "def sat(inds: List[int], s=\"vane\", target=\"\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"vane\", target=\"\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_6",
    "sat": "def sat(inds: List[int], s=\"fehycowezulahifehycowezulahifehycowezulahi\", target=\"\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"fehycowezulahifehycowezulahifehycowezulahi\", target=\"\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_7",
    "sat": "def sat(inds: List[int], s=\"thexapupivovach\", target=\"tpo\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"thexapupivovach\", target=\"tpo\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_8",
    "sat": "def sat(inds: List[int], s=\"xiwohahiquupothyhumoxiwohahiquupothyhumo\", target=\"oh\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"xiwohahiquupothyhumoxiwohahiquupothyhumo\", target=\"oh\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSlice_9",
    "sat": "def sat(inds: List[int], s=\"cakiribocakiribo\", target=\"i\"):\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    i, j, k = inds\n    return s[i:j:k] == target",
    "sols": [
      "def sol(s=\"cakiribocakiribo\", target=\"i\"):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_0",
    "sat": "def sat(s: str, big_str=\"foobar\", index=2):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"foobar\", index=2):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_1",
    "sat": "def sat(s: str, big_str=\"textypidoquitextotuchyhexaquaquofethahuchethiwoji\", index=17):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"textypidoquitextotuchyhexaquaquofethahuchethiwoji\", index=17):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_2",
    "sat": "def sat(s: str, big_str=\"mybunypiquabogezotextisydojehodocewuhochahu\", index=17):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"mybunypiquabogezotextisydojehodocewuhochahu\", index=17):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_3",
    "sat": "def sat(s: str, big_str=\"danoxosizybivugukodywite\", index=21):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"danoxosizybivugukodywite\", index=21):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_4",
    "sat": "def sat(s: str, big_str=\"mechavowegypolyfikucheradupapojutextafurudo\", index=39):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"mechavowegypolyfikucheradupapojutextafurudo\", index=39):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_5",
    "sat": "def sat(s: str, big_str=\"fychexazelutextoketothechozodetha\", index=24):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"fychexazelutextoketothechozodetha\", index=24):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_6",
    "sat": "def sat(s: str, big_str=\"textuthyquawelybuxohadebohycijahog\", index=22):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"textuthyquawelybuxohadebohycijahog\", index=22):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_7",
    "sat": "def sat(s: str, big_str=\"ryquichymojequet\", index=11):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"ryquichymojequet\", index=11):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_8",
    "sat": "def sat(s: str, big_str=\"pybiluquosybethomisavibequawicitex\", index=14):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"pybiluquosybethomisavibequawicitex\", index=14):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex_9",
    "sat": "def sat(s: str, big_str=\"tubyxohajysugydaxemamuvulyfahythijaru\", index=32):\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index",
    "sols": [
      "def sol(big_str=\"tubyxohajysugydaxemamuvulyfahythijaru\", index=32):\n    return big_str[index:]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_0",
    "sat": "def sat(big_str: str, sub_str=\"foobar\", index=2):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"foobar\", index=2):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_1",
    "sat": "def sat(big_str: str, sub_str=\"tijocicebyrotharicevibe\", index=395):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"tijocicebyrotharicevibe\", index=395):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_2",
    "sat": "def sat(big_str: str, sub_str=\"wujitujykuvequuzecipichoxythecath\", index=167):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"wujitujykuvequuzecipichoxythecath\", index=167):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_3",
    "sat": "def sat(big_str: str, sub_str=\"tavytextoquekucelemut\", index=761):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"tavytextoquekucelemut\", index=761):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_4",
    "sat": "def sat(big_str: str, sub_str=\"lyva\", index=573):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"lyva\", index=573):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_5",
    "sat": "def sat(big_str: str, sub_str=\"lylogochejytextutextaquyfytextehahupythuwakado\", index=469):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"lylogochejytextutextaquyfytextehahupythuwakado\", index=469):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_6",
    "sat": "def sat(big_str: str, sub_str=\"letexteke\", index=199):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"letexteke\", index=199):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_7",
    "sat": "def sat(big_str: str, sub_str=\"textifywajawethodywowicy\", index=566):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"textifywajawethodywowicy\", index=566):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_8",
    "sat": "def sat(big_str: str, sub_str=\"thagythaquycov\", index=412):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"thagythaquycov\", index=412):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIndex2_9",
    "sat": "def sat(big_str: str, sub_str=\"firevekaluxu\", index=963):\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index",
    "sols": [
      "def sol(sub_str=\"firevekaluxu\", index=963):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_0",
    "sat": "def sat(s: str, a=\"hello\", b=\"yellow\", length=4):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"hello\", b=\"yellow\", length=4):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_1",
    "sat": "def sat(s: str, a=\"kuchuriherecysopinycaquuchumegytibiquuviqu\", b=\"zidixithcysopinycaquuchusebivosechamoluquyp\", length=16):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"kuchuriherecysopinycaquuchumegytibiquuviqu\", b=\"zidixithcysopinycaquuchusebivosechamoluquyp\", length=16):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_2",
    "sat": "def sat(s: str, a=\"faquhuburygydeqhivok\", b=\"hewepyzoxahuburygydeqkaxubichoje\", length=11):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"faquhuburygydeqhivok\", b=\"hewepyzoxahuburygydeqkaxubichoje\", length=11):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_3",
    "sat": "def sat(s: str, a=\"rahacyhathefaxigynlazagucisabivaktatunajywerifotet\", b=\"wagugipetofuflazagucisabivakmosacalochevokykochi\", length=15):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"rahacyhathefaxigynlazagucisabivaktatunajywerifotet\", b=\"wagugipetofuflazagucisabivakmosacalochevokykochi\", length=15):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_4",
    "sat": "def sat(s: str, a=\"fudchuzogijudutexlorydegythygumuci\", b=\"lochudoxunifebugechuzogijudutexbisa\", length=14):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"fudchuzogijudutexlorydegythygumuci\", b=\"lochudoxunifebugechuzogijudutexbisa\", length=14):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_5",
    "sat": "def sat(s: str, a=\"nazycyvabujalanocwasegalasypoluha\", b=\"nevuwogomeneruwemutewasepidogygafabad\", length=4):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"nazycyvabujalanocwasegalasypoluha\", b=\"nevuwogomeneruwemutewasepidogygafabad\", length=4):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_6",
    "sat": "def sat(s: str, a=\"vosytextezynunerpcomafetextodoh\", b=\"gasedychuxpcib\", length=1):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"vosytextezynunerpcomafetextodoh\", b=\"gasedychuxpcib\", length=1):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_7",
    "sat": "def sat(s: str, a=\"textamoncithiluvupudithythix\", b=\"lepehanthipax\", length=1):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"textamoncithiluvupudithythix\", b=\"lepehanthipax\", length=1):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_8",
    "sat": "def sat(s: str, a=\"kynozipywpowerosohijlaxosigothyki\", b=\"japowerosohijnutexta\", length=11):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"kynozipywpowerosohijlaxosigothyki\", b=\"japowerosohijnutexta\", length=11):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn_9",
    "sat": "def sat(s: str, a=\"xpuxekybfijaloquur\", b=\"sulafasekacuripuxekybmimipynusatha\", length=7):\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and s in b",
    "sols": [
      "def sol(a=\"xpuxekybfijaloquur\", b=\"sulafasekacuripuxekybmimipynusatha\", length=7):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_0",
    "sat": "def sat(substrings: List[str], s=\"hello\", count=15):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"hello\", count=15):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_1",
    "sat": "def sat(substrings: List[str], s=\"vasyjaromuwoz\", count=90):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"vasyjaromuwoz\", count=90):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_2",
    "sat": "def sat(substrings: List[str], s=\"dupabojochexanaliciwilathymufysuvetubo\", count=724):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"dupabojochexanaliciwilathymufysuvetubo\", count=724):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_3",
    "sat": "def sat(substrings: List[str], s=\"pi\", count=4):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"pi\", count=4):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_4",
    "sat": "def sat(substrings: List[str], s=\"haveramytafumegavejethybuzidifotedu\", count=610):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"haveramytafumegavejethybuzidifotedu\", count=610):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_5",
    "sat": "def sat(substrings: List[str], s=\"deryvymitagedujihuxenewuthyrudeciboquasexyviquekom\", count=1245):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"deryvymitagedujihuxenewuthyrudeciboquasexyviquekom\", count=1245):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_6",
    "sat": "def sat(substrings: List[str], s=\"pateludumuvomajijyquyzisatyte\", count=421):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"pateludumuvomajijyquyzisatyte\", count=421):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_7",
    "sat": "def sat(substrings: List[str], s=\"wuberizujykequoxolathithejochoque\", count=545):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"wuberizujykequoxolathithejochoque\", count=545):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_8",
    "sat": "def sat(substrings: List[str], s=\"taxuquulojynucemuribopowogocasaberytopivikovuchu\", count=1150):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"taxuquulojynucemuribopowogocasaberytopivikovuchu\", count=1150):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrIn2_9",
    "sat": "def sat(substrings: List[str], s=\"fepujygiquotexty\", count=133):\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "sols": [
      "def sol(s=\"fepujygiquotexty\", count=133):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_0",
    "sat": "def sat(string: str, substring=\"a\", count=10, length=100):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"a\", count=10, length=100):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_1",
    "sat": "def sat(string: str, substring=\"niwiweg\", count=26, length=483):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"niwiweg\", count=26, length=483):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_2",
    "sat": "def sat(string: str, substring=\"quiwu\", count=77, length=842):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"quiwu\", count=77, length=842):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_3",
    "sat": "def sat(string: str, substring=\"loqu\", count=99, length=1160):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"loqu\", count=99, length=1160):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_4",
    "sat": "def sat(string: str, substring=\"xojythi\", count=96, length=712):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"xojythi\", count=96, length=712):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_5",
    "sat": "def sat(string: str, substring=\"ser\", count=3, length=673):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"ser\", count=3, length=673):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_6",
    "sat": "def sat(string: str, substring=\"her\", count=72, length=847):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"her\", count=72, length=847):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_7",
    "sat": "def sat(string: str, substring=\"thu\", count=57, length=313):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"thu\", count=57, length=313):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_8",
    "sat": "def sat(string: str, substring=\"g\", count=87, length=906):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"g\", count=87, length=906):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrCount_9",
    "sat": "def sat(string: str, substring=\"xu\", count=18, length=966):\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length",
    "sols": [
      "def sol(substring=\"xu\", count=18, length=966):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_0",
    "sat": "def sat(x: str, parts=['I', 'love', 'dumplings', '!'], length=100):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['I', 'love', 'dumplings', '!'], length=100):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_1",
    "sat": "def sat(x: str, parts=['lixotextuquokoso', 'cicivigusovatos', 'nojyronalicycha'], length=103):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['lixotextuquokoso', 'cicivigusovatos', 'nojyronalicycha'], length=103):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_2",
    "sat": "def sat(x: str, parts=['burytextib', 'saxurofyk', 'ruzyq', 'chi', 'xycyl'], length=110):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['burytextib', 'saxurofyk', 'ruzyq', 'chi', 'xycyl'], length=110):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_3",
    "sat": "def sat(x: str, parts=['quyrucanalotiwaz'], length=102):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['quyrucanalotiwaz'], length=102):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_4",
    "sat": "def sat(x: str, parts=['fathuzu', 'giwuthejamedoq', 'jyzinyj', 'v', 'zatha'], length=57):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['fathuzu', 'giwuthejamedoq', 'jyzinyj', 'v', 'zatha'], length=57):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_5",
    "sat": "def sat(x: str, parts=['duchat', 'w', 'tihaqui', 'zumaw', 'jaquytizawigelim'], length=44):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['duchat', 'w', 'tihaqui', 'zumaw', 'jaquytizawigelim'], length=44):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_6",
    "sat": "def sat(x: str, parts=['w', 'rygiwiwykocetext', 'retextikylacherethid'], length=82):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['w', 'rygiwiwykocetext', 'retextikylacherethid'], length=82):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_7",
    "sat": "def sat(x: str, parts=['chebetextu', 'pac', 'tamogolychigapujerib'], length=127):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['chebetextu', 'pac', 'tamogolychigapujerib'], length=127):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_8",
    "sat": "def sat(x: str, parts=['lefo', 'xofezu', 'jur'], length=30):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['lefo', 'xofezu', 'jur'], length=30):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplit_9",
    "sat": "def sat(x: str, parts=['ludono', 'da', 'thisozazitucekoji', 'honolixothocham'], length=78):\n    \"\"\"Find a string of a given length with a certain split\"\"\"\n    return len(x) == length and x.split() == parts",
    "sols": [
      "def sol(parts=['ludono', 'da', 'thisozazitucekoji', 'honolixothocham'], length=78):\n    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_0",
    "sat": "def sat(x: str, parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_1",
    "sat": "def sat(x: str, parts=['po', 'mucyhosukoch', 'miletextexetyfotyhyd', 'nynochot'], string=\"pogalomucyhosukochgalomiletextexetyfotyhydgalonynochot\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['po', 'mucyhosukoch', 'miletextexetyfotyhyd', 'nynochot'], string=\"pogalomucyhosukochgalomiletextexetyfotyhydgalonynochot\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_2",
    "sat": "def sat(x: str, parts=['bothodyzutextozupaj', 'chisyrypuwonogoryta', 'biworure', 'nocu'], string=\"bothodyzutextozupajzalchisyrypuwonogorytazalbiworurezalnocu\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['bothodyzutextozupaj', 'chisyrypuwonogoryta', 'biworure', 'nocu'], string=\"bothodyzutextozupajzalchisyrypuwonogorytazalbiworurezalnocu\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_3",
    "sat": "def sat(x: str, parts=['galil', 'quiwitanat', 'jymasihe'], string=\"galilmoroxyjibediquydynabquiwitanatmoroxyjibediquydynabjymasihe\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['galil', 'quiwitanat', 'jymasihe'], string=\"galilmoroxyjibediquydynabquiwitanatmoroxyjibediquydynabjymasihe\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_4",
    "sat": "def sat(x: str, parts=['cari', 'zi', 'tugythachyjywiniwep', 'textarucijithazuz'], string=\"carisyvelejetumoreczisyvelejetumorectugythachyjywiniwepsyvelejetumorectextarucijithazuz\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['cari', 'zi', 'tugythachyjywiniwep', 'textarucijithazuz'], string=\"carisyvelejetumoreczisyvelejetumorectugythachyjywiniwepsyvelejetumorectextarucijithazuz\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_5",
    "sat": "def sat(x: str, parts=['gaxamequodozo', 'kydoxyxaqu', 'f', 'thiquigi'], string=\"gaxamequodozojothechuboditokydoxyxaqujothechuboditofjothechuboditothiquigi\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['gaxamequodozo', 'kydoxyxaqu', 'f', 'thiquigi'], string=\"gaxamequodozojothechuboditokydoxyxaqujothechuboditofjothechuboditothiquigi\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_6",
    "sat": "def sat(x: str, parts=['cachuhynetojotexted', 'notojesaquonyduq', 'volycesasyloc'], string=\"cachuhynetojotextedhanotojesaquonyduqhavolycesasyloc\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['cachuhynetojotexted', 'notojesaquonyduq', 'volycesasyloc'], string=\"cachuhynetojotextedhanotojesaquonyduqhavolycesasyloc\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_7",
    "sat": "def sat(x: str, parts=['nutextacinytexto'], string=\"nutextacinytexto\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['nutextacinytexto'], string=\"nutextacinytexto\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_8",
    "sat": "def sat(x: str, parts=['henotextir', 'hoj', 'fyfuzol'], string=\"henotextirzikiwisylatextojeghojzikiwisylatextojegfyfuzol\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['henotextir', 'hoj', 'fyfuzol'], string=\"henotextirzikiwisylatextojeghojzikiwisylatextojegfyfuzol\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrSplitter_9",
    "sat": "def sat(x: str, parts=['vycoj'], string=\"vycoj\"):\n    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"\n    return string.split(x) == parts",
    "sols": [
      "def sol(parts=['vycoj'], string=\"vycoj\"):\n    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_0",
    "sat": "def sat(x: str, parts=['I!!', '!love', 'dumplings', '!', ''], string=\"I!!!!!love!!dumplings!!!!!\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['I!!', '!love', 'dumplings', '!', ''], string=\"I!!!!!love!!dumplings!!!!!\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_1",
    "sat": "def sat(x: str, parts: List[str]=[], string=\"\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=[], string=\"\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_2",
    "sat": "def sat(x: str, parts=['thaquuwuvapes', 'togechilusus', 'xusypijythufilino', 'thibuc'], string=\"thaquuwuvapesxabesojtogechilususxabesojxusypijythufilinoxabesojthibuc\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['thaquuwuvapes', 'togechilusus', 'xusypijythufilino', 'thibuc'], string=\"thaquuwuvapesxabesojtogechilususxabesojxusypijythufilinoxabesojthibuc\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_3",
    "sat": "def sat(x: str, parts=['pydovelafec'], string=\"pydovelafec\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['pydovelafec'], string=\"pydovelafec\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_4",
    "sat": "def sat(x: str, parts=['lazehit'], string=\"lazehit\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['lazehit'], string=\"lazehit\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_5",
    "sat": "def sat(x: str, parts=['lewobil'], string=\"lewobil\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['lewobil'], string=\"lewobil\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_6",
    "sat": "def sat(x: str, parts=['momin', 'pothimik', 'lekem', 'rychirij'], string=\"momingasepemobelizehypothimikgasepemobelizehylekemgasepemobelizehyrychirij\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['momin', 'pothimik', 'lekem', 'rychirij'], string=\"momingasepemobelizehypothimikgasepemobelizehylekemgasepemobelizehyrychirij\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_7",
    "sat": "def sat(x: str, parts=[''], string=\"\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=[''], string=\"\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_8",
    "sat": "def sat(x: str, parts=['do', 'rivojygo', 'hijefo', 'xykovogop'], string=\"dogodytextrivojygogodytexthijefogodytextxykovogop\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['do', 'rivojygo', 'hijefo', 'xykovogop'], string=\"dogodytextrivojygogodytexthijefogodytextxykovogop\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrJoiner_9",
    "sat": "def sat(x: str, parts=['bihidogomugoromi', 'muthovawal', 'nezathypecisehof', 'tikiry'], string=\"bihidogomugoromiryquubedofypybmuthovawalryquubedofypybnezathypecisehofryquubedofypybtikiry\"):\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string",
    "sols": [
      "def sol(parts=['bihidogomugoromi', 'muthovawal', 'nezathypecisehof', 'tikiry'], string=\"bihidogomugoromiryquubedofypybmuthovawalryquubedofypybnezathypecisehofryquubedofypybtikiry\"):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_0",
    "sat": "def sat(parts: List[str], sep=\"!!\", string=\"I!!!!!love!!dumplings!!!!!\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"!!\", string=\"I!!!!!love!!dumplings!!!!!\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_1",
    "sat": "def sat(parts: List[str], sep=\"tiwuhoraxovus\", string=\"magydycovu\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"tiwuhoraxovus\", string=\"magydycovu\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_2",
    "sat": "def sat(parts: List[str], sep=\"fatextoc\", string=\"fychelixusitextfatextoczenecochitextiwagymafatextocp\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"fatextoc\", string=\"fychelixusitextfatextoczenecochitextiwagymafatextocp\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_3",
    "sat": "def sat(parts: List[str], sep=\"quitherat\", string=\"\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"quitherat\", string=\"\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_4",
    "sat": "def sat(parts: List[str], sep=\"ceter\", string=\"fceterbexejedibuthatunocetergypexyxitextutac\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"ceter\", string=\"fceterbexejedibuthatunocetergypexyxitextutac\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_5",
    "sat": "def sat(parts: List[str], sep=\"xogudyruxahecozo\", string=\"\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"xogudyruxahecozo\", string=\"\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_6",
    "sat": "def sat(parts: List[str], sep=\"huv\", string=\"bekakedylivypusymecahuvhuvkazeby\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"huv\", string=\"bekakedylivypusymecahuvhuvkazeby\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_7",
    "sat": "def sat(parts: List[str], sep=\"x\", string=\"thixgilosycene\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"x\", string=\"thixgilosycene\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_8",
    "sat": "def sat(parts: List[str], sep=\"maxuruthehovagad\", string=\"figomufekevudyc\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"maxuruthehovagad\", string=\"figomufekevudyc\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "StrParts_9",
    "sat": "def sat(parts: List[str], sep=\"kuwapuquy\", string=\"hixinuvebazusatekuwapuquytextofefechkuwapuquypejajigelaquodujkuwapuquychywisojihufotext\"):\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "sols": [
      "def sol(sep=\"kuwapuquy\", string=\"hixinuvebazusatekuwapuquytextofefechkuwapuquypejajigelaquodujkuwapuquychywisojihufotext\"):\n    return string.split(sep)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_0",
    "sat": "def sat(li: List[int], dups=42155):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=42155):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_1",
    "sat": "def sat(li: List[int], dups=85546):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=85546):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_2",
    "sat": "def sat(li: List[int], dups=3551):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=3551):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_3",
    "sat": "def sat(li: List[int], dups=52623):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=52623):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_4",
    "sat": "def sat(li: List[int], dups=30820):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=30820):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_5",
    "sat": "def sat(li: List[int], dups=62835):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=62835):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_6",
    "sat": "def sat(li: List[int], dups=20845):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=20845):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_7",
    "sat": "def sat(li: List[int], dups=67175):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=67175):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_8",
    "sat": "def sat(li: List[int], dups=57631):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=57631):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSetLen_9",
    "sat": "def sat(li: List[int], dups=23863):\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups",
    "sols": [
      "def sol(dups=23863):\n    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_0",
    "sat": "def sat(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[17, 9, -1, 17, 9, -1], n=2):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_1",
    "sat": "def sat(li: List[int], target: List[int]=[], n=0):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[], n=0):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_2",
    "sat": "def sat(li: List[int], target=[23383, 84440, 27391, 77658, 73736, -67493, -81632, 77868, -38842, 23383, 84440, 27391, 77658, 73736, -67493, -81632, 77868, -38842], n=2):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[23383, 84440, 27391, 77658, 73736, -67493, -81632, 77868, -38842, 23383, 84440, 27391, 77658, 73736, -67493, -81632, 77868, -38842], n=2):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_3",
    "sat": "def sat(li: List[int], target=[90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649], n=5):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649, 90830, 96627, -88832, -33311, 28856, 18565, 16649], n=5):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_4",
    "sat": "def sat(li: List[int], target=[-86463, -86463, -86463, -86463, -86463, -86463, -86463, -86463], n=4):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[-86463, -86463, -86463, -86463, -86463, -86463, -86463, -86463], n=4):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_5",
    "sat": "def sat(li: List[int], target=[-49911, -24323, 23799, -36761, -46160, -68088, 28372, -49911, -24323, 23799, -36761, -46160, -68088, 28372, -49911, -24323, 23799, -36761, -46160, -68088, 28372], n=3):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[-49911, -24323, 23799, -36761, -46160, -68088, 28372, -49911, -24323, 23799, -36761, -46160, -68088, 28372, -49911, -24323, 23799, -36761, -46160, -68088, 28372], n=3):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_6",
    "sat": "def sat(li: List[int], target=[54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828], n=9):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828, 54774, 80868, -49172, -34400, 27415, 76532, -12685, 37828], n=9):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_7",
    "sat": "def sat(li: List[int], target=[58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129], n=8):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129, 58031, -27196, -42129], n=8):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_8",
    "sat": "def sat(li: List[int], target=[591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638], n=9):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638, 591, -4620, -73938, 29638], n=9):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListMul_9",
    "sat": "def sat(li: List[int], target=[-55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301], n=7):\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target",
    "sols": [
      "def sol(target=[-55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301, -55482, 34442, -64301], n=7):\n    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_0",
    "sat": "def sat(li: List[int], n=85012):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=85012):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_1",
    "sat": "def sat(li: List[int], n=6):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=6):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_2",
    "sat": "def sat(li: List[int], n=8):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=8):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_3",
    "sat": "def sat(li: List[int], n=6000):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=6000):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_4",
    "sat": "def sat(li: List[int], n=7411):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=7411):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_5",
    "sat": "def sat(li: List[int], n=88):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=88):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_6",
    "sat": "def sat(li: List[int], n=865):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=865):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_7",
    "sat": "def sat(li: List[int], n=9):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=9):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_8",
    "sat": "def sat(li: List[int], n=9708):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=9708):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListLen_9",
    "sat": "def sat(li: List[int], n=512):\n    \"\"\"Find a list of a given length n\"\"\"\n    return len(li) == n",
    "sols": [
      "def sol(n=512):\n    return [1] * n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_0",
    "sat": "def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_1",
    "sat": "def sat(i: int, li=[68, 64], target=64):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[68, 64], target=64):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_2",
    "sat": "def sat(i: int, li=[-61, 39, 81, 69, 87, -76, -62, 98, 94, -90, -99, 58, 39, 56], target=81):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[-61, 39, 81, 69, 87, -76, -62, 98, 94, -90, -99, 58, 39, 56], target=81):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_3",
    "sat": "def sat(i: int, li=[-47, -7, -49, -46, -38, 11, 7, 44, 19, -29, 28], target=11):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[-47, -7, -49, -46, -38, 11, 7, 44, 19, -29, 28], target=11):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_4",
    "sat": "def sat(i: int, li=[-10, -74, -40, -46, -32, -41, -86, -14, -77], target=-32):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[-10, -74, -40, -46, -32, -41, -86, -14, -77], target=-32):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_5",
    "sat": "def sat(i: int, li=[91, -84, -13, -49, -42, 63, 38, 50, 59, -29, -62, -31], target=50):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[91, -84, -13, -49, -42, 63, 38, 50, 59, -29, -62, -31], target=50):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_6",
    "sat": "def sat(i: int, li=[-13, 71, -82, 18, -68, 81, -100, 83], target=71):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[-13, 71, -82, 18, -68, 81, -100, 83], target=71):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_7",
    "sat": "def sat(i: int, li=[-68, 48, 95, 58, 74, 83, 18, 16, -26], target=-26):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[-68, 48, 95, 58, 74, 83, 18, 16, -26], target=-26):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_8",
    "sat": "def sat(i: int, li=[92], target=92):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[92], target=92):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListAt_9",
    "sat": "def sat(i: int, li=[67, -50, 6, -39, -75, -1, -49], target=6):\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target",
    "sols": [
      "def sol(li=[67, -50, 6, -39, -75, -1, -49], target=6):\n    return li.index(target)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_0",
    "sat": "def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[17, 31, 91, 18, 42, 1, 9], target=91):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_1",
    "sat": "def sat(i: int, li=[-91, -42, -47, 10, -81, 91, -7, -73, 87, 78], target=10):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[-91, -42, -47, 10, -81, 91, -7, -73, 87, 78], target=10):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_2",
    "sat": "def sat(i: int, li=[-46, 9, 77, 67, -32, 32, 62, 14, 50, -52, 96, -20, -99, -30, 77, 58], target=58):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[-46, 9, 77, 67, -32, 32, 62, 14, 50, -52, 96, -20, -99, -30, 77, 58], target=58):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_3",
    "sat": "def sat(i: int, li=[-65, -3, 35, 43, -13, 41, 15, -41, -62, -21], target=-41):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[-65, -3, 35, 43, -13, 41, 15, -41, -62, -21], target=-41):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_4",
    "sat": "def sat(i: int, li=[88, -24, -20, 4, -21, -64, 26, 83, -9, -70, -96, -99, -36, -6, -42], target=-20):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[88, -24, -20, 4, -21, -64, 26, 83, -9, -70, -96, -99, -36, -6, -42], target=-20):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_5",
    "sat": "def sat(i: int, li=[52, -61, -83, -8, -36, 83, -76, 47, 80, -49, 11], target=47):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[52, -61, -83, -8, -36, 83, -76, 47, 80, -49, 11], target=47):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_6",
    "sat": "def sat(i: int, li=[-69, 70, -36, 66, -81], target=-81):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[-69, 70, -36, 66, -81], target=-81):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_7",
    "sat": "def sat(i: int, li=[75], target=75):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[75], target=75):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_8",
    "sat": "def sat(i: int, li=[42, 86, -76, -2, 55, -4, -31, 23, 71, -93, -1, 75, -24], target=71):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[42, 86, -76, -2, 55, -4, -31, 23, 71, -93, -1, 75, -24], target=71):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListNegAt_9",
    "sat": "def sat(i: int, li=[40, 25, 91, -14, -100, 6, 1, -44, -98, 18], target=1):\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0",
    "sols": [
      "def sol(li=[40, 25, 91, -14, -100, 6, 1, -44, -98, 18], target=1):\n    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_0",
    "sat": "def sat(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_1",
    "sat": "def sat(inds: List[int], li=[69, -58, -39, -83, 61, -7, 82, -28, 6, -48, 71, 44, 56, 84, 25, -14], target=[71]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[69, -58, -39, -83, 61, -7, 82, -28, 6, -48, 71, 44, 56, 84, 25, -14], target=[71]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_2",
    "sat": "def sat(inds: List[int], li=[-6, -22, -35, 9, 26, 84], target=[84]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[-6, -22, -35, 9, 26, 84], target=[84]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_3",
    "sat": "def sat(inds: List[int], li=[29, -90, 49, 16, -56, -85, 48, -77, -39, -21, 88, -99, -81, 13, 48, -17, 44, -85, -87], target=[29]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[29, -90, 49, 16, -56, -85, 48, -77, -39, -21, 88, -99, -81, 13, 48, -17, 44, -85, -87], target=[29]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_4",
    "sat": "def sat(inds: List[int], li=[78, 78, -22, 73, 1, -59, -36, -59], target=[-22, -36]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[78, 78, -22, 73, 1, -59, -36, -59], target=[-22, -36]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_5",
    "sat": "def sat(inds: List[int], li=[-47, -67, -100, 34, 97, 92, -62, -100, 85, -43, -78, 90], target=[-100]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[-47, -67, -100, 34, 97, 92, -62, -100, 85, -43, -78, 90], target=[-100]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_6",
    "sat": "def sat(inds: List[int], li=[87, 94, 47, -12, 29], target: List[int]=[]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[87, 94, 47, -12, 29], target=[]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_7",
    "sat": "def sat(inds: List[int], li=[-84, -72, -95, -42, 84, 4, -51, -43, 79], target=[84, -51]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[-84, -72, -95, -42, 84, 4, -51, -43, 79], target=[84, -51]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_8",
    "sat": "def sat(inds: List[int], li=[-41, 96, 83, 67, 32, 37, -44, 95, -4, -28, -97, -53, -51, -61], target=[-97]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[-41, 96, 83, 67, 32, 37, -44, 95, -4, -28, -97, -53, -51, -61], target=[-97]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListSlice_9",
    "sat": "def sat(inds: List[int], li=[-64, -35, 93, -80, -85, -64, 16, 35, 45, -70, -36, 20, 99, -45, -29, 9], target=[20]):\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    i, j, k = inds\n    return li[i:j:k] == target",
    "sols": [
      "def sol(li=[-64, -35, 93, -80, -85, -64, 16, 35, 45, -70, -36, 20, 99, -45, -29, 9], target=[20]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_0",
    "sat": "def sat(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[17, 2, 3, 9, 11, 11], index=4):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_1",
    "sat": "def sat(item: int, li=[59, -44, 9, -37, 87, -57, 73, 96, 56, -14, -9, -10, -91, 86], index=10):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[59, -44, 9, -37, 87, -57, 73, 96, 56, -14, -9, -10, -91, 86], index=10):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_2",
    "sat": "def sat(item: int, li=[85, 39, 8, -40, 69, 46, 76, -61, 40, 75, 95, -15], index=5):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[85, 39, 8, -40, 69, 46, 76, -61, 40, 75, 95, -15], index=5):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_3",
    "sat": "def sat(item: int, li=[-13, 27, -34, 54, -14, -29, 56, 13, -15, 96, 84, -71, -46], index=1):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[-13, 27, -34, 54, -14, -29, 56, 13, -15, 96, 84, -71, -46], index=1):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_4",
    "sat": "def sat(item: int, li=[54, 84, -57, -81, 68, 18, 14], index=1):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[54, 84, -57, -81, 68, 18, 14], index=1):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_5",
    "sat": "def sat(item: int, li=[-37, -82, 11, -69, -38, -97, 18, 24], index=3):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[-37, -82, 11, -69, -38, -97, 18, 24], index=3):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_6",
    "sat": "def sat(item: int, li=[-33, 41, 44, -1], index=1):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[-33, 41, 44, -1], index=1):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_7",
    "sat": "def sat(item: int, li=[90, 47], index=1):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[90, 47], index=1):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_8",
    "sat": "def sat(item: int, li=[-46, -24, -19, -76, 53, -50, 69, -35, 52], index=2):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[-46, -24, -19, -76, 53, -50, 69, -35, 52], index=2):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex_9",
    "sat": "def sat(item: int, li=[-26, -82, -50, 94, 55, 87, 45, -6, 59, -47, 67, -91, -72, 12, -56], index=4):\n    \"\"\"Find the item whose first index in li is index\"\"\"\n    return li.index(item) == index",
    "sols": [
      "def sol(li=[-26, -82, -50, 94, 55, 87, 45, -6, 59, -47, 67, -91, -72, 12, -56], index=4):\n    return li[index]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_0",
    "sat": "def sat(li: List[int], i=29, index=10412):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=29, index=10412):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_1",
    "sat": "def sat(li: List[int], i=59398, index=10211):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=59398, index=10211):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_2",
    "sat": "def sat(li: List[int], i=-83668, index=98919):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=-83668, index=98919):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_3",
    "sat": "def sat(li: List[int], i=55770, index=30698):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=55770, index=30698):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_4",
    "sat": "def sat(li: List[int], i=-88841, index=32921):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=-88841, index=32921):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_5",
    "sat": "def sat(li: List[int], i=7852, index=55843):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=7852, index=55843):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_6",
    "sat": "def sat(li: List[int], i=2355, index=39653):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=2355, index=39653):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_7",
    "sat": "def sat(li: List[int], i=-41344, index=7341):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=-41344, index=7341):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_8",
    "sat": "def sat(li: List[int], i=-3150, index=20122):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=-3150, index=20122):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIndex2_9",
    "sat": "def sat(li: List[int], i=8654, index=30629):\n    \"\"\"Find a list that contains i first at index index\"\"\"\n    return li.index(i) == index",
    "sols": [
      "def sol(i=8654, index=30629):\n    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_0",
    "sat": "def sat(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_1",
    "sat": "def sat(s: str, a=['gud', 'bygunyhaxakebysoc', 'majop', 'bomu', 'xuwedu', 'b', 'zefugaliquu', 'n', 'diq', 'chokiwajatequuxafic', 'hyhychug', 'lyvic', 'durehavelumac', 'xugusehamubofevatext', 'citunarygujawol', 'chohorotext', 'quichyw', 'zezacha', 'cojyhipisunaquetext', 'v', 'sytisot', 'chevidiq', 'calowuhifuvoniwute', 'xuthyfihudafevy', 'x', 'chisisunuwehex', 'quamequudigecate', 'zigytubonocem', 'revyvazawaganasut', 'hyth', 'quuquochiwuficyp', 'vugymepufirokiti', 'pegol', 'quit', 'wythitextucinux', 'wic', 'r', 'ho', 'th', 'd', 'vyxedu', 'quepetextavozy', 'kethur', 'petextyguche', 'finirequylyhegyvo', 'laxa', 'guchunohixoquoryquov', 'pu', 'fenihe', 'citatugajifozurefip', 'buca', 'textu', 'kecucifu', 'dibynythobichysot', 'xucokosuky', 'hil', 'cunojoluquovuqui', 'culufywuxelifugok', 'wakalicu', 'maquudyxivilabuka', 'jujivipo', 'chawajivychu', 'zohutextawetext', 'w', 'jazachochu', 'ponypytextanase', 'chemyte', 'wychomagem', 'gobocosozahecajufevu', 'vijeguligebe', 'chithibupijyquuche'], b=['chizufy', 'timoxivoridevute', 'ne', 'vijeguligebe', 'fowuboquipeju', 'kufe', 'ch', 'chywe', 'jiletex', 'cichylajuveput', 'chejujetextasoliluma', 'thykenylyfafefifoko', 'zinipymachycasoth', 'cohothigithomusuhe', 'nicith', 'soquyricoxoli', 'gehyruruxotivufufeha']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['gud', 'bygunyhaxakebysoc', 'majop', 'bomu', 'xuwedu', 'b', 'zefugaliquu', 'n', 'diq', 'chokiwajatequuxafic', 'hyhychug', 'lyvic', 'durehavelumac', 'xugusehamubofevatext', 'citunarygujawol', 'chohorotext', 'quichyw', 'zezacha', 'cojyhipisunaquetext', 'v', 'sytisot', 'chevidiq', 'calowuhifuvoniwute', 'xuthyfihudafevy', 'x', 'chisisunuwehex', 'quamequudigecate', 'zigytubonocem', 'revyvazawaganasut', 'hyth', 'quuquochiwuficyp', 'vugymepufirokiti', 'pegol', 'quit', 'wythitextucinux', 'wic', 'r', 'ho', 'th', 'd', 'vyxedu', 'quepetextavozy', 'kethur', 'petextyguche', 'finirequylyhegyvo', 'laxa', 'guchunohixoquoryquov', 'pu', 'fenihe', 'citatugajifozurefip', 'buca', 'textu', 'kecucifu', 'dibynythobichysot', 'xucokosuky', 'hil', 'cunojoluquovuqui', 'culufywuxelifugok', 'wakalicu', 'maquudyxivilabuka', 'jujivipo', 'chawajivychu', 'zohutextawetext', 'w', 'jazachochu', 'ponypytextanase', 'chemyte', 'wychomagem', 'gobocosozahecajufevu', 'vijeguligebe', 'chithibupijyquuche'], b=['chizufy', 'timoxivoridevute', 'ne', 'vijeguligebe', 'fowuboquipeju', 'kufe', 'ch', 'chywe', 'jiletex', 'cichylajuveput', 'chejujetextasoliluma', 'thykenylyfafefifoko', 'zinipymachycasoth', 'cohothigithomusuhe', 'nicith', 'soquyricoxoli', 'gehyruruxotivufufeha']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_2",
    "sat": "def sat(s: str, a=['wuzawyvipavozachi', 'r', 'kydahemezih', 'byredozase', 'din', 'xuwihuq', 'refecitextiquychesuh', 'lirynyhochonosoxuf', 'bumivukyhaxipycothi', 'xachydixefotebu', 'xaquatanibotadabovih', 'quavatextomefuwu', 'torahiwy', 'he', 'nubaxewosinybidite', 'fitex', 'futextytext', 'fefuquemevihub'], b=['zivethith', 'miqu', 'tex', 'gamug', 'q', 'haquohaquanipyketh', 'buhawodevuhazasa', 'datohexytext', 'fufycoquecag', 'jojagi', 'c', 'noquiquichynuquybo', 'kydahemezih', 'ch', 'cic', 'soget', 'xatextumudanukiquyca', 'kutahoj', 'dyfyxywytexty', 'xevutequutexte', 'vahyhutextapif', 'pethobejohez', 'vavadi', 'kut', 'nuquilixubikedac', 'n', 'zalisitextivaru', 'buquavalaly', 've', 'xuju', 'latextiquoxegytuky', 'textunacimutotythybu', 'tex']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['wuzawyvipavozachi', 'r', 'kydahemezih', 'byredozase', 'din', 'xuwihuq', 'refecitextiquychesuh', 'lirynyhochonosoxuf', 'bumivukyhaxipycothi', 'xachydixefotebu', 'xaquatanibotadabovih', 'quavatextomefuwu', 'torahiwy', 'he', 'nubaxewosinybidite', 'fitex', 'futextytext', 'fefuquemevihub'], b=['zivethith', 'miqu', 'tex', 'gamug', 'q', 'haquohaquanipyketh', 'buhawodevuhazasa', 'datohexytext', 'fufycoquecag', 'jojagi', 'c', 'noquiquichynuquybo', 'kydahemezih', 'ch', 'cic', 'soget', 'xatextumudanukiquyca', 'kutahoj', 'dyfyxywytexty', 'xevutequutexte', 'vahyhutextapif', 'pethobejohez', 'vavadi', 'kut', 'nuquilixubikedac', 'n', 'zalisitextivaru', 'buquavalaly', 've', 'xuju', 'latextiquoxegytuky', 'textunacimutotythybu', 'tex']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_3",
    "sat": "def sat(s: str, a=['quahofygefynihohy', 'ko', 'tuchiwurumasochego', 'licegunerymytexta', 'honaset', 'myfunicocydyzechenyg', 'textu', 'c', 'chafumufe', 'ryjinymyz', 'pyfiximilyd', 'jelyquanetextyn', 'thymebawapyquucy', 'xovevegiput', 'dythejifecupeq', 'text', 'thur', 'dypejolypyb', 'gychahorysigadaj'], b=['t', 'luchycheti', 'jynavutextygefosi', 'textyliby', 'sigynimepegidiji', 'kythypupyxyw', 'nutajig', 'fofukidum', 'zepitextogahunac', 'rofujepu', 'rechybetextulanac', 'tuhyj', 'jyzis', 'vywylet', 'tufisezyn', 'sawyly', 'fizu', 'rygotextaxynat', 'koxajofopedelo', 'syzythath', 'thythog', 'wolydotextetyt', 'thyjyfut', 'ninotek', 'buhujyquevowemosadot', 'mochamajywutext', 'vyzakibyle', 'quu', 'jyrudochon', 'textawegetuny', 'xykoquo', 'quuvachywypivekyxi', 'korota', 'mafefuchy', 'pucechyzowamac', 'q', 'fywamylu', 'typagete', 'sogopali', 'bethyx', 'sygavysynec', 'roma', 'chubechemazytextyfe', 'wuko', 'filetextoxat', 'focijuvitichuni', 'vazecetextytextud', 'quijaw', 'wethochesov', 'licegunerymytexta', 'pogithabipigotext', 'caka', 'hethicuchex', 'chuxaguhyboxef', 'b', 'dazytham', 'zytextuge', 'pobenydigajazowesi', 'sothechoxinubemu', 'cothu', 'jathetehuwohothi', 'duco', 'hatefivavuquuchap', 'nef', 'thozygehitextule', 'xa', 'thezyferekufalat', 'textyfodinumyp', 'ribuluhaxuwohavihir', 'chuhewoduthar', 'textachiquit', 'lehemujicuhulibudove', 'w', 'textugytuwisuc', 'wamejecafykolyha', 'pumetexticuracebo', 'chiliwaf', 'ruwecukyqu', 'q', 'reb', 'xegoruwatextazo', 'l', 'vynykotheguchimizy', 'nalyxit', 'chyzuxatucukip']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['quahofygefynihohy', 'ko', 'tuchiwurumasochego', 'licegunerymytexta', 'honaset', 'myfunicocydyzechenyg', 'textu', 'c', 'chafumufe', 'ryjinymyz', 'pyfiximilyd', 'jelyquanetextyn', 'thymebawapyquucy', 'xovevegiput', 'dythejifecupeq', 'text', 'thur', 'dypejolypyb', 'gychahorysigadaj'], b=['t', 'luchycheti', 'jynavutextygefosi', 'textyliby', 'sigynimepegidiji', 'kythypupyxyw', 'nutajig', 'fofukidum', 'zepitextogahunac', 'rofujepu', 'rechybetextulanac', 'tuhyj', 'jyzis', 'vywylet', 'tufisezyn', 'sawyly', 'fizu', 'rygotextaxynat', 'koxajofopedelo', 'syzythath', 'thythog', 'wolydotextetyt', 'thyjyfut', 'ninotek', 'buhujyquevowemosadot', 'mochamajywutext', 'vyzakibyle', 'quu', 'jyrudochon', 'textawegetuny', 'xykoquo', 'quuvachywypivekyxi', 'korota', 'mafefuchy', 'pucechyzowamac', 'q', 'fywamylu', 'typagete', 'sogopali', 'bethyx', 'sygavysynec', 'roma', 'chubechemazytextyfe', 'wuko', 'filetextoxat', 'focijuvitichuni', 'vazecetextytextud', 'quijaw', 'wethochesov', 'licegunerymytexta', 'pogithabipigotext', 'caka', 'hethicuchex', 'chuxaguhyboxef', 'b', 'dazytham', 'zytextuge', 'pobenydigajazowesi', 'sothechoxinubemu', 'cothu', 'jathetehuwohothi', 'duco', 'hatefivavuquuchap', 'nef', 'thozygehitextule', 'xa', 'thezyferekufalat', 'textyfodinumyp', 'ribuluhaxuwohavihir', 'chuhewoduthar', 'textachiquit', 'lehemujicuhulibudove', 'w', 'textugytuwisuc', 'wamejecafykolyha', 'pumetexticuracebo', 'chiliwaf', 'ruwecukyqu', 'q', 'reb', 'xegoruwatextazo', 'l', 'vynykotheguchimizy', 'nalyxit', 'chyzuxatucukip']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_4",
    "sat": "def sat(s: str, a=['desahosat', 'fadupaxytextogetexty', 'quubymuquutextate', 'kenezy', 'thozog', 'lexosihaqui', 'vujocudutaquiruhisi', 'pyzinabimuquamamoc', 'jo', 'tabuzigyrabezaby', 'voretutextutoh', 'j', 'textyzegut', 'textiwofuw', 'tex', 'cusachaxeb', 'fatextatextakyj', 'gazihythedizoquivuz', 'tasotogazuxykegixafi', 'ryvelywytibytextaco', 'katulygitajekela', 'quap', 'vatizojigolecoquepy', 'te', 'quen', 'x', 'th', 'welyxerofachazepihat', 'ryzuc', 'gelokinec', 'texta', 'vochiwalikovyvaxet', 'zutex', 'fypuwurenevekidihy', 'devytudadopejamakyt', 'l', 'puvut', 'negolazidige', 'textuvaregitho', 'lemidychath', 'texoguquypocuthoc', 'gethoh', 'cutex', 'rehubelyxu', 'wutextovom', 'mafevutabujejabak', 'wovafylyp', 'nichyref', 'n', 'hyxutuvagok', 'nerotextebokodyvycor', 'b', 'j', 'pu', 'zuw', 'tothaguthotexteko', 'jejivut', 'xefesaculunukaxate', 'zategelobuth', 'wozyr', 'potoquuhythem', 'thogujek', 'kytextiwabinu', 'thofuthow', 'cizewiquajiquaqua', 'zironymutedytijadow', 'lyfipachydeky', 'quiconefuwycu', 'ponynusetecygavytasy', 'jowoch', 'gyvoquoxojykesety', 'vulyforykome', 'cusyqu', 'sabychedewathiqu', 'wylobyly', 'thym', 'buwinyfovidebole', 'raferyhak', 'jalitochypa', 'perehyfathudugo', 'teb', 's', 'g', 'toquehemuhuwyn', 'jydumyd', 'thuthizothis', 'dochopotizu', 'pujywotosoz', 'macuwyjy', 'pypeg', 'zizefoluxixajarubyk', 'chothunigyt'], b=['quakotextychegis', 'nuh', 'runytitextatextufu', 'kewutejaru', 'xyhozaquufyquicajid', 'vytext', 'z', 'bymadoguq', 'rotheh', 'quu', 'xoryh', 'ha', 'chitonezethesuheno', 'jydumyd', 'nehofawodoxur', 'joquicydo', 'wyryc', 'quaxud', 'rykizezawobuzi', 'fofudyjatyjor', 'hipiqu', 'fywibi', 'xithodotechugisotext', 'cawaxamepyxykodyla', 'noxutextulovethyte', 'fibywothibimob', 'tuduwalyquycagoqu', 'ryquetextoxethuvosug', 'themuh', 'hucevifuvu', 'fipevilosazup', 'sip', 'thufafichimixoriv', 'dylefog', 'mutextokoz']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['desahosat', 'fadupaxytextogetexty', 'quubymuquutextate', 'kenezy', 'thozog', 'lexosihaqui', 'vujocudutaquiruhisi', 'pyzinabimuquamamoc', 'jo', 'tabuzigyrabezaby', 'voretutextutoh', 'j', 'textyzegut', 'textiwofuw', 'tex', 'cusachaxeb', 'fatextatextakyj', 'gazihythedizoquivuz', 'tasotogazuxykegixafi', 'ryvelywytibytextaco', 'katulygitajekela', 'quap', 'vatizojigolecoquepy', 'te', 'quen', 'x', 'th', 'welyxerofachazepihat', 'ryzuc', 'gelokinec', 'texta', 'vochiwalikovyvaxet', 'zutex', 'fypuwurenevekidihy', 'devytudadopejamakyt', 'l', 'puvut', 'negolazidige', 'textuvaregitho', 'lemidychath', 'texoguquypocuthoc', 'gethoh', 'cutex', 'rehubelyxu', 'wutextovom', 'mafevutabujejabak', 'wovafylyp', 'nichyref', 'n', 'hyxutuvagok', 'nerotextebokodyvycor', 'b', 'j', 'pu', 'zuw', 'tothaguthotexteko', 'jejivut', 'xefesaculunukaxate', 'zategelobuth', 'wozyr', 'potoquuhythem', 'thogujek', 'kytextiwabinu', 'thofuthow', 'cizewiquajiquaqua', 'zironymutedytijadow', 'lyfipachydeky', 'quiconefuwycu', 'ponynusetecygavytasy', 'jowoch', 'gyvoquoxojykesety', 'vulyforykome', 'cusyqu', 'sabychedewathiqu', 'wylobyly', 'thym', 'buwinyfovidebole', 'raferyhak', 'jalitochypa', 'perehyfathudugo', 'teb', 's', 'g', 'toquehemuhuwyn', 'jydumyd', 'thuthizothis', 'dochopotizu', 'pujywotosoz', 'macuwyjy', 'pypeg', 'zizefoluxixajarubyk', 'chothunigyt'], b=['quakotextychegis', 'nuh', 'runytitextatextufu', 'kewutejaru', 'xyhozaquufyquicajid', 'vytext', 'z', 'bymadoguq', 'rotheh', 'quu', 'xoryh', 'ha', 'chitonezethesuheno', 'jydumyd', 'nehofawodoxur', 'joquicydo', 'wyryc', 'quaxud', 'rykizezawobuzi', 'fofudyjatyjor', 'hipiqu', 'fywibi', 'xithodotechugisotext', 'cawaxamepyxykodyla', 'noxutextulovethyte', 'fibywothibimob', 'tuduwalyquycagoqu', 'ryquetextoxethuvosug', 'themuh', 'hucevifuvu', 'fipevilosazup', 'sip', 'thufafichimixoriv', 'dylefog', 'mutextokoz']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_5",
    "sat": "def sat(s: str, a=['th', 'pyjagusa', 'fyfof', 'xequaquiwo', 'gychajyci', 'wymozo', 'nyporesyw', 'janotextach', 'saju', 'guthafibegosif', 'jysetex', 'quynalo', 'mavuq', 'kethe', 'liquyquavuf', 'lofibebydozeforot', 'mybylebochuxakur', 'dypadefabo', 'luthaboquaj', 'galywuguxut', 'hupysyte', 'chycihezaquepyzewe', 'thogetiris', 'sacu', 'c', 'dym', 'quokuvurohyvyp', 'thydawohotextothasyc', 'buzocosew', 'pichachuvewidetex', 'zujetuxewedotyfitho', 'jaquajisexax', 'wikufo', 'xychyzegahafotext', 'fegyquijuguch', 'que', 'ra', 'chagigotutextobeto', 'chipexukub', 'wytitextyfybeci', 'cugotextegige', 'tyd', 'xedufymucho', 'futyrotuzyhete', 'hubumoquynec', 'jipuwobyronifuja'], b=['rocyquy', 'dewijechutivyzany', 'kebixyhythaciparoha', 'zachokytextamymy', 'textafa', 'rori', 'bo', 'xefovehiquuviriv', 'thithaquathuruzych', 'futyrotuzyhete', 'quyv', 'nyx', 'go', 'sutatextafa', 'nuqu', 'pezebuw', 'le', 'gufitextuhujufedexi', 'cuthihohychuchutext', 'fo', 'lacanududajavufysoj', 'sac', 'livyquelotamisujah', 'tyvotetoduxygumukal', 'dorexyvefez', 'rupogudach', 'latextudiwaxu', 'tahojotextopyla', 'vethunyjylugytexti', 'xigiwysete', 'suquywo', 'kuwi', 'dulochinu', 'chifimaqueka', 'w', 'quigidatil', 'cizecychy', 'textoquaxamiretitex', 'dag', 'vututextobote', 'zochywozurytevyqueti', 'textymukipoxa', 'quatuchuraquipahytex', 'vaxutolasymajypic', 'ku', 'wimaquuganenibe', 'vesytepi', 't', 'ruh', 'thatextare', 'lufelitotumaxev', 'comek', 'pojetextiru', 'xe', 'zopikebalifyjuca', 'kegatyzybozyvoxar', 'myxoquaquomok', 'wethuvunykukaceh', 'hubamichojichedu', 'th', 'textesyf', 'chucythusavyguce', 'hutextofydizyvu', 'soquowatulidibyth', 'wezufycate', 'thukalosi', 'felichahenetextidib', 'text', 'wuthamu', 'thybutextulexe', 'tex', 'ke', 'c', 'xakokomajes', 'tyho', 'vukuquacalogaquuga', 'xiquut', 'pawynynatex', 'joquo', 'kypodugyceveradetex', 'quosojumigechoha', 'quehachyhura']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['th', 'pyjagusa', 'fyfof', 'xequaquiwo', 'gychajyci', 'wymozo', 'nyporesyw', 'janotextach', 'saju', 'guthafibegosif', 'jysetex', 'quynalo', 'mavuq', 'kethe', 'liquyquavuf', 'lofibebydozeforot', 'mybylebochuxakur', 'dypadefabo', 'luthaboquaj', 'galywuguxut', 'hupysyte', 'chycihezaquepyzewe', 'thogetiris', 'sacu', 'c', 'dym', 'quokuvurohyvyp', 'thydawohotextothasyc', 'buzocosew', 'pichachuvewidetex', 'zujetuxewedotyfitho', 'jaquajisexax', 'wikufo', 'xychyzegahafotext', 'fegyquijuguch', 'que', 'ra', 'chagigotutextobeto', 'chipexukub', 'wytitextyfybeci', 'cugotextegige', 'tyd', 'xedufymucho', 'futyrotuzyhete', 'hubumoquynec', 'jipuwobyronifuja'], b=['rocyquy', 'dewijechutivyzany', 'kebixyhythaciparoha', 'zachokytextamymy', 'textafa', 'rori', 'bo', 'xefovehiquuviriv', 'thithaquathuruzych', 'futyrotuzyhete', 'quyv', 'nyx', 'go', 'sutatextafa', 'nuqu', 'pezebuw', 'le', 'gufitextuhujufedexi', 'cuthihohychuchutext', 'fo', 'lacanududajavufysoj', 'sac', 'livyquelotamisujah', 'tyvotetoduxygumukal', 'dorexyvefez', 'rupogudach', 'latextudiwaxu', 'tahojotextopyla', 'vethunyjylugytexti', 'xigiwysete', 'suquywo', 'kuwi', 'dulochinu', 'chifimaqueka', 'w', 'quigidatil', 'cizecychy', 'textoquaxamiretitex', 'dag', 'vututextobote', 'zochywozurytevyqueti', 'textymukipoxa', 'quatuchuraquipahytex', 'vaxutolasymajypic', 'ku', 'wimaquuganenibe', 'vesytepi', 't', 'ruh', 'thatextare', 'lufelitotumaxev', 'comek', 'pojetextiru', 'xe', 'zopikebalifyjuca', 'kegatyzybozyvoxar', 'myxoquaquomok', 'wethuvunykukaceh', 'hubamichojichedu', 'th', 'textesyf', 'chucythusavyguce', 'hutextofydizyvu', 'soquowatulidibyth', 'wezufycate', 'thukalosi', 'felichahenetextidib', 'text', 'wuthamu', 'thybutextulexe', 'tex', 'ke', 'c', 'xakokomajes', 'tyho', 'vukuquacalogaquuga', 'xiquut', 'pawynynatex', 'joquo', 'kypodugyceveradetex', 'quosojumigechoha', 'quehachyhura']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_6",
    "sat": "def sat(s: str, a=['xochet', 'dytextekukot', 'ch', 'citext', 'thithewun', 'popad', 'byrowup', 'nusegozufevalelileth', 'zexothinecud', 'futucychopy', 'se', 'l', 'dazawagolabicamycy', 'raquyte', 'bavuvesyhenowi', 'wawujam', 'mul', 'tywuxa', 'xod', 'zijukeq'], b=['quunavumybijovyhoche', 'mul', 'pasiquapidogojesy', 'filenabutaxi', 'tonisyzyly', 'zajypythaxatu', 'rewytextyq', 'mirutevywytoq', 'wis', 'hylathytextideku', 'nythutupijapytynyset', 'goby', 'duchofajaculazebubiv', 't']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['xochet', 'dytextekukot', 'ch', 'citext', 'thithewun', 'popad', 'byrowup', 'nusegozufevalelileth', 'zexothinecud', 'futucychopy', 'se', 'l', 'dazawagolabicamycy', 'raquyte', 'bavuvesyhenowi', 'wawujam', 'mul', 'tywuxa', 'xod', 'zijukeq'], b=['quunavumybijovyhoche', 'mul', 'pasiquapidogojesy', 'filenabutaxi', 'tonisyzyly', 'zajypythaxatu', 'rewytextyq', 'mirutevywytoq', 'wis', 'hylathytextideku', 'nythutupijapytynyset', 'goby', 'duchofajaculazebubiv', 't']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_7",
    "sat": "def sat(s: str, a=['textovychichoharixig', 'textudezochoquyhoga', 'soguxowechago', 'narochobofi', 'textojo', 'ton', 'jabafi', 'c', 'wydaqu', 'textygaxa', 'puquy', 'kolovesizetythe', 'xinitesoxotat'], b=['memuk', 'thy', 'gadekycawutyfyhe', 'sujegizokythyxevut', 'tatijofotextitho', 'po', 'puquy', 'kiresopewycydaqu', 'wavutumabydapin', 'tu', 'quofo', 'sobulapurofuchyx', 'luwytowyfyl', 'cesinachedodinachy', 'jacijizapyf', 'masuzipuqu']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['textovychichoharixig', 'textudezochoquyhoga', 'soguxowechago', 'narochobofi', 'textojo', 'ton', 'jabafi', 'c', 'wydaqu', 'textygaxa', 'puquy', 'kolovesizetythe', 'xinitesoxotat'], b=['memuk', 'thy', 'gadekycawutyfyhe', 'sujegizokythyxevut', 'tatijofotextitho', 'po', 'puquy', 'kiresopewycydaqu', 'wavutumabydapin', 'tu', 'quofo', 'sobulapurofuchyx', 'luwytowyfyl', 'cesinachedodinachy', 'jacijizapyf', 'masuzipuqu']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_8",
    "sat": "def sat(s: str, a=['jy', 'goxet', 'pocapivyf', 'thucokiwedopajov', 'des', 'hany', 'tylosadiquad', 'futextopachykeho', 'mupemep', 'thunazosyjugat', 'wequypibuhu', 'ji', 'rujibukepody', 'tezogamipahoxi', 'myrihetaputyjij', 'julib', 'jivememy', 'kychyxapoxefejytu', 'bodavuzecys', 'mylythopa', 'kihekyzegyhut', 'zaberowu'], b=['batheduchodaquute', 'rudarac', 'kape', 'texti', 'xaxi', 'cigachuvaratextyc', 'nanapazajufydaty', 'te', 'fafofy', 'rovanaxy', 'thejitextijithahyra', 'thagihoqua', 'zemejywydodedumisuc', 'fotichixu', 'tanojit', 'kyhyte', 'kadawel', 'wizavygesizyna', 'vivakitextasupidafec', 'kewiluhumytextula', 'folynybip', 'kychyhid', 'quejizocecysetextute', 'thedyrevajibotextow', 'chabypuwucobawisifib', 'ta', 'cilochuquothuca', 'keh', 'jeregepucoquidobal', 'jybijohonaxogejichi', 'bynimichusesech', 'wequypibuhu', 'filu', 'tijodon', 'hihorukadexafetext', 'hopynirujase', 'fyp', 'hechomahax', 'henavuvexatextuval', 'folufo']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['jy', 'goxet', 'pocapivyf', 'thucokiwedopajov', 'des', 'hany', 'tylosadiquad', 'futextopachykeho', 'mupemep', 'thunazosyjugat', 'wequypibuhu', 'ji', 'rujibukepody', 'tezogamipahoxi', 'myrihetaputyjij', 'julib', 'jivememy', 'kychyxapoxefejytu', 'bodavuzecys', 'mylythopa', 'kihekyzegyhut', 'zaberowu'], b=['batheduchodaquute', 'rudarac', 'kape', 'texti', 'xaxi', 'cigachuvaratextyc', 'nanapazajufydaty', 'te', 'fafofy', 'rovanaxy', 'thejitextijithahyra', 'thagihoqua', 'zemejywydodedumisuc', 'fotichixu', 'tanojit', 'kyhyte', 'kadawel', 'wizavygesizyna', 'vivakitextasupidafec', 'kewiluhumytextula', 'folynybip', 'kychyhid', 'quejizocecysetextute', 'thedyrevajibotextow', 'chabypuwucobawisifib', 'ta', 'cilochuquothuca', 'keh', 'jeregepucoquidobal', 'jybijohonaxogejichi', 'bynimichusesech', 'wequypibuhu', 'filu', 'tijodon', 'hihorukadexafetext', 'hopynirujase', 'fyp', 'hechomahax', 'henavuvexatextuval', 'folufo']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "ListIn_9",
    "sat": "def sat(s: str, a=['fed', 'quytextet', 'gyzyharoquuzyxykijim', 'chysumum', 'fecathichych', 'textaquygivychi', 'zozawybezekyce', 'larafilawodevilohich', 'gathedudaquixugewety', 'thochuthachite', 'metextathekugy', 'xarizatextudazoq', 'lycajuponejeth', 'techyvojiryb', 'xep', 'hysehikaxyhygyn', 'kadezehohec', 'tuhiw', 'kikythuthe', 'judozunu', 'tu', 'vak', 'pinudirysidagaduzo', 'bacybohelikabijazik', 'kuvolejunihupocho', 'mirycadochalowu', 'tot', 'chy', 'chypijomimutoxytexty', 'lachomythisatexta', 'rizykyhalaweto', 'lu', 'quem', 'zykathet', 'kogochucuwoth', 'typukodyqu', 'tedochowogyn', 'quabalurizicukiridit', 'benochitonek', 'g', 'papujitokizopuwoba', 'thotacaluquuquyda', 'baditathyche', 'texteticur', 'gyfetextan', 'tocha', 'thinariluquov', 'macukywymatubutex', 'lojabituviz', 'fazatextor', 'kyl', 'danatextefesoq', 'textyvuvudiwusizoci', 'piryxu', 'tasemady', 'vapifeholeth', 'dadatextapetykecivok', 'gichenotexturo', 'textisigo', 'textaquicyxotet', 'quycholesipywevykym', 'byf', 'textumy', 'quithepo', 'pywifoq', 'lodytacuth', 'jofenukuzejemyteci', 'rebokapyr', 'wojepytextosadezapy', 'fysothobozesat'], b=['thogatychathoputaf', 'nachuthitextyquitex', 'ketonogedof', 'texteticur', 'xebutex', 'chuku', 'dyc', 'pofiquubysejidylo', 'machytijewamiqu', 'kizytextiz']):\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b",
    "sols": [
      "def sol(a=['fed', 'quytextet', 'gyzyharoquuzyxykijim', 'chysumum', 'fecathichych', 'textaquygivychi', 'zozawybezekyce', 'larafilawodevilohich', 'gathedudaquixugewety', 'thochuthachite', 'metextathekugy', 'xarizatextudazoq', 'lycajuponejeth', 'techyvojiryb', 'xep', 'hysehikaxyhygyn', 'kadezehohec', 'tuhiw', 'kikythuthe', 'judozunu', 'tu', 'vak', 'pinudirysidagaduzo', 'bacybohelikabijazik', 'kuvolejunihupocho', 'mirycadochalowu', 'tot', 'chy', 'chypijomimutoxytexty', 'lachomythisatexta', 'rizykyhalaweto', 'lu', 'quem', 'zykathet', 'kogochucuwoth', 'typukodyqu', 'tedochowogyn', 'quabalurizicukiridit', 'benochitonek', 'g', 'papujitokizopuwoba', 'thotacaluquuquyda', 'baditathyche', 'texteticur', 'gyfetextan', 'tocha', 'thinariluquov', 'macukywymatubutex', 'lojabituviz', 'fazatextor', 'kyl', 'danatextefesoq', 'textyvuvudiwusizoci', 'piryxu', 'tasemady', 'vapifeholeth', 'dadatextapetykecivok', 'gichenotexturo', 'textisigo', 'textaquicyxotet', 'quycholesipywevykym', 'byf', 'textumy', 'quithepo', 'pywifoq', 'lodytacuth', 'jofenukuzejemyteci', 'rebokapyr', 'wojepytextosadezapy', 'fysothobozesat'], b=['thogatychathoputaf', 'nachuthitextyquitex', 'ketonogedof', 'texteticur', 'xebutex', 'chuku', 'dyc', 'pofiquubysejidylo', 'machytijewamiqu', 'kizytextiz']):\n    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_0",
    "sat": "def sat(x: int, a=93252338):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=93252338):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_1",
    "sat": "def sat(x: int, a=-4958479260636040):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=-4958479260636040):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_2",
    "sat": "def sat(x: int, a=-1528473368457484):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=-1528473368457484):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_3",
    "sat": "def sat(x: int, a=9291335047739966):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=9291335047739966):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_4",
    "sat": "def sat(x: int, a=-4394894330624108):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=-4394894330624108):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_5",
    "sat": "def sat(x: int, a=6306272794721914):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=6306272794721914):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_6",
    "sat": "def sat(x: int, a=5984403738332186):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=5984403738332186):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_7",
    "sat": "def sat(x: int, a=-2405181051387020):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=-2405181051387020):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_8",
    "sat": "def sat(x: int, a=7058660688388074):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=7058660688388074):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNeg_9",
    "sat": "def sat(x: int, a=4976603307478642):\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a",
    "sols": [
      "def sol(a=4976603307478642):\n    return - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_0",
    "sat": "def sat(x: int, a=1073258, b=72352549):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=1073258, b=72352549):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_1",
    "sat": "def sat(x: int, a=-626575174617516, b=-3170375341908439):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=-626575174617516, b=-3170375341908439):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_2",
    "sat": "def sat(x: int, a=-9579599826188706, b=9644761732248617):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=-9579599826188706, b=9644761732248617):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_3",
    "sat": "def sat(x: int, a=4955663182619681, b=-7116560056812532):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=4955663182619681, b=-7116560056812532):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_4",
    "sat": "def sat(x: int, a=-1690125810777360, b=1468184990295379):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=-1690125810777360, b=1468184990295379):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_5",
    "sat": "def sat(x: int, a=-800308874897950, b=-1142127749641084):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=-800308874897950, b=-1142127749641084):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_6",
    "sat": "def sat(x: int, a=4101233176782060, b=-9302477649378229):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=4101233176782060, b=-9302477649378229):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_7",
    "sat": "def sat(x: int, a=-8855613199505532, b=-6116867672034087):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=-8855613199505532, b=-6116867672034087):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_8",
    "sat": "def sat(x: int, a=-7247514880799682, b=-807912930929229):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=-7247514880799682, b=-807912930929229):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSum_9",
    "sat": "def sat(x: int, a=8571894645140330, b=-1238106095744160):\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b",
    "sols": [
      "def sol(a=8571894645140330, b=-1238106095744160):\n    return b - a"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_0",
    "sat": "def sat(x: int, a=-382, b=14546310):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=-382, b=14546310):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_1",
    "sat": "def sat(x: int, a=7162922398636283, b=6891602764329870):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=7162922398636283, b=6891602764329870):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_2",
    "sat": "def sat(x: int, a=-1699295798056188, b=8092962891923642):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=-1699295798056188, b=8092962891923642):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_3",
    "sat": "def sat(x: int, a=5011685393066917, b=7286447952409246):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=5011685393066917, b=7286447952409246):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_4",
    "sat": "def sat(x: int, a=1702395033952800, b=-1215966043590260):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=1702395033952800, b=-1215966043590260):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_5",
    "sat": "def sat(x: int, a=5704335965234840, b=4670263308731484):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=5704335965234840, b=4670263308731484):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_6",
    "sat": "def sat(x: int, a=7065572948929927, b=-6826585230434697):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=7065572948929927, b=-6826585230434697):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_7",
    "sat": "def sat(x: int, a=-2057919301188102, b=8253009622784231):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=-2057919301188102, b=8253009622784231):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_8",
    "sat": "def sat(x: int, a=-7574182145708605, b=-3418773981602532):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=-7574182145708605, b=-3418773981602532):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub_9",
    "sat": "def sat(x: int, a=-5506583355226861, b=6699201754760246):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b",
    "sols": [
      "def sol(a=-5506583355226861, b=6699201754760246):\n    return a + b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_0",
    "sat": "def sat(x: int, a=8665464, b=-93206):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=8665464, b=-93206):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_1",
    "sat": "def sat(x: int, a=-379623302953351, b=1560034151333336):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=-379623302953351, b=1560034151333336):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_2",
    "sat": "def sat(x: int, a=1800720218213612, b=-2926443871309164):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=1800720218213612, b=-2926443871309164):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_3",
    "sat": "def sat(x: int, a=5057372951635800, b=6004390405443454):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=5057372951635800, b=6004390405443454):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_4",
    "sat": "def sat(x: int, a=8451235115164314, b=-5145514001263123):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=8451235115164314, b=-5145514001263123):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_5",
    "sat": "def sat(x: int, a=1287752181890854, b=-5713038727076944):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=1287752181890854, b=-5713038727076944):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_6",
    "sat": "def sat(x: int, a=8921825486295401, b=2692060738983265):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=8921825486295401, b=2692060738983265):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_7",
    "sat": "def sat(x: int, a=-5909561708570201, b=-382306777915770):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=-5909561708570201, b=-382306777915770):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_8",
    "sat": "def sat(x: int, a=-4906047812646789, b=2149237807150978):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=-4906047812646789, b=2149237807150978):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSub2_9",
    "sat": "def sat(x: int, a=185095853942980, b=1981292192734264):\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b",
    "sols": [
      "def sol(a=185095853942980, b=1981292192734264):\n    return a - b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_0",
    "sat": "def sat(n: int, a=14302, b=5):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=14302, b=5):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_1",
    "sat": "def sat(n: int, a=699871, b=18):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=699871, b=18):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_2",
    "sat": "def sat(n: int, a=896610, b=30):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=896610, b=30):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_3",
    "sat": "def sat(n: int, a=789287, b=83):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=789287, b=83):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_4",
    "sat": "def sat(n: int, a=518920, b=-13):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=518920, b=-13):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_5",
    "sat": "def sat(n: int, a=333973, b=76):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=333973, b=76):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_6",
    "sat": "def sat(n: int, a=17921, b=37):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=17921, b=37):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_7",
    "sat": "def sat(n: int, a=477907, b=47):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=477907, b=47):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_8",
    "sat": "def sat(n: int, a=-493675, b=48):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=-493675, b=48):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntMul_9",
    "sat": "def sat(n: int, a=528247, b=55):\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + (a % b) == a",
    "sols": [
      "def sol(a=528247, b=55):\n    return a // b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_0",
    "sat": "def sat(n: int, a=3, b=23463462):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=3, b=23463462):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_1",
    "sat": "def sat(n: int, a=-2, b=5919548904866657):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-2, b=5919548904866657):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_2",
    "sat": "def sat(n: int, a=-2, b=-5667093437719394):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-2, b=-5667093437719394):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_3",
    "sat": "def sat(n: int, a=-4, b=5594747902112224):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-4, b=5594747902112224):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_4",
    "sat": "def sat(n: int, a=1, b=4234926608408733):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=1, b=4234926608408733):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_5",
    "sat": "def sat(n: int, a=-2, b=9925106044191353):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-2, b=9925106044191353):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_6",
    "sat": "def sat(n: int, a=-1, b=-3429336342142598):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-1, b=-3429336342142598):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_7",
    "sat": "def sat(n: int, a=-7, b=-7491935273933817):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-7, b=-7491935273933817):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_8",
    "sat": "def sat(n: int, a=-3, b=6880019779424194):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-3, b=6880019779424194):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv_9",
    "sat": "def sat(n: int, a=-5, b=-9132119262989482):\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a",
    "sols": [
      "def sol(a=-5, b=-9132119262989482):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_0",
    "sat": "def sat(n: int, a=345346363, b=10):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=345346363, b=10):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_1",
    "sat": "def sat(n: int, a=-1061181386057654, b=1059194070510451):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-1061181386057654, b=1059194070510451):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_2",
    "sat": "def sat(n: int, a=-908865179463422, b=5212192185799717):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-908865179463422, b=5212192185799717):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_3",
    "sat": "def sat(n: int, a=-8552244469867994, b=-1554558376987911):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-8552244469867994, b=-1554558376987911):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_4",
    "sat": "def sat(n: int, a=-1094643274331109, b=3296381146801536):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-1094643274331109, b=3296381146801536):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_5",
    "sat": "def sat(n: int, a=8790063671458903, b=2493696400761451):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=8790063671458903, b=2493696400761451):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_6",
    "sat": "def sat(n: int, a=-354715715606029, b=-7522197138826954):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-354715715606029, b=-7522197138826954):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_7",
    "sat": "def sat(n: int, a=-7048953987444515, b=-4193313929417082):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-7048953987444515, b=-4193313929417082):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_8",
    "sat": "def sat(n: int, a=-5106407492038402, b=4601223154479684):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=-5106407492038402, b=4601223154479684):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntDiv2_9",
    "sat": "def sat(n: int, a=4158329518487053, b=-5108122676409554):\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a",
    "sols": [
      "def sol(a=4158329518487053, b=-5108122676409554):\n    return a * b"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_0",
    "sat": "def sat(x: int, a=10201202001):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=10201202001):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_1",
    "sat": "def sat(x: int, a=2571718002732713025):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=2571718002732713025):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_2",
    "sat": "def sat(x: int, a=1526504930948958724):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=1526504930948958724):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_3",
    "sat": "def sat(x: int, a=563587642755315025):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=563587642755315025):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_4",
    "sat": "def sat(x: int, a=518931294457699600):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=518931294457699600):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_5",
    "sat": "def sat(x: int, a=3871607752021461904):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=3871607752021461904):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_6",
    "sat": "def sat(x: int, a=4427783711936221849):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=4427783711936221849):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_7",
    "sat": "def sat(x: int, a=4572788081619834244):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=4572788081619834244):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_8",
    "sat": "def sat(x: int, a=3077680464478903396):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=3077680464478903396):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntSquareRoot_9",
    "sat": "def sat(x: int, a=5278987626716164):\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a",
    "sols": [
      "def sol(a=5278987626716164):\n    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_0",
    "sat": "def sat(n: int, a=10000200001):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=10000200001):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_1",
    "sat": "def sat(n: int, a=365421838627726596):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=365421838627726596):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_2",
    "sat": "def sat(n: int, a=2630598493574288169):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=2630598493574288169):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_3",
    "sat": "def sat(n: int, a=192515169255436036):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=192515169255436036):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_4",
    "sat": "def sat(n: int, a=684484338983761969):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=684484338983761969):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_5",
    "sat": "def sat(n: int, a=673954914330800041):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=673954914330800041):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_6",
    "sat": "def sat(n: int, a=2079487408190984100):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=2079487408190984100):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_7",
    "sat": "def sat(n: int, a=3038153462373961156):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=3038153462373961156):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_8",
    "sat": "def sat(n: int, a=2672052143703581521):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=2672052143703581521):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "IntNegSquareRoot_9",
    "sat": "def sat(n: int, a=810385564471787329):\n    return a == n * n and n < 0",
    "sols": [
      "def sol(a=810385564471787329):\n    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_0",
    "sat": "def sat(x: float, a=1020):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=1020):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_1",
    "sat": "def sat(x: float, a=5803938002):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=5803938002):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_2",
    "sat": "def sat(x: float, a=8209483093):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=8209483093):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_3",
    "sat": "def sat(x: float, a=7733422434):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=7733422434):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_4",
    "sat": "def sat(x: float, a=1692941324):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=1692941324):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_5",
    "sat": "def sat(x: float, a=708536664):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=708536664):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_6",
    "sat": "def sat(x: float, a=8722645606):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=8722645606):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_7",
    "sat": "def sat(x: float, a=9632015080):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=9632015080):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_8",
    "sat": "def sat(x: float, a=1720451211):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=1720451211):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatSquareRoot_9",
    "sat": "def sat(x: float, a=2694852324):\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3",
    "sols": [
      "def sol(a=2694852324):\n    return a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_0",
    "sat": "def sat(x: float, a=1020):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=1020):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_1",
    "sat": "def sat(x: float, a=5449956299):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=5449956299):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_2",
    "sat": "def sat(x: float, a=9344597911):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=9344597911):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_3",
    "sat": "def sat(x: float, a=8517433040):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=8517433040):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_4",
    "sat": "def sat(x: float, a=9407087056):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=9407087056):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_5",
    "sat": "def sat(x: float, a=2466945721):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=2466945721):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_6",
    "sat": "def sat(x: float, a=339349957):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=339349957):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_7",
    "sat": "def sat(x: float, a=1839816461):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=1839816461):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_8",
    "sat": "def sat(x: float, a=7437023514):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=7437023514):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "FloatNegSquareRoot_9",
    "sat": "def sat(x: float, a=9814216923):\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "sols": [
      "def sol(a=9814216923):\n    return -a ** 0.5"
    ],
    "module": "trivial_inverse"
  },
  {
    "name": "Tutorial1_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s == \"Hello world\"",
    "sols": [
      "def sol():\n    return \"world\""
    ],
    "module": "tutorial"
  },
  {
    "name": "Tutorial2_0",
    "sat": "def sat(s: str):\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return \"Hello \" + s[::-1] == \"Hello world\"",
    "sols": [
      "def sol():\n    return \"world\"[::-1]"
    ],
    "module": "tutorial"
  },
  {
    "name": "Tutorial3_0",
    "sat": "def sat(x: List[int]):\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3",
    "sols": [
      "def sol():\n    return [1, 2]"
    ],
    "module": "tutorial"
  },
  {
    "name": "Tutorial4_0",
    "sat": "def sat(s: List[str]):\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)",
    "sols": [
      "def sol():\n    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]"
    ],
    "module": "tutorial"
  },
  {
    "name": "Tutorial5_0",
    "sat": "def sat(n: int):\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith(\"123456789\")",
    "sols": [
      "def sol():\n    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1"
    ],
    "module": "tutorial"
  }
]